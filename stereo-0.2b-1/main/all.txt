3:3: calibrate.c - camera calibration minimisation algorithms                              
484:2: callback.c - main callback routines from button presses                               
852:2: camera.c - undestort camera coordinates                                               
995:2: desktop.c - save and restore the desktop to *.dsk files                               
1188:2: display.c - main() function                                                           
1457:2: displaycam.c - draw a list of the camera data                                         
1795:2: fitline.c - line, circle, ellipse, plane, and cylinder fitting routines               
3476:2: hugeimage.c - widget to draw the tiff file, zoom box and do caching of image data     
4119:2: imagefit.c - commands to fit objects to desktop markers                               
4850:2: imagehandler.c - handles events from the view windows                                 
5042:2: join.c - for a number of grid surfaces, this zips up edges of one                     
5043:3:          surface that are close to an adjacent surface                                
5588:2: loadcalfile.c - loads a calibration file into the desktop structure                   
5718:2: marker.c - marker handling and finding real pointer positions in images               
6179:2: matrix.c - a matrix manipulation library                                              
7416:2: output.c - this outputs an object (line, circle, etc) to the editor                   
7604:2: picsetup.c - setup and destroy pictures and views                                    
7866:2: savewindow.c - saves the rendered 3D scene as a targa file                            
8008:2: simplex.c - simplex optimisation algorithm                                            





1:1:/* \begin{verbatim} */
2:2:/*****************************************************************************************/
3:3:/* calibrate.c - camera calibration minimisation algorithms                              */
4:4:/*****************************************************************************************/
5:5:
6:6:/*
7:7:   Copyright (C) 1996, 1997 Paul Sheer
8:8:
9:9:   This program is free software; you can redistribute it and/or modify
10:10:   it under the terms of the GNU General Public License as published by
11:11:   the Free Software Foundation; either version 2 of the License, or
12:12:   (at your option) any later version.
13:13:
14:14:   This program is distributed in the hope that it will be useful,
15:15:   but WITHOUT ANY WARRANTY; without even the implied warranty of
16:16:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
17:17:   GNU General Public License for more details.
18:18:
19:19:   You should have received a copy of the GNU General Public License
20:20:   along with this program; if not, write to the Free Software
21:21:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
22:22: */
23:23:
24:24:#include <config.h>
25:25:#include "global.h"
26:26:#include <stdio.h>
27:27:#include <my_string.h>
28:28:#include <stdlib.h>
29:29:#include <stdarg.h>
30:30:#include <math.h>
31:31:
32:32:#include <X11/Xlib.h>
33:33:#include <X11/Xutil.h>
34:34:#include <X11/Xresource.h>
35:35:#include <X11/keysym.h>
36:36:
37:37:#include "stringtools.h"
38:38:#include "app_glob.c"
39:39:#include "dirtools.h"
40:40:
41:41:#include "coolwidget.h"
42:42:#include "matrix.h"
43:43:#include "calibrate.h"
44:44:#include "simplex.h"
45:45:#include "display.h"
46:46:#include "marker.h"
47:47:#include "dialog.h"
48:48:#include "quickmath.h"
49:49:#include "imagefit.h"
50:50:
51:51:#include "mad.h"
52:52:
53:53:extern unsigned char cross_bits[];
54:54:
55:55:#define FTOL 1e-10
56:56:#define ROUGH_TOL 1e-7
57:57:#define MIN_MARKS_NEEDED_TO_CALIBRATE 4
58:58:
59:59:static int stop = 0;
60:60:
61:61:/* call once with omit passed as NULL before using. This is to initialise */
62:62:/* 
63:63:   procedure tries all combinarion of leaving out i of the 3D points
64:64:   (because not enough markers where specified) plus the points
65:65:   leaveout1 and leavout2 (if they are passed as non-negative)
66:66: */
67:67:char *recursive_loop (Desktop * d, char omit[], int from, int to, int i,
68:68:                      double tol, int leaveout1, int leaveout2,
69:69:                      int calc_distortion)
70:70:{
71:71:    int j;
72:72:    double e;
73:73:    static double emin = 10e90;
74:74:    static char *omitmin = 0;
75:75:    if (!omit) {
76:76:        emin = 10e90;
77:77:        destroy ((void *) &omitmin);
78:78:        return 0;
79:79:    }
80:80:    if (i) {
81:81:        for (j = from; j <= to - i; j++) {
82:82:            if (stop)
83:83:                break;
84:84:            omit[j] = 1;
85:85:            recursive_loop (d, omit, j + 1, to, i - 1, tol, leaveout1,
86:86:                            leaveout2, calc_distortion);
87:87:            omit[j] = 0;
88:88:        }
89:89:    } else {
90:90:        Vec *v;
91:91:        double *x, *y;
92:92:        int leave_out = (leaveout1 >= 0) + (leaveout2 >= 0);
93:93:        int k;
94:94:        int n;
95:95:        for (i = 0, j = 0; j < to; i += omit[j++]);
96:96:        n = to - i - leave_out;
97:97:        v = Cmalloc (sizeof (Vec) * n);
98:98:        x = Cmalloc (sizeof (double) * n);
99:99:        y = Cmalloc (sizeof (double) * n);
100:100:        i = 0;
101:101:        k = 0;
102:102:        for (j = 0; j < to; j++) {
103:103:            printf ("%d", (int) omit[j]);
104:104:            if (!omit[j]) {
105:105:                if (k != leaveout1 && k != leaveout2) {
106:106:                    v[i] = d->cal_points[j];
107:107:                    x[i] = d->view[d->current_view].mark[k].x;
108:108:                    y[i] = d->view[d->current_view].mark[k].y;
109:109:                    i++;
110:110:                }
111:111:                k++;
112:112:            }
113:113:        }
114:114:        printf ("\n");
115:115:        e = findcameraposition (x, y, v, n,
116:116:                                &(d->view[d->current_view].cam), tol, 1,
117:117:                                calc_distortion);
118:118:        if (e < emin) {
119:119:            emin = e;
120:120:            destroy ((void *) &omitmin);
121:121:            omitmin = Cmalloc (to);
122:122:            memcpy (omitmin, omit, to);
123:123:        }
124:124:        free (x);
125:125:        free (y);
126:126:    }
127:127:    return omitmin;
128:128:}
129:129:
130:130:
131:131:/*
132:132:   leave out specifies the number of calibration points to omit when 
133:133:   making the optimisation. The routine will try omitting every 
134:134:   combination of points (eg. 1st then 2nd, then 1st then 3rd, etc)
135:135:   and find which produces the least error. This allows the program
136:136:   to cope with one or two calibration points that are eroneous
137:137:   ('leave_out' can be only 0, 1 or 2). The routine also tries
138:138:   every combination of omition when the number of markers is less
139:139:   than the number of calibration points.
140:140:   'ce' is not used.
141:141: */
142:142:/* returns 0 if succesful, 2 if cal points 'n markers not ok, and 1 if cancelled
143:143:   during operation */
144:144:int calibrate_view (Desktop * d, CEvent * ce, int leave_out,
145:145:                    int calc_distortion)
146:146:{
147:147:    char *omitted, *omitmin;
148:148:    int omit;
149:149:    double ermin = 10e90;
150:150:    int leaveout1 = -1, leaveout2 = -1;
151:151:    int l1 = -1, l2 = -1;
152:152:
153:153:    stop = 0;
154:154:
155:155:    set_current_from_pointer (d, ce);
156:156:    omit = d->num_cal_points - d->view[d->current_view].num_marks;
157:157:
158:158:    {
159:159:        if (d->num_cal_points - leave_out < MIN_MARKS_NEEDED_TO_CALIBRATE) {
160:160:            Cerrordialog (0, 0, 0, " Calibrate ", " You have at least %d \
161:161:                calibration points to calibrate ", MIN_MARKS_NEEDED_TO_CALIBRATE);
162:162:            return 2;
163:163:        }
164:164:        if (omit < 0) {
165:165:            Cerrordialog (0, 0, 0, " Calibrate ",
166:166:                          " You have more markers than calibration points ");
167:167:            return 2;
168:168:        }
169:169:        if (d->view[d->current_view].num_marks <
170:170:            MIN_MARKS_NEEDED_TO_CALIBRATE) {
171:171:            Cerrordialog (0, 0, 0, " Calibrate ",
172:172:                          " You have at least %d markers to calibrate ",
173:173:                          MIN_MARKS_NEEDED_TO_CALIBRATE);
174:174:            return 2;
175:175:        }
176:176:    }
177:177:
178:178:    omitted = Cmalloc (d->num_cal_points);
179:179:    memset (omitted, 0, d->num_cal_points);
180:180:
181:181:    recursive_loop (0, 0, 0, 0, 0, 0, 0, 0, 0); /* reset */
182:182:
183:183:/* try omitting every combination of calibration points without markers and see which 
184:184:    gives the minimum error */
185:185:/* Here we are not yet leaving out markers: we are first trying to find out which 
186:186:    markers correspond to which calibration point */
187:187:    printf ("Which markers are which?: Trying all combinations:\n");
188:188:    omitmin = recursive_loop (d, omitted, 0, d->num_cal_points, omit,
189:189:                              ROUGH_TOL, -1, -1, calc_distortion);
190:190:    if (stop)
191:191:        return 1;
192:192:
193:193:/* save the result, there is a 1 in the array if that calibration point is \
194:194:            omitted omitted */
195:195:    memcpy (omitted, omitmin, d->num_cal_points);
196:196:
197:197:    printf ("You think that %d calibration points must be scrapped: Trying all \
198:198:                combinations:\n",
199:199:            leave_out);
200:200:
201:201:/* now try every combination of leaving out two of the markers 
202:202:    (and hence two more calibration points) */
203:203:    l1 = l2 = -1;
204:204:    if (leave_out == 2) {
205:205:        for (leaveout1 = 0; leaveout1 < d->num_cal_points - omit - 1;
206:206:             leaveout1++)
207:207:            for (leaveout2 = leaveout1 + 1;
208:208:                 leaveout2 < d->num_cal_points - omit; leaveout2++) {
209:209:                recursive_loop (d, omitted, 0, d->num_cal_points, 0, FTOL,
210:210:                                leaveout1, leaveout2, calc_distortion);
211:211:                if (d->view[d->current_view].cam.e < ermin) { /* find the minimum */
212:212:                    if (stop)
213:213:                        return 1;
214:214:                    ermin = d->view[d->current_view].cam.e;
215:215:                    l1 = leaveout1;
216:216:                    l2 = leaveout2;
217:217:                }
218:218:            }
219:219:
220:220:        printf ("Best error was in leaving out marker %d and marker %d.\n",
221:221:                l1 + 1, l2 + 1);
222:222:
223:223:/* or, if specified, ONE of the markers (and hence two more calibration points) */
224:224:    } else if (leave_out == 1) {
225:225:        leaveout2 = -1;
226:226:        for (leaveout1 = 0; leaveout1 < d->num_cal_points - omit;
227:227:             leaveout1++) {
228:228:            recursive_loop (d, omitted, 0, d->num_cal_points, 0, FTOL,
229:229:                            leaveout1, -1, calc_distortion);
230:230:            if (d->view[d->current_view].cam.e < ermin) { /* find the minimum */
231:231:                if (stop)
232:232:                    return 1;
233:233:                ermin = d->view[d->current_view].cam.e;
234:234:                l1 = leaveout1;
235:235:            }
236:236:        }
237:237:
238:238:        printf ("Best error was in leaving out marker %d.\n", l1 + 1);
239:239:
240:240:    } else {
241:241:
242:242:        printf ("All markers where used.\n");
243:243:
244:244:    }
245:245:    if (stop)
246:246:        return 1;
247:247:
248:248:    printf ("Now refine.\n");
249:249:
250:250:    recursive_loop (d, omitted, 0, d->num_cal_points, 0, FTOL, l1, l2, calc_distortion); /* this is now the minimum */
251:251:
252:252:    recursive_loop (0, 0, 0, 0, 0, 0, 0, 0, 0); /* reset and free */
253:253:
254:254:    d->view[d->current_view].calibrated = 1;
255:255:
256:256:    return 0;
257:257:}
258:258:
259:259:
260:260:double calerror (double *x, double *y, Vec * v, Camera * c, int n)
261:261:{
262:262:    int i, j;
263:263:    Vec *s;
264:264:    double *r;
265:265:    double xs, ys, e = 0;
266:266:    getrotation (&(c->m_x), &(c->m_s), &(c->m_y), c->phi, c->theta,
267:267:                 c->tsi);
268:268:    r = Cmalloc ((n * 2) * sizeof (double));
269:269:    s = Cmalloc ((n * 2) * sizeof (Vec));
270:270:    j = 0;
271:271:    for (i = 0; i < n; i++) {
272:272:        xs = x[i];
273:273:        ys = y[i];
274:274:        imagetocamera (c, xs, ys);
275:275:        s[j] = plus (times (c->m_s, xs), times (c->m_x, c->f));
276:276:        r[j] = dot (s[j], v[i]);
277:277:        j++;
278:278:        s[j] = plus (times (c->m_s, ys), times (c->m_y, c->f));
279:279:        r[j] = dot (s[j], v[i]);
280:280:        j++;
281:281:    }
282:282:    c->x = vec_invert (s, r, j);
283:283:    for (i = 0; i < n; i++) {
284:284:        phystocamera (c, v[i], xs, ys);
285:285:        cameratoimage (c, xs, ys);
286:286:        e += fsqr (x[i] - xs) + fsqr (y[i] - ys);
287:287:    }
288:288:    free (s);
289:289:    free (r);
290:290:    return e;
291:291:}
292:292:
293:293:
294:294:static double *x_data, *y_data;
295:295:static Vec *XYZ_data;
296:296:static int num_cal_points;
297:297:
298:298:static Window calprogwin;
299:299:static Camera camera;
300:300:static Camera fixedvalues;
301:301:
302:302:static XEvent xevent;
303:303:static CEvent cwevent;
304:304:
305:305:int callback (double tol, double error, double *v, int num_evals)
306:306:{
307:307:    static int i = 0;
308:308:
309:309:    i++;
310:310:    if (!(i % 10)) {
311:311:        Cdrawprogress ("caliprog", calprogwin, 20, 20, 260, 25,
312:312:                       (1 - log (tol)) * 65535 / (0.5 - log (FTOL)));
313:313:        cwevent.ident = "canccali";
314:314:        if (Ccheckifevent (&xevent, &cwevent)) {
315:315:            stop = 1;
316:316:            return 1;
317:317:        }
318:318:    }
319:319:    return 0;
320:320:}
321:321:
322:322:
323:323:double tominimise4 (double *x)
324:324:{
325:325:    camera.phi = x[0];
326:326:    camera.theta = x[1];
327:327:    camera.tsi = x[2];
328:328:    camera.f = x[3];
329:329:    camera.sig = fixedvalues.sig;
330:330:    return calerror (x_data, y_data, XYZ_data, &camera, num_cal_points);
331:331:}
332:332:
333:333:double tominimise5 (double *x)
334:334:{
335:335:    camera.phi = x[0];
336:336:    camera.theta = x[1];
337:337:    camera.tsi = x[2];
338:338:    camera.f = x[3];
339:339:    camera.sig = x[4];
340:340:    return calerror (x_data, y_data, XYZ_data, &camera, num_cal_points);
341:341:}
342:342:
343:343:/*
344:344:   finds f, phi, theta and tsi for a given set of calibration points
345:345:   whose 3D positions are given by v and whose 2D picture postions are given
346:346:   by x and y.
347:347:   pass calc_distortion with CALC_SIGMA set to optimise sigma, otherwise set sigma
348:348: */
349:349:double findcameraposition (double *x, double *y, Vec * v, int n,
350:350:                           Camera * c, double tol, int make_initial_guess,
351:351:                           int calc_distortion)
352:352:{
353:353:    int i, j;
354:354:    int numitters;
355:355:    double d, result[10], emin = 10e90, e;
356:356:
357:357:    if (!Cwidget ("calprogw")) {
358:358:        calprogwin = Cdrawwindow ("calprogw", CMain, 50, 50, 300, 110, "");
359:359:        Cwidget ("calprogw")->position = CFIXED_POSITION | CALWAYS_ON_TOP;
360:360:        Cdrawbitmapbutton ("canccali", calprogwin, 126, 53,
361:361:                           40, 40, Ccolor (18), C_FLAT, cross_bits);
362:362:    }
363:363:    Cdrawprogress ("caliprog", calprogwin, 20, 20, 260, 25, 0);
364:364:    Ccheckifevent (NULL, NULL);
365:365:
366:366:    x_data = x;
367:367:    y_data = y;
368:368:    XYZ_data = v;
369:369:    num_cal_points = n;
370:370:
371:371:    memcpy (&fixedvalues, c, sizeof (Camera));
372:372:
373:373:    if (make_initial_guess) {
374:374:
375:375:/*
376:376:   first we find an estimate for the order of magnitude of f.
377:377:   The calibration points would be spaced across a reasonable proportion
378:378:   of the image. A camera would typically have a field angle of 20 degrees
379:379:   and the image extents divided by tan(20) gives a rough estimate of -f
380:380: */
381:381:        d = 0;
382:382:        for (i = 0; i < n - 1; i++)
383:383:            for (j = i + 1; j < n; j++)
384:384:                d = fmax (d,
385:385:                          sqrt (fsqr (y[i] - y[j]) + fsqr (x[i] - x[j])));
386:386:
387:387:/*
388:388:   we will scale this up a bit to over estimate f. This will
389:389:   result in XC being further from the calibration point cluster and
390:390:   ensure that it does not penetrate it during the guesstimation procedure
391:391:   below.
392:392: */
393:393:
394:394:        memset (c, 0, sizeof (Camera));
395:395:        c->f = d * (-4.0);
396:396:
397:397:/*search for an initial guess of the entire space (this is quite fast) */
398:398:        for (c->theta = -PI / 2; c->theta <= PI / 2; c->theta += PI / 8) {
399:399:            cwevent.ident = "canccali";
400:400:            if (Ccheckifevent (&xevent, &cwevent)) {
401:401:                stop = 1;
402:402:                return 1;
403:403:            }
404:404:            for (c->tsi = -PI; c->tsi < PI; c->tsi += PI / 8)
405:405:                for (c->phi = -PI; c->phi < PI; c->phi += PI / 8) {
406:406:                    e = calerror (x_data, y_data, XYZ_data, c, n);
407:407:                    numitters = 0;
408:408:                    if (emin > e) {
409:409:                        emin = e;
410:410:                        memcpy (&camera, c, sizeof (Camera));
411:411:                    }
412:412:                }
413:413:        }
414:414:    } else {                    /* initial guess is given */
415:415:        memcpy (&camera, c, sizeof (Camera));
416:416:    }
417:417:    /*
418:418:       now we have an estimate for f, theta, and tsi and phi.
419:419:       First guess for the other camera parameters is zero (if there are any).
420:420:     */
421:421:    result[0] = camera.phi;
422:422:    result[1] = camera.theta;
423:423:    result[2] = camera.tsi;
424:424:    result[3] = camera.f;
425:425:
426:426:    if (calc_distortion & CALC_SIGMA) {
427:427:        result[4] = 0;
428:428:        numitters =
429:429:            simplex_optimise (result, 5, tol, PI / 16, tominimise5,
430:430:                              callback);
431:431:    } else {
432:432:        numitters =
433:433:            simplex_optimise (result, 4, tol, PI / 16, tominimise4,
434:434:                              callback);
435:435:        result[4] = fixedvalues.sig;
436:436:    }
437:437:
438:438:    c->phi = result[0];
439:439:    c->theta = result[1];
440:440:    c->tsi = result[2];
441:441:    c->f = result[3];
442:442:    c->sig = result[4];
443:443:
444:444:    getrotation (&(c->m_x), &(c->m_s), &(c->m_y), c->phi, c->theta,
445:445:                 c->tsi);
446:446:
447:447:    c->e = calerror (x_data, y_data, XYZ_data, c, n);
448:448:    return c->e;
449:449:}
450:1:/*
451:2:   Copyright (C) 1996, 1997 Paul Sheer
452:3:
453:4:   This program is free software; you can redistribute it and/or modify
454:5:   it under the terms of the GNU General Public License as published by
455:6:   the Free Software Foundation; either version 2 of the License, or
456:7:   (at your option) any later version.
457:8:
458:9:   This program is distributed in the hope that it will be useful,
459:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
460:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
461:12:   GNU General Public License for more details.
462:13:
463:14:   You should have received a copy of the GNU General Public License
464:15:   along with this program; if not, write to the Free Software
465:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
466:17: */
467:18:#ifndef CALIBRATE_H
468:19:#define CALIBRATE_H
469:20:
470:21:#include "camera.h"
471:22:#include "display.h"
472:23:
473:24:#define CALC_SIGMA 1
474:25:
475:26:double findcameraposition (double *x, double *y, Vec * v, int n,
476:27:                           Camera * c, double tol, int make_initial_guess,
477:28:                           int calc_distortion);
478:29:
479:30:int calibrate_view (Desktop * d, CEvent * ce, int leave_out,
480:31:                    int calc_distortion);
481:32:
482:33:#endif
483:1:/*****************************************************************************************/
484:2:/* callback.c - main callback routines from button presses                               */
485:3:/*****************************************************************************************/
486:4:/*
487:5:   Copyright (C) 1996, 1997 Paul Sheer
488:6:
489:7:   This program is free software; you can redistribute it and/or modify
490:8:   it under the terms of the GNU General Public License as published by
491:9:   the Free Software Foundation; either version 2 of the License, or
492:10:   (at your option) any later version.
493:11:
494:12:   This program is distributed in the hope that it will be useful,
495:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
496:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
497:15:   GNU General Public License for more details.
498:16:
499:17:   You should have received a copy of the GNU General Public License
500:18:   along with this program; if not, write to the Free Software
501:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
502:20: */
503:21:
504:22:#include "display.h"
505:23:#include "widget3d.h"
506:24:#include "main/marker.h"
507:25:#include "main/displaycam.h"
508:26:#include "loadcalfile.h"
509:27:#include "imagehandler.h"
510:28:#include "picsetup.h"
511:29:#include "edit.h"
512:30:#include "dialog.h"
513:31:#include "loadfile.h"
514:32:#include "desktop.h"
515:33:#include "imagefit.h"
516:34:#include "calibrate.h"
517:35:
518:36:extern Desktop desktop;
519:37:
520:38:int save_window_to_file (Window win, int x, int y, int width, int height);
521:39:
522:40:int cb_save_window (CWidget * none, XEvent * xevent, CEvent * cwevent)
523:41:{
524:42:    CWidget *w;
525:43:    w = Cwidget ("3dview");
526:44:    save_window_to_file (w->winid, 0, 0, w->width, w->height);
527:45:    return 0;
528:46:}
529:47:
530:48:
531:49:int cb_getsurface (CWidget * none, XEvent * xevent, CEvent * cwevent)
532:50:{
533:51:    output_surface (&desktop);
534:52:    return 0;
535:53:}
536:54:
537:55:int cb_getcircle (CWidget * none, XEvent * xevent, CEvent * cwevent)
538:56:{
539:57:    output_circle (&desktop);
540:58:    return 0;
541:59:}
542:60:
543:61:int cb_getellipse (CWidget * none, XEvent * xevent, CEvent * cwevent)
544:62:{
545:63:    output_ellipse (&desktop);
546:64:    return 0;
547:65:}
548:66:
549:67:int cb_getpoint (CWidget * none, XEvent * xevent, CEvent * cwevent)
550:68:{
551:69:    output_point (&desktop);
552:70:    return 0;
553:71:}
554:72:
555:73:int cb_getline (CWidget * none, XEvent * xevent, CEvent * cwevent)
556:74:{
557:75:    output_line (&desktop);
558:76:    return 0;
559:77:}
560:78:
561:79:int cb_getcircleedge (CWidget * none, XEvent * xevent, CEvent * cwevent)
562:80:{
563:81:    output_circle_edge (&desktop);
564:82:    return 0;
565:83:}
566:84:
567:85:int cb_getlineedge (CWidget * none, XEvent * xevent, CEvent * cwevent)
568:86:{
569:87:    output_line_edge (&desktop);
570:88:    return 0;
571:89:}
572:90:
573:91:int cb_getcylinderedge (CWidget * none, XEvent * xevent, CEvent * cwevent)
574:92:{
575:93:    output_cylinder_edge (&desktop);
576:94:    return 0;
577:95:}
578:96:
579:97:int cb_getcylinder (CWidget * none, XEvent * xevent, CEvent * cwevent)
580:98:{
581:99:    output_cylinder (&desktop);
582:100:    return 0;
583:101:}
584:102:
585:103:int cb_save_desktop (CWidget * w, XEvent * xe, CEvent * ce)
586:104:{
587:105:    save_desktop (&desktop);
588:106:    return 0;
589:107:}
590:108:
591:109:int cb_load_desktop (CWidget * w, XEvent * xe, CEvent * ce)
592:110:{
593:111:    load_desktop (&desktop);
594:112:    return 0;
595:113:}
596:114:
597:115:int cb_leave (CWidget * w, XEvent * xe, CEvent * ce)
598:116:{
599:117:    Picture *p;
600:118:    set_current_from_pointer (&desktop, ce);
601:119:    p = &desktop.view[desktop.current_view].pic;
602:120:    Credrawtext (p->Tleave->ident, " %d ",
603:121:                 (atoi (p->Tleave->text + 1) + 1) % 3);
604:122:    return 0;
605:123:}
606:124:
607:125:int cb_sigma (CWidget * w, XEvent * xe, CEvent * ce)
608:126:{
609:127:    Picture *p;
610:128:    set_current_from_pointer (&desktop, ce);
611:129:
612:130:    p = &desktop.view[desktop.current_view].pic;
613:131:    if (p->Isigma) {
614:132:        Cundrawwidget (p->Isigma->ident);
615:133:        p->Isigma = 0;
616:134:    } else {
617:135:        p->Isigma = Cdrawtextinput (catstrs (p->Ssig->ident, ".input", 0),
618:136:                                    p->main_win->winid, 120,
619:137:                                    p->main_win->height - 60, 50, 20, 10,
620:138:                                    "0");
621:139:    }
622:140:    return 0;
623:141:}
624:142:
625:143:
626:144:int cb_calibrate (CWidget * w, XEvent * xe, CEvent * ce)
627:145:{
628:146:    int calc_distortion = 0;
629:147:    Picture *p;
630:148:    double sigma;
631:149:    set_current_from_pointer (&desktop, ce);
632:150:    p = &desktop.view[desktop.current_view].pic;
633:151:    if (p->Isigma) {
634:152:        sigma = atof (p->Isigma->text);
635:153:    } else {
636:154:        sigma = 0;
637:155:        calc_distortion |= CALC_SIGMA;
638:156:    }
639:157:    desktop.view[desktop.current_view].cam.sig = sigma;
640:158:    if (calibrate_view
641:159:        (&desktop, ce, atoi (p->Tleave->text + 1), calc_distortion) == 1)
642:160:        clear (&desktop.view[desktop.current_view].cam, Camera);
643:161:    Cundrawwidget ("calprogw");
644:162:    return 0;
645:163:}
646:164:
647:165:int cb_showcal (CWidget * w, XEvent * xe, CEvent * ce)
648:166:{
649:167:    show_cal_points (&desktop, ce);
650:168:    return 0;
651:169:}
652:170:
653:171:void insert_marker (Picture * p, CEvent * e)
654:172:{
655:173:    Vec v;
656:174:    v = zoom_event_to_image_coord (p, e);
657:175:    new_marker (&desktop, v);
658:176:    draw_markers (&desktop);
659:177:}
660:178:
661:179:void move_marker (Picture * p, CEvent * e)
662:180:{
663:181:    Vec v;
664:182:    v = zoom_event_to_image_coord (p, e);
665:183:    move_closest_marker (&desktop, v);
666:184:    draw_markers (&desktop);
667:185:}
668:186:
669:187:void remove_marker (Picture * p, CEvent * e)
670:188:{
671:189:    Vec v;
672:190:    v = zoom_event_to_image_coord (p, e);
673:191:    remove_closest_marker (&desktop, v);
674:192:    draw_markers (&desktop);
675:193:}
676:194:
677:195:
678:196:int cb_draw_cam_data (CWidget * w, XEvent * xe, CEvent * ce)
679:197:{
680:198:    draw_camera_data (&desktop, ce);
681:199:    return 0;
682:200:}
683:201:
684:202:int cb_loadcal (CWidget * w, XEvent * xe, CEvent * ce)
685:203:{
686:204:    load_calibration (&desktop);
687:205:    return 0;
688:206:}
689:207:
690:208:int cb_zoomimage (CWidget * w, XEvent * xe, CEvent * ce)
691:209:{
692:210:    handle_zoom_box (&desktop, ce);
693:211:    return 0;
694:212:}
695:213:
696:214:int cb_mainimage (CWidget * w, XEvent * xe, CEvent * ce)
697:215:{
698:216:    handle_main_box (&desktop, ce);
699:217:    return 0;
700:218:}
701:219:
702:220:int cb_newimage (CWidget * w, XEvent * xe, CEvent * ce)
703:221:{
704:222:    load_view (&desktop);
705:223:    return 0;
706:224:}
707:225:
708:226:int cb_killimage (CWidget * w, XEvent * xe, CEvent * ce)
709:227:{
710:228:    set_current_from_pointer (&desktop, ce);
711:229:    destroy_current_view (&desktop);
712:230:    return 0;
713:231:}
714:232:
715:233:int cb_clearallmarkers (CWidget * none, XEvent * xe, CEvent * ce)
716:234:{
717:235:    set_current_from_pointer (&desktop, ce);
718:236:    clear_markers (&desktop);
719:237:    draw_markers (&desktop);
720:238:    return 0;
721:239:}
722:240:
723:241:int cb_removelastmarker (CWidget * none, XEvent * xe, CEvent * ce)
724:242:{
725:243:    set_current_from_pointer (&desktop, ce);
726:244:    remove_last_marker (&desktop);
727:245:    draw_markers (&desktop);
728:246:    return 0;
729:247:}
730:248:
731:249:int cb_newrender (CWidget * w, XEvent * xevent, CEvent * cwevent)
732:250:{
733:251:    w = Cwidget ("3dview");
734:252:    switch (w->solid->render) {
735:253:    case TD_MESH:
736:254:        w->solid->render = TD_MESH_AND_SOLID;
737:255:        break;
738:256:    case TD_MESH_AND_SOLID:
739:257:        w->solid->render = TD_SOLID;
740:258:        break;
741:259:    case TD_SOLID:
742:260:        w->solid->render = TD_EDGES_ONLY;
743:261:        break;
744:262:    case TD_EDGES_ONLY:
745:263:        w->solid->render = TD_MESH;
746:264:        break;
747:265:    }
748:266:    Credraw3dobject ("3dview", 0);
749:267:    return 0;
750:268:}
751:269:
752:270:#define CK_Save                 101
753:271:
754:272:int Cdraw3d_from_text (const char *ident, const char *text);
755:273:
756:274:int cb_editor (CWidget * editor, XEvent * xevent, CEvent * cwevent)
757:275:{
758:276:    char *t;
759:277:    long tlen;
760:278:
761:279:    if ((cwevent->key == XK_r || cwevent->key == XK_R)
762:280:        && (cwevent->state & Mod1Mask)) {
763:281:        Cclear_all_surfaces ("3dview");
764:282:        Cedit_execute_command (editor->editor, CK_Save, -1);
765:283:        t = loadfile (path_compress
766:284:                      (editor->editor->dir, editor->editor->filename),
767:285:                      &tlen);
768:286:        if (t && tlen) {
769:287:            Cdraw3d_from_text ("3dview", t);
770:288:        } else
771:289:            Cerrordialog (0, 0, 0, "Get Surface",
772:290:                          "Error reloading file \"%s\" in call to cb_editor - check file permissions.",
773:291:                          editor->editor->filename);
774:292:    }
775:293:    return 0;
776:294:}
777:295:
778:296:int cb_3dplane (CWidget * w, XEvent * xevent, CEvent * cwevent)
779:297:{
780:298:    static int y3dprev = 0, x3dprev = 0;
781:299:    static float alphaprev = 0, betaprev = 0;
782:300:    if (cwevent->type == ButtonPress && cwevent->button == Button1) {
783:301:        x3dprev = cwevent->x;
784:302:        y3dprev = cwevent->y;
785:303:        alphaprev = w->solid->alpha;
786:304:        betaprev = w->solid->beta;
787:305:    }
788:306:    if ((cwevent->type == MotionNotify && (cwevent->state & Button1Mask))
789:307:        || (cwevent->type == ButtonRelease
790:308:            && cwevent->button == Button1)) {
791:309:        w->solid->alpha =
792:310:            (float) alphaprev + (float) ((float) cwevent->x -
793:311:                                         x3dprev) / 100;
794:312:        w->solid->beta =
795:313:            (float) betaprev + (float) ((float) cwevent->y -
796:314:                                        y3dprev) / 100;
797:315:        Credraw3dobject ("3dview", 0);
798:316:    }
799:317:    return 0;
800:318:}
801:1:/*
802:2:   Copyright (C) 1996, 1997 Paul Sheer
803:3:
804:4:   This program is free software; you can redistribute it and/or modify
805:5:   it under the terms of the GNU General Public License as published by
806:6:   the Free Software Foundation; either version 2 of the License, or
807:7:   (at your option) any later version.
808:8:
809:9:   This program is distributed in the hope that it will be useful,
810:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
811:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
812:12:   GNU General Public License for more details.
813:13:
814:14:   You should have received a copy of the GNU General Public License
815:15:   along with this program; if not, write to the Free Software
816:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
817:17: */
818:18:#ifndef _CALLBACK_H
819:19:#define _CALLBACK_H
820:20:
821:21:void move_marker (Picture * p, CEvent * e);
822:22:void remove_marker (Picture * p, CEvent * e);
823:23:void insert_marker (Picture * p, CEvent * e);
824:24:int cb_calibrate (CWidget * w, XEvent * xe, CEvent * ce);
825:25:int cb_loadcal (CWidget * w, XEvent * xe, CEvent * ce);
826:26:int cb_zoomimage (CWidget * w, XEvent * xe, CEvent * ce);
827:27:int cb_mainimage (CWidget * w, XEvent * xe, CEvent * ce);
828:28:int cb_newimage (CWidget * w, XEvent * xe, CEvent * ce);
829:29:int cb_killimage (CWidget * w, XEvent * xe, CEvent * ce);
830:30:int cb_clearallmarkers (CWidget * none, XEvent * xe, CEvent * ce);
831:31:int cb_removelastmarker (CWidget * none, XEvent * xe, CEvent * ce);
832:32:int cb_newrender (CWidget * w, XEvent * xevent, CEvent * cwevent);
833:33:int cb_editor (CWidget * editor, XEvent * xevent, CEvent * cwevent);
834:34:int cb_3dplane (CWidget * w, XEvent * xevent, CEvent * cwevent);
835:35:int cb_draw_cam_data (CWidget * w, XEvent * xe, CEvent * ce);
836:36:int cb_showcal (CWidget * w, XEvent * xe, CEvent * ce);
837:37:int cb_leave (CWidget * w, XEvent * xe, CEvent * ce);
838:38:int cb_sigma (CWidget * w, XEvent * xe, CEvent * ce);
839:39:int cb_save_desktop (CWidget * w, XEvent * xe, CEvent * ce);
840:40:int cb_load_desktop (CWidget * w, XEvent * xe, CEvent * ce);
841:41:int cb_getsurface (CWidget * none, XEvent * xevent, CEvent * cwevent);
842:42:int cb_getcircle (CWidget * none, XEvent * xevent, CEvent * cwevent);
843:43:int cb_getellipse (CWidget * none, XEvent * xevent, CEvent * cwevent);
844:44:int cb_getline (CWidget * none, XEvent * xevent, CEvent * cwevent);
845:45:int cb_save_window (CWidget * none, XEvent * xevent, CEvent * cwevent);
846:46:int cb_getcylinderedge (CWidget * none, XEvent * xevent, CEvent * cwevent);
847:47:int cb_getlineedge (CWidget * none, XEvent * xevent, CEvent * cwevent);
848:48:int cb_getcircleedge (CWidget * none, XEvent * xevent, CEvent * cwevent);
849:49:
850:50:#endif
851:1:/*****************************************************************************************/
852:2:/* camera.c - undestort camera coordinates                                               */
853:3:/*****************************************************************************************/
854:4:/*
855:5:   Copyright (C) 1996, 1997 Paul Sheer
856:6:
857:7:   This program is free software; you can redistribute it and/or modify
858:8:   it under the terms of the GNU General Public License as published by
859:9:   the Free Software Foundation; either version 2 of the License, or
860:10:   (at your option) any later version.
861:11:
862:12:   This program is distributed in the hope that it will be useful,
863:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
864:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
865:15:   GNU General Public License for more details.
866:16:
867:17:   You should have received a copy of the GNU General Public License
868:18:   along with this program; if not, write to the Free Software
869:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
870:20: */
871:21:
872:22:#include <config.h>
873:23:#include "global.h"
874:24:#include "matrix.h"
875:25:#include "camera.h"
876:26:
877:27:Matrix *Macamundestortmany (Camera * c, Matrix * x)
878:28:{
879:29:    int i = 0;
880:30:    for (; i < x->columns; i++)
881:31:        imagetocamera (c, (Mard (*x, 0, i)), (Mard (*x, 1, i)));
882:32:    return x;
883:33:}
884:34:
885:35:void camundestortmany (Camera * cam, double *x, double *y, int n)
886:36:{
887:37:    int i;
888:38:    for (i = 0; i < n; i++)
889:39:        imagetocamera (cam, x[i], y[i]);
890:40:}
891:1:/*
892:2:   Copyright (C) 1996, 1997 Paul Sheer
893:3:
894:4:   This program is free software; you can redistribute it and/or modify
895:5:   it under the terms of the GNU General Public License as published by
896:6:   the Free Software Foundation; either version 2 of the License, or
897:7:   (at your option) any later version.
898:8:
899:9:   This program is distributed in the hope that it will be useful,
900:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
901:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
902:12:   GNU General Public License for more details.
903:13:
904:14:   You should have received a copy of the GNU General Public License
905:15:   along with this program; if not, write to the Free Software
906:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
907:17: */
908:18:#ifndef CAMERA_H
909:19:#define CAMERA_H
910:20:
911:21:#include "matrix.h"
912:22:#include "quickmath.h"
913:23:
914:24:typedef struct {
915:25:    double phi;
916:26:    double theta;
917:27:    double tsi;
918:28:    double f;
919:29:    double sig;                 /*sigma */
920:30:    double s;
921:31:    Vec x;                      /* centre */
922:32:    Vec m_x, m_y, m_s;
923:33:/*
924:34:   distortion correction could come here:
925:35: */
926:36:    double a1;
927:37:    double a2;
928:38:    double a3;
929:39:    double a4;
930:40:    double a5;
931:41:    double a6;
932:42:
933:43:/* sum squared error in calculation */
934:44:    double e;
935:45:} Camera;
936:46:
937:47:/* 
938:48:   some definitions:
939:49:   a PICTURE is the structure containing black and white of that
940:50:   view. It has coords top left and down.
941:51:
942:52:   an IMAGE is the physical photograph. It has coords centre and up.
943:53:
944:54:   a CAMERA is same as the IMAGE but undestorted
945:55:
946:56:   finally PHYS is the unrotated actual 3D coord.
947:57:
948:58:   sequence of transformation is.
949:59:
950:60:   phystocamera (cam,v,x,y)  /+ result in x, y +/
951:61:   cameratoimage (cam, v.x, v.y)        /+ v.x and v.y altered +/
952:62:   imagetopic (pic, v.x, v.y)   /+ v.x and v.y altered +/
953:63:   the result is the picture coord (from the top left corner and
954:64:   always positive)
955:65:   the reverse is just pictoimage, imagetocamera,
956:66:   camtophys (c1, c2, v, x1, y1, x2, y2)
957:67: */
958:68:
959:69:#define imagetocamera(c,x,y) { \
960:70:    (y) /= (1 + (c)->sig / 100); \
961:71:}
962:72:
963:73:#define cameratoimage(c,x,y) { \
964:74:    (y) *= (1 + (c)->sig / 100); \
965:75:}
966:76:
967:77:#define phystocamera(c,v,xs,ys) { \
968:78:    Vec ___v; \
969:79:    double ___s = dot ((c)->m_s, ___v = minus ((v), (c)->x)); \
970:80:    if (___s <= 0) \
971:81:        ___s = -1e-10; \
972:82:    (xs) = -(c)->f * dot ((c)->m_x, ___v) / ___s; \
973:83:    (ys) = -(c)->f * dot ((c)->m_y, ___v) / ___s; \
974:84:}
975:85:
976:86:/* camtophys(Camera *c1, Camera *c2, Vec v, double x1, 
977:87:   double y1, double x2, double y2);  */
978:88:
979:89:#define cameratophys(c1,c2,v,x1,y1,x2,y2) { \
980:90:    Camera *___c[2]; \
981:91:    double ___x[2], ___y[2]; \
982:92:    ___x[0] = (x1); \
983:93:    ___x[1] = (x2); \
984:94:    ___y[0] = (y1); \
985:95:    ___y[1] = (y2); \
986:96:    ___c[0] = (c1); \
987:97:    ___c[1] = (c2); \
988:98:    (v) = triangulate_camera_point (___x, ___y, c, 2); \
989:99:}
990:100:
991:101:void camundestortmany (Camera * cam, double *x, double *y, int n);
992:102:
993:103:#endif
994:1:/*****************************************************************************************/
995:2:/* desktop.c - save and restore the desktop to *.dsk files                               */
996:3:/*****************************************************************************************/
997:4:/*
998:5:   Copyright (C) 1996, 1997 Paul Sheer
999:6:
1000:7:   This program is free software; you can redistribute it and/or modify
1001:8:   it under the terms of the GNU General Public License as published by
1002:9:   the Free Software Foundation; either version 2 of the License, or
1003:10:   (at your option) any later version.
1004:11:
1005:12:   This program is distributed in the hope that it will be useful,
1006:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
1007:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
1008:15:   GNU General Public License for more details.
1009:16:
1010:17:   You should have received a copy of the GNU General Public License
1011:18:   along with this program; if not, write to the Free Software
1012:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
1013:20: */
1014:21:
1015:22:#include "display.h"
1016:23:#include "widget3d.h"
1017:24:#include "marker.h"
1018:25:#include "displaycam.h"
1019:26:#include "loadcalfile.h"
1020:27:#include "imagehandler.h"
1021:28:#include "picsetup.h"
1022:29:#include "edit.h"
1023:30:#include "dialog.h"
1024:31:#include "loadfile.h"
1025:32:
1026:33:/* \end{verbatim} \begin{verbatim} */
1027:34:
1028:35:static void strwrite (int f, const char *s)
1029:36:{
1030:37:    int len;
1031:38:    if (!s) {
1032:39:        len = -1;
1033:40:        write (f, (char *) &len, sizeof (int));
1034:41:    } else {
1035:42:        len = strlen (s);
1036:43:        write (f, (char *) &len, sizeof (int));
1037:44:        write (f, s, len);
1038:45:    }
1039:46:}
1040:47:
1041:48:static char *strread (int f)
1042:49:{
1043:50:    int len;
1044:51:    char *s;
1045:52:    read (f, (char *) &len, sizeof (int));
1046:53:    if (len < 0) {
1047:54:        return 0;
1048:55:    } else {
1049:56:        s = Cmalloc (len + 1);
1050:57:        read (f, s, len);
1051:58:        s[len] = 0;
1052:59:        return s;
1053:60:    }
1054:61:}
1055:62:
1056:63:
1057:64:int do_save_desktop (Desktop * d, char *filename)
1058:65:{
1059:66:    int f;
1060:67:    if ((f = creat (filename, 0644)) >= 0) {
1061:68:        int i;
1062:69:        Desktop save;
1063:70:        memcpy (&save, d, sizeof (Desktop));
1064:71:        save.cal_points = 0;
1065:72:        save.cal_file = 0;
1066:73:        save.temp_dir = save.image_dir = 0;
1067:74:        for (i = 0; i < save.num_views; i++) {
1068:75:            save.view[i].filename = 0;
1069:76:            memset (&save.view[i].pic.main_image, 0, (unsigned long)
1070:77:                    (&save.view[i].pic.last_pointer) - (unsigned long)
1071:78:                    (&save.view[i].pic.main_image));
1072:79:        }
1073:80:        strwrite (f, "stereo\n - saved desktop\n\n");
1074:81:        write (f, &save, sizeof (Desktop));
1075:82:        write (f, d->cal_points, d->num_cal_points * sizeof (Vec));
1076:83:        strwrite (f, d->cal_file);
1077:84:        strwrite (f, d->temp_dir);
1078:85:        strwrite (f, d->image_dir);
1079:86:        if (d->num_views)
1080:87:            for (i = 0; i < d->num_views; i++)
1081:88:                strwrite (f, d->view[i].filename);
1082:89:        close (f);
1083:90:        return 0;
1084:91:    } else {
1085:92:        Cerrordialogue (CMain, 20, 20, " Save Desktop ",
1086:93:                        get_sys_error (" Error trying to save file. "));
1087:94:    }
1088:95:    return 1;
1089:96:}
1090:97:
1091:98:
1092:99:int save_desktop (Desktop * d)
1093:100:{
1094:101:    char *filename;
1095:102:
1096:103:    filename = Cgetfile (0, 0, 0, home_dir, "", " Save Desktop ");
1097:104:
1098:105:    if (filename)
1099:106:        if (*filename)
1100:107:            return do_save_desktop (d, filename);
1101:108:    return 1;
1102:109:}
1103:110:
1104:111:int setup_view (Desktop * d, char *filename, int x, int y, int i);
1105:112:
1106:113:int do_load_desktop (Desktop * d, char *filename)
1107:114:{
1108:115:    int f;
1109:116:    if ((f = open (filename, O_RDONLY)) >= 0) {
1110:117:        int i, x = 40, y = 40;
1111:118:        char *sign;
1112:119:        sign = strread (f);
1113:120:        if (strcmp (sign, "stereo\n - saved desktop\n\n")) {
1114:121:            close (f);
1115:122:            Cerrordialogue (CMain, 20, 20, " Load Desktop ",
1116:123:                            " This is not a desktop file ");
1117:124:            free (sign);
1118:125:            return 1;
1119:126:        }
1120:127:        free (sign);
1121:128:        for (i = 0; i < d->num_views; i++)
1122:129:            destroy_view (&(d->view[i]));
1123:130:        clear (d, Desktop);
1124:131:        read (f, d, sizeof (Desktop));
1125:132:        destroy ((void *) &d->cal_points);
1126:133:        d->cal_points = Cmalloc (d->num_cal_points * sizeof (Vec));
1127:134:        read (f, d->cal_points, d->num_cal_points * sizeof (Vec));
1128:135:        d->cal_file = strread (f);
1129:136:        d->temp_dir = strread (f);
1130:137:        d->image_dir = strread (f);
1131:138:        if (d->num_views)
1132:139:            for (i = 0; i < d->num_views; i++) {
1133:140:                char *v;
1134:141:                v = strread (f);
1135:142:                if (v) {
1136:143:                    setup_view (d, v, x += 20, y += 20, i);
1137:144:                    d->view[i].filename = v;
1138:145:                }
1139:146:            }
1140:147:        draw_markers (d);
1141:148:        close (f);
1142:149:        return 0;
1143:150:    } else {
1144:151:        Cerrordialogue (CMain, 20, 20, " Load Desktop ",
1145:152:                        get_sys_error (" Error trying to save file. "));
1146:153:    }
1147:154:    return 1;
1148:155:}
1149:156:
1150:157:int load_desktop (Desktop * d)
1151:158:{
1152:159:    char *filename;
1153:160:
1154:161:    filename = Cgetfile (0, 0, 0, home_dir, "", " Load Desktop ");
1155:162:
1156:163:    if (filename)
1157:164:        if (*filename)
1158:165:            return do_load_desktop (d, filename);
1159:166:    return 1;
1160:167:}
1161:1:/*
1162:2:   Copyright (C) 1996, 1997 Paul Sheer
1163:3:
1164:4:   This program is free software; you can redistribute it and/or modify
1165:5:   it under the terms of the GNU General Public License as published by
1166:6:   the Free Software Foundation; either version 2 of the License, or
1167:7:   (at your option) any later version.
1168:8:
1169:9:   This program is distributed in the hope that it will be useful,
1170:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
1171:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
1172:12:   GNU General Public License for more details.
1173:13:
1174:14:   You should have received a copy of the GNU General Public License
1175:15:   along with this program; if not, write to the Free Software
1176:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
1177:17: */
1178:18:#ifndef _DESK_TOP_H
1179:19:#define _DESK_TOP_H
1180:20:
1181:21:int do_save_desktop (Desktop * d, char *filename);
1182:22:int do_load_desktop (Desktop * d, char *filename);
1183:23:int save_desktop (Desktop * d);
1184:24:int load_desktop (Desktop * d);
1185:25:
1186:26:#endif
1187:1:/*****************************************************************************************/
1188:2:/* display.c - main() function                                                           */
1189:3:/*****************************************************************************************/
1190:4:/*
1191:5:   Copyright (C) 1996, 1997 Paul Sheer
1192:6:
1193:7:   This program is free software; you can redistribute it and/or modify
1194:8:   it under the terms of the GNU General Public License as published by
1195:9:   the Free Software Foundation; either version 2 of the License, or
1196:10:   (at your option) any later version.
1197:11:
1198:12:   This program is distributed in the hope that it will be useful,
1199:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
1200:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
1201:15:   GNU General Public License for more details.
1202:16:
1203:17:   You should have received a copy of the GNU General Public License
1204:18:   along with this program; if not, write to the Free Software
1205:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
1206:20: */
1207:21:
1208:22:#include <config.h>
1209:23:#include "global.h"
1210:24:#include <stdio.h>
1211:25:#include <stdlib.h>
1212:26:
1213:27:#include <X11/Xlib.h>
1214:28:#include <X11/Xutil.h>
1215:29:#include <X11/keysym.h>
1216:30:
1217:31:#include "app_glob.c"
1218:32:#include "coolwidget.h"
1219:33:#include "imagewidget.h"
1220:34:
1221:35:#include "stringtools.h"
1222:36:#include "dirtools.h"
1223:37:#include "hugeimage.h"
1224:38:#include "widget3d.h"
1225:39:#include "edit.h"
1226:40:#include "camera.h"
1227:41:#include "fitline.h"
1228:42:
1229:43:#include <sys/types.h>
1230:44:#include <dirent.h>
1231:45:#include <string.h>
1232:46:#include <sys/stat.h>
1233:47:#include <unistd.h>
1234:48:#include <math.h>
1235:49:
1236:50:#include "loadfile.h"
1237:51:#include "display.h"
1238:52:#include "main/callback.h"
1239:53:#include "main/imagefit.h"
1240:54:#include "dialog.h"
1241:55:#include "matrix.h"
1242:56:#include "calibrate.h"
1243:57:#include "3dkit.h"
1244:58:#include "desktop.h"
1245:59:#include "mad.h"
1246:60:
1247:61:Desktop desktop;
1248:62:
1249:63:#define WIDTH3D 640
1250:64:#define HEIGHT3D 480
1251:65:
1252:66:/* options */
1253:67:
1254:68:char *editor_options_file = 0;
1255:69:
1256:70:char *option_display = 0;
1257:71:char *option_geometry = 0;
1258:72:char *option_background_color = 0;
1259:73:char *option_foreground_red = 0;
1260:74:char *option_foreground_green = 0;
1261:75:char *option_foreground_blue = 0;
1262:76:char *option_font = 0;
1263:77:
1264:78:
1265:79:int leave_out_calibration_points = 0;
1266:80:
1267:81:void goto_error (char *message)
1268:82:{
1269:83:
1270:84:}
1271:85:
1272:86:void init_desktop (Desktop * d)
1273:87:{
1274:88:    clear (d, Desktop);
1275:89:    d->image_dir = strdup (DATADIR);
1276:90:    d->temp_dir = strdup (TEMPDIR);
1277:91:}
1278:92:
1279:93:
1280:94:void stereo_init (char *name)
1281:95:{
1282:96:    CInitData stereo_startup = {
1283:97:        20, 0, 0, 0, 0, 0, 0, 0,
1284:98:        0, 0, 0, 0, 0, 0, 0, 0,
1285:99:        0
1286:100:    };
1287:101:
1288:102:    stereo_startup.height_plus = 900;
1289:103:    stereo_startup.lines = 0;
1290:104:    stereo_startup.width_plus = 700;
1291:105:    stereo_startup.columns = 0;
1292:106:    stereo_startup.options |= CINIT_OPTION_USE_GREY;
1293:107:
1294:108:    stereo_startup.name = name;
1295:109:
1296:110:/* initialise: */
1297:111:    Cinit (&stereo_startup);
1298:112:}
1299:113:
1300:114:void main (int argc, char **argv)
1301:115:{
1302:116:    int menuopen = 0;
1303:117:    int x, y, x1;
1304:118:    CEvent cwevent;
1305:119:    XEvent xevent;
1306:120:    Window choicewin, editorwin, win3d;
1307:121:
1308:122:    init_desktop (&desktop);
1309:123:
1310:124:    stereo_init (argv[0]);
1311:125:
1312:126:    choicewin = Cdrawwindow ("choicewin", CMain, 0, 0, 10, 10, "");
1313:127:    Cgethintpos (&x, &y);
1314:128:    x1 = x;
1315:129:    Cdrawbutton ("load", choicewin, x, y, AUTO_SIZE, " Load Image ");
1316:130:    Cgethintpos (&x, 0);
1317:131:    Cdrawbutton ("loadcal", choicewin, x, y, AUTO_SIZE,
1318:132:                 " Load Calibration File ");
1319:133:    Cgethintpos (&x, 0);
1320:134:    Cdrawbutton ("showcal", choicewin, x, y, AUTO_SIZE,
1321:135:                 " Display Calibration Points ");
1322:136:    Cgethintpos (0, &y);
1323:137:    x = x1;
1324:138:    Cdrawbutton ("loadd", choicewin, x, y, AUTO_SIZE,
1325:139:                 " Load Previous Desktop ");
1326:140:    Cgethintpos (&x, 0);
1327:141:    Cdrawbutton ("saved", choicewin, x, y, AUTO_SIZE,
1328:142:                 " Save Previous Desktop ");
1329:143:    Cgethintpos (&x, 0);
1330:144:    Cdrawbutton ("finish", choicewin, x, y, AUTO_SIZE, " Quit ");
1331:145:    Cgethintpos (0, &y);
1332:146:    x = x1;
1333:147:    Cdrawbutton ("getpnt", choicewin, x, y, AUTO_SIZE,
1334:148:                 " Triangulate Point        ");
1335:149:    Cgethintpos (&x, 0);
1336:150:    Cdrawbutton ("getsurf", choicewin, x, y, AUTO_SIZE,
1337:151:                 " Triangulate Multiple Points (Surface)   ");
1338:152:    Cgethintpos (0, &y);
1339:153:    x = x1;
1340:154:    Cdrawbutton ("getline", choicewin, x, y, AUTO_SIZE,
1341:155:                 " Fit Line from Points     ");
1342:156:    Cgethintpos (&x, 0);
1343:157:    Cdrawbutton ("getlineedge", choicewin, x, y, AUTO_SIZE,
1344:158:                 " Fit Line from two Line Projections      ");
1345:159:    Cgethintpos (0, &y);
1346:160:    x = x1;
1347:161:    Cdrawbutton ("getcyl", choicewin, x, y, AUTO_SIZE,
1348:162:                 " Fit Cylinder from Points ");
1349:163:    Cgethintpos (&x, 0);
1350:164:    Cdrawbutton ("getcyle", choicewin, x, y, AUTO_SIZE,
1351:165:                 " Fit Cylinder from four Line Projections ");
1352:166:    Cgethintpos (0, &y);
1353:167:    x = x1;
1354:168:    Cdrawbutton ("getcirc", choicewin, x, y, AUTO_SIZE,
1355:169:                 " Fit Circle from Points   ");
1356:170:    Cgethintpos (&x, 0);
1357:171:    Cdrawbutton ("getcircedge", choicewin, x, y, AUTO_SIZE,
1358:172:                 " Fit Circle from Ellipses Projections    ");
1359:173:    Cgethintpos (0, &y);
1360:174:    x = x1;
1361:175:    Cdrawbutton ("getellipse", choicewin, x, y, AUTO_SIZE,
1362:176:                 " Fit Ellipse from Points  ");
1363:177:    Cgethintpos (&x, 0);
1364:178:
1365:179:    Csetsizehintpos ("choicewin");
1366:180:
1367:181:    editorwin = Cdrawwindow ("editorwin", CMain, 200, 100, 640 + 18,
1368:182:                             450 + 40 + 18 + TEXT_PIX_PER_LINE + 11, "");
1369:183:    Cdraweditor ("editor", editorwin, 6, 6 + 40,
1370:184:                 640, 450, "", 0, "/home/terry/stereo-0.2b/tmp/");
1371:185:
1372:186:    CDrawEditMenuButtons ("em", editorwin, Cwidget ("editor")->winid, 10,
1373:187:                          10);
1374:188:
1375:189:    Caddcallback ("editor", cb_editor);
1376:190:
1377:191:
1378:192:    Cdraw3dobject ("3dview", win3d = Cdrawwindow ("3dplanewin",
1379:193:                                                  CMain, 150, 150,
1380:194:                                                  WIDTH3D + 100,
1381:195:                                                  16 + HEIGHT3D, ""), 6, 6,
1382:196:                   WIDTH3D, HEIGHT3D, 1, 256);
1383:197:
1384:198:    Cdrawbutton ("plshr", win3d, WIDTH3D + 20, 10, 70, 20, "Shrink");
1385:199:    Cdrawbutton ("plenl", win3d, WIDTH3D + 20, 40, 70, 20, "Enlarge");
1386:200:    Cdrawbutton ("newrender", win3d, WIDTH3D + 20, 70, 70, 20,
1387:201:                 "New render");
1388:202:    Cdrawbutton ("density", win3d, WIDTH3D + 20, 100, 70, 20, "Density");
1389:203:    Cdrawbutton ("flattri", win3d, WIDTH3D + 20, 130, 70, 20,
1390:204:                 "Flat Triangle");
1391:205:    Cdrawbutton ("savewin", win3d, WIDTH3D + 20, 160, 70, 20,
1392:206:                 "Save Window");
1393:207:
1394:208:
1395:209:    Caddcallback ("getpnt", cb_getpoint);
1396:210:    Caddcallback ("getellipse", cb_getellipse);
1397:211:    Caddcallback ("getcircedge", cb_getcircleedge);
1398:212:
1399:213:    Caddcallback ("load", cb_newimage);
1400:214:
1401:215:    Caddcallback ("3dview", cb_3dplane);
1402:216:    Caddcallback ("newrender", cb_newrender);
1403:217:
1404:218:
1405:219:    Caddcallback ("getsurf", cb_getsurface);
1406:220:    Caddcallback ("getline", cb_getline);
1407:221:    Caddcallback ("getcirc", cb_getcircle);
1408:222:    Caddcallback ("getcyle", cb_getcylinderedge);
1409:223:    Caddcallback ("getcyl", cb_getcylinder);
1410:224:    Caddcallback ("getlineedge", cb_getlineedge);
1411:225:
1412:226:    Caddcallback ("loadcal", cb_loadcal);
1413:227:    Caddcallback ("showcal", cb_showcal);
1414:228:    Caddcallback ("saved", cb_save_desktop);
1415:229:    Caddcallback ("loadd", cb_load_desktop);
1416:230:
1417:231:    Caddcallback ("savewin", cb_save_window);
1418:232:
1419:233:    if (argc > 1)
1420:234:        if (*argv[1] != '-')
1421:235:            do_load_desktop (&desktop, argv[1]);
1422:236:
1423:237:    do {
1424:238:        CNextEvent (&xevent, &cwevent);
1425:239:
1426:240:        if (!strcmp (cwevent.ident, "plshr")) {
1427:241:            Cwidget ("3dview")->solid->distance += 2400;
1428:242:            Cwidget ("3dview")->solid->y_cam += 2400;
1429:243:            Credraw3dobject ("3dview", 0);
1430:244:        }
1431:245:        if (!strcmp (cwevent.ident, "plenl")) {
1432:246:            Cwidget ("3dview")->solid->distance -= 2400;
1433:247:            Cwidget ("3dview")->solid->y_cam -= 2400;
1434:248:            Credraw3dobject ("3dview", 0);
1435:249:        }
1436:250:        if (!strcmp (cwevent.ident, "flattri")) {
1437:251:            CWidget *w = Cwidget ("3dview");
1438:252:            if (w->solid->option_flags & TDOPTION_FLAT_TRIANGLE) {
1439:253:                w->solid->option_flags &=
1440:254:                    0xFFFFFFFF - TDOPTION_FLAT_TRIANGLE;
1441:255:            } else {
1442:256:                w->solid->option_flags |= TDOPTION_FLAT_TRIANGLE;
1443:257:            }
1444:258:            Credraw3dobject ("3dview", 0);
1445:259:        }
1446:260:        if (!strcmp (cwevent.ident, "kill")) {
1447:261:            menuopen = 0;
1448:262:            Cundrawwidget ("win1");
1449:263:        }
1450:264:    } while (strcmp (cwevent.ident, "finish"));
1451:265:
1452:266:    Cundrawall ();
1453:267:    mad_finalize (__FILE__, __LINE__);
1454:268:
1455:269:}
1456:1:/*****************************************************************************************/
1457:2:/* displaycam.c - draw a list of the camera data                                         */
1458:3:/*****************************************************************************************/
1459:4:/*
1460:5:   Copyright (C) 1996, 1997 Paul Sheer
1461:6:
1462:7:   This program is free software; you can redistribute it and/or modify
1463:8:   it under the terms of the GNU General Public License as published by
1464:9:   the Free Software Foundation; either version 2 of the License, or
1465:10:   (at your option) any later version.
1466:11:
1467:12:   This program is distributed in the hope that it will be useful,
1468:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
1469:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
1470:15:   GNU General Public License for more details.
1471:16:
1472:17:   You should have received a copy of the GNU General Public License
1473:18:   along with this program; if not, write to the Free Software
1474:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
1475:20: */
1476:21:
1477:22:#include "display.h"
1478:23:#include "main/imagefit.h"
1479:24:#include "app_glob.c"
1480:25:#include "hugeimage.h"
1481:26:#include "widget3d.h"
1482:27:#include "main/marker.h"
1483:28:#include "main/displaycam.h"
1484:29:#include "picsetup.h"
1485:30:#include "dialog.h"
1486:31:#include "stringtools.h"
1487:32:#include "callback.h"
1488:33:#include "matrix.h"
1489:34:
1490:35:
1491:36:#include "bitmap/camera.bitmap"
1492:37:#include "bitmap/camphi.bitmap"
1493:38:#include "bitmap/camtheta.bitmap"
1494:39:#include "bitmap/campsi.bitmap"
1495:40:#include "bitmap/camf.bitmap"
1496:41:#include "bitmap/camsig.bitmap"
1497:42:#include "bitmap/camxy.bitmap"
1498:43:#include "bitmap/camz.bitmap"
1499:44:
1500:45:/* \end{verbatim} \begin{verbatim} */
1501:46:
1502:47:void draw_camera_data_text (Camera * c, Window win, int x, int y)
1503:48:{
1504:49:    if (!Ci ("caldatabitmaps")) {
1505:50:        Cdrawbitmap ("caldatabitmaps", win, x, y,
1506:51:                     40, 32, Ccolor (1), Ccolor (25), camphi_bits);
1507:52:        Cdrawbitmap ("", win, x, y + 50,
1508:53:                     40, 32, Ccolor (1), Ccolor (25), camtheta_bits);
1509:54:        Cdrawbitmap ("", win, x, y + 100,
1510:55:                     40, 32, Ccolor (1), Ccolor (25), campsi_bits);
1511:56:        Cdrawbitmap ("", win, x, y + 150,
1512:57:                     40, 32, Ccolor (1), Ccolor (25), camf_bits);
1513:58:        Cdrawbitmap ("", win, x, y + 200,
1514:59:                     40, 40, Ccolor (1), Ccolor (25), camxy_bits);
1515:60:        Cdrawbitmap ("", win, x, y + 258,
1516:61:                     40, 20, Ccolor (1), Ccolor (25), camz_bits);
1517:62:        Cdrawbitmap ("", win, x, y + 296,
1518:63:                     40, 32, Ccolor (1), Ccolor (25), camsig_bits);
1519:64:
1520:65:        y += 10;
1521:66:        x += 55;
1522:67:
1523:68:        Cdrawtext ("tcalphi", win, x, y, " %15.2f ", c->phi * 180 / PI);
1524:69:        Cdrawtext ("tcaltheta", win, x, y + 50, " %15.2f ",
1525:70:                   c->theta * 180 / PI);
1526:71:        Cdrawtext ("tcaltsi", win, x, y + 100, " %15.2f ",
1527:72:                   c->tsi * 180 / PI);
1528:73:        Cdrawtext ("tcalf", win, x, y + 150, " %15.8g ", c->f);
1529:74:        Cdrawtext ("tcalx", win, x, y + 192, " %15.8g ", c->x.x);
1530:75:        Cdrawtext ("tcaly", win, x, y + 216, " %15.8g ", c->x.y);
1531:76:        Cdrawtext ("tcalz", win, x, y + 252, " %15.8g ", c->x.z);
1532:77:        Cdrawtext ("tcalsig", win, x, y + 296, " %15.5g ", c->sig);
1533:78:        Cdrawtext ("tcale", win, 10, y + 340,
1534:79:                   " Sum squared error in pixels: \n %15.5g ", c->e);
1535:80:
1536:81:    } else {                    /*merely update the text */
1537:82:        y += 10;
1538:83:        x += 55;
1539:84:
1540:85:        Credrawtext ("tcalphi", " %15.2f ", c->phi * 180 / PI);
1541:86:        Credrawtext ("tcaltheta", " %15.2f ", c->theta * 180 / PI);
1542:87:        Credrawtext ("tcaltsi", " %15.2f ", c->tsi * 180 / PI);
1543:88:        Credrawtext ("tcalf", " %15.8g ", c->f);
1544:89:        Credrawtext ("tcalx", " %15.8g ", c->x.x);
1545:90:        Credrawtext ("tcaly", " %15.8g ", c->x.y);
1546:91:        Credrawtext ("tcalz", " %15.8g ", c->x.z);
1547:92:        Credrawtext ("tcalsig", " %15.5g ", c->sig);
1548:93:    }
1549:94:}
1550:95:
1551:96:
1552:97:void draw_calibrarion_data_text (Desktop * d, Window win, int x, int y)
1553:98:{
1554:99:    int i;
1555:100:    if (d->num_cal_points)
1556:101:        for (i = 0; i < d->num_cal_points; i++)
1557:102:            Cdrawtext (catstrs ("calpoint", itoa (i), 0), win, x,
1558:103:                       y + 30 * i, " %3d: %15f %15f %15f ", i + 1,
1559:104:                       d->cal_points[i].x, d->cal_points[i].y,
1560:105:                       d->cal_points[i].z);
1561:106:    else
1562:107:        Cdrawtext ("calpoint", win, x, y, " Data not loaded ");
1563:108:}
1564:109:
1565:110:
1566:111:void draw_camera_data_window (Camera * c)
1567:112:{
1568:113:    Window win;
1569:114:    static isopen = 0;
1570:115:
1571:116:    if (isopen) {
1572:117:        Cundrawwidget ("camdatawin");
1573:118:        isopen = 0;
1574:119:    } else {
1575:120:        win =
1576:121:            Cdrawwindow ("camdatawin", CMain, 20, 20, 300, 410,
1577:122:                         "caldatawin");
1578:123:        draw_camera_data_text (c, win, 10, 10);
1579:124:        isopen = 1;
1580:125:    }
1581:126:}
1582:127:
1583:128:void draw_camera_data (Desktop * d, CEvent * e)
1584:129:{
1585:130:    set_current_from_pointer (d, e);
1586:131:    if (d->num_views) {
1587:132:        draw_camera_data_window (&d->view[d->current_view].cam);
1588:133:    }
1589:134:}
1590:135:
1591:136:void show_cal_points (Desktop * d, CEvent * e)
1592:137:{
1593:138:    Window win;
1594:139:    static int isopen = 0;
1595:140:
1596:141:    if (isopen) {
1597:142:        Cundrawwidget ("caldatawin");
1598:143:        isopen = 0;
1599:144:    } else {
1600:145:        int x, y;
1601:146:        win = Cdrawheadedwindow ("caldatawin", CMain, 20, 20, 460,
1602:147:                                 (d->num_cal_points ? d->
1603:148:                                  num_cal_points : 1) * 30 + 10,
1604:149:                                 " Calibration Points ");
1605:150:        Cgethintpos (&x, &y);
1606:151:        draw_calibrarion_data_text (d, win, x, y);
1607:152:        Csetsizehintpos ("caldatawin");
1608:153:        isopen = 1;
1609:154:    }
1610:155:}
1611:1:/*
1612:2:   Copyright (C) 1996, 1997 Paul Sheer
1613:3:
1614:4:   This program is free software; you can redistribute it and/or modify
1615:5:   it under the terms of the GNU General Public License as published by
1616:6:   the Free Software Foundation; either version 2 of the License, or
1617:7:   (at your option) any later version.
1618:8:
1619:9:   This program is distributed in the hope that it will be useful,
1620:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
1621:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
1622:12:   GNU General Public License for more details.
1623:13:
1624:14:   You should have received a copy of the GNU General Public License
1625:15:   along with this program; if not, write to the Free Software
1626:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
1627:17: */
1628:18:#ifndef _DISPLAY_CAM_H
1629:19:#define _DISPLAY_CAM_H
1630:20:
1631:21:void draw_camera_data_window (Camera * c);
1632:22:void draw_camera_data (Desktop * d, CEvent * e);
1633:23:void show_cal_points (Desktop * d, CEvent * ce);
1634:24:
1635:25:#endif
1636:1:/*
1637:2:   Copyright (C) 1996, 1997 Paul Sheer
1638:3:
1639:4:   This program is free software; you can redistribute it and/or modify
1640:5:   it under the terms of the GNU General Public License as published by
1641:6:   the Free Software Foundation; either version 2 of the License, or
1642:7:   (at your option) any later version.
1643:8:
1644:9:   This program is distributed in the hope that it will be useful,
1645:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
1646:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
1647:12:   GNU General Public License for more details.
1648:13:
1649:14:   You should have received a copy of the GNU General Public License
1650:15:   along with this program; if not, write to the Free Software
1651:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
1652:17: */
1653:18:#ifndef _DISPLAY_H
1654:19:#define _DISPLAY_H
1655:20:
1656:21:#include <config.h>
1657:22:#include "global.h"
1658:23:#include <stdlib.h>
1659:24:#include <stdio.h>
1660:25:#include <sys/types.h>
1661:26:
1662:27:#ifdef HAVE_UNISTD_H
1663:28:#include <unistd.h>
1664:29:#endif
1665:30:
1666:31:#include <my_string.h>
1667:32:#include <sys/stat.h>
1668:33:
1669:34:#ifdef HAVE_FCNTL_H
1670:35:#include <fcntl.h>
1671:36:#endif
1672:37:
1673:38:#include <stdlib.h>
1674:39:#include <stdarg.h>
1675:40:
1676:41:#ifdef HAVE_SYS_TIME_H
1677:42:#include <sys/time.h>
1678:43:#endif
1679:44:
1680:45:#include "regex.h"
1681:46:
1682:47:#include <X11/Xlib.h>
1683:48:#include <X11/Xutil.h>
1684:49:#include <X11/keysym.h>
1685:50:#include "coolwidget.h"
1686:51:
1687:52:#include "camera.h"
1688:53:#include "fitline.h"
1689:54:
1690:55:
1691:56:struct picwithzoom {
1692:57:    CWidget *main_image;        /* thumbnail image */
1693:58:    CWidget *zoom_image;        /* zoombox image */
1694:59:    CWidget *main_win;          /* window of thumbnail image */
1695:60:    CWidget *zoom_win;          /* window of zoombox image */
1696:61:    CWidget *main_rect;         /* zoombox rectagle rectangle 
1697:62:                                   in thumnail image */
1698:63:    CWidget *zoom_rect;         /* ..in zoom image */
1699:64:    CWidget *main_markers;      /* markers in thumbnail */
1700:65:    CWidget *zoom_markers;      /* markers in zoombox */
1701:66:
1702:67:
1703:68:    CWidget *Ttext;             /* text display of image info */
1704:69:    CWidget *Binfo;             /* display cam info button */
1705:70:    CWidget *Blast;             /* remove last marker button */
1706:71:    CWidget *Ball;              /* remove all markers button */
1707:72:    CWidget *Bcalibrate;        /* calibrate camera button */
1708:73:    CWidget *Bkill;             /* kill this window button */
1709:74:
1710:75:    CWidget *Bleave;            /* for later use */
1711:76:    CWidget *Tleave;
1712:77:    CWidget *Ssig;
1713:78:    CWidget *Isigma;
1714:79:    CWidget *B5;
1715:80:    int last_pointer;
1716:81:
1717:82:    long width, height;         /* width and height of the thumbnail image */
1718:83:    double real_width, real_height; /* width and height of the original image */
1719:84:    double x0, y0;              /* image centre */
1720:85:    int zwidth, zheight;        /* width and height of the zoomed area */
1721:86:    long xzoom, yzoom;          /* position of the zoomed area */
1722:87:    int mag;                    /* zoombox magnification */
1723:88:};
1724:89:
1725:90:typedef struct picwithzoom Picture;
1726:91:
1727:92:#define MAX_NUM_VIEWS 32
1728:93:#define MAX_NUM_MARKS 256
1729:94:
1730:95:typedef struct marks Mark;
1731:96:
1732:97:struct view {
1733:98:    Picture pic;
1734:99:    char *filename;             /* a tiff or targa file. 0 if non-existant */
1735:100:    Camera cam;                 /* camera data structure */
1736:101:    int calibrated;             /* always 1 if calibrated */
1737:102:    Vec mark[MAX_NUM_MARKS];
1738:103:    int num_marks;
1739:104:};
1740:105:
1741:106:typedef struct view View;
1742:107:
1743:108:struct desktop {
1744:109:    View view[MAX_NUM_VIEWS];
1745:110:    Vec *cal_points;
1746:111:    int num_cal_points;
1747:112:    int leave_out_calibration_points;
1748:113:    int optimise_sigma;
1749:114:    char *cal_file;
1750:115:    int current_view;
1751:116:    int num_views;
1752:117:    char *temp_dir;
1753:118:    char *image_dir;
1754:119:    Vec centre_offset_for_3d;
1755:120:    double scale_units_for_3d;
1756:121:};
1757:122:
1758:123:typedef struct desktop Desktop;
1759:124:
1760:125:
1761:126:int load_calibration_points (Desktop * d);
1762:127:int save_calibration_points (Desktop * d);
1763:128:int load_new_view (Desktop * d);
1764:129:/* int save_view(Desktop *d); */
1765:130:
1766:131:/* fits an object (see fitline.h) to the markers */
1767:132:int fit_object (Desktop * d, Object * object, int type);
1768:133:
1769:134:#define ZOOMSIZE (192*2)
1770:135:
1771:136:#define THESE_2D_PROJECTIONS_HAVE_BEEN_ADJUSTED_FOR_LENS_DISTORTION YES
1772:137:
1773:138:#define MAX_CAP 1024
1774:139:
1775:140:#define MONITOR_GAMMA 1.2
1776:141:
1777:142:#define MAX_CAL_FILE_SIZE 65536
1778:143:
1779:144:void Dcoordtotext (char *widgetevent, char *strx, char *stry,
1780:145:                   struct picwithzoom *image);
1781:146:
1782:147:int Cundrawrectangle (const char *ident);
1783:148:
1784:149:int Cdrawrectangle (const char *ident, int x, int y, int w,
1785:150:                    int h, unsigned long color);
1786:151:
1787:152:void Dcheckinsertcoordfromimage (CEvent * cwevent, const char *ident,
1788:153:                                 struct picwithzoom *image, int p);
1789:154:
1790:155:void Dimagecoord (CEvent * cwevent, double *x, double *y,
1791:156:                  struct picwithzoom *image);
1792:157:
1793:158:#endif                          /* _DISPLAY_H */
1794:1:/*****************************************************************************************/
1795:2:/* fitline.c - line, circle, ellipse, plane, and cylinder fitting routines               */
1796:3:/*****************************************************************************************/
1797:4:/*
1798:5:   Copyright (C) 1996, 1997 Paul Sheer
1799:6:
1800:7:   This program is free software; you can redistribute it and/or modify
1801:8:   it under the terms of the GNU General Public License as published by
1802:9:   the Free Software Foundation; either version 2 of the License, or
1803:10:   (at your option) any later version.
1804:11:
1805:12:   This program is distributed in the hope that it will be useful,
1806:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
1807:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
1808:15:   GNU General Public License for more details.
1809:16:
1810:17:   You should have received a copy of the GNU General Public License
1811:18:   along with this program; if not, write to the Free Software
1812:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
1813:20: */
1814:21:
1815:22:#include <config.h>
1816:23:#include "global.h"
1817:24:#include <stdlib.h>
1818:25:#include <string.h>
1819:26:#include <stdio.h>
1820:27:#include <math.h>
1821:28:#include "matrix.h"
1822:29:#include "camera.h"
1823:30:#include "simplex.h"
1824:31:#include "fitline.h"
1825:32:#include "quickmath.h"
1826:33:
1827:34:/* \end{verbatim} \begin{verbatim} */
1828:35:
1829:36:/* fast gauss-jordan elimination to diagonalise a 3x3 matrix 
1830:37:    with partial pivotting */
1831:38:Vec solve3x3 (double a[4][3])
1832:39:{
1833:40:    Vec v = { 10e20, 10e20, 10e20 };
1834:41:    int i, j, k, max;
1835:42:    double temp, r;
1836:43:    for (i = 0; i < 3; i++) {
1837:44:        max = i;
1838:45:        for (j = i + 1; j < 3; j++) {
1839:46:            if (fabs (a[i][j]) >= fabs (a[i][max]))
1840:47:                max = j;
1841:48:        }
1842:49:        for (k = i; k < 4; k++) {
1843:50:            temp = a[k][i];
1844:51:            a[k][i] = a[k][max];
1845:52:            a[k][max] = temp;
1846:53:        }
1847:54:        for (j = i + 1; j < 3; j++) {
1848:55:            if (!a[i][i])
1849:56:                return v;
1850:57:            r = a[i][j] / a[i][i];
1851:58:            for (k = 3; k >= i; k--)
1852:59:                a[k][j] -= a[k][i] * r;
1853:60:        }
1854:61:    }
1855:62:    for (i = 2; i > 0; i--) {
1856:63:        if (!a[i][i])
1857:64:            return v;
1858:65:        r = 1 / a[i][i] * a[3][i];
1859:66:        for (j = i - 1; j >= 0; j--) {
1860:67:            a[3][j] -= a[i][j] * r;
1861:68:            a[i][j] = 0;
1862:69:        }
1863:70:    }
1864:71:    if (!a[0][0] || !a[1][1] || !a[2][2])
1865:72:        return v;
1866:73:    v.x = a[3][0] / a[0][0];
1867:74:    v.y = a[3][1] / a[1][1];
1868:75:    v.z = a[3][2] / a[2][2];
1869:76:    return v;
1870:77:}
1871:78:
1872:79:
1873:80:static inline Vec screen (Camera * cam, Vec p)
1874:81:{
1875:82:    Vec v;
1876:83:    v.z = 0;
1877:84:    phystocamera (cam, p, v.x, v.y);
1878:85:    return v;
1879:86:}
1880:87:
1881:88:
1882:89:/* fitline fits a 2D line to 'numpoints' points whose x and y values 
1883:90:   are given as arrays xvals and yvals.
1884:91:
1885:92:   returns a, b and c of the line
1886:93:   a*x + b*y = c
1887:94:   in aa, ab, and ac.
1888:95:
1889:96:   return rules:
1890:97:   a^2 + b^2 = 1
1891:98:   b >= 0
1892:99:
1893:100:   errors are minimised normal to the line no-matter what the line's
1894:101:   orientation.
1895:102:   Fitline returns error.
1896:103: */
1897:104:double fitline (double *xvals, double *yvals, int numpoints,
1898:105:                double *aa, double *ab, double *ac)
1899:106:{
1900:107:    double e1, e2, a, b, c, p, q, r, s, t, m1, m2, c1, c2;
1901:108:    double sumx = 0, sumy = 0, sumxy = 0, sumxx = 0, sumyy = 0;
1902:109:    int i;
1903:110:
1904:111:    for (i = 0; i < numpoints; i++) {
1905:112:        sumx += xvals[i];
1906:113:        sumy += yvals[i];
1907:114:        sumxy += xvals[i] * yvals[i];
1908:115:        sumxx += xvals[i] * xvals[i];
1909:116:        sumyy += yvals[i] * yvals[i];
1910:117:    }
1911:118:
1912:119:/*Need to divide by 'numpoints' because of an algeabraic error. Usually 'numpoints' */
1913:120:/*would be included in the minimisation expression. */
1914:121:
1915:122:    p = sumx / numpoints;
1916:123:    q = sumy / numpoints;
1917:124:    r = sumxx / numpoints;
1918:125:    s = sumyy / numpoints;
1919:126:    t = sumxy / numpoints;
1920:127:
1921:128:/*coefficents of quadratic in m, (a m^2 + b m + c = 0): */
1922:129:
1923:130:    a = (double) p *q - t;
1924:131:    b = (double) p *p - (q * q + r - s);
1925:132:    c = (double) -a;
1926:133:
1927:134:    if (fabs (b) < fabs (10000 * a)) {
1928:135:        /*Indicating a not to steep slope. 
1929:136:           Otherwise minimisation must be handled differently. */
1930:137:
1931:138:/*There are two solutions; one for the maximum and one for minimum: */
1932:139:        m1 = (-b - sqrt (b * b - 4 * a * c)) / (2 * a);
1933:140:        m2 = (-b + sqrt (b * b - 4 * a * c)) / (2 * a);
1934:141:        c1 = q - m1 * p;
1935:142:        c2 = q - m2 * p;
1936:143:
1937:144:/*To determine the min from the max, check the actually error: */
1938:145:        e1 = (double) ((double) c1 * c1 + 2 * m1 * c1 * p +
1939:146:                       m1 * m1 * r - 2 * c1 * q - 2 * m1 * t +
1940:147:                       s) / (m1 * m1 + 1);
1941:148:        e2 = (double) ((double) c2 * c2 + 2 * m2 * c2 * p + m2 * m2 * r -
1942:149:                       2 * c2 * q - 2 * m2 * t + s) / (m2 * m2 + 1);
1943:150:
1944:151:        if (e1 < e2) {
1945:152:            m2 = m1;
1946:153:            c2 = c1;
1947:154:            e2 = e1;
1948:155:        }
1949:156:/*Return coefficients (a*x + b*y = c): */
1950:157:        if (fabs (m2) > 1) {
1951:158:            *ab = (double) 1 / m2;
1952:159:            *aa = (double) -1;
1953:160:            *ac = (double) c2 / m2;
1954:161:        } else {
1955:162:            *ab = 1;
1956:163:            *aa = -m2;
1957:164:            *ac = c2;
1958:165:        }
1959:166:    } else {
1960:167:
1961:168:/*For very steep lines (either close to vertical or close to horizontal), */
1962:169:/*use usual least squares fit, reversing x and y axis if */
1963:170:/*vertical. */
1964:171:
1965:172:        if ((sumxx - numpoints * p * p) > (sumyy - numpoints * q * q)) {
1966:173:            /* gives an indication of vertical or horizontal. */
1967:174:            *ac = ((double) sumxx * sumy - sumxy * sumx) /
1968:175:                (numpoints * sumxx - sumx * sumx);
1969:176:            *aa = -((double) numpoints * sumxy - sumx * sumy) /
1970:177:                (numpoints * sumxx - sumx * sumx);
1971:178:            *ab = 1;
1972:179:            e2 = sumyy + (*aa) * (*aa) * sumxx + 2 * (*ac) * (*aa) * sumx
1973:180:                + (*ac) * (*ac) + 2 * (*aa) * sumxy + 2 * (*ac) * sumy;
1974:181:            /*almost horizontal line */
1975:182:        } else {
1976:183:            *ac = ((double) sumyy * sumx - (double) sumxy * sumy) /
1977:184:                ((double) numpoints * sumyy - (double) sumy * sumy);
1978:185:            *ab = -((double) numpoints * sumxy - (double) sumy * sumx) /
1979:186:                ((double) numpoints * sumyy - (double) sumy * sumy);
1980:187:            *aa = 1;
1981:188:/*****check this error value as it seldom happens*/
1982:189:            e2 = sumxx + (*ab) * (*ab) * sumyy + 2 * (*ac) * (*ab) * sumy
1983:190:                + (*ac) * (*ac) + 2 * (*ab) * sumxy + 2 * (*ac) * sumx;
1984:191:            /*almost vertical line */
1985:192:        }
1986:193:    }
1987:194:
1988:195:    r = sqrt (sqr (*aa) + sqr (*ab));
1989:196:    if (*ab < 0)
1990:197:        r = -r;
1991:198:    *aa /= r;
1992:199:    *ab /= r;
1993:200:    *ac /= r;
1994:201:
1995:202:    return e2;
1996:203:}
1997:204:
1998:205:
1999:206:
2000:207:/*
2001:208:   Given 3D point coords this calcs the SS error with the least 3D line in
2002:209:   the direction (u,v,w). Returns the offset of where the first point is
2003:210:   closest to the line in (a,b,c). (u,v,w) is the vector
2004:211:   between where the first and last points are closest
2005:212:   to the line. The first and last points must
2006:213:   not coincide.
2007:214: */
2008:215:
2009:216:double error3dline (double *xp, double *yp, double *zp,
2010:217:                    int num_points,
2011:218:                    double u, double v, double w,
2012:219:                    double *a, double *b, double *c)
2013:220:{
2014:221:    Matrix *A;
2015:222:    double d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
2016:223:    double m, n, o, x, y, z;
2017:224:    double r;
2018:225:    int t;
2019:226:
2020:227:    r = u * u + v * v + w * w;
2021:228:
2022:229:    if (r) {
2023:230:        if (num_points > 2) {
2024:231:            for (t = 1; t < num_points - 1; t++) {
2025:232:                d += xp[t] * yp[t];
2026:233:                e += yp[t] * zp[t];
2027:234:                f += xp[t] * zp[t];
2028:235:                g += xp[t];
2029:236:                h += yp[t];
2030:237:                i += zp[t];
2031:238:                j += xp[t] * xp[t];
2032:239:                k += yp[t] * yp[t];
2033:240:                l += zp[t] * zp[t];
2034:241:            }
2035:242:        }
2036:243:        m = xp[num_points - 1];
2037:244:        n = yp[num_points - 1];
2038:245:        o = zp[num_points - 1];
2039:246:        x = xp[0];
2040:247:        y = yp[0];
2041:248:        z = zp[0];
2042:249:
2043:250:        num_points -= 2;
2044:251:        A = Madoublestomatrix (3, 4, (v * v + w * w) * num_points + 2 * r,
2045:252:                               -u * v * num_points,
2046:253:                               -u * w * num_points,
2047:254:                               h * u * v + i * u * w - g * (v * v +
2048:255:                                                            w * w) - (m +
2049:256:                                                                      x -
2050:257:                                                                      u) *
2051:258:                               r, -u * v * num_points,
2052:259:                               (u * u + w * w) * num_points + 2 * r,
2053:260:                               -v * w * num_points,
2054:261:                               g * u * v + i * v * w - h * (u * u +
2055:262:                                                            w * w) - (n +
2056:263:                                                                      y -
2057:264:                                                                      v) *
2058:265:                               r, -u * w * num_points, -v * w * num_points,
2059:266:                               (u * u + v * v) * num_points + 2 * r,
2060:267:                               g * u * w + h * v * w - i * (u * u +
2061:268:                                                            v * v) - (o +
2062:269:                                                                      z -
2063:270:                                                                      w) *
2064:271:                               r);
2065:272:
2066:273:        if (Madiag (A)) {
2067:274:
2068:275:            (*a) = -Mard ((*A), 0, 3);
2069:276:            (*b) = -Mard ((*A), 1, 3);
2070:277:            (*c) = -Mard ((*A), 2, 3);
2071:278:
2072:279:            Mafreematrix (A);
2073:280:
2074:281:            e = sqr (u + (*a) - m) + sqr (v + (*b) - n) + sqr (w + (*c) -
2075:282:                                                               o)
2076:283:                + sqr ((*a) - x) + sqr ((*b) - y) + sqr ((*c) - z)
2077:284:                - (sqr (u) * j + 2 * u * v * d + 2 * u * w * f - 2 *
2078:285:                   u * g * ((*a) * u + (*b) * v + (*c) * w)
2079:286:                   + sqr (v) * k + 2 * v * w * e - 2 * v * h *
2080:287:                   ((*a) * u + (*b) * v + (*c) * w)
2081:288:                   + sqr (w) * l - 2 * w * i * ((*a) * u + (*b) * v +
2082:289:                                                (*c) * w)
2083:290:                   +
2084:291:                   num_points *
2085:292:                   (pow ((*a) * u + (*b) * v + (*c) * w, 2))) / r + j -
2086:293:                2 * (*a) * g + k - 2 * (*b) * h + l - 2 * (*c) * i +
2087:294:                (sqr (*a) + sqr (*b) + sqr (*c)) * num_points;
2088:295:
2089:296:            return e;
2090:297:        }
2091:298:        Mafreematrix (A);
2092:299:    }
2093:300:    fprintf (stderr, "stereo:%s:%d: in call to error3dline()\n", __FILE__,
2094:301:             __LINE__);
2095:302:    return 10e90;
2096:303:}
2097:304:
2098:305:
2099:306:
2100:307:static double *x_points;
2101:308:static double *y_points;
2102:309:static double *z_points;
2103:310:static int num_3d_points;
2104:311:static double c_x, c_y, c_z;
2105:312:
2106:313:
2107:314:static double tominimise3dline (double *u)
2108:315:{
2109:316:    return error3dline (x_points, y_points, z_points, num_3d_points,
2110:317:                        u[0], u[1], u[2], &c_x, &c_y, &c_z);
2111:318:}
2112:319:
2113:320:
2114:321:LineSegment linesegment (Vec p1, Vec p2)
2115:322:{
2116:323:    LineSegment l;
2117:324:    memset (&l, 0, sizeof (LineSegment));
2118:325:    l.p1 = p1;
2119:326:    l.p2 = p2;
2120:327:    l.e = 0;
2121:328:    l.u = minus (p2, p1);
2122:329:    l.l = norm (l.u);
2123:330:    l.u = times (l.u, 1 / l.l);
2124:331:    l.psi = atan2 (l.u.y, l.u.x);
2125:332:    l.beta = atan2 (l.u.z, sqrt (sqr (l.u.x) + sqr (l.u.y)));
2126:333:    l.m = times (plus (l.p1, l.p2), 0.5);
2127:334:    l.a = -l.u.y;
2128:335:    l.b = l.u.x;
2129:336:    l.c = l.a * l.p1.x + l.b * l.p1.y;
2130:337:    l.type = LINE_SEGMENT;
2131:338:    return l;
2132:339:}
2133:340:
2134:341:
2135:342:
2136:343:
2137:344:/* this fits a line to numpoints 2D or 3D points and returns a lineseg structure */
2138:345:LineSegment linesegmentfrompoints (double *xvals, double *yvals,
2139:346:                                   double *zvals, int numpoints)
2140:347:{
2141:348:    LineSegment l;
2142:349:    int i;
2143:350:    double vmax = -10e90, vmin = 10e90, len;
2144:351:    Vec v0, vi;
2145:352:    memset (&l, 0, sizeof (LineSegment));
2146:353:    l.n = numpoints;
2147:354:
2148:355:    if (zvals) {
2149:356:        double result[3];
2150:357:
2151:358:        num_3d_points = numpoints;
2152:359:        x_points = xvals;
2153:360:        y_points = yvals;
2154:361:        z_points = zvals;
2155:362:
2156:363:        result[0] = 1;          /* initial guess */
2157:364:        result[1] = 1;
2158:365:        result[2] = 1;
2159:366:
2160:367:        simplex_optimise (result, 3, 10e-7, 1, tominimise3dline, NULL);
2161:368:
2162:369:        l.e = tominimise3dline (result);
2163:370:        l.u.x = result[0];
2164:371:        l.u.y = result[1];
2165:372:        l.u.z = result[2];
2166:373:        l.u = times (l.u, 1 / norm (l.u));
2167:374:        v0.x = c_x;
2168:375:        v0.y = c_y;
2169:376:        v0.z = c_z;
2170:377:        for (i = 0; i < l.n; i++) {
2171:378:            vi.x = xvals[i];
2172:379:            vi.y = yvals[i];
2173:380:            vi.z = zvals[i];
2174:381:            len = dot (l.u, minus (vi, v0));
2175:382:            if (len > vmax)
2176:383:                vmax = len;
2177:384:            if (len < vmin)
2178:385:                vmin = len;
2179:386:        }
2180:387:        l.p1 = plus (times (l.u, vmin), v0);
2181:388:        l.p2 = plus (times (l.u, vmax), v0);
2182:389:    } else {
2183:390:        l.e = fitline (xvals, yvals, numpoints, &l.a, &l.b, &l.c);
2184:391:        /* returns normalised values */
2185:392:        l.u.x = -l.b;
2186:393:        l.u.y = l.a;
2187:394:        v0.x = l.a * l.c;
2188:395:        v0.y = l.b * l.c;
2189:396:        v0.z = 0;
2190:397:/* v0 is now a point on the line */
2191:398:        vi.z = 0;
2192:399:        for (i = 0; i < l.n; i++) {
2193:400:            vi.x = xvals[i];
2194:401:            vi.y = yvals[i];
2195:402:            len = dot (l.u, minus (vi, v0));
2196:403:            if (len > vmax)
2197:404:                vmax = len;
2198:405:            if (len < vmin)
2199:406:                vmin = len;
2200:407:        }
2201:408:        l.p1 = plus (times (l.u, vmin), v0);
2202:409:        l.p2 = plus (times (l.u, vmax), v0);
2203:410:    }
2204:411:    l.psi = atan2 (l.u.y, l.u.x);
2205:412:    l.beta = atan2 (l.u.z, sqrt (sqr (l.u.x) + sqr (l.u.y)));
2206:413:    l.l = norm (minus (l.p2, l.p1));
2207:414:    l.m = times (plus (l.p1, l.p2), 0.5);
2208:415:    l.type = LINE_SEGMENT;
2209:416:    return l;
2210:417:}
2211:418:
2212:419:
2213:420:/* [requires l->p1, l->u] */
2214:421:double distancetoline (Vec x, LineSegment * l)
2215:422:{
2216:423:    double r;
2217:424:    x = minus (x, l->p1);
2218:425:    r = fsqr (norm (x)) - fsqr (dot (x, l->u));
2219:426:    if (r <= 0)
2220:427:        return 0;
2221:428:    return sqrt (r);
2222:429:}
2223:430:
2224:431:#define Distancetoplane(x,u,d) fabs(dot(minus(x, times(u,d)),u))
2225:432:
2226:433:/*  [requires p->u and p->d] */
2227:434:double distancetoplane (Vec x, PlaneSegment * p)
2228:435:{
2229:436:    return Distancetoplane (x, p->u, p->d);
2230:437:}
2231:438:
2232:439:
2233:440:/* [requires p1, u] */
2234:441:Vec pointonline (Vec x, LineSegment * l)
2235:442:{
2236:443:    return plus (l->p1, times (l->u, dot (minus (x, l->p1), l->u)));
2237:444:}
2238:445:
2239:446:/* returns the point on the plane closest to x */
2240:447:/*  [requires p->n and p->d] */
2241:448:Vec pointonplane (Vec x, PlaneSegment * p)
2242:449:{
2243:450:    Vec c = times (p->u, p->d);
2244:451:    x = minus (x, c);
2245:452:    return plus (minus (x, times (p->u, dot (x, p->u))), c);
2246:453:}
2247:454:
2248:455:
2249:456:/* returns half way between the two lines where they are closest, \
2250:457:                    [requires p1, p2 and u for both lines] */
2251:458:Vec interceptionbetweentwolines (LineSegment * l1, LineSegment * l2)
2252:459:{
2253:460:    Matrix *A = Madoublestomatrix (2, 3, dot (l1->u, l1->u),
2254:461:                                   -dot (l1->u, l2->u),
2255:462:                                   dot (minus (l2->p1, l1->p1), l1->u),
2256:463:                                   dot (l1->u, l2->u), -dot (l2->u, l2->u),
2257:464:                                   dot (minus (l2->p1, l1->p1), l2->u));
2258:465:    Vec v;
2259:466:    if (Madiag (A)) {
2260:467:        v = times (plus (plus (l1->p1, times (l1->u, Mard (*A, 0, 2))),
2261:468:                         plus (l2->p1, times (l2->u, Mard (*A, 1, 2)))),
2262:469:                   0.5);
2263:470:    } else {
2264:471:        v = times (plus (plus (l1->p1, l1->p2), plus (l2->p1, l2->p2)),
2265:472:                   0.25);
2266:473:    }
2267:474:    Mafreematrix (A);
2268:475:    return v;
2269:476:}
2270:477:
2271:478:
2272:479:double shortestdistancebetweentwolines (LineSegment * l1, LineSegment * l2)
2273:480:{
2274:481:    Vec c = cross (l1->u, l2->u);
2275:482:    double n = norm (c);
2276:483:    if (n) {
2277:484:        return fabs (dot (minus (l1->p1, l2->p1), times (c, 1 / n)));
2278:485:    } else {                    /* the lines are parallel */
2279:486:        Vec m = minus (l1->p1, l2->p1);
2280:487:        return sqrt (fsqr (norm (m)) - fsqr (dot (m, l1->u)));
2281:488:    }
2282:489:}
2283:490:
2284:491:
2285:492:
2286:493:/* returns 1 if on the line, zero otherwise, [requires p1, u, and l] */
2287:494:int ispointonline (Vec x, LineSegment * l)
2288:495:{
2289:496:    if (l->l) {
2290:497:        double d = dot (minus (x, l->p1), l->u);
2291:498:        if (d > l->l || d < 0)
2292:499:            return 0;
2293:500:        return 1;
2294:501:    }
2295:502:    return 0;
2296:503:}
2297:504:
2298:505:
2299:506:
2300:507:
2301:508:/* returns only .p1 and .u of the LineSegement */
2302:509:LineSegment lineinterceptionoftwoplanes (PlaneSegment * p1,
2303:510:                                         PlaneSegment * p2)
2304:511:{
2305:512:    LineSegment l;
2306:513:    Vec r = cross (p1->u, p2->u);
2307:514:    Matrix *A;
2308:515:
2309:516:    memset (&l, 0, sizeof (LineSegment));
2310:517:    l.u = times (r, 1 / norm (r));
2311:518:    A = Madoublestomatrix (3, 4, p1->u.x, p1->u.y, p1->u.z, p1->d,
2312:519:                           p2->u.x, p2->u.y, p2->u.z, p2->d,
2313:520:                           l.u.x, l.u.y, l.u.z, NULL);
2314:521:    Madiag (A);
2315:522:    l.p1.x = Mard (*A, 0, 3);
2316:523:    l.p1.y = Mard (*A, 1, 3);
2317:524:    l.p1.z = Mard (*A, 2, 3);
2318:525:    Mafreematrix (A);
2319:526:    return l;
2320:527:}
2321:528:
2322:529:
2323:530:
2324:531:/* returns only ->c and ->u of the LineSegement */
2325:532:LineSegment segmentinterceptionoftwoplanes (PlaneSegment * p1,
2326:533:                                            PlaneSegment * p2)
2327:534:{
2328:535:    LineSegment l = lineinterceptionoftwoplanes (p1, p2);
2329:536:    Vec limits[16];
2330:537:    int nlimits = 0;
2331:538:    int i, nmax = 0, nmin = 0;
2332:539:    double vmax = -10e90, vmin = 10e90, len;
2333:540:    double d;
2334:541:
2335:542:    for (i = 0; i < p1->num; i++) {
2336:543:        limits[nlimits] = interceptionbetweentwolines (&l, &p1->l[i]);
2337:544:        d = shortestdistancebetweentwolines (&l, &p1->l[i]);
2338:545:        if (ispointonline (limits[nlimits], &p1->l[i]))
2339:546:            nlimits++;
2340:547:    }
2341:548:
2342:549:    for (i = 0; i < p2->num; i++) {
2343:550:        limits[nlimits] = interceptionbetweentwolines (&l, &p2->l[i]);
2344:551:        d = shortestdistancebetweentwolines (&l, &p2->l[i]);
2345:552:        if (ispointonline (limits[nlimits], &p2->l[i]))
2346:553:            nlimits++;
2347:554:    }
2348:555:
2349:556:    if (nlimits) {
2350:557:        for (i = 0; i < nlimits; i++) {
2351:558:            len = dot (l.u, minus (l.p1, limits[i]));
2352:559:            if (len > vmax) {
2353:560:                nmax = i;
2354:561:                vmax = len;
2355:562:            }
2356:563:            if (len < vmin) {
2357:564:                nmin = i;
2358:565:                vmin = len;
2359:566:            }
2360:567:        }
2361:568:        l.p1 = limits[nmin];
2362:569:        l.p2 = limits[nmax];
2363:570:    }
2364:571:    return linesegment (l.p1, l.p2);
2365:572:}
2366:573:
2367:574:
2368:575:/* returns the vector pointing from the camera out to a point */
2369:576:LineSegment linethroughpointandcamcentre (double x, double y, Camera * cam)
2370:577:{
2371:578:    PlaneSegment p1, p2;
2372:579:    LineSegment l;
2373:580:    p1.u = plus (times (cam->m_s, x), times (cam->m_x, cam->f));
2374:581:    p1.d = dot (p1.u, cam->x);
2375:582:    p2.u = plus (times (cam->m_s, y), times (cam->m_y, cam->f));
2376:583:    p2.d = dot (p2.u, cam->x);
2377:584:    l = lineinterceptionoftwoplanes (&p1, &p2);
2378:585:    l.u = times (l.u, fsgn (dot (cam->m_s, l.u)));
2379:586:    /* direction is arbitrary, so make it point outward from the camera */
2380:587:    l.p1 = cam->x;
2381:588:    l.p2 = plus (l.p1, times (l.u, 10e50));
2382:589:    return linesegment (l.p1, l.p2);
2383:590:}
2384:591:
2385:592:
2386:593:
2387:594:/*
2388:595:   Calculates:
2389:596:        [ a*f*m_x + b*f*m_y + c*m_s : (a*f*m_x + b*f*m_y + c*m_s).X_0 ] = [ abc : d ]
2390:597:   whence
2391:598:   ax + by + cz = d
2392:599:   (a,b,c) is a unit vector normal to the plane.
2393:600: */
2394:601:PlaneSegment planethroughlineandcamcentre (LineSegment * l, Camera * cam)
2395:602:{
2396:603:    PlaneSegment plane;
2397:604:    Vec abc;
2398:605:    double r;
2399:606:    memset (&plane, 0, sizeof (PlaneSegment));
2400:607:
2401:608:    abc = plus (plus (times (cam->m_x, cam->f * l->a),
2402:609:                      times (cam->m_y, cam->f * l->b)), times (cam->m_s,
2403:610:                                                               l->c));
2404:611:    plane.d = dot (abc, cam->x);
2405:612:    r = norm (abc);
2406:613:    abc = times (abc, 1 / r);
2407:614:    plane.u = abc;
2408:615:    plane.d /= r;
2409:616:
2410:617:/* now find limits of the plane */
2411:618:    plane.l[0] = linethroughpointandcamcentre (l->p1.x, l->p1.y, cam);
2412:619:    plane.l[1] = linethroughpointandcamcentre (l->p2.x, l->p2.y, cam);
2413:620:    plane.num = 2;
2414:621:
2415:622:    return plane;
2416:623:}
2417:624:
2418:625:
2419:626:
2420:627:
2421:628:LineSegment fit3dlinetoprojections (LineSegment * line1,
2422:629:                                    LineSegment * line2, Camera * cam1,
2423:630:                                    Camera * cam2)
2424:631:{
2425:632:    PlaneSegment plane1 = planethroughlineandcamcentre (line1, cam1);
2426:633:    PlaneSegment plane2 = planethroughlineandcamcentre (line2, cam2);
2427:634:    return segmentinterceptionoftwoplanes (&plane1, &plane2);
2428:635:}
2429:636:
2430:637:
2431:638:/* this undestorts x and y values */
2432:639:LineSegment linefromstereoedge (double *x1, double *y1, int n1, double *x2,
2433:640:                                double *y2, int n2, Camera * cam1,
2434:641:                                Camera * cam2)
2435:642:{
2436:643:    LineSegment l1, l2;
2437:644:
2438:645:    l1 = linesegmentfrompoints (x1, y1, 0, n1);
2439:646:    l2 = linesegmentfrompoints (x2, y2, 0, n2);
2440:647:
2441:648:    return fit3dlinetoprojections (&l1, &l2, cam1, cam2);
2442:649:}
2443:650:
2444:651:
2445:652:
2446:653:
2447:654:
2448:655:
2449:656:/* how much do the line segments exactly match ? */
2450:657:double comparelinesegments (LineSegment * l1, LineSegment * l2)
2451:658:{
2452:659:    return fmin (norm (minus (l1->p1, l2->p1)) +
2453:660:                 norm (minus (l1->p2, l2->p2))
2454:661:                 ,
2455:662:                 norm (minus (l1->p2, l2->p1)) +
2456:663:                 norm (minus (l1->p1, l2->p2))
2457:664:        );
2458:665:}
2459:666:
2460:667:/* how much do the line equations exactly match in the region of the lines ? */
2461:668:double comparelines (LineSegment * l1, LineSegment * l2)
2462:669:{
2463:670:    return
2464:671:        fmax (distancetoline (l1->p1, l2) +
2465:672:              distancetoline (l1->p2, l2),
2466:673:              distancetoline (l2->p1, l1) + distancetoline (l2->p2, l1));
2467:674:/* fmax is so that if one of the lines is short, it does not appear
2468:675:                                                     to have a small error */
2469:676:}
2470:677:
2471:678:
2472:679:
2473:680:
2474:681:void findcylinderedges (Camera * cam, LineSegment * axis, double r,
2475:682:                        LineSegment * one_edge, LineSegment * other_edge)
2476:683:{
2477:684:    double a, b, c, d, e, f;
2478:685:    double A, B, C;
2479:686:    Vec r1, r2;
2480:687:    double alpha1, alpha2;
2481:688:    Vec p = minus (screen (cam, axis->p2), screen (cam, axis->p1));
2482:689:
2483:690:    fswap (p.x, p.y);
2484:691:    p.x = -p.x;                 /* p now normal to line of projected axis */
2485:692:
2486:693:    orth_vectors (axis->u, &r1, &r2, r);
2487:694:
2488:695:    a = (dot (axis->p1, cam->m_x) - dot (cam->x, cam->m_x)) * p.x +
2489:696:        (dot (axis->p1, cam->m_y) - dot (cam->x, cam->m_y)) * p.y;
2490:697:    b = (dot (r1, cam->m_x)) * p.x + (dot (r1, cam->m_y)) * p.y;
2491:698:    c = (dot (r2, cam->m_x)) * p.x + (dot (r2, cam->m_y)) * p.y;
2492:699:
2493:700:    d = dot (axis->p1, cam->m_s) - dot (cam->x, cam->m_s);
2494:701:    e = dot (r1, cam->m_s);
2495:702:    f = dot (r2, cam->m_s);
2496:703:
2497:704:/* (b d - a e) COS (t) + (a f - c d) SIN (t) + b f - c e  =  0 */
2498:705:
2499:706:    A = a * f - c * d;
2500:707:    B = b * d - a * e;
2501:708:    C = b * f - c * e;
2502:709:
2503:710:    a = sqr (A) + sqr (B);
2504:711:    b = 2 * B * C;
2505:712:    c = sqr (C) - sqr (A);
2506:713:    d = sqrt (sqr (b) - 4 * a * c);
2507:714:    alpha1 = acos ((-b + d) / (2 * a));
2508:715:    alpha2 = acos ((-b - d) / (2 * a));
2509:716:
2510:717:    *one_edge =
2511:718:        linesegment (screen
2512:719:                     (cam,
2513:720:                      plus (plus
2514:721:                            (times (r1, sin (alpha1)),
2515:722:                             times (r2, cos (alpha1))), axis->p1)),
2516:723:                     screen (cam,
2517:724:                             plus (plus
2518:725:                                   (times (r1, sin (alpha1)),
2519:726:                                    times (r2, cos (alpha1))), axis->p2)));
2520:727:    *other_edge =
2521:728:        linesegment (screen
2522:729:                     (cam,
2523:730:                      plus (plus
2524:731:                            (times (r1, sin (alpha2)),
2525:732:                             times (r2, cos (alpha2))), axis->p1)),
2526:733:                     screen (cam,
2527:734:                             plus (plus
2528:735:                                   (times (r1, sin (alpha2)),
2529:736:                                    times (r2, cos (alpha2))), axis->p2)));
2530:737:}
2531:738:
2532:739:
2533:740:
2534:741:
2535:742:
2536:743:
2537:744:Cylinder cylinderfromstereoedge (double *x1l, double *y1l, int n1l,
2538:745:                                 double *x2l, double *y2l, int n2l,
2539:746:                                 double *x1r, double *y1r, int n1r,
2540:747:                                 double *x2r, double *y2r, int n2r,
2541:748:                                 Camera * caml, Camera * camr)
2542:749:{
2543:750:    double t, d, dp;
2544:751:    LineSegment l1r, l2r, l1l, l2l;
2545:752:    LineSegment ll, lr, edge1l, edge2l, edge1r, edge2r;
2546:753:    Cylinder cyl;
2547:754:    double p[4];
2548:755:    Vec v, u;
2549:756:    int i;
2550:757:    double mx, mn;
2551:758:
2552:759:    l1l = linesegmentfrompoints (x1l, y1l, 0, n1l);
2553:760:    l2l = linesegmentfrompoints (x2l, y2l, 0, n2l);
2554:761:    u = times (plus (l1l.u, l2l.u), 0.5);
2555:762:    u = times (u, 1 / norm (u));
2556:763:
2557:764:/* is z value zero here ? */
2558:765:    v = interceptionbetweentwolines (&l1l, &l2l);
2559:766:    p[0] = dot (u, minus (l1l.p1, v));
2560:767:    p[1] = dot (u, minus (l1l.p2, v));
2561:768:    p[2] = dot (u, minus (l2l.p1, v));
2562:769:    p[3] = dot (u, minus (l2l.p2, v));
2563:770:
2564:771:    mx = -9e90;
2565:772:    mn = 9e90;
2566:773:    for (i = 0; i < 4; i++) {
2567:774:        if (p[i] > mx)
2568:775:            mx = p[i];
2569:776:        if (p[i] < mn)
2570:777:            mn = p[i];
2571:778:    }
2572:779:    ll.p1 = plus (v, times (u, mn));
2573:780:    ll.p2 = plus (v, times (u, mx));
2574:781:
2575:782:    ll = linesegment (ll.p1, ll.p2);
2576:783:
2577:784:    l1r = linesegmentfrompoints (x1r, y1r, 0, n1r);
2578:785:    l2r = linesegmentfrompoints (x2r, y2r, 0, n2r);
2579:786:    u = times (plus (l1r.u, l2r.u), 0.5);
2580:787:    u = times (u, 1 / norm (u));
2581:788:
2582:789:/* is z value zero here ? */
2583:790:    v = interceptionbetweentwolines (&l1r, &l2r);
2584:791:    p[0] = dot (u, minus (l1r.p1, v));
2585:792:    p[1] = dot (u, minus (l1r.p2, v));
2586:793:    p[2] = dot (u, minus (l2r.p1, v));
2587:794:    p[3] = dot (u, minus (l2r.p2, v));
2588:795:
2589:796:    mx = -9e90;
2590:797:    mn = 9e90;
2591:798:    for (i = 0; i < 4; i++) {
2592:799:        if (p[i] > mx)
2593:800:            mx = p[i];
2594:801:        if (p[i] < mn)
2595:802:            mn = p[i];
2596:803:    }
2597:804:    lr.p1 = plus (v, times (u, mn));
2598:805:    lr.p2 = plus (v, times (u, mx));
2599:806:
2600:807:    lr = linesegment (lr.p1, lr.p2);
2601:808:
2602:809:
2603:810:    cyl.l = fit3dlinetoprojections (&ll, &lr, caml, camr);
2604:811:    edge1l = fit3dlinetoprojections (&l1r, &l1l, camr, caml);
2605:812:    cyl.r = distancetoline (edge1l.p1, &cyl.l); /* estimate */
2606:813:
2607:814:    t = cyl.r / 10;
2608:815:    d = 1e90;
2609:816:    do {
2610:817:        do {
2611:818:            cyl.r += t;
2612:819:            dp = d;
2613:820:            findcylinderedges (caml, &cyl.l, cyl.r, &edge1l, &edge2l);
2614:821:            findcylinderedges (camr, &cyl.l, cyl.r, &edge1r, &edge2r);
2615:822:            d = fmin (comparelines (&edge1l, &l1l),
2616:823:                      comparelines (&edge2l, &l1l));
2617:824:            /* we don't know which line is which */
2618:825:            d += fmin (comparelines (&edge1r, &l1r),
2619:826:                       comparelines (&edge2r, &l1r));
2620:827:        } while (d < dp);
2621:828:        t *= -0.5;
2622:829:    } while (fabs (t) > 0.00000001);
2623:830:
2624:831:    cyl.e = l1l.e + l1r.e + l2l.e + l2r.e + d;
2625:832:
2626:833:    cyl.type = CYLINDER;
2627:834:    return cyl;
2628:835:}
2629:836:
2630:837:double fitcirc (double *xvals, double *yvals, int numpoints,
2631:838:                double *ax, double *ay, double *ar);
2632:839:
2633:840:
2634:841:double circ_x, circ_y, circ_r;
2635:842:Vec cyl_r1, cyl_r2, cyl_n;
2636:843:
2637:844:static double tominimise3dcylinder (double *u)
2638:845:{
2639:846:    double e, *x, *y;
2640:847:    Vec v;
2641:848:    int i;
2642:849:
2643:850:    cyl_n.x = u[0];
2644:851:    cyl_n.y = u[1];
2645:852:    cyl_n.z = u[2];
2646:853:    if (norm (cyl_n) == 0) {
2647:854:        cyl_n.z = 1;
2648:855:    }
2649:856:    orth_vectors (cyl_n, &cyl_r1, &cyl_r2, 1);
2650:857:
2651:858:    x = malloc (num_3d_points * sizeof (double));
2652:859:    y = malloc (num_3d_points * sizeof (double));
2653:860:
2654:861:    for (i = 0; i < num_3d_points; i++) {
2655:862:        v.x = x_points[i];
2656:863:        v.y = y_points[i];
2657:864:        v.z = z_points[i];
2658:865:        x[i] = dot (cyl_r1, v);
2659:866:        y[i] = dot (cyl_r2, v);
2660:867:    }
2661:868:
2662:869:    e = fitcirc (x, y, num_3d_points, &circ_x, &circ_y, &circ_r);
2663:870:
2664:871:    free (y);
2665:872:    free (x);
2666:873:
2667:874:    return e;
2668:875:}
2669:876:
2670:877:
2671:878:
2672:879:
2673:880:
2674:881:Cylinder cylinderfrompoints (double *xvals, double *yvals,
2675:882:                             double *zvals, int numpoints)
2676:883:{
2677:884:    double result[3];
2678:885:    Cylinder c;
2679:886:    Vec v0, vi;
2680:887:    double len, e, emin = 9e90;
2681:888:    int i, imin = 0;
2682:889:    double vmax = -9e90;
2683:890:    double vmin = 9e90;
2684:891:
2685:892:    num_3d_points = numpoints;
2686:893:    x_points = xvals;
2687:894:    y_points = yvals;
2688:895:    z_points = zvals;
2689:896:
2690:897:/* try with various initial guesses */
2691:898:    for (i = 0; i < 3; i++) {
2692:899:        result[0] = 0;
2693:900:        result[1] = 0;
2694:901:        result[2] = 0;
2695:902:        result[i] = 1;
2696:903:        simplex_optimise (result, 3, 10e-3, 1, tominimise3dcylinder, NULL);
2697:904:        e = tominimise3dcylinder (result);
2698:905:        if (e < emin) {
2699:906:            emin = e;
2700:907:            imin = i;
2701:908:        }
2702:909:    }
2703:910:
2704:911:    result[0] = 0;
2705:912:    result[1] = 0;
2706:913:    result[2] = 0;
2707:914:    result[imin] = 1;
2708:915:    simplex_optimise (result, 3, 10e-7, 1, tominimise3dcylinder, NULL);
2709:916:
2710:917:    c.e = emin;
2711:918:    c.r = circ_r;
2712:919:    cyl_n = times (cyl_n, 1 / norm (cyl_n));
2713:920:    c.l.u = cyl_n;
2714:921:    v0 = plus (times (cyl_r1, circ_x), times (cyl_r2, circ_y));
2715:922:
2716:923:    for (i = 0; i < numpoints; i++) {
2717:924:        vi.x = xvals[i];
2718:925:        vi.y = yvals[i];
2719:926:        vi.z = zvals[i];
2720:927:        len = dot (c.l.u, minus (vi, v0));
2721:928:        if (len > vmax)
2722:929:            vmax = len;
2723:930:        if (len < vmin)
2724:931:            vmin = len;
2725:932:    }
2726:933:    c.l = linesegment (plus (times (c.l.u, vmin), v0),
2727:934:                       plus (times (c.l.u, vmax), v0));
2728:935:    c.type = CYLINDER;
2729:936:    c.l.n = numpoints;
2730:937:    return c;
2731:938:}
2732:939:
2733:940:
2734:941:
2735:942:
2736:943:
2737:944:/* fits a circle numpoints points (xvals, yvals). Places result in (ax,bx) radius r */
2738:945:double fitcirc (double *xvals, double *yvals, int numpoints, double *ax,
2739:946:                double *ay, double *ar)
2740:947:{
2741:948:    double s = 0, sx = 0, sy = 0, sxxy = 0, sxyy = 0, sxy = 0, sxx = 0,
2742:949:        sxxx = 0, syy = 0, syyy = 0, e = 0;
2743:950:    Matrix *A;
2744:951:    int i;
2745:952:    double xs, ys;
2746:953:
2747:954:    for (i = 0; i < numpoints; i++) {
2748:955:        s++;
2749:956:        xs = xvals[i];
2750:957:        ys = yvals[i];
2751:958:
2752:959:        sx += xs;
2753:960:        sy += ys;
2754:961:        sxy += xs * ys;
2755:962:        sxxy += ys * xs * xs;
2756:963:        sxyy += ys * ys * xs;
2757:964:        sxx += xs * xs;
2758:965:        sxxx += xs * xs * xs;
2759:966:        syy += ys * ys;
2760:967:        syyy += ys * ys * ys;
2761:968:    }
2762:969:
2763:970:    A = Madoublestomatrix (3, 4, sxx, sxy, sx, sxxx + sxyy,
2764:971:                           sxy, syy, sy, syyy + sxxy,
2765:972:                           sx, sy, s, sxx + syy);
2766:973:
2767:974:    if (Madiag (A)) {
2768:975:        *ax = Mard (*A, 0, 3) / 2;
2769:976:        *ay = Mard (*A, 1, 3) / 2;
2770:977:        *ar = sqrt (Mard (*A, 2, 3) + *ax * *ax + *ay * *ay);
2771:978:        for (i = 0; i < numpoints; i++) /* calculate error */
2772:979:            e += fsqr (*ar -
2773:980:                       sqrt (fsqr (*ax - xvals[i]) +
2774:981:                             fsqr (*ay - yvals[i])));
2775:982:    } else
2776:983:        e = 1e90;               /* singular matrix */
2777:984:
2778:985:    Mafreematrix (A);
2779:986:    return e;
2780:987:}
2781:988:
2782:989:
2783:990:
2784:991:
2785:992:struct sums {
2786:993:    double c;
2787:994:    double d;
2788:995:    double e;
2789:996:    double f;
2790:997:    double g;
2791:998:    double h;
2792:999:    double i;
2793:1000:    double j;
2794:1001:    double k;
2795:1002:    double l;
2796:1003:    double m;
2797:1004:    double n;
2798:1005:    double o;
2799:1006:    double p;
2800:1007:};
2801:1008:
2802:1009:Vec solve3x3 (double a[4][3]);
2803:1010:
2804:1011:double ellipfunc (double a, double b, struct sums *s,
2805:1012:                  double *xu, double *yu, double *zu)
2806:1013:{
2807:1014:    double matrix[4][3];
2808:1015:    double x, y, z;
2809:1016:    double funcf, funcg;
2810:1017:
2811:1018:/* Reduce five non-linear equations to two non-linear equations */
2812:1019:/* by solving for three of them: */
2813:1020:    matrix[0][0] = (8 * pow (a, 4) * s->f + 16 * pow (a, 3) * b * s->e +
2814:1021:                    sqr (a) * (8 * sqr (b) * s->g + 16 * s->f) +
2815:1022:                    16 * a * b * s->e + 8 * s->f);
2816:1023:    matrix[1][0] =
2817:1024:        (8 * pow (a, 3) * b * s->f +
2818:1025:         sqr (a) * (16 * sqr (b) * s->e + 8 * s->e) +
2819:1026:         a * (8 * pow (b, 3) * s->g + b * (8 * s->f + 8 * s->g)) +
2820:1027:         8 * sqr (b) * s->e + 8 * s->e);
2821:1028:    matrix[2][0] = (-4 * sqr (a) * s->c - 4 * a * b * s->d - 4 * s->c);
2822:1029:    matrix[3][0] = -4 * pow (a, 4) * s->j - 12 * pow (a, 3) * b * s->h
2823:1030:        + sqr (a) * (-12 * sqr (b) * s->i - 4 * s->i - 8 * s->j) +
2824:1031:        a * (b * (-12 * s->h - 4 * s->k) - 4 * pow (b, 3) * s->k) -
2825:1032:        4 * sqr (b) * s->i - 4 * s->i - 4 * s->j;
2826:1033:
2827:1034:    matrix[0][1] = (8 * pow (a, 3) * b * s->f + sqr (a) * (16 * sqr (b) *
2828:1035:                                                           s->e +
2829:1036:                                                           8 * s->e) +
2830:1037:                    a * (8 * pow (b, 3) * s->g +
2831:1038:                         b * (8 * s->f + 8 * s->g)) + 8 * sqr (b) * s->e +
2832:1039:                    8 * s->e);
2833:1040:    matrix[1][1] =
2834:1041:        (8 * sqr (a) * sqr (b) * s->f +
2835:1042:         a * (16 * pow (b, 3) * s->e + 16 * b * s->e) + 8 * pow (b,
2836:1043:                                                                 4) *
2837:1044:         s->g + 16 * sqr (b) * s->g + 8 * s->g);
2838:1045:    matrix[2][1] = (-4 * a * b * s->c - 4 * sqr (b) * s->d - 4 * s->d);
2839:1046:    matrix[3][1] = -4 * pow (a, 3) * b * s->j + sqr (a) * (-12 * sqr (b)
2840:1047:                                                           * s->h -
2841:1048:                                                           4 * s->h) +
2842:1049:        a * (b * (-12 * s->i - 4 * s->j) - 12 * pow (b, 3) * s->i) -
2843:1050:        4 * pow (b,
2844:1051:                 4) * s->k + sqr (b) * (-4 * s->h - 8 * s->k) - 4 * s->h -
2845:1052:        4 * s->k;
2846:1053:
2847:1054:    matrix[0][2] = (-4 * sqr (a) * s->c - 4 * a * b * s->d - 4 * s->c);
2848:1055:    matrix[1][2] = (-4 * a * b * s->c - 4 * sqr (b) * s->d - 4 * s->d);
2849:1056:    matrix[2][2] = 2;
2850:1057:    matrix[3][2] = 2 * sqr (a) * s->f + 4 * a * b * s->e + 2 * sqr (b)
2851:1058:        * s->g + 2 * s->f + 2 * s->g;
2852:1059:
2853:1060:    solve3x3 (matrix);
2854:1061:    x = -matrix[3][0];
2855:1062:    y = -matrix[3][1];
2856:1063:    z = -matrix[3][2];
2857:1064:
2858:1065:#define SQR(x) ((x)*(x))
2859:1066:
2860:1067:    /* Return value of two non-linears: */
2861:1068:    funcf = 16 * SQR (x) * pow (a, 3) * s->f + 24 * SQR (x) * SQR (a) * b *
2862:1069:        s->e + 8 * SQR (x) * a * SQR (b) * s->g + 16 * SQR (x) * a * s->f +
2863:1070:        8 * SQR (x) * b * s->e + 24 * x * y * SQR (a) * b * s->f +
2864:1071:        32 * x * y * a * SQR (b) * s->e + 16 * x * y * a * s->e +
2865:1072:        8 * x * y * pow (b,
2866:1073:                         3) * s->g + 8 * x * y * b * s->f +
2867:1074:        8 * x * y * b * s->g - 8 * x * z * a * s->c -
2868:1075:        4 * x * z * b * s->d - 16 * x * pow (a,
2869:1076:                                             3) * s->j -
2870:1077:        36 * x * SQR (a) * b * s->h - 24 * x * a * SQR (b) * s->i -
2871:1078:        16 * x * a * s->j - 8 * x * a * s->i - 4 * x * pow (b,
2872:1079:                                                            3) * s->k -
2873:1080:        12 * x * b * s->h - 4 * x * b * s->k +
2874:1081:        8 * SQR (y) * a * SQR (b) * s->f + 8 * SQR (y) * pow (b,
2875:1082:                                                              3) * s->e +
2876:1083:        8 * SQR (y) * b * s->e - 4 * y * z * b * s->c -
2877:1084:        12 * y * SQR (a) * b * s->j - 24 * y * a * SQR (b) * s->h -
2878:1085:        8 * y * a * s->h - 12 * y * pow (b,
2879:1086:                                         3) * s->i - 4 * y * b * s->j -
2880:1087:        12 * y * b * s->i + 4 * z * a * s->f + 4 * z * b * s->e +
2881:1088:        4 * pow (a,
2882:1089:                 3) * s->o + 12 * SQR (a) * b * s->n +
2883:1090:        12 * a * SQR (b) * s->m + 4 * a * s->o + 4 * a * s->m + 4 * pow (b,
2884:1091:                                                                         3)
2885:1092:        * s->l + 4 * b * s->n + 4 * b * s->l;
2886:1093:    funcg =
2887:1094:        8 * SQR (x) * pow (a,
2888:1095:                           3) * s->e + 8 * SQR (x) * SQR (a) * b * s->g +
2889:1096:        8 * SQR (x) * a * s->e + 8 * x * y * pow (a,
2890:1097:                                                  3) * s->f +
2891:1098:        32 * x * y * SQR (a) * b * s->e + 24 * x * y * a * SQR (b) * s->g +
2892:1099:        8 * x * y * a * s->f + 8 * x * y * a * s->g +
2893:1100:        16 * x * y * b * s->e - 4 * x * z * a * s->d - 12 * x * pow (a,
2894:1101:                                                                     3) *
2895:1102:        s->h - 24 * x * SQR (a) * b * s->i - 12 * x * a * SQR (b) * s->k -
2896:1103:        12 * x * a * s->h - 4 * x * a * s->k - 8 * x * b * s->i +
2897:1104:        8 * SQR (y) * SQR (a) * b * s->f + 24 * SQR (y)
2898:1105:        * a * SQR (b) * s->e + 8 * SQR (y) * a * s->e +
2899:1106:        16 * SQR (y) * pow (b,
2900:1107:                            3) * s->g + 16 * SQR (y) * b * s->g -
2901:1108:        4 * y * z * a * s->c - 8 * y * z * b * s->d - 4 * y * pow (a,
2902:1109:                                                                   3) *
2903:1110:        s->j - 24 * y * SQR (a) * b * s->h - 36 * y * a * SQR (b) * s->i -
2904:1111:        4 * y * a * s->j - 12 * y * a * s->i - 16 * y * pow (b,
2905:1112:                                                             3) * s->k -
2906:1113:        8 * y * b * s->h - 16 * y * b * s->k + 4 * z * a * s->e +
2907:1114:        4 * z * b * s->g + 4 * pow (a, 3)
2908:1115:        * s->n + 12 * SQR (a) * b * s->m + 12 * a * SQR (b) * s->l +
2909:1116:        4 * a * s->n + 4 * a * s->l + 4 * pow (b,
2910:1117:                                               3) * s->p + 4 * b * s->m +
2911:1118:        4 * b * s->p;
2912:1119:
2913:1120:    /* Return other variables: */
2914:1121:    *xu = x;
2915:1122:    *yu = y;
2916:1123:    *zu = z;
2917:1124:    return funcf * funcf + funcg * funcg;
2918:1125:}
2919:1126:
2920:1127:
2921:1128:double ellipse_x;
2922:1129:double ellipse_y;
2923:1130:double ellipse_z;
2924:1131:struct sums ellipse_sums;
2925:1132:
2926:1133:double tominimiseellipse (double *r)
2927:1134:{
2928:1135:    return ellipfunc (r[0], r[1], &ellipse_sums,
2929:1136:                      &ellipse_x, &ellipse_y, &ellipse_z);
2930:1137:}
2931:1138:
2932:1139:
2933:1140:double fitellip (double *xvals, double *yvals, int numpoints,
2934:1141:                 double *ax, double *ay, double *aa, double *ab,
2935:1142:                 double *ar)
2936:1143:{
2937:1144:    int i;
2938:1145:    double s = 0, sx = 0, sy = 0, sxxy = 0, sxyy = 0;
2939:1146:    double sxy = 0, sxx = 0, sxxx = 0, syy = 0, syyy = 0;
2940:1147:    double syyyy = 0, sxyyy = 0, sxxyy = 0, sxxxy = 0, sxxxx = 0;
2941:1148:    double result[2];
2942:1149:    struct sums sig;
2943:1150:    float xs, ys;
2944:1151:
2945:1152:    for (i = 0; i < numpoints; i++) {
2946:1153:        xs = xvals[i];
2947:1154:        ys = yvals[i];
2948:1155:
2949:1156:        s++;
2950:1157:        sx += (double) xs;
2951:1158:        sy += (double) ys;
2952:1159:        sxy += (double) xs *ys;
2953:1160:        sxxy += (double) ys *xs * xs;
2954:1161:        sxyy += (double) ys *ys * xs;
2955:1162:        sxx += (double) xs *xs;
2956:1163:        sxxx += (double) xs *xs * xs;
2957:1164:        syy += (double) ys *ys;
2958:1165:        syyy += (double) ys *ys * ys;
2959:1166:        sxyyy += (double) ys *ys * ys * xs;
2960:1167:        sxxyy += (double) xs *xs * ys * ys;
2961:1168:        sxxxy += (double) xs *xs * xs * ys;
2962:1169:        sxxxx += (double) xs *xs * xs * xs;
2963:1170:        syyyy += (double) ys *ys * ys * ys;
2964:1171:    }
2965:1172:
2966:1173:/* Normalise all sums: */
2967:1174:    sig.c = sx / s;
2968:1175:    sig.d = sy / s;
2969:1176:    sig.e = sxy / s;
2970:1177:    sig.f = sxx / s;
2971:1178:    sig.g = syy / s;
2972:1179:    sig.h = sxxy / s;
2973:1180:    sig.i = sxyy / s;
2974:1181:    sig.j = sxxx / s;
2975:1182:    sig.k = syyy / s;
2976:1183:    sig.l = sxyyy / s;
2977:1184:    sig.m = sxxyy / s;
2978:1185:    sig.n = sxxxy / s;
2979:1186:    sig.o = sxxxx / s;
2980:1187:    sig.p = syyyy / s;
2981:1188:
2982:1189:    result[0] = 1;
2983:1190:    result[1] = 1;
2984:1191:
2985:1192:    simplex_optimise (result, 2, 10e-7, 1, tominimiseellipse, NULL);
2986:1193:
2987:1194:    *ax = ellipse_x;
2988:1195:    *ay = ellipse_y;
2989:1196:    *aa = result[0];
2990:1197:    *ab = result[1];
2991:1198:    *ar = sqrt (-ellipse_z + ellipse_x * ellipse_x + ellipse_y * ellipse_y
2992:1199:                + (result[0] * ellipse_x +
2993:1200:                   result[1] * ellipse_y) * (result[0] * ellipse_x +
2994:1201:                                             result[1] * ellipse_y));
2995:1202:    return tominimiseellipse (result);
2996:1203:}
2997:1204:
2998:1205:
2999:1206:
3000:1207:
3001:1208:
3002:1209:
3003:1210:
3004:1211:
3005:1212:
3006:1213:
3007:1214:
3008:1215:
3009:1216:
3010:1217:static double tominimise3dplane (double *u)
3011:1218:{
3012:1219:    Vec n, x;
3013:1220:    double d, e = 0;
3014:1221:    int i;
3015:1222:
3016:1223:    n.x = u[0];
3017:1224:    n.y = u[1];
3018:1225:    n.z = u[2];
3019:1226:
3020:1227:    d = norm (n);
3021:1228:    n = times (n, 1 / d);
3022:1229:    d = u[3] / d;
3023:1230:
3024:1231:    for (i = 0; i < num_3d_points; i++) {
3025:1232:        x.x = x_points[i];
3026:1233:        x.y = y_points[i];
3027:1234:        x.z = z_points[i];
3028:1235:        e += fsqr (Distancetoplane (x, n, d));
3029:1236:    }
3030:1237:    return e;
3031:1238:}
3032:1239:
3033:1240:
3034:1241:
3035:1242:
3036:1243:
3037:1244:
3038:1245:PlaneSegment planefrompoints (double *xvals, double *yvals,
3039:1246:                              double *zvals, int numpoints)
3040:1247:{
3041:1248:    double result[4];
3042:1249:    PlaneSegment p;
3043:1250:    int i;
3044:1251:    double x = 0, y = 0, z = 0;
3045:1252:
3046:1253:    num_3d_points = numpoints;
3047:1254:    x_points = xvals;
3048:1255:    y_points = yvals;
3049:1256:    z_points = zvals;
3050:1257:
3051:1258:    result[0] = 1 / sqrt (3);   /* initial guess */
3052:1259:    result[1] = result[0];
3053:1260:    result[2] = result[0];
3054:1261:    result[3] = 0;
3055:1262:
3056:1263:    simplex_optimise (result, 4, 10e-7, 1, tominimise3dplane, NULL);
3057:1264:
3058:1265:    p.e = tominimise3dplane (result);
3059:1266:    p.u.x = result[0];
3060:1267:    p.u.y = result[1];
3061:1268:    p.u.z = result[2];
3062:1269:    p.u = times (p.u, p.d = 1 / norm (p.u));
3063:1270:    p.d *= result[3];
3064:1271:    p.num = numpoints;
3065:1272:    p.gx = p.u.x / p.u.z;
3066:1273:    p.gy = p.u.y / p.u.z;
3067:1274:    p.elev = sqrt (sqr (p.gx) + sqr (p.gy));
3068:1275:    for (i = 0; i < numpoints; i++) {
3069:1276:        x += xvals[i];
3070:1277:        y += yvals[i];
3071:1278:        z += zvals[i];
3072:1279:    }
3073:1280:    p.c.x = x / numpoints;
3074:1281:    p.c.y = y / numpoints;
3075:1282:    p.c.z = z / numpoints;
3076:1283:
3077:1284:    p.c = pointonplane (p.c, &p);
3078:1285:    return p;
3079:1286:}
3080:1287:
3081:1288:
3082:1289:
3083:1290:Circle circlefrompoints (double *xvals, double *yvals, double *zvals,
3084:1291:                         int numpoints)
3085:1292:{
3086:1293:    Circle circ;
3087:1294:
3088:1295:    memset (&circ, 0, sizeof (Circle));
3089:1296:
3090:1297:    if (zvals) {                /* 3D fit */
3091:1298:        double rx, ry;
3092:1299:        PlaneSegment p;
3093:1300:        double *x = malloc (numpoints * sizeof (double));
3094:1301:        double *y = malloc (numpoints * sizeof (double));
3095:1302:        Vec r1, r2;
3096:1303:        int i;
3097:1304:        p = planefrompoints (xvals, yvals, zvals, numpoints);
3098:1305:        orth_vectors (p.u, &r1, &r2, 1);
3099:1306:        for (i = 0; i < numpoints; i++) {
3100:1307:/* we want to fit a 2D circle to points on the plane. 
3101:1308:                                        So find positions w.r.t. r1 and r2 */
3102:1309:            x[i] = (xvals[i] - p.c.x) * r1.x + (yvals[i] - p.c.y) * r1.y + (zvals[i] - p.c.z) * r1.z; /* dot */
3103:1310:            y[i] = (xvals[i] - p.c.x) * r2.x + (yvals[i] - p.c.y) *
3104:1311:                r2.y + (zvals[i] - p.c.z) * r2.z;
3105:1312:        }
3106:1313:        circ.e = fitcirc (x, y, numpoints, &rx, &ry, &circ.r) + p.e;
3107:1314:        circ.p = plus (plus (times (r1, rx), times (r2, ry)), p.c);
3108:1315:        circ.u = p.u;
3109:1316:        circ.n = numpoints;
3110:1317:    } else {                    /* 2D fit */
3111:1318:        circ.e =
3112:1319:            fitcirc (xvals, yvals, numpoints, &circ.p.x, &circ.p.y,
3113:1320:                     &circ.r);
3114:1321:        circ.u.z = 1;
3115:1322:        circ.n = numpoints;
3116:1323:    }
3117:1324:    circ.type = CIRCLE;
3118:1325:    return circ;
3119:1326:}
3120:1327:
3121:1328:
3122:1329:Ellipse ellipsefrompoints (double *xvals, double *yvals, double *zvals,
3123:1330:                           int numpoints)
3124:1331:{
3125:1332:    Ellipse ellip;
3126:1333:
3127:1334:    memset (&ellip, 0, sizeof (Ellipse));
3128:1335:
3129:1336:    if (zvals) {                /* 3D fit */
3130:1337:        double rx, ry, ra, rb;
3131:1338:        PlaneSegment p;
3132:1339:        double *x = malloc (numpoints * sizeof (double));
3133:1340:        double *y = malloc (numpoints * sizeof (double));
3134:1341:        Vec r1, r2;
3135:1342:        int i;
3136:1343:        p = planefrompoints (xvals, yvals, zvals, numpoints);
3137:1344:        orth_vectors (p.u, &r1, &r2, 1);
3138:1345:        for (i = 0; i < numpoints; i++) {
3139:1346:/* we want to fit a 2D ellipse to points on the plane. 
3140:1347:                                        So find positions w.r.t. r1 and r2 */
3141:1348:            x[i] = (xvals[i] - p.c.x) * r1.x + (yvals[i] - p.c.y) * r1.y + (zvals[i] - p.c.z) * r1.z; /* dot */
3142:1349:            y[i] = (xvals[i] - p.c.x) * r2.x + (yvals[i] - p.c.y) *
3143:1350:                r2.y + (zvals[i] - p.c.z) * r2.z;
3144:1351:        }
3145:1352:        ellip.e =
3146:1353:            fitellip (x, y, numpoints, &rx, &ry, &ra, &rb, &ellip.r) + p.e;
3147:1354:        ellip.p = plus (plus (times (r1, rx), times (r2, ry)), p.c);
3148:1355:        ellip.q = plus (plus (times (r1, ra), times (r2, rb)), p.c);
3149:1356:        ellip.u = p.u;
3150:1357:        ellip.n = numpoints;
3151:1358:    } else {                    /* 2D fit */
3152:1359:        ellip.e = fitellip (xvals, yvals, numpoints,
3153:1360:                            &ellip.p.x, &ellip.p.y, &ellip.q.x, &ellip.q.y,
3154:1361:                            &ellip.r);
3155:1362:        ellip.u.z = 1;
3156:1363:        ellip.n = numpoints;
3157:1364:    }
3158:1365:    ellip.type = ELLIPSE;
3159:1366:    return ellip;
3160:1367:}
3161:1368:
3162:1369:
3163:1370:double *xvals1, *yvals1, *xvals2, *yvals2;
3164:1371:Camera *camera1, *camera2;
3165:1372:int num1points, num2points;
3166:1373:
3167:1374:
3168:1375:double to_minimise_stereo_circle (double *r)
3169:1376:{
3170:1377:    double error;
3171:1378:    double a, b, c, d, e, f, g, h, i, j, k, l;
3172:1379:    int ic;
3173:1380:    Vec u, r1, r2, p;
3174:1381:    double x, y;
3175:1382:    double theta, ex, ey, dtheta, etot, etotp;
3176:1383:
3177:1384:    u.x = r[0];
3178:1385:    u.y = r[1];
3179:1386:    u.z = r[2];
3180:1387:    p.x = r[3];
3181:1388:    p.y = r[4];
3182:1389:    p.z = r[5];
3183:1390:
3184:1391:    error = 0;
3185:1392:
3186:1393:    orth_vectors (u, &r1, &r2, norm (u));
3187:1394:
3188:1395:    a = dot (p, camera1->m_x) - dot (camera1->x, camera1->m_x);
3189:1396:    b = dot (r1, camera1->m_x);
3190:1397:    c = dot (r2, camera1->m_x);
3191:1398:
3192:1399:    j = d = dot (p, camera1->m_s) - dot (camera1->x, camera1->m_s);
3193:1400:    k = e = dot (r1, camera1->m_s);
3194:1401:    l = f = dot (r2, camera1->m_s);
3195:1402:
3196:1403:    g = dot (p, camera1->m_y) - dot (camera1->x, camera1->m_y);
3197:1404:    h = dot (r1, camera1->m_y);
3198:1405:    i = dot (r2, camera1->m_y);
3199:1406:
3200:1407:    for (ic = 0; ic < num1points; ic++) {
3201:1408:        x = xvals1[ic];
3202:1409:        y = yvals1[ic];
3203:1410:
3204:1411:        dtheta = 20;
3205:1412:        theta = 0;
3206:1413:        etot = 1e90;
3207:1414:        do {
3208:1415:            do {
3209:1416:                theta += dtheta;
3210:1417:                etotp = etot;
3211:1418:                ex = x + camera1->f * (a + b * sin (theta) +
3212:1419:                                       c * cos (theta)) / (d +
3213:1420:                                                           e *
3214:1421:                                                           sin (theta) +
3215:1422:                                                           f *
3216:1423:                                                           cos (theta));
3217:1424:                ey = y + camera1->f * (g + h * sin (theta) +
3218:1425:                                       i * cos (theta)) / (j +
3219:1426:                                                           k *
3220:1427:                                                           sin (theta) +
3221:1428:                                                           l *
3222:1429:                                                           cos (theta));
3223:1430:                etot = ex * ex + ey * ey;
3224:1431:            } while (etot < etotp);
3225:1432:            dtheta *= -0.5;
3226:1433:        } while (fabs (dtheta) > 0.00001);
3227:1434:
3228:1435:        error += etotp;
3229:1436:    }
3230:1437:
3231:1438:    a = dot (p, camera2->m_x) - dot (camera2->x, camera2->m_x);
3232:1439:    b = dot (r1, camera2->m_x);
3233:1440:    c = dot (r2, camera2->m_x);
3234:1441:
3235:1442:    j = d = dot (p, camera2->m_s) - dot (camera2->x, camera2->m_s);
3236:1443:    k = e = dot (r1, camera2->m_s);
3237:1444:    l = f = dot (r2, camera2->m_s);
3238:1445:
3239:1446:    g = dot (p, camera2->m_y) - dot (camera2->x, camera2->m_y);
3240:1447:    h = dot (r1, camera2->m_y);
3241:1448:    i = dot (r2, camera2->m_y);
3242:1449:
3243:1450:    for (ic = 0; ic < num2points; ic++) {
3244:1451:        x = xvals2[ic];
3245:1452:        y = yvals2[ic];
3246:1453:
3247:1454:        dtheta = 20;
3248:1455:        theta = 0;
3249:1456:        etot = 1e90;
3250:1457:        do {
3251:1458:            do {
3252:1459:                theta += dtheta;
3253:1460:                etotp = etot;
3254:1461:                ex = x + camera2->f * (a + b * sin (theta) +
3255:1462:                                       c * cos (theta)) / (d +
3256:1463:                                                           e *
3257:1464:                                                           sin (theta) +
3258:1465:                                                           f *
3259:1466:                                                           cos (theta));
3260:1467:                ey = y + camera2->f * (g + h * sin (theta) +
3261:1468:                                       i * cos (theta)) / (j +
3262:1469:                                                           k *
3263:1470:                                                           sin (theta) +
3264:1471:                                                           l *
3265:1472:                                                           cos (theta));
3266:1473:                etot = ex * ex + ey * ey;
3267:1474:            } while (etot < etotp);
3268:1475:            dtheta *= -0.5;
3269:1476:        } while (fabs (dtheta) > 0.00001);
3270:1477:
3271:1478:        error += etotp;
3272:1479:    }
3273:1480:
3274:1481:    return error;
3275:1482:}
3276:1483:
3277:1484:
3278:1485:
3279:1486:Circle circlefromstereoedge (double *x1, double *y1, int n1,
3280:1487:                             double *x2, double *y2, int n2, Camera * cam1,
3281:1488:                             Camera * cam2)
3282:1489:{
3283:1490:    Circle circ;
3284:1491:    double p[6];
3285:1492:
3286:1493:/* This is a test only */
3287:1494:    p[0] = 0;
3288:1495:    p[1] = 250;
3289:1496:    p[2] = 0;
3290:1497:    p[3] = 375;
3291:1498:    p[4] = 0;
3292:1499:    p[5] = 375;
3293:1500:
3294:1501:    camera1 = cam1;
3295:1502:    camera2 = cam2;
3296:1503:    xvals1 = x1;
3297:1504:    yvals1 = y1;
3298:1505:    xvals2 = x2;
3299:1506:    yvals2 = y2;
3300:1507:    num1points = n1;
3301:1508:    num2points = n2;
3302:1509:
3303:1510:    simplex_optimise (p, 6, 10e-7, 1, to_minimise_stereo_circle, NULL);
3304:1511:
3305:1512:    circ.u.x = p[0];
3306:1513:    circ.u.y = p[1];
3307:1514:    circ.u.z = p[2];
3308:1515:    circ.r = norm (circ.u);
3309:1516:    circ.u = times (circ.u, 1 / circ.r);
3310:1517:    circ.p.x = p[3];
3311:1518:    circ.p.y = p[4];
3312:1519:    circ.p.z = p[5];
3313:1520:    circ.type = CIRCLE;
3314:1521:    circ.e = to_minimise_stereo_circle (p);
3315:1522:    return circ;
3316:1523:}
3317:1:/*
3318:2:   Copyright (C) 1996, 1997 Paul Sheer
3319:3:
3320:4:   This program is free software; you can redistribute it and/or modify
3321:5:   it under the terms of the GNU General Public License as published by
3322:6:   the Free Software Foundation; either version 2 of the License, or
3323:7:   (at your option) any later version.
3324:8:
3325:9:   This program is distributed in the hope that it will be useful,
3326:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
3327:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
3328:12:   GNU General Public License for more details.
3329:13:
3330:14:   You should have received a copy of the GNU General Public License
3331:15:   along with this program; if not, write to the Free Software
3332:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
3333:17: */
3334:18:#ifndef FITLINE_H
3335:19:#define FITLINE_H
3336:20:
3337:21:#include "quickmath.h"
3338:22:
3339:23:/* type is one of */
3340:24:enum {
3341:25:    NO_TYPE, VECTOR, POINT, LINE_SEGMENT, CYLINDER, CIRCLE, PLANE_SEGMENT,
3342:26:        SURFACE, ELLIPSE
3343:27:};
3344:28:
3345:29:typedef struct vector {
3346:30:    int type;
3347:31:    Vec p;
3348:32:    Vec u;
3349:33:} Vector;
3350:34:
3351:35:typedef struct point {
3352:36:    int type;
3353:37:    Vec p;
3354:38:} Point;
3355:39:
3356:40:typedef struct lineseg {
3357:41:    int type;
3358:42:    Vec p1;                     /* begin point */
3359:43:    Vec p2;                     /* end point */
3360:44:    double l;                   /* length x1,y1,z1 -> x2,y2,z2 */
3361:45:    double psi;                 /* psi = atan2(uy, ux) is the azimuth */
3362:46:    double beta;                /* the elivation = 0 for 2D lines */
3363:47:    double a, b, c;             /* ax + by = c 2d lines only */
3364:48:    Vec u;                      /* unit vector x1,y1 -> x2,y2 */
3365:49:    Vec m;                      /* position of centre */
3366:50:    double e;                   /* error in fit */
3367:51:    int n;                      /* number of points used in fit */
3368:52:} LineSegment;
3369:53:
3370:54:typedef struct cylseg {
3371:55:    int type;
3372:56:    LineSegment l;              /* axis */
3373:57:    double r, e;                /* radius, error */
3374:58:} Cylinder;
3375:59:
3376:60:typedef struct circle {
3377:61:    int type;
3378:62:    Vec p;                      /* centre */
3379:63:    double r;                   /* length x1,y1,z1 -> x2,y2,z2 */
3380:64:    Vec u;                      /* unit vector normal to plane */
3381:65:    double e;                   /* error in fit */
3382:66:    int n;                      /* number of points used in fit */
3383:67:} Circle;
3384:68:
3385:69:typedef struct ellipse {
3386:70:    int type;
3387:71:    Vec p;                      /* centre */
3388:72:    Vec q;                      /* direction of minor axis */
3389:73:    double r;                   /* length x1,y1,z1 -> x2,y2,z2 */
3390:74:    Vec u;                      /* unit vector normal to plane */
3391:75:    double e;                   /* error in fit */
3392:76:    int n;                      /* number of points used in fit */
3393:77:} Ellipse;
3394:78:
3395:79:
3396:80:/* dot(n, (x,y,z)) = d */
3397:81:typedef struct planeseg {
3398:82:    int type;
3399:83:    LineSegment l[8];           /* border */
3400:84:    int num;                    /* number of LineSegments used to border */
3401:85:    Vec u;                      /* normal (unit vector) */
3402:86:    double d;                   /* least distance from origin */
3403:87:    Vec c;                      /* centre point */
3404:88:    double elev;                /* max elivation gradient */
3405:89:    double gx, gy;              /* gradient in the x and y directions */
3406:90:    double e;
3407:91:    int n;
3408:92:} PlaneSegment;
3409:93:
3410:94:typedef struct surface {
3411:95:    int type;
3412:96:    int w, h;
3413:97:    Vec *p;
3414:98:} Surface;
3415:99:
3416:100:typedef union object {
3417:101:    int type;
3418:102:    Point point;
3419:103:    Vector vector;
3420:104:    LineSegment line;
3421:105:    Cylinder cylinder;
3422:106:    Circle circle;
3423:107:    Ellipse ellipse;
3424:108:    PlaneSegment plane;
3425:109:    Surface surface;
3426:110:} Object;
3427:111:
3428:112:
3429:113:Vec solve3x3 (double a[4][3]);
3430:114:
3431:115:double fitline (double *xvals, double *yvals, int numpoints, double *aa,
3432:116:                double *ab, double *ac);
3433:117:LineSegment linesegment (Vec p1, Vec p2);
3434:118:LineSegment linesegmentfrompoints (double *xvals, double *yvals,
3435:119:                                   double *zvals, int numpoints);
3436:120:double distancetoline (Vec x, LineSegment * l);
3437:121:Vec pointonline (Vec x, LineSegment * l);
3438:122:Vec interceptionbetweentwolines (LineSegment * l1, LineSegment * l2);
3439:123:int ispointonline (Vec x, LineSegment * l);
3440:124:LineSegment lineinterceptionoftwoplanes (PlaneSegment * p1,
3441:125:                                         PlaneSegment * p2);
3442:126:LineSegment segmentinterceptionoftwoplanes (PlaneSegment * p1,
3443:127:                                            PlaneSegment * p2);
3444:128:LineSegment linethroughpointandcamcentre (double x, double y,
3445:129:                                          Camera * cam);
3446:130:PlaneSegment planethroughlineandcamcentre (LineSegment * l, Camera * cam);
3447:131:LineSegment fit3dlinetoprojections (LineSegment * line1,
3448:132:                                    LineSegment * line2, Camera * cam1,
3449:133:                                    Camera * cam2);
3450:134:LineSegment linefromstereoedge (double *x1, double *y1, int n1, double *x2,
3451:135:                                double *y2, int n2, Camera * cam1,
3452:136:                                Camera * cam2);
3453:137:void linetest3d (void);
3454:138:void get_perp_vec (Vec X, Vec * r1, Vec * r2, double r);
3455:139:double comparelinesegments (LineSegment * l1, LineSegment * l2);
3456:140:double comparelines (LineSegment * l1, LineSegment * l2);
3457:141:void findcylinderedges (Camera * c, LineSegment * axis, double r,
3458:142:                        LineSegment * one_edge, LineSegment * other_edge);
3459:143:Cylinder cylinderfromstereoedge (double *x1l, double *y1l, int n1l,
3460:144:                                 double *x2l, double *y2l, int n2l,
3461:145:                                 double *x1r, double *y1r, int n1r,
3462:146:                                 double *x2r, double *y2r, int n2r,
3463:147:                                 Camera * camr, Camera * caml);
3464:148:Circle circlefrompoints (double *xvals, double *yvals, double *zvals,
3465:149:                         int numpoints);
3466:150:Cylinder cylinderfrompoints (double *xvals, double *yvals, double *zvals,
3467:151:                             int numpoints);
3468:152:Ellipse ellipsefrompoints (double *xvals, double *yvals, double *zvals,
3469:153:                           int numpoints);
3470:154:Circle circlefromstereoedge (double *x1, double *y1, int n1, double *x2,
3471:155:                             double *y2, int n2, Camera * cam1,
3472:156:                             Camera * cam2);
3473:157:
3474:158:#endif
3475:1:/*****************************************************************************************/
3476:2:/* hugeimage.c - widget to draw the tiff file, zoom box and do caching of image data     */
3477:3:/*****************************************************************************************/
3478:4:/*
3479:5:   Copyright (C) 1996, 1997 Paul Sheer
3480:6:
3481:7:   This program is free software; you can redistribute it and/or modify
3482:8:   it under the terms of the GNU General Public License as published by
3483:9:   the Free Software Foundation; either version 2 of the License, or
3484:10:   (at your option) any later version.
3485:11:
3486:12:   This program is distributed in the hope that it will be useful,
3487:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
3488:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
3489:15:   GNU General Public License for more details.
3490:16:
3491:17:   You should have received a copy of the GNU General Public License
3492:18:   along with this program; if not, write to the Free Software
3493:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
3494:20: */
3495:21:
3496:22:#include <config.h>
3497:23:#include "global.h"
3498:24:#include <stdlib.h>
3499:25:#include <stdio.h>
3500:26:
3501:27:#include <X11/Xlib.h>
3502:28:#include <X11/Xutil.h>
3503:29:
3504:30:#include "stringtools.h"
3505:31:#include "app_glob.c"
3506:32:
3507:33:#include "coolwidget.h"
3508:34:#include "hugeimage.h"
3509:35:#include <sys/types.h>
3510:36:#include <sys/stat.h>
3511:37:#include <fcntl.h>
3512:38:#include <unistd.h>
3513:39:#include <string.h>
3514:40:#include "display.h"
3515:41:#include "loadtiff.h"
3516:42:#include "dialog.h"
3517:43:
3518:44:#include "mad.h"
3519:45:
3520:46:int hugegetpixel (HugeImage * image, unsigned long x, unsigned long y)
3521:47:{
3522:48:    if (y < 0 || y >= image->height || x < 0 || x >= image->width)
3523:49:        return 0;
3524:50:    else {
3525:51:        int i = x >> COLUMNSHIFT;
3526:52:
3527:53:/*check if the point has not already been read: */
3528:54:        if (y < image->linestart[i] || y >= image->lineend[i])
3529:55:            hugeloadnextbuf (image, x, y, i);
3530:56:
3531:57:        return (image->
3532:58:                buffers[i])[((y - image->linestart[i]) << COLUMNSHIFT)
3533:59:                            + (x & COLUMNMASK)];
3534:60:    }
3535:61:}
3536:62:
3537:63:
3538:64:void hugeloadnextbuf (HugeImage * image, long x, long y, int i)
3539:65:{
3540:66:/*try not to seek if possible, rather just read the next
3541:67:   adjacent LINESCACHED : */
3542:68:    if (y >= image->lineend[i] + LINESCACHED || y < image->lineend[i]) {
3543:69:        lseek (image->temp[i], y * image->columnwidth, SEEK_SET);
3544:70:        image->linestart[i] = y;
3545:71:        image->lineend[i] = y + LINESCACHED;
3546:72:    } else {
3547:73:        image->linestart[i] += LINESCACHED;
3548:74:        image->lineend[i] += LINESCACHED;
3549:75:    }
3550:76:    read (image->temp[i], image->buffers[i],
3551:77:          image->columnwidth * LINESCACHED);
3552:78:}
3553:79:
3554:80:
3555:81:int loadhugeimage (HugeImage * image, const char *fname)
3556:82:{
3557:83:    Window progresswin;
3558:84:    unsigned char *blockofrows; /*holds the block of hieght BLOCKHEIGHT */
3559:85:    long width, height;         /*of the whole image */
3560:86:    long numblocks, numcolumns, i, j, k, bheight;
3561:87:    char tempstr[256];
3562:88:    int fileformat = 0;
3563:89:    unsigned char *cache;
3564:90:    int createtempfiles = 0;
3565:91:    char *imagefile = strdup (fname);
3566:92:
3567:93:    memset (image, 0, sizeof (HugeImage));
3568:94:    image->has_been_allocated = 314159265;
3569:95:    /* this is just so we don't free anything that hasn't been allocated */
3570:96:
3571:97:/*The first thing is to do create a whole lot of temp files,
3572:98:   hence setting up the HugeImage structure.
3573:99:   Each temp file is a columnwidth-pixels-wide column of the image.
3574:100:   By dividing the image up into columns like this, we can speed
3575:101:   up access to the image. The data in the temp file is contigous
3576:102:   scan lines with no header.
3577:103: */
3578:104:
3579:105:/*first get the image width and height and find the file format */
3580:106:
3581:107:    if ((blockofrows = loadgreytiff (imagefile, &width, &height,
3582:108:                                     0, 1, MONITOR_GAMMA)))
3583:109:        fileformat = 1;
3584:110:    else if ((blockofrows =
3585:111:              loadtarga2grey (imagefile, &width, &height, 0, 1)))
3586:112:        fileformat = 2;
3587:113:    else {
3588:114:        Cerrordialog (CMain, 20, 20, " Load Image ",
3589:115:                      " Unsupported image file format ");
3590:116:        goto error;
3591:117:    }
3592:118:    free (blockofrows);
3593:119:
3594:120:    image->width = width;
3595:121:    image->height = height;
3596:122:
3597:123:    numcolumns = (width + COLUMNWIDTH - 1) / COLUMNWIDTH;
3598:124:    numblocks = (height + BLOCKHEIGHT - 1) / BLOCKHEIGHT;
3599:125:
3600:126:    image->columnwidth = COLUMNWIDTH;
3601:127:    image->numcolumns = numcolumns;
3602:128:
3603:129:    image->temp = Cmalloc (numcolumns * sizeof (int));
3604:130:    image->buffers = Cmalloc (numcolumns * sizeof (unsigned char *));
3605:131:    image->linestart = Cmalloc (numcolumns * sizeof (long));
3606:132:    image->lineend = Cmalloc (numcolumns * sizeof (long));
3607:133:
3608:134:    printf ("loading image: res=(%ldx%ld)\n", width, height);
3609:135:
3610:136:/*open files and set up caches */
3611:137:    for (i = 0; i < numcolumns; i++) {
3612:138:        for (j = strlen (imagefile); j > 0; j--)
3613:139:            if (imagefile[j] == '/')
3614:140:                break;
3615:141:        if (imagefile[j] != '/') {
3616:142:            memmove (imagefile + 1, imagefile + j,
3617:143:                     strlen (imagefile + j) + 1);
3618:144:            imagefile[0] = '/';
3619:145:            j = 0;
3620:146:        }
3621:147:        sprintf (tempstr, "%s%s%ld.temp", TEMPDIR, imagefile + j, i);
3622:148:        if ((image->temp[i] = open (tempstr, O_RDWR)) == -1) {
3623:149:            createtempfiles = 1;
3624:150:            if ((image->temp[i] =
3625:151:                 open (tempstr, O_RDWR | O_CREAT | O_TRUNC,
3626:152:                       S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP)) == -1) {
3627:153:                printf ("%s\n", tempstr);
3628:154:                Cerror (" cannot open temporary file %s ");
3629:155:            }
3630:156:        } else {
3631:157:/********** ask user if they want to use temp files, or create new ones.*/
3632:158:            /*tempfiles exist this flag says don't need to write them out */
3633:159:        }
3634:160:/*********/
3635:161:        image->buffers[i] = Cmalloc (LINESCACHED * COLUMNWIDTH);
3636:162:        image->linestart[i] = 0;
3637:163:        /* linestart = lineend = 0 will force a cache */
3638:164:        image->lineend[i] = 0;  /*load on the first call to hugegetpixel */
3639:165:    }
3640:166:
3641:167:    if (createtempfiles)
3642:168:        printf ("Creating new temp column files.\n");
3643:169:    else
3644:170:        printf ("Using existing temp column files.\n");
3645:171:
3646:172:    progresswin = Cdrawwindow ("loadprogw", CMain, 50, 50, 300, 110, "");
3647:173:
3648:174:    if (createtempfiles) {
3649:175:        cache = Cmalloc (BLOCKHEIGHT * COLUMNWIDTH);
3650:176:        for (i = 0; i < numblocks; i++) {
3651:177:            bheight = height - i * BLOCKHEIGHT;
3652:178:            if (bheight > BLOCKHEIGHT)
3653:179:                bheight = BLOCKHEIGHT;
3654:180:            blockofrows = NULL;
3655:181:
3656:182:
3657:183:            Cdrawprogress ("loadprogbar", progresswin, 20, 20, 260, 25,
3658:184:                           i * 65535 / numblocks);
3659:185:            Ccheckifevent (NULL, NULL);
3660:186:
3661:187:            switch (fileformat) {
3662:188:            case 1:
3663:189:                blockofrows = loadgreytiff (imagefile, &width, &height,
3664:190:                                            i * BLOCKHEIGHT,
3665:191:                                            i * BLOCKHEIGHT + bheight,
3666:192:                                            MONITOR_GAMMA);
3667:193:                break;
3668:194:            case 2:
3669:195:                blockofrows = loadtarga2grey (imagefile, &width, &height,
3670:196:                                              i * BLOCKHEIGHT,
3671:197:                                              i * BLOCKHEIGHT + bheight);
3672:198:                break;
3673:199:            }
3674:200:
3675:201:            for (k = 0; k < numcolumns; k++) {
3676:202:                for (j = 0; j < bheight; j++)
3677:203:                    memcpy (cache + j * COLUMNWIDTH,
3678:204:                            blockofrows + j * width + k * COLUMNWIDTH,
3679:205:                            COLUMNWIDTH);
3680:206:                write (image->temp[k], cache, COLUMNWIDTH * bheight);
3681:207:            }
3682:208:            if (blockofrows)
3683:209:                free (blockofrows);
3684:210:        }
3685:211:        free (cache);
3686:212:    }
3687:213:    Cundrawwidget ("loadprogw");
3688:214:
3689:215:    free (imagefile);
3690:216:    return 0;
3691:217:  error:;
3692:218:    free (imagefile);
3693:219:    return 1;
3694:220:}
3695:221:
3696:222:/* This just frees all the stuff allocated in loadhugeimage */
3697:223:void freehugeimage (HugeImage * image)
3698:224:{
3699:225:    int i;
3700:226:
3701:227:    if (image->has_been_allocated != 314159265)
3702:228:        return;
3703:229:
3704:230:    if (image->temp)
3705:231:        for (i = 0; i < image->numcolumns; i++)
3706:232:            if (image->temp[i] >= 0) /*do you get zero file handles? */
3707:233:                close (image->temp[i]);
3708:234:
3709:235:    if (image->buffers)
3710:236:        for (i = 0; i < image->numcolumns; i++)
3711:237:            if (image->buffers[i])
3712:238:                free (image->buffers[i]);
3713:239:
3714:240:    if (image->temp)
3715:241:        free (image->temp);
3716:242:    if (image->buffers)
3717:243:        free (image->buffers);
3718:244:    if (image->linestart)
3719:245:        free (image->linestart);
3720:246:    if (image->lineend)
3721:247:        free (image->lineend);
3722:248:    memset (image, 0, sizeof (HugeImage));
3723:249:}
3724:250:
3725:251:
3726:252:void destroy_huge (CWidget * w)
3727:253:{
3728:254:    if (CUserOf (w)) {
3729:255:        freehugeimage (CUserOf (w));
3730:256:        free (CUserOf (w));
3731:257:        CUserOf (w) = 0;
3732:258:    }
3733:259:}
3734:260:
3735:261:
3736:262:
3737:263:/*
3738:264:   Draw a huge image. The image is scaled (i.e. scaled by proper interpolation
3739:265:   NOT by just leaving out scanlines) to the size specified (width, height).
3740:266:   if width is zero image is scaled to height and width set adjusted to
3741:267:   preserve aspect ratio. Similarly if height is zero.
3742:268:
3743:269:   At the moment this handles only tiff files as discribed in imagewidget.c
3744:270:   loadgreytiff(...) ********** 
3745:271: */
3746:272:/*, HugeImage * returnimage */
3747:273:
3748:274:CWidget *Cdrawhugebwimage (const char *identifier, Window parent, int x,
3749:275:                           int y, long *width, long *height,
3750:276:                           const char *imagefile)
3751:277:{
3752:278:    Window progresswin;
3753:279:    CWidget *wdt;
3754:280:    unsigned char *data;
3755:281:/* check what happens to 'data' memory for mallocing and freeing***** */
3756:282:    HugeImage *image;
3757:283:    long i, j;
3758:284:    long pixel;
3759:285:    unsigned long xfrac, yfrac;
3760:286:    unsigned long xs1, ys1, xs2, ys2, xp, yp, area;
3761:287:    char fstr[256];
3762:288:    long w, h;
3763:289:
3764:290:    image = Cmalloc (sizeof (HugeImage));
3765:291:
3766:292:    if (loadhugeimage (image, imagefile)) {
3767:293:        free (image);
3768:294:        return NULL;
3769:295:    }
3770:296:    if (!(*width | *height)) {
3771:297:        *width = image->width;
3772:298:        *height = image->height;
3773:299:
3774:300:        data = Cmalloc (*width * *height);
3775:301:
3776:302:        for (j = 0; j < *height; j++)
3777:303:            for (i = 0; i < *width; i++)
3778:304:                data[i + j * *width] = hugegetpixel (image, i, j);
3779:305:
3780:306:    } else {
3781:307:        sprintf (fstr, "%s.thumb.tga", imagefile);
3782:308:        data = loadtarga2grey (fstr, &w, &h, 0, 1 << 30);
3783:309:
3784:310:        if (!data) {            /*a previously created thumbnail image does not exist, so... */
3785:311:            printf
3786:312:                ("No thumbnail image exists, creating thumbnail image from original.\n");
3787:313:            if (!*width)
3788:314:                *width = image->width * (*height) / image->height;
3789:315:            if (!*height)
3790:316:                *height = image->height * (*width) / image->width;
3791:317:
3792:318:            data = Cmalloc ((*width + 20) * *height);
3793:319:
3794:320:#define PFRAC 256
3795:321:#define PSH 8
3796:322:
3797:323:            area = (double) image->width * image->height * PFRAC * PFRAC /
3798:324:                (*height * *width);
3799:325:
3800:326:            progresswin =
3801:327:                Cdrawwindow ("loadprogw", CMain, 50, 50, 300, 110, "");
3802:328:
3803:329:            for (j = 0; j < *height; j++) {
3804:330:
3805:331:                Cdrawprogress ("loadprogbar", progresswin, 20, 20, 260, 25,
3806:332:                               j * 65535 / (*height));
3807:333:                Ccheckifevent (NULL, NULL);
3808:334:                for (i = 0; i < *width; i++) {
3809:335:                    pixel = 0;  /*pixel holds the accumulated sum */
3810:336:
3811:337:/*the following rectangle must be averaged; it bounds an unscaled pixel: */
3812:338:                    xs1 = ((i * image->width) << PSH) / (*width);
3813:339:                    xs2 = (((i + 1) * image->width) << PSH) / (*width);
3814:340:                    ys1 = ((j * image->height) << PSH) / (*height);
3815:341:                    ys2 = (((j + 1) * image->height) << PSH) / (*height);
3816:342:
3817:343:/*
3818:344:   yfrac is the proportion of the pixel that can be seen if
3819:345:   the pixel crosses the rectangle border. It is out of 1 << PSH = PFRAC
3820:346:   and is therefore only less than PFRAC for border pixels.
3821:347: */
3822:348:
3823:349:                    yfrac = PFRAC - (ys1 & (PFRAC - 1));
3824:350:
3825:351:                    for (yp = (ys1 >> PSH); yp < (ys2 >> PSH); yp++) {
3826:352:                        xfrac = PFRAC - (xs1 & (PFRAC - 1));
3827:353:                        for (xp = (xs1 >> PSH); xp < (xs2 >> PSH); xp++) {
3828:354:                            pixel +=
3829:355:                                xfrac * yfrac * hugegetpixel (image, xp,
3830:356:                                                              yp);
3831:357:                            xfrac = PFRAC;
3832:358:                            /* inner pixels can all be seen entirely */
3833:359:                        }
3834:360:/*do last pixel in row */
3835:361:                        if ((xfrac = (xs2 & (PFRAC - 1))))
3836:362:                            pixel +=
3837:363:                                xfrac * yfrac * hugegetpixel (image, xp,
3838:364:                                                              yp);
3839:365:                        yfrac = PFRAC;
3840:366:                    }
3841:367:
3842:368:/*now do the last row of the rectangle */
3843:369:                    if ((yfrac = (ys2 & (PFRAC - 1)))) {
3844:370:                        xfrac = PFRAC - (xs1 & (PFRAC - 1));
3845:371:                        for (xp = (xs1 >> PSH); xp < (xs2 >> PSH); xp++) {
3846:372:                            pixel +=
3847:373:                                xfrac * yfrac * hugegetpixel (image, xp,
3848:374:                                                              yp);
3849:375:                            xfrac = PFRAC;
3850:376:                        }
3851:377:/*do last pixel in row */
3852:378:                        xfrac = (xs2 & (PFRAC - 1));
3853:379:                        pixel +=
3854:380:                            xfrac * yfrac * hugegetpixel (image, xp, yp);
3855:381:                    }
3856:382:                    data[i + j * *width] = (long) pixel / area;
3857:383:                }
3858:384:            }
3859:385:
3860:386:            Cundrawwidget ("loadprogw");
3861:387:            writetarga (data, fstr, *width, *height, 1);
3862:388:            /* save the thumbnail image for later */
3863:389:        } else {                /* thumbnail image exists and is stored in data so do nothing */
3864:390:            printf ("Thumbnail image exists, loading.\n");
3865:391:            *width = w;
3866:392:            *height = h;
3867:393:        }
3868:394:    }
3869:395:
3870:396:    wdt = Cdrawbwimage (identifier, parent, x, y, *width, *height, data);
3871:397:
3872:398:    CUserOf (wdt) = (void *) image;
3873:399:    wdt->destroy = destroy_huge;
3874:400:    return wdt;
3875:401:}
3876:402:
3877:403:
3878:404:void Crenderzoombox (CWidget * wdt, int x, int y, int rendw, int rendh)
3879:405:{
3880:406:    int w = wdt->width;
3881:407:    int h = wdt->height;
3882:408:    Window win = wdt->winid;
3883:409:    int xim, yim, xwin, ywin;
3884:410:
3885:411:    xim = x - 2;
3886:412:    yim = y - 2;
3887:413:    xwin = x;
3888:414:    ywin = y;
3889:415:    if (xim < 0) {
3890:416:        rendw += xim;
3891:417:        xim = 0;
3892:418:        xwin = 2;
3893:419:    }
3894:420:    if (yim < 0) {
3895:421:        rendh += yim;
3896:422:        yim = 0;
3897:423:        ywin = 2;
3898:424:    }
3899:425:    XPutImage (CDisplay, win, CGC, wdt->ximage,
3900:426:               xim, yim, xwin, ywin, rendw, rendh);
3901:427:
3902:428:    Crenderbevel (win, 0, 0, w - 1, h - 1, 2, 1);
3903:429:
3904:430:}
3905:431:
3906:432:
3907:433:
3908:434:/*
3909:435:   x, y is position in huge image. w, h is data size, zoom is
3910:436:   pixel width of a hugeimage pixel i.e. the enlargement factor.
3911:437: */
3912:438:void extractfromhugeimage (HugeImage * image, unsigned char *data,
3913:439:                           long x, long y, int width, int height, int zoom)
3914:440:{                               /*this must be tested */
3915:441:    long i, j;
3916:442:    long c, l, m, k;
3917:443:    unsigned char *q = data;
3918:444:
3919:445:/*wanna optimise more than this? I'm sure there's room. */
3920:446:    if (zoom)
3921:447:        if (zoom == 1) {
3922:448:            for (j = y; j < height + y; j++)
3923:449:                for (i = x; i < width + x; i++) {
3924:450:                    *(q++) = hugegetpixel (image, i, j);
3925:451:                }
3926:452:        } else if (zoom == 2) {
3927:453:            for (j = 0; j < height; j += 2)
3928:454:                for (i = 0; i < width; i += 2) {
3929:455:                    data[k = (i + j * width)] = c =
3930:456:                        hugegetpixel (image, (i >> 1) + x, (j >> 1) + y);
3931:457:                    data[k + 1] = c;
3932:458:                    data[(k++) + width] = c;
3933:459:                    data[k + width] = c;
3934:460:                }
3935:461:        } else if (zoom == 3) {
3936:462:            for (j = 0; j < height; j += 3)
3937:463:                for (i = 0; i < width; i += 3) {
3938:464:                    data[k = (i + j * width)] = c =
3939:465:                        hugegetpixel (image, i / 3 + x, j / 3 + y);
3940:466:                    data[k + 1] = c;
3941:467:                    data[k + 2] = c;
3942:468:                    k += width;
3943:469:                    data[k] = c;
3944:470:                    data[k + 1] = c;
3945:471:                    data[k + 2] = c;
3946:472:                    k += width;
3947:473:                    data[k] = c;
3948:474:                    data[k + 1] = c;
3949:475:                    data[k + 2] = c;
3950:476:                }
3951:477:        } else if (zoom == 4) {
3952:478:            for (j = 0; j < height; j += 4)
3953:479:                for (i = 0; i < width; i += 4) {
3954:480:                    data[k = (i + j * width)] = c =
3955:481:                        hugegetpixel (image, (i >> 2) + x, (j >> 2) + y);
3956:482:                    data[k + 1] = c;
3957:483:                    data[k + 2] = c;
3958:484:                    data[k + 3] = c;
3959:485:                    k += width;
3960:486:                    data[k] = c;
3961:487:                    data[k + 1] = c;
3962:488:                    data[k + 2] = c;
3963:489:                    data[k + 3] = c;
3964:490:                    k += width;
3965:491:                    data[k] = c;
3966:492:                    data[k + 1] = c;
3967:493:                    data[k + 2] = c;
3968:494:                    data[k + 3] = c;
3969:495:                    k += width;
3970:496:                    data[k] = c;
3971:497:                    data[k + 1] = c;
3972:498:                    data[k + 2] = c;
3973:499:                    data[k + 3] = c;
3974:500:                }
3975:501:        } else {
3976:502:            for (j = 0; j < height; j += zoom)
3977:503:                for (i = 0; i < width; i += zoom) {
3978:504:                    c = hugegetpixel (image, i / zoom + x, j / zoom + y);
3979:505:                    k = i + j * width;
3980:506:                    for (m = 0; m < zoom; m++, k += width)
3981:507:                        for (l = 0; l < zoom; l++)
3982:508:                            data[k + l] = c;
3983:509:                }
3984:510:        }
3985:511:}
3986:512:
3987:513:CWidget *Cdrawzoombox (const char *identifier, const char *main,
3988:514:                       Window parent, int x, int y, long width,
3989:515:                       long height, long posx, long posy, int zoom)
3990:516:{
3991:517:    CWidget *w;
3992:518:    unsigned char *data = Cmalloc (width * height);
3993:519:    HugeImage *hi = (HugeImage *) CUserOf (Cwidget (main));
3994:520:    extractfromhugeimage (hi, data, posx, posy, width, height, zoom);
3995:521:
3996:522:    w = Cdrawbwimage (identifier, parent, x, y, width, height, data);
3997:523:    CUserOf (w) = hi;
3998:524:/*    w->destroy = destroy_huge; */
3999:525:    free (data);
4000:526:    return w;
4001:527:}
4002:528:
4003:529:
4004:530:CWidget *Cupdatezoombox (const char *identifier, long posx, long posy,
4005:531:                         int zoom)
4006:532:{
4007:533:    Window win;
4008:534:    unsigned char *data;
4009:535:    long width, height;
4010:536:    HugeImage *hi;
4011:537:
4012:538:    CWidget *w = Cwidget (identifier);
4013:539:    hi = (HugeImage *) CUserOf (w);
4014:540:
4015:541:    win = w->winid;
4016:542:    width = w->width;
4017:543:    height = w->height;
4018:544:
4019:545:    data = Cmalloc (width * height);
4020:546:
4021:547:    extractfromhugeimage (hi, data, posx, posy, width - 4, height - 4,
4022:548:                          zoom);
4023:549:
4024:550:/* as with Cdrawbwimage: */
4025:551:    greyscaletopix (w->ximage->data, data, width - 4, height - 4,
4026:552:                    w->ximage->bits_per_pixel / 8);
4027:553:
4028:554:    Cexpose (identifier);
4029:555:
4030:556:    free (data);
4031:557:    return w;
4032:558:}
4033:559:
4034:560:
4035:561:
4036:562:long CHugeImageRealWidth (const char *ident)
4037:563:{
4038:564:    return ((HugeImage *) CUserOf (Cwidget (ident)))->width;
4039:565:}
4040:566:
4041:567:
4042:568:long CHugeImageRealHeight (const char *ident)
4043:569:{
4044:570:    return ((HugeImage *) CUserOf (Cwidget (ident)))->height;
4045:571:}
4046:1:/*
4047:2:   Copyright (C) 1996, 1997 Paul Sheer
4048:3:
4049:4:   This program is free software; you can redistribute it and/or modify
4050:5:   it under the terms of the GNU General Public License as published by
4051:6:   the Free Software Foundation; either version 2 of the License, or
4052:7:   (at your option) any later version.
4053:8:
4054:9:   This program is distributed in the hope that it will be useful,
4055:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
4056:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
4057:12:   GNU General Public License for more details.
4058:13:
4059:14:   You should have received a copy of the GNU General Public License
4060:15:   along with this program; if not, write to the Free Software
4061:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
4062:17: */
4063:18:#ifndef HUG_IMAGE_H
4064:19:#define HUG_IMAGE_H
4065:20:
4066:21:typedef struct {
4067:22:    long width;
4068:23:    long height;
4069:24:    int *temp;
4070:25:    long *linestart;            /* first line cached in buffer (inclusive of this line) */
4071:26:    long *lineend;              /* last line cached in buffer (exclusive of this line) */
4072:27:    unsigned char **buffers;    /* buffer */
4073:28:    int columnwidth;
4074:29:    long numcolumns;
4075:30:    unsigned long has_been_allocated;
4076:31:} HugeImage;
4077:32:
4078:33:#define BLOCKHEIGHT 64
4079:34:/*the number of rows we are going to read from the file
4080:35:   at a time. Small to reduce memory requirements, large to be
4081:36:   faster */
4082:37:#define COLUMNSHIFT 7
4083:38:#define COLUMNWIDTH 128
4084:39:#define COLUMNMASK 127
4085:40:
4086:41:/*This must be about the size as the maximum mask you
4087:42:   might want to use on the image. i.e. if you are going to
4088:43:   readily access pixel(i,j) followed by pixel(i, j+4) then
4089:44:   choose 5. If you are only going to readily access
4090:45:   pixel(i+1,j) after pixel(i,j) the choose 1.
4091:46:   In any even, mask must also be accessed from left to right. */
4092:47:#define LINESCACHED 128
4093:48:
4094:49:void hugeloadnextbuf (HugeImage * image, long x, long y, int i);
4095:50:
4096:51:/*getpixel gets a pixel grey value (0-255) from a huge image.
4097:52:   It exploits a caching mechanism to improve speed. This is a little
4098:53:   faster than the caching mechanism used by the FILE type.
4099:54:   The caching mechanism works best when pixels are accessed from left to
4100:55:   right in the image. See LINESCACHED above. */
4101:56:
4102:57:CWidget *Cdrawhugebwimage (const char *identifier, Window parent, int x,
4103:58:                           int y, long *width, long *height,
4104:59:                           const char *imagefile);
4105:60:void Crenderzoombox (CWidget * w, int x, int y, int rendw, int rendh);
4106:61:void extractfromhugeimage (HugeImage * image, unsigned char *data,
4107:62:                           long x, long y, int width, int height,
4108:63:                           int zoom);
4109:64:CWidget *Cdrawzoombox (const char *identifier, const char *main,
4110:65:                       Window parent, int x, int y, long width,
4111:66:                       long height, long posx, long posy, int zoom);
4112:67:CWidget *Cupdatezoombox (const char *identifier, long posx, long posy,
4113:68:                         int zoom);
4114:69:long CHugeImageRealHeight (const char *ident);
4115:70:long CHugeImageRealWidth (const char *ident);
4116:71:
4117:72:#endif
4118:1:/*****************************************************************************************/
4119:2:/* imagefit.c - commands to fit objects to desktop markers                               */
4120:3:/*****************************************************************************************/
4121:4:/*
4122:5:   Copyright (C) 1996, 1997 Paul Sheer
4123:6:
4124:7:   This program is free software; you can redistribute it and/or modify
4125:8:   it under the terms of the GNU General Public License as published by
4126:9:   the Free Software Foundation; either version 2 of the License, or
4127:10:   (at your option) any later version.
4128:11:
4129:12:   This program is distributed in the hope that it will be useful,
4130:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
4131:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
4132:15:   GNU General Public License for more details.
4133:16:
4134:17:   You should have received a copy of the GNU General Public License
4135:18:   along with this program; if not, write to the Free Software
4136:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
4137:20: */
4138:21:
4139:22:#include "display.h"
4140:23:#include "main/imagefit.h"
4141:24:#include "app_glob.c"
4142:25:#include "hugeimage.h"
4143:26:#include "widget3d.h"
4144:27:#include "main/marker.h"
4145:28:#include "main/displaycam.h"
4146:29:#include "picsetup.h"
4147:30:#include "dialog.h"
4148:31:#include "stringtools.h"
4149:32:#include "callback.h"
4150:33:#include "matrix.h"
4151:34:#include "output.h"
4152:35:
4153:36:/* \end{verbatim} \begin{verbatim} */
4154:37:
4155:38:extern Desktop desktop;
4156:39:
4157:40:Matrix *get_3d_points (Desktop * d)
4158:41:{
4159:42:    return 0;
4160:43:}
4161:44:
4162:45:
4163:46:#define LOTS 30000
4164:47:
4165:48:static int get_min_points (Marker * m)
4166:49:{
4167:50:    int i, min = LOTS;
4168:51:    for (i = 0; m[i].v; i++)
4169:52:        if (m[i].n < min)
4170:53:            min = m[i].n;
4171:54:    return min;
4172:55:}
4173:56:
4174:57:
4175:58:/* minimise an overconstrained nx3 matrix */
4176:59:Vec vec_invert (Vec * s, double *r, int n)
4177:60:{
4178:61:    int i;
4179:62:    double a[4][3] = {
4180:63:        {0, 0, 0},
4181:64:        {0, 0, 0},
4182:65:        {0, 0, 0},
4183:66:        {0, 0, 0}
4184:67:    };
4185:68:    if (n < 3) {
4186:69:        fprintf (stderr,
4187:70:                 "stereo:%s:%d: call to vec_invert with less than three rows\n",
4188:71:                 __FILE__, __LINE__);
4189:72:        abort ();
4190:73:    }
4191:74:    if (n > 3) {
4192:75:        for (i = 0; i < n; i++) { /* s transpose multiplied by s */
4193:76:            a[0][0] += s[i].x * s[i].x;
4194:77:            a[0][1] += s[i].y * s[i].x;
4195:78:            a[0][2] += s[i].z * s[i].x;
4196:79:            a[1][0] += s[i].x * s[i].y;
4197:80:            a[1][1] += s[i].y * s[i].y;
4198:81:            a[1][2] += s[i].z * s[i].y;
4199:82:            a[2][0] += s[i].x * s[i].z;
4200:83:            a[2][1] += s[i].y * s[i].z;
4201:84:            a[2][2] += s[i].z * s[i].z;
4202:85:            a[3][0] += r[i] * s[i].x;
4203:86:            a[3][1] += r[i] * s[i].y;
4204:87:            a[3][2] += r[i] * s[i].z;
4205:88:        }
4206:89:        return solve3x3 (a);
4207:90:    }
4208:91:    a[0][0] = s[0].x;
4209:92:    a[0][1] = s[1].x;
4210:93:    a[0][2] = s[2].x;
4211:94:    a[1][0] = s[0].y;
4212:95:    a[1][1] = s[1].y;
4213:96:    a[1][2] = s[2].y;
4214:97:    a[2][0] = s[0].z;
4215:98:    a[2][1] = s[1].z;
4216:99:    a[2][2] = s[2].z;
4217:100:    a[3][0] = r[0];
4218:101:    a[3][1] = r[1];
4219:102:    a[3][2] = r[2];
4220:103:    return solve3x3 (a);
4221:104:}
4222:105:
4223:106:
4224:107:
4225:108:
4226:109:Vec triangulate_camera_point (double *x, double *y, Camera ** c, int n)
4227:110:{
4228:111:/* Here we find the best estimate for the points position: a linear problem. */
4229:112:    int i, j;
4230:113:    Vec *s, v;
4231:114:    double *r;
4232:115:    r = Cmalloc ((n * 2) * sizeof (double));
4233:116:    s = Cmalloc ((n * 2) * sizeof (Vec));
4234:117:    j = 0;
4235:118:    for (i = 0; i < n; i++) {
4236:119:        s[j] = plus (times (c[i]->m_s, x[i]), times (c[i]->m_x, c[i]->f));
4237:120:        r[j] = dot (s[j], c[i]->x);
4238:121:        j++;
4239:122:        s[j] = plus (times (c[i]->m_s, y[i]), times (c[i]->m_y, c[i]->f));
4240:123:        r[j] = dot (s[j], c[i]->x);
4241:124:        j++;
4242:125:    }
4243:126:    v = vec_invert (s, r, j);
4244:127:    free (s);
4245:128:    free (r);
4246:129:    return v;
4247:130:}
4248:131:
4249:132:
4250:133:
4251:134:Vec *triangulate_image_points (Marker * m, int *n)
4252:135:{
4253:136:    Vec *v;
4254:137:    int num_sets = 0, i, j;
4255:138:    double *x, *y;
4256:139:    Camera **c;
4257:140:    *n = get_min_points (m);
4258:141:    while (m[num_sets].v)
4259:142:        num_sets++;
4260:143:
4261:144:    c = Cmalloc (num_sets * sizeof (Camera *));
4262:145:    v = Cmalloc (*n * sizeof (Vec));
4263:146:    x = Cmalloc (num_sets * sizeof (double));
4264:147:    y = Cmalloc (num_sets * sizeof (double));
4265:148:
4266:149:    for (i = 0; i < num_sets; i++)
4267:150:        c[i] = m[i].cam;
4268:151:
4269:152:    for (j = 0; j < *n; j++) {
4270:153:        for (i = 0; i < num_sets; i++) {
4271:154:            x[i] = m[i].v[j].x;
4272:155:            y[i] = m[i].v[j].y;
4273:156:            imagetocamera (c[i], x[i], y[i]);
4274:157:        }
4275:158:        v[j] = triangulate_camera_point (x, y, c, num_sets);
4276:159:    }
4277:160:    free (y);
4278:161:    free (x);
4279:162:    free (c);
4280:163:    return v;
4281:164:}
4282:165:
4283:166:
4284:167:/* alignment **** */
4285:168:/* this object may be free'd with just free */
4286:169:Object *get_surface (Marker * m, int w, int h)
4287:170:{
4288:171:    Vec *v;
4289:172:    int n;
4290:173:    Object *o;
4291:174:
4292:175:    v = triangulate_image_points (m, &n);
4293:176:    if (n != w * h) {
4294:177:        free (v);
4295:178:        Cerrordialog (0, 0, 0, " Get surface ",
4296:179:                      " width * height not the same as the number of points triangulated \n"
4297:180:                      " check that you have a representative marker in each image ");
4298:181:        return 0;
4299:182:    }
4300:183:    o = Cmalloc (sizeof (Object) + n * sizeof (Vec));
4301:184:    o->surface.p = (Vec *) ((char *) o + sizeof (Object));
4302:185:    memcpy (o->surface.p, v, n * sizeof (Vec));
4303:186:    free (v);
4304:187:    o->surface.w = w;
4305:188:    o->surface.h = h;
4306:189:    o->type = SURFACE;
4307:190:    return o;
4308:191:}
4309:192:
4310:193:void width_and_height_query (int *w, int *h)
4311:194:{
4312:195:    CEvent e;
4313:196:    Window size_query = Cdrawwindow ("surfsizeQ", CMain, 20, 20, 320,
4314:197:                                     145, "surfsizeQ");
4315:198:
4316:199:    Cdrawbitmapbutton ("surfsizeQ.close", size_query, 136, 93,
4317:200:                       40, 40, Ccolor (6), C_FLAT, tick_bits);
4318:201:
4319:202:    Cdrawtext ("", size_query, 4, 4, "Enter width\n");
4320:203:    Cdrawtext ("", size_query, 4, 32, "Enter height\n");
4321:204:    Cdrawtextinput ("surfsizeQ.width", size_query, 120, 4, 50, 20, 20, "");
4322:205:    Cdrawtextinput ("surfsizeQ.height", size_query, 120, 32,
4323:206:                    50, 20, 20, "");
4324:207:
4325:208:    do {
4326:209:        CNextEvent (NULL, &e);
4327:210:    } while (strcmp (e.ident, "surfsizeQ.close"));
4328:211:
4329:212:    *w = atoi (Cgettext ("surfsizeQ.width"));
4330:213:    *h = atoi (Cgettext ("surfsizeQ.height"));
4331:214:
4332:215:    Cundrawwidget ("surfsizeQ");
4333:216:}
4334:217:
4335:218:
4336:219:Object *fit_surface (Desktop * d)
4337:220:{
4338:221:    int w, h;
4339:222:    Marker *m = 0;
4340:223:    Object *o;
4341:224:    if (!check_markers (d, 2, LOTS, 4, LOTS, " Fit Surface "))
4342:225:        return 0;
4343:226:    width_and_height_query (&w, &h);
4344:227:    if ((w | h)) {
4345:228:        m = get_all_markers (d);
4346:229:        o = get_surface (m, w, h);
4347:230:        free (m);
4348:231:        return o;
4349:232:    }
4350:233:    free (m);
4351:234:    return 0;
4352:235:}
4353:236:
4354:237:
4355:238:void output_surface (Desktop * d)
4356:239:{
4357:240:    Object *o;
4358:241:    o = fit_surface (d);
4359:242:    if (o) {
4360:243:        output_object (o);
4361:244:        free (o);
4362:245:    }
4363:246:}
4364:247:
4365:248:Circle circle_from_points (Vec * v, int n)
4366:249:{
4367:250:    Circle c;
4368:251:    double *x, *y, *z;
4369:252:    int i;
4370:253:    x = Cmalloc (sizeof (double) * n * 3);
4371:254:    y = x + n;
4372:255:    z = y + n;
4373:256:    for (i = 0; i < n; i++) {
4374:257:        x[i] = v[i].x;
4375:258:        y[i] = v[i].y;
4376:259:        z[i] = v[i].z;
4377:260:    }
4378:261:
4379:262:    c = circlefrompoints (x, y, z, n);
4380:263:    free (x);
4381:264:    return c;
4382:265:}
4383:266:
4384:267:Cylinder cylinder_from_points (Vec * v, int n)
4385:268:{
4386:269:    Cylinder c;
4387:270:    double *x, *y, *z;
4388:271:    int i;
4389:272:    x = Cmalloc (sizeof (double) * n * 3);
4390:273:    y = x + n;
4391:274:    z = y + n;
4392:275:    for (i = 0; i < n; i++) {
4393:276:        x[i] = v[i].x;
4394:277:        y[i] = v[i].y;
4395:278:        z[i] = v[i].z;
4396:279:    }
4397:280:
4398:281:    c = cylinderfrompoints (x, y, z, n);
4399:282:    free (x);
4400:283:    return c;
4401:284:}
4402:285:
4403:286:
4404:287:LineSegment line_from_points (Vec * v, int n)
4405:288:{
4406:289:    LineSegment l;
4407:290:    double *x, *y, *z;
4408:291:    int i;
4409:292:    x = Cmalloc (sizeof (double) * n * 3);
4410:293:    y = x + n;
4411:294:    z = y + n;
4412:295:    for (i = 0; i < n; i++) {
4413:296:        x[i] = v[i].x;
4414:297:        y[i] = v[i].y;
4415:298:        z[i] = v[i].z;
4416:299:    }
4417:300:
4418:301:    l = linesegmentfrompoints (x, y, z, n);
4419:302:    free (x);
4420:303:    return l;
4421:304:}
4422:305:
4423:306:Ellipse ellipse_from_points (Vec * v, int n)
4424:307:{
4425:308:    Ellipse e;
4426:309:    double *x, *y, *z;
4427:310:    int i;
4428:311:    x = Cmalloc (sizeof (double) * n * 3);
4429:312:    y = x + n;
4430:313:    z = y + n;
4431:314:    for (i = 0; i < n; i++) {
4432:315:        x[i] = v[i].x;
4433:316:        y[i] = v[i].y;
4434:317:        z[i] = v[i].z;
4435:318:    }
4436:319:
4437:320:    e = ellipsefrompoints (x, y, z, n);
4438:321:    free (x);
4439:322:    return e;
4440:323:}
4441:324:
4442:325:
4443:326:Object *fit_circle (Desktop * d)
4444:327:{
4445:328:    int n;
4446:329:    Vec *v;
4447:330:    Marker *m;
4448:331:    Object *o;
4449:332:    if (!check_markers (d, 2, LOTS, 3, LOTS, " Fit Circle "))
4450:333:        return 0;
4451:334:    m = get_all_markers (d);
4452:335:    v = triangulate_image_points (m, &n);
4453:336:    o = Cmalloc (sizeof (Object));
4454:337:    o->circle = circle_from_points (v, n);
4455:338:    if (o->type != CIRCLE) {
4456:339:        free (o);
4457:340:        o = 0;
4458:341:    }
4459:342:    free (v);
4460:343:    free (m);
4461:344:    return o;
4462:345:}
4463:346:
4464:347:
4465:348:Object *fit_ellipse (Desktop * d)
4466:349:{
4467:350:    int n;
4468:351:    Vec *v;
4469:352:    Marker *m;
4470:353:    Object *o;
4471:354:    if (!check_markers (d, 2, LOTS, 3, LOTS, " Fit Circle "))
4472:355:        return 0;
4473:356:    m = get_all_markers (d);
4474:357:    v = triangulate_image_points (m, &n);
4475:358:    o = Cmalloc (sizeof (Object));
4476:359:    o->ellipse = ellipse_from_points (v, n);
4477:360:    if (o->type != ELLIPSE) {
4478:361:        free (o);
4479:362:        o = 0;
4480:363:    }
4481:364:    free (v);
4482:365:    free (m);
4483:366:    return o;
4484:367:}
4485:368:
4486:369:Object *fit_cylinder (Desktop * d)
4487:370:{
4488:371:    int n;
4489:372:    Vec *v;
4490:373:    Marker *m;
4491:374:    Object *o;
4492:375:    if (!check_markers (d, 2, LOTS, 3, LOTS, " Fit Circle "))
4493:376:        return 0;
4494:377:    m = get_all_markers (d);
4495:378:    v = triangulate_image_points (m, &n);
4496:379:    o = Cmalloc (sizeof (Object));
4497:380:    o->cylinder = cylinder_from_points (v, n);
4498:381:    if (o->type != CYLINDER) {
4499:382:        free (o);
4500:383:        o = 0;
4501:384:    }
4502:385:    free (v);
4503:386:    free (m);
4504:387:    return o;
4505:388:}
4506:389:
4507:390:
4508:391:void output_circle (Desktop * d)
4509:392:{
4510:393:    Object *o;
4511:394:    o = fit_circle (d);
4512:395:    if (o) {
4513:396:        output_object (o);
4514:397:        free (o);
4515:398:    }
4516:399:}
4517:400:
4518:401:
4519:402:void output_ellipse (Desktop * d)
4520:403:{
4521:404:    Object *o;
4522:405:    o = fit_ellipse (d);
4523:406:    if (o) {
4524:407:        output_object (o);
4525:408:        free (o);
4526:409:    }
4527:410:}
4528:411:
4529:412:/* this object may be free'd with just free */
4530:413:Object *triangulate_single_point (Desktop * d)
4531:414:{
4532:415:    Vec *v;
4533:416:    Object *o;
4534:417:    Marker *m;
4535:418:    int n;
4536:419:
4537:420:    o = Cmalloc (sizeof (Object));
4538:421:    if (!check_markers (d, 2, LOTS, 1, 1, " Get Point "))
4539:422:        return 0;
4540:423:    m = get_all_markers (d);
4541:424:    v = triangulate_image_points (m, &n);
4542:425:    free (m);
4543:426:    o->point.p = v[0];
4544:427:    free (v);
4545:428:    o->type = POINT;
4546:429:    return o;
4547:430:}
4548:431:
4549:432:void output_point (Desktop * d)
4550:433:{
4551:434:    Object *o;
4552:435:    o = triangulate_single_point (d);
4553:436:    if (o) {
4554:437:        output_object (o);
4555:438:        free (o);
4556:439:    }
4557:440:}
4558:441:
4559:442:void output_cylinder (Desktop * d)
4560:443:{
4561:444:    Object *o;
4562:445:    o = fit_cylinder (d);
4563:446:    if (o) {
4564:447:        output_object (o);
4565:448:        free (o);
4566:449:    }
4567:450:}
4568:451:
4569:452:
4570:453:Object *fit_line (Desktop * d)
4571:454:{
4572:455:    int n;
4573:456:    Vec *v;
4574:457:    Marker *m;
4575:458:    Object *o;
4576:459:    if (!check_markers (d, 2, LOTS, 2, LOTS, " Fit Circle "))
4577:460:        return 0;
4578:461:    m = get_all_markers (d);
4579:462:    v = triangulate_image_points (m, &n);
4580:463:    o = Cmalloc (sizeof (Object));
4581:464:    o->line = line_from_points (v, n);
4582:465:    if (o->type != LINE_SEGMENT) {
4583:466:        free (o);
4584:467:        o = 0;
4585:468:    }
4586:469:    free (v);
4587:470:    free (m);
4588:471:    return o;
4589:472:}
4590:473:
4591:474:
4592:475:void output_line (Desktop * d)
4593:476:{
4594:477:    Object *o;
4595:478:    o = fit_line (d);
4596:479:    if (o) {
4597:480:        output_object (o);
4598:481:        free (o);
4599:482:    }
4600:483:}
4601:484:
4602:485:
4603:486:
4604:487:static int dividepointsintotwolines (double *x, double *y,
4605:488:                                     int n, double **x1, double **y1,
4606:489:                                     int *n1, double **x2, double **y2,
4607:490:                                     int *n2)
4608:491:{
4609:492:    LineSegment l;
4610:493:    int i = 2;
4611:494:    Vec v = { 0, 0, 0 };
4612:495:
4613:496:    *x1 = NULL;
4614:497:    *y1 = NULL;
4615:498:    *x2 = NULL;
4616:499:    *y2 = NULL;
4617:500:    *n1 = 0;
4618:501:    *n2 = 0;
4619:502:
4620:503:    while (i < n) {
4621:504:        l = linesegmentfrompoints (x, y, NULL, i);
4622:505:        v.x = x[i];
4623:506:        v.y = y[i];
4624:507:        if (distancetoline (v, &l) > DIVIDE_THRESHOLD) {
4625:508:            *n1 = i;
4626:509:            *x1 = Cmalloc (i * sizeof (double));
4627:510:            memcpy (*x1, x, i * sizeof (double));
4628:511:            *y1 = Cmalloc (i * sizeof (double));
4629:512:            memcpy (*y1, y, i * sizeof (double));
4630:513:            *n2 = n - i;
4631:514:            *x2 = Cmalloc ((*n2) * sizeof (double));
4632:515:            memcpy (*x2, x + i, (*n2) * sizeof (double));
4633:516:            *y2 = Cmalloc ((*n2) * sizeof (double));
4634:517:            memcpy (*y2, y + i, (*n2) * sizeof (double));
4635:518:            return 1;
4636:519:        }
4637:520:        i++;
4638:521:    }
4639:522:    return 0;
4640:523:}
4641:524:
4642:525:
4643:526:/* 
4644:527:   gets markers from the first two marked images only 
4645:528:   and returns them as array x1,... length n1, n2. Also removes
4646:529:   camera distortion
4647:530: */
4648:531:void get_two_sets_of_markers (Marker * m, double **x1,
4649:532:                              double **y1, int *n1, double **x2,
4650:533:                              double **y2, int *n2)
4651:534:{
4652:535:    int i;
4653:536:    *n1 = m[0].n;
4654:537:    *n2 = m[1].n;
4655:538:    *x1 = Cmalloc (*n1 * sizeof (double));
4656:539:    *y1 = Cmalloc (*n1 * sizeof (double));
4657:540:    *x2 = Cmalloc (*n2 * sizeof (double));
4658:541:    *y2 = Cmalloc (*n2 * sizeof (double));
4659:542:
4660:543:    for (i = 0; i < *n1; i++) {
4661:544:        (*x1)[i] = m[0].v[i].x;
4662:545:        (*y1)[i] = m[0].v[i].y;
4663:546:        imagetocamera (m[0].cam, (*x1)[i], (*y1)[i]);
4664:547:    }
4665:548:
4666:549:    for (i = 0; i < *n2; i++) {
4667:550:        (*x2)[i] = m[1].v[i].x;
4668:551:        (*y2)[i] = m[1].v[i].y;
4669:552:        imagetocamera (m[1].cam, (*x2)[i], (*y2)[i]);
4670:553:    }
4671:554:}
4672:555:
4673:556:
4674:557:Object *fit_edge_line (Desktop * d)
4675:558:{
4676:559:    double *x1, *y1, *y2, *x2;
4677:560:    int n1, n2;
4678:561:    Marker *m;
4679:562:    Object *o;
4680:563:
4681:564:    if (!check_markers (d, 2, 2, 2, LOTS, " Fit Line "))
4682:565:        return 0;
4683:566:    o = Cmalloc (sizeof (Object));
4684:567:
4685:568:    m = get_all_markers (d);
4686:569:    get_two_sets_of_markers (m, &x1, &y1, &n1, &x2, &y2, &n2);
4687:570:    o->line =
4688:571:        linefromstereoedge (x1, y1, n1, x2, y2, n2, m[0].cam, m[1].cam);
4689:572:    free (x1);
4690:573:    free (y1);
4691:574:    free (x2);
4692:575:    free (y2);
4693:576:
4694:577:    if (o->type != LINE_SEGMENT) {
4695:578:        free (o);
4696:579:        o = 0;
4697:580:    }
4698:581:    free (m);
4699:582:    return o;
4700:583:}
4701:584:
4702:585:Object *fit_edge_circle (Desktop * d)
4703:586:{
4704:587:    double *x1, *y1, *y2, *x2;
4705:588:    int n1, n2;
4706:589:    Marker *m;
4707:590:    Object *o;
4708:591:
4709:592:    if (!check_markers (d, 2, 2, 3, LOTS, " Fit Circle "))
4710:593:        return 0;
4711:594:    o = Cmalloc (sizeof (Object));
4712:595:
4713:596:    m = get_all_markers (d);
4714:597:    get_two_sets_of_markers (m, &x1, &y1, &n1, &x2, &y2, &n2);
4715:598:    o->circle =
4716:599:        circlefromstereoedge (x1, y1, n1, x2, y2, n2, m[0].cam, m[1].cam);
4717:600:    free (x1);
4718:601:    free (y1);
4719:602:    free (x2);
4720:603:    free (y2);
4721:604:
4722:605:    if (o->type != CIRCLE) {
4723:606:        free (o);
4724:607:        o = 0;
4725:608:    }
4726:609:    free (m);
4727:610:    return o;
4728:611:}
4729:612:
4730:613:
4731:614:Object *fit_edge_cylinder (Desktop * d)
4732:615:{
4733:616:    double *xl, *yl, *yr, *xr;
4734:617:    int nl, nr;
4735:618:    Marker *m;
4736:619:    Object *o;
4737:620:    double *x1l, *y1l, *x2l, *y2l, *x1r, *y1r, *x2r, *y2r;
4738:621:    int n1l, n2l, n1r, n2r;
4739:622:
4740:623:    if (!check_markers (d, 2, 2, 2, LOTS, " Fit Circle "))
4741:624:        return 0;
4742:625:    o = Cmalloc (sizeof (Object));
4743:626:    clear (o, Object);
4744:627:
4745:628:    m = get_all_markers (d);
4746:629:    get_two_sets_of_markers (m, &xl, &yl, &nl, &xr, &yr, &nr);
4747:630:
4748:631:    if (dividepointsintotwolines
4749:632:        (xl, yl, nl, &x1l, &y1l, &n1l, &x2l, &y2l, &n2l)) {
4750:633:        if (dividepointsintotwolines
4751:634:            (xr, yr, nr, &x1r, &y1r, &n1r, &x2r, &y2r, &n2r)) {
4752:635:            o->cylinder =
4753:636:                cylinderfromstereoedge (x1l, y1l, n1l, x2l, y2l, n2l, x1r,
4754:637:                                        y1r, n1r, x2r, y2r, n2r, m[0].cam,
4755:638:                                        m[1].cam);
4756:639:            free (x1l);
4757:640:            free (y1l);
4758:641:            free (x2l);
4759:642:            free (y2l);
4760:643:        }
4761:644:        free (x1r);
4762:645:        free (y1r);
4763:646:        free (x2r);
4764:647:        free (y2r);
4765:648:    }
4766:649:    free (xl);
4767:650:    free (yl);
4768:651:    free (xr);
4769:652:    free (yr);
4770:653:
4771:654:    if (o->type != CYLINDER) {
4772:655:        free (o);
4773:656:        o = 0;
4774:657:    }
4775:658:    free (m);
4776:659:    return o;
4777:660:}
4778:661:
4779:662:void output_line_edge (Desktop * d)
4780:663:{
4781:664:    Object *o;
4782:665:    o = fit_edge_line (d);
4783:666:    if (o) {
4784:667:        output_object (o);
4785:668:        free (o);
4786:669:    }
4787:670:}
4788:671:
4789:672:void output_circle_edge (Desktop * d)
4790:673:{
4791:674:    Object *o;
4792:675:    o = fit_edge_circle (d);
4793:676:    if (o) {
4794:677:        output_object (o);
4795:678:        free (o);
4796:679:    }
4797:680:}
4798:681:
4799:682:void output_cylinder_edge (Desktop * d)
4800:683:{
4801:684:    Object *o;
4802:685:    o = fit_edge_cylinder (d);
4803:686:    if (o) {
4804:687:        output_object (o);
4805:688:        free (o);
4806:689:    }
4807:690:}
4808:1:/*
4809:2:   Copyright (C) 1996, 1997 Paul Sheer
4810:3:
4811:4:   This program is free software; you can redistribute it and/or modify
4812:5:   it under the terms of the GNU General Public License as published by
4813:6:   the Free Software Foundation; either version 2 of the License, or
4814:7:   (at your option) any later version.
4815:8:
4816:9:   This program is distributed in the hope that it will be useful,
4817:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
4818:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
4819:12:   GNU General Public License for more details.
4820:13:
4821:14:   You should have received a copy of the GNU General Public License
4822:15:   along with this program; if not, write to the Free Software
4823:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
4824:17: */
4825:18:#ifndef _IMAGE_FIT
4826:19:#define _IMAGE_FIT
4827:20:
4828:21:#define EDITOR Cwidget("editor")->editor
4829:22:#define DIVIDE_THRESHOLD 10
4830:23:#define LINE_THICKNES_3D (scale_units_for_3d / 1000)
4831:24:
4832:25:Vec vec_invert (Vec * s, double *r, int n);
4833:26:
4834:27:void output_surface (Desktop * d);
4835:28:void output_circle (Desktop * d);
4836:29:void output_line (Desktop * d);
4837:30:void output_line_edge (Desktop * d);
4838:31:void output_circle_edge (Desktop * d);
4839:32:void output_cylinder_edge (Desktop * d);
4840:33:void output_cylinder (Desktop * d);
4841:34:
4842:35:int cb_getcircle (CWidget * none, XEvent * xevent, CEvent * cwevent);
4843:36:int cb_getlinefrom3D (CWidget * none, XEvent * xevent, CEvent * cwevent);
4844:37:int cb_getpoint (CWidget * none, XEvent * xevent, CEvent * cwevent);
4845:38:int cb_getline (CWidget * none, XEvent * xevent, CEvent * cwevent);
4846:39:int cb_getcylinder (CWidget * none, XEvent * xevent, CEvent * cwevent);
4847:40:
4848:41:#endif                          /* _IMAGE_FIT */
4849:1:/*****************************************************************************************/
4850:2:/* imagehandler.c - handles events from the view windows                                 */
4851:3:/*****************************************************************************************/
4852:4:/*
4853:5:   Copyright (C) 1996, 1997 Paul Sheer
4854:6:
4855:7:   This program is free software; you can redistribute it and/or modify
4856:8:   it under the terms of the GNU General Public License as published by
4857:9:   the Free Software Foundation; either version 2 of the License, or
4858:10:   (at your option) any later version.
4859:11:
4860:12:   This program is distributed in the hope that it will be useful,
4861:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
4862:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
4863:15:   GNU General Public License for more details.
4864:16:
4865:17:   You should have received a copy of the GNU General Public License
4866:18:   along with this program; if not, write to the Free Software
4867:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
4868:20: */
4869:21:
4870:22:#include "display.h"
4871:23:#include "marker.h"
4872:24:#include "app_glob.c"
4873:25:#include "hugeimage.h"
4874:26:#include "widget3d.h"
4875:27:#include "main/marker.h"
4876:28:#include "main/displaycam.h"
4877:29:#include "picsetup.h"
4878:30:#include "dialog.h"
4879:31:#include "stringtools.h"
4880:32:#include "callback.h"
4881:33:
4882:34:
4883:35:/* check zoom box motion */
4884:36:static int check_motion (Picture * image, CEvent * cwevent)
4885:37:{
4886:38:    if (!CPending (CDisplay)) {
4887:39:        Csetdrawingtarget (image->zoom_rect->ident);
4888:40:        Cremovepp (0);
4889:41:        Cdrawpicrectangle ((cwevent->x - 1) -
4890:42:                           (cwevent->x - 1) % image->mag - 1,
4891:43:                           (cwevent->y - 1) - (cwevent->y -
4892:44:                                               1) % image->mag - 1,
4893:45:                           image->mag + 1, image->mag + 1, Ccolor (19));
4894:46:        return 1;
4895:47:    } else
4896:48:        return 0;
4897:49:}
4898:50:
4899:51:
4900:52:static int check_button_release (Picture * image, CEvent * cwevent)
4901:53:{
4902:54:    double x, y;
4903:55:    int xzoom, yzoom;
4904:56:    long p, q;
4905:57:    float oldmag = image->mag;
4906:58:    xzoom = cwevent->x / image->mag;
4907:59:    yzoom = cwevent->y / image->mag;
4908:60:
4909:61:    x = (double) (image->xzoom + xzoom) * image->width / image->real_width;
4910:62:    y = (double) (image->yzoom + yzoom) * image->width / image->real_width;
4911:63:
4912:64:    image->mag <<= 1;           /*cycle zooming with right mouse button */
4913:65:    if (image->mag > 16)
4914:66:        image->mag = 1;
4915:67:
4916:68:    q = ZOOMSIZE / (2 * image->mag);
4917:69:    p = q * image->width / image->real_width;
4918:70:
4919:71:    image->xzoom = (double) x *image->real_width / image->width - q;
4920:72:    image->yzoom = (double) y *image->real_width / image->width - q;
4921:73:
4922:74:    Csetdrawingtarget (image->main_rect->ident);
4923:75:    Cremovepp (0);
4924:76:    Cdrawpicrectangle (x - p - 2, y - p - 2, p * 2 + 1, p * 2 + 1,
4925:77:                       Ccolor (19));
4926:78:
4927:79:    Csetdrawingtarget (image->zoom_rect->ident);
4928:80:    Cremovepp (0);
4929:81:
4930:82:    Csetdrawingtarget (image->zoom_markers->ident);
4931:83:    Cscalepicture ((float) image->mag / oldmag);
4932:84:    Csetwidgetposition (image->zoom_markers->ident,
4933:85:                        -image->xzoom * image->mag + 2,
4934:86:                        -image->yzoom * image->mag + 2);
4935:87:    Cupdatezoombox (image->zoom_image->ident, image->xzoom, image->yzoom,
4936:88:                    image->mag);
4937:89:    return 1;
4938:90:}
4939:91:
4940:92:static int check_button_drag (Picture * image, CEvent * cwevent)
4941:93:{
4942:94:    int xzoom, yzoom;
4943:95:    long p, q;
4944:96:    xzoom = cwevent->x;
4945:97:    yzoom = cwevent->y;
4946:98:    q = ZOOMSIZE / (2 * image->mag);
4947:99:    p = q * image->width / image->real_width;
4948:100:
4949:101:    image->xzoom = xzoom * image->real_width / image->width - q;
4950:102:    image->yzoom = yzoom * image->real_width / image->width - q;
4951:103:
4952:104:    if (!CPending (CDisplay) || !(cwevent->type == MotionNotify)) {
4953:105:        Csetdrawingtarget (image->zoom_markers->ident);
4954:106:        Csetwidgetposition (image->zoom_markers->ident,
4955:107:                            -image->xzoom * image->mag + 2,
4956:108:                            -image->yzoom * image->mag + 2);
4957:109:
4958:110:        Csetdrawingtarget (image->main_rect->ident);
4959:111:        Cremovepp (0);
4960:112:        Cdrawpicrectangle (xzoom - p - 2, yzoom - p - 2, p * 2 + 1,
4961:113:                           p * 2 + 1, Ccolor (19));
4962:114:
4963:115:        Csetdrawingtarget (image->zoom_rect->ident);
4964:116:        Cremovepp (0);
4965:117:
4966:118:        Cupdatezoombox (image->zoom_image->ident, image->xzoom,
4967:119:                        image->yzoom, image->mag);
4968:120:    }
4969:121:    return 1;
4970:122:}
4971:123:
4972:124:
4973:125:int handle_zoom_box (Desktop * d, CEvent * cwevent)
4974:126:{
4975:127:    Picture *p;
4976:128:
4977:129:    set_current_from_pointer (d, cwevent);
4978:130:    p = &(d->view[d->current_view].pic);
4979:131:
4980:132:    if (cwevent->state & ControlMask) {
4981:133:        if ((cwevent->button == Button1
4982:134:             && (cwevent->type == ButtonRelease
4983:135:                 || cwevent->type == ButtonPress))
4984:136:            || (cwevent->state & Button1Mask
4985:137:                && cwevent->type == MotionNotify))
4986:138:            move_marker (p, cwevent);
4987:139:
4988:140:        if (cwevent->button == Button2 && cwevent->type == ButtonRelease)
4989:141:            remove_marker (p, cwevent);
4990:142:    } else {
4991:143:        if (cwevent->button == Button1 && cwevent->type == ButtonRelease)
4992:144:            insert_marker (p, cwevent);
4993:145:
4994:146:        if (cwevent->button == Button2 && cwevent->type == ButtonRelease)
4995:147:            check_button_release (p, cwevent);
4996:148:    }
4997:149:
4998:150:    if (cwevent->type == MotionNotify || cwevent->type == ButtonRelease)
4999:151:        return check_motion (p, cwevent);
5000:152:
5001:153:    return 0;
5002:154:}
5003:155:
5004:156:
5005:157:int handle_main_box (Desktop * d, CEvent * cwevent)
5006:158:{
5007:159:    Picture *p;
5008:160:
5009:161:    set_current_from_pointer (d, cwevent);
5010:162:    p = &(d->view[d->current_view].pic);
5011:163:
5012:164:    if (cwevent->button == Button1 || (cwevent->state & Button1Mask))
5013:165:        return check_button_drag (p, cwevent);
5014:166:
5015:167:    return 0;
5016:168:}
5017:1:/*
5018:2:   Copyright (C) 1996, 1997 Paul Sheer
5019:3:
5020:4:   This program is free software; you can redistribute it and/or modify
5021:5:   it under the terms of the GNU General Public License as published by
5022:6:   the Free Software Foundation; either version 2 of the License, or
5023:7:   (at your option) any later version.
5024:8:
5025:9:   This program is distributed in the hope that it will be useful,
5026:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
5027:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
5028:12:   GNU General Public License for more details.
5029:13:
5030:14:   You should have received a copy of the GNU General Public License
5031:15:   along with this program; if not, write to the Free Software
5032:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
5033:17: */
5034:18:#ifndef _IMAGE_HANDLER_H
5035:19:#define _IMAGE_HANDLER_H
5036:20:
5037:21:int handle_zoom_box (Desktop * d, CEvent * cwevent);
5038:22:int handle_main_box (Desktop * d, CEvent * cwevent);
5039:23:
5040:24:#endif  /* _IMAGE_HANDLER_H */
5041:1:/*****************************************************************************************/
5042:2:/* join.c - for a number of grid surfaces, this zips up edges of one                     */
5043:3:/*          surface that are close to an adjacent surface                                */
5044:4:/*****************************************************************************************/
5045:5:/*
5046:6:   Copyright (C) 1996, 1997 Paul Sheer
5047:7:
5048:8:   This program is free software; you can redistribute it and/or modify
5049:9:   it under the terms of the GNU General Public License as published by
5050:10:   the Free Software Foundation; either version 2 of the License, or
5051:11:   (at your option) any later version.
5052:12:
5053:13:   This program is distributed in the hope that it will be useful,
5054:14:   but WITHOUT ANY WARRANTY; without even the implied warranty of
5055:15:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
5056:16:   GNU General Public License for more details.
5057:17:
5058:18:   You should have received a copy of the GNU General Public License
5059:19:   along with this program; if not, write to the Free Software
5060:20:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
5061:21: */
5062:22:
5063:23:#include <config.h>
5064:24:#include "global.h"
5065:25:#include "stdio.h"
5066:26:#include "display.h"
5067:27:#include "main/imagefit.h"
5068:28:#include "app_glob.c"
5069:29:#include "hugeimage.h"
5070:30:#include "widget3d.h"
5071:31:#include "main/marker.h"
5072:32:#include "main/displaycam.h"
5073:33:#include "picsetup.h"
5074:34:#include "dialog.h"
5075:35:#include "stringtools.h"
5076:36:#include "callback.h"
5077:37:#include "matrix.h"
5078:38:#include "output.h"
5079:39:#include "imagefit.h"
5080:40:
5081:41:#define NORMAL_LENGTH 256
5082:42:
5083:43:
5084:44:static inline double normal (Vec x)
5085:45:{
5086:46:    double l;
5087:47:    l = norm (x);
5088:48:    return l == 0 ? 1e-10 : l;
5089:49:}
5090:50:
5091:51:#define norm(x) normal(x)
5092:52:
5093:53:
5094:54:/*
5095:55:   This is an isolated file to do two things to an 3D object.
5096:56:
5097:57:   The first is to join together edges of a surface that are close.
5098:58:   So if two surfaces are adjacent, but not quite touching, this will
5099:59:   move the edges so that they touch exactly.
5100:60:
5101:61:   The other thing it does is to set all the normal vectors perfectly.
5102:62:   Adjacent surfaces, if their edges have normal that different by less
5103:63:   than AngleTheshold, then the normals are made the same at the edges.
5104:64:   This avoid bad shadowing on edges.
5105:65: */
5106:66:
5107:67:
5108:68:struct close_line {
5109:69:    TD_Surface *s;
5110:70:    int i, j, dir;
5111:71:    double d;
5112:72:};
5113:73:
5114:74:
5115:75:/* returns 1 if on the line, zero otherwise, [requires p1, u, and l] */
5116:76:int ispointonline (Vec x, LineSegment * l);
5117:77:
5118:78:/* [requires l->p1, l->u] */
5119:79:double distancetoline (Vec x, LineSegment * l);
5120:80:
5121:81:
5122:82:/*
5123:83:
5124:84:   width ---->
5125:85:
5126:86:                   |
5127:87:   length         |
5128:88:                   V
5129:89:
5130:90: */
5131:91:
5132:92:#define DIR_RIGHT 0
5133:93:#define DIR_LEFT 1
5134:94:#define DIR_DOWN 2
5135:95:#define DIR_UP 3
5136:96:
5137:97:Vec surfpoint (TD_Surface * s, int i, int j)
5138:98:{
5139:99:    Vec x;
5140:100:    TD_Point *p;
5141:101:
5142:102:    if (i < 0 || i >= s->w || j < 0 || j >= s->l) {
5143:103:        printf ("surfpoint aborting\n");
5144:104:        abort ();
5145:105:    }
5146:106:    p = s->point + i + j * s->w;
5147:107:    x.x = p->x;
5148:108:    x.y = p->y;
5149:109:    x.z = p->z;
5150:110:    return x;
5151:111:}
5152:112:
5153:113:void insertsurfpoint (Vec x, TD_Surface * s, int i, int j)
5154:114:{
5155:115:    TD_Point *p;
5156:116:
5157:117:    if (i < 0 || i >= s->w || j < 0 || j >= s->l) {
5158:118:        printf ("insertsurfpoint aborting\n");
5159:119:        abort ();
5160:120:    }
5161:121:    p = s->point + i + j * s->w;
5162:122:    p->x = x.x;
5163:123:    p->y = x.y;
5164:124:    p->z = x.z;
5165:125:}
5166:126:
5167:127:
5168:128:
5169:129:LineSegment getlinefromsurface (TD_Surface * s, int i, int j, int dir)
5170:130:{
5171:131:    LineSegment l;
5172:132:    TD_Point *p;
5173:133:
5174:134:    if (i < 0 || i >= s->w || j < 0 || j >= s->l) {
5175:135:        printf ("getlinefromsurface aborting\n");
5176:136:        abort ();
5177:137:    }
5178:138:    p = s->point + i + j * s->w;
5179:139:    l.p1.x = p->x;
5180:140:    l.p1.y = p->y;
5181:141:    l.p1.z = p->z;
5182:142:    switch (dir) {
5183:143:    case DIR_RIGHT:
5184:144:        i++;
5185:145:        p += 1;
5186:146:        break;
5187:147:    case DIR_LEFT:
5188:148:        i--;
5189:149:        p -= 1;
5190:150:        break;
5191:151:    case DIR_DOWN:
5192:152:        j++;
5193:153:        p += s->w;
5194:154:        break;
5195:155:    case DIR_UP:
5196:156:        j--;
5197:157:        p -= s->w;
5198:158:    }
5199:159:
5200:160:    if (i < 0 || i >= s->w || j < 0 || j >= s->l) {
5201:161:        printf ("getlinefromsurface aborting\n");
5202:162:        abort ();
5203:163:    }
5204:164:    l.p2.x = p->x;
5205:165:    l.p2.y = p->y;
5206:166:    l.p2.z = p->z;
5207:167:    l.u = minus (l.p2, l.p1);
5208:168:    if (norm (l.u) == 0) {
5209:169:        l.u.x = 10e-10;
5210:170:        l.u.y = 10e-10;
5211:171:        l.u.z = 10e-10;
5212:172:    }
5213:173:    l.l = norm (l.u);
5214:174:    l.u = times (l.u, 1 / l.l);
5215:175:    return l;
5216:176:}
5217:177:
5218:178:
5219:179:#define IS_MIN \
5220:180:    l = getlinefromsurface (s, i, j, dir); \
5221:181:    if (ispointonline (x, &l)) { \
5222:182:        d = distancetoline (x, &l); \
5223:183:        if (d < dmin) { \
5224:184:            dmin = d; \
5225:185:            imin = i; \
5226:186:            jmin = j; \
5227:187:            dirmin = dir; \
5228:188:        } \
5229:189:    } \
5230:190:
5231:191:
5232:192:void checksurf (TD_Surface * s, Vec x, struct close_line *cl)
5233:193:{
5234:194:    LineSegment l;
5235:195:    double d, dmin;
5236:196:    int i, j, dir, dirmin = 0, imin = 0, jmin = 0;
5237:197:
5238:198:    dmin = 9e90;
5239:199:
5240:200:    j = 0;
5241:201:    i = 0;
5242:202:    dir = DIR_RIGHT;
5243:203:    for (; i < s->w - 1; i++) {
5244:204:        l = getlinefromsurface (s, i, j, dir);
5245:205:        if (ispointonline (x, &l)) {
5246:206:            d = distancetoline (x, &l);
5247:207:            if (d < dmin) {
5248:208:                dmin = d;
5249:209:                imin = i;
5250:210:                jmin = j;
5251:211:                dirmin = dir;
5252:212:            }
5253:213:        }
5254:214:    }
5255:215:
5256:216:    j = 0;
5257:217:    i = s->w - 1;
5258:218:    dir = DIR_DOWN;
5259:219:    for (; j < s->l - 1; j++) {
5260:220:        l = getlinefromsurface (s, i, j, dir);
5261:221:        if (ispointonline (x, &l)) {
5262:222:            d = distancetoline (x, &l);
5263:223:            if (d < dmin) {
5264:224:                dmin = d;
5265:225:                imin = i;
5266:226:                jmin = j;
5267:227:                dirmin = dir;
5268:228:            }
5269:229:        }
5270:230:    }
5271:231:
5272:232:    j = s->l - 1;
5273:233:    i = 0;
5274:234:    dir = DIR_RIGHT;
5275:235:    for (; i < s->w - 1; i++) {
5276:236:        l = getlinefromsurface (s, i, j, dir);
5277:237:        if (ispointonline (x, &l)) {
5278:238:            d = distancetoline (x, &l);
5279:239:            if (d < dmin) {
5280:240:                dmin = d;
5281:241:                imin = i;
5282:242:                jmin = j;
5283:243:                dirmin = dir;
5284:244:            }
5285:245:        }
5286:246:    }
5287:247:
5288:248:    j = 0;
5289:249:    i = 0;
5290:250:    dir = DIR_DOWN;
5291:251:    for (; j < s->l - 1; j++) {
5292:252:        l = getlinefromsurface (s, i, j, dir);
5293:253:        if (ispointonline (x, &l)) {
5294:254:            d = distancetoline (x, &l);
5295:255:            if (d < dmin) {
5296:256:                dmin = d;
5297:257:                imin = i;
5298:258:                jmin = j;
5299:259:                dirmin = dir;
5300:260:            }
5301:261:        }
5302:262:    }
5303:263:
5304:264:    if (dmin < cl->d) {
5305:265:        cl->d = dmin;
5306:266:        cl->dir = dirmin;
5307:267:        cl->i = imin;
5308:268:        cl->j = jmin;
5309:269:        cl->s = s;
5310:270:    }
5311:271:}
5312:272:
5313:273:
5314:274:/* 'omit' is the surface that we must NOT check that x belongs to */
5315:275:void checkobject (TD_Solid * o, Vec x, int omit, struct close_line *cl)
5316:276:{
5317:277:    int i;
5318:278:    TD_Surface *s;
5319:279:
5320:280:    for (i = 0; i < o->num_surfaces; i++) {
5321:281:        s = o->surf + i;
5322:282:        if (i == omit || !s)
5323:283:            continue;
5324:284:        checksurf (s, x, cl);
5325:285:    }
5326:286:}
5327:287:
5328:288:/*
5329:289:
5330:290:   #define CHECK_OBJECT \
5331:291:   cl.s = 0; \
5332:292:   cl.d = limit; \
5333:293:   s = o->surf + k; \
5334:294:   if (s) { \
5335:295:   checkobject (o, surfpoint (s, i, j), k, &cl); \
5336:296:   if (cl.s) \
5337:297:   (*cb) (&cl, s->point + i + j * s->w); \
5338:298:   }
5339:299:
5340:300:
5341:301: */
5342:302:/*
5343:303:   this finds the closest line to each point in object 'o' and calls cb for each point.
5344:304:   The distance to the line must however fall within limit, or else cb won't be called.
5345:305:   Only lines along edges of surfaces are considered. Each close line and point is
5346:306:   passed to cn.
5347:307: */
5348:308:void find_closest_line (TD_Solid * o, double limit,
5349:309:                        void (*cb) (struct close_line *, TD_Point *))
5350:310:{
5351:311:    int i, j, k;
5352:312:    TD_Surface *s;
5353:313:
5354:314:    struct close_line cl;
5355:315:
5356:316:    for (k = 0; k < o->num_surfaces; k++) {
5357:317:        s = o->surf + k;
5358:318:        if (!s)
5359:319:            continue;
5360:320:        j = 0;
5361:321:        i = 0;
5362:322:        for (; i < s->w - 1; i++) {
5363:323:            cl.s = 0;
5364:324:            cl.d = limit;
5365:325:            s = o->surf + k;
5366:326:            if (s) {
5367:327:                checkobject (o, surfpoint (s, i, j), k, &cl);
5368:328:                if (cl.s)
5369:329:                    (*cb) (&cl, s->point + i + j * s->w);
5370:330:            }
5371:331:        }
5372:332:        j = 1;
5373:333:        i = 0;
5374:334:        for (; j < s->l - 1; j++) {
5375:335:            cl.s = 0;
5376:336:            cl.d = limit;
5377:337:            s = o->surf + k;
5378:338:            if (s) {
5379:339:                checkobject (o, surfpoint (s, i, j), k, &cl);
5380:340:                if (cl.s)
5381:341:                    (*cb) (&cl, s->point + i + j * s->w);
5382:342:            }
5383:343:        }
5384:344:        j = 0;
5385:345:        i = s->w - 1;
5386:346:        for (; j < s->l; j++) {
5387:347:            cl.s = 0;
5388:348:            cl.d = limit;
5389:349:            s = o->surf + k;
5390:350:            if (s) {
5391:351:                checkobject (o, surfpoint (s, i, j), k, &cl);
5392:352:                if (cl.s)
5393:353:                    (*cb) (&cl, s->point + i + j * s->w);
5394:354:            }
5395:355:        }
5396:356:        j = s->l - 1;
5397:357:        i = 0;
5398:358:        for (; i < s->w; i++) {
5399:359:            cl.s = 0;
5400:360:            cl.d = limit;
5401:361:            s = o->surf + k;
5402:362:            if (s) {
5403:363:                checkobject (o, surfpoint (s, i, j), k, &cl);
5404:364:                if (cl.s)
5405:365:                    (*cb) (&cl, s->point + i + j * s->w);
5406:366:            }
5407:367:        }
5408:368:    }
5409:369:}
5410:370:
5411:371:
5412:372:/* this moves the point half way to the closest line */
5413:373:void cb_join (struct close_line *cl, TD_Point * p)
5414:374:{
5415:375:    LineSegment l;
5416:376:    Vec x, y;
5417:377:    x.x = p->x;
5418:378:    x.y = p->y;
5419:379:    x.z = p->z;
5420:380:    l = getlinefromsurface (cl->s, cl->i, cl->j, cl->dir);
5421:381:    y = pointonline (x, &l);
5422:382:    x = times (plus (x, y), 0.5);
5423:383:    p->x = x.x;
5424:384:    p->y = x.y;
5425:385:    p->z = x.z;
5426:386:}
5427:387:
5428:388:/*
5429:389:   this takes the point and its closest line from the edge of the nearest surface
5430:390:   and computes the mean normal. This smooths the rendering.
5431:391: */
5432:392:static double norm_threshold;
5433:393:void cb_norm (struct close_line *cl, TD_Point * p)
5434:394:{
5435:395:    int dir2;
5436:396:    int d = 0;
5437:397:    Vec x, y;
5438:398:    double a;
5439:399:    if (cl->dir == DIR_LEFT || cl->dir == DIR_RIGHT) {
5440:400:        if (cl->j)
5441:401:            dir2 = DIR_UP;
5442:402:        else
5443:403:            dir2 = DIR_DOWN;
5444:404:        x = getlinefromsurface (cl->s, cl->i, cl->j, cl->dir).u;
5445:405:        y = getlinefromsurface (cl->s, cl->i, cl->j, dir2).u;
5446:406:    } else {
5447:407:        d = 1;
5448:408:        if (cl->i)
5449:409:            dir2 = DIR_LEFT;
5450:410:        else
5451:411:            dir2 = DIR_RIGHT;
5452:412:        x = getlinefromsurface (cl->s, cl->i, cl->j, dir2).u;
5453:413:        y = getlinefromsurface (cl->s, cl->i, cl->j, cl->dir).u;
5454:414:    }
5455:415:
5456:416:    if (dir2 + cl->dir == 3)    /* quick way to check clockwise/anti-clockwise */
5457:417:        y = cross (y, x);
5458:418:    else
5459:419:        y = cross (x, y);
5460:420:    x.x = p->dirx;
5461:421:    x.y = p->diry;
5462:422:    x.z = p->dirz;
5463:423:    x = times (x, 1 / norm (x));
5464:424:    y = times (y, 1 / norm (y));
5465:425:    a = acos (norm (minus (x, y)) / 2);
5466:426:    if (a < norm_threshold) {
5467:427:        x = plus (x, y);        /* average them */
5468:428:        x = times (x, NORMAL_LENGTH / norm (x));
5469:429:        /* normalise to NORMAL_LENGTH */
5470:430:        p->dirx = x.x;          /* store the point */
5471:431:        p->diry = x.y;
5472:432:        p->dirz = x.z;
5473:433:    }
5474:434:}
5475:435:
5476:436:void cb_both (struct close_line *cl, TD_Point * p)
5477:437:{
5478:438:    cb_join (cl, p);
5479:439:    cb_norm (cl, p);
5480:440:}
5481:441:
5482:442:
5483:443:/*
5484:444:   t is the threshold. When surface edge points are less than t away from the closest
5485:445:   edge, they are deemed to be 'touching', and the surface edges are zipped together.
5486:446: */
5487:447:void join_up_surface_edges (TD_Solid * o, double t)
5488:448:{
5489:449:    find_closest_line (o, t, cb_join);
5490:450:}
5491:451:
5492:452:/*
5493:453:   t is the threshold. When surface edge points panels are more than an angle t
5494:454:   from the panel of the closest edge, they are deemed to be not 'touching',
5495:455:   and the surface normals are not averaged.
5496:456: */
5497:457:void join_up_normals (TD_Solid * o, double t, double a)
5498:458:{
5499:459:    norm_threshold = a;
5500:460:    find_closest_line (o, t, cb_norm);
5501:461:}
5502:462:
5503:463:void join_up_normals_and_surface_edges (TD_Solid * o, double t, double a)
5504:464:{
5505:465:    norm_threshold = a;
5506:466:    find_closest_line (o, t, cb_both);
5507:467:}
5508:468:
5509:469:static inline Vec unit (Vec v)
5510:470:{
5511:471:    return times (v, norm (v));
5512:472:}
5513:473:
5514:474:void calc_all_normals (TD_Solid * o)
5515:475:{
5516:476:    Vec n;
5517:477:    TD_Point *p;
5518:478:    int i, j, k;
5519:479:    TD_Surface *s;
5520:480:
5521:481:    for (k = 0; k < o->num_surfaces; k++) {
5522:482:        s = o->surf + k;
5523:483:        if (!s)
5524:484:            continue;
5525:485:        p = s->point;
5526:486:        for (j = 0; j < s->l; j++) {
5527:487:            for (i = 0; i < s->w; i++) {
5528:488:                if (i < s->w - 1 && j < s->l - 1)
5529:489:                    n = unit (cross
5530:490:                              (getlinefromsurface (s, i, j, DIR_RIGHT).u,
5531:491:                               getlinefromsurface (s, i, j, DIR_DOWN).u));
5532:492:                if (i < s->w - 1 && j > 0)
5533:493:                    n = plus (n,
5534:494:                              unit (cross
5535:495:                                    (getlinefromsurface (s, i, j, DIR_UP).
5536:496:                                     u, getlinefromsurface (s, i, j,
5537:497:                                                            DIR_RIGHT).
5538:498:                                     u)));
5539:499:                if (i > 0 && j > 0)
5540:500:                    n = plus (n,
5541:501:                              unit (cross
5542:502:                                    (getlinefromsurface
5543:503:                                     (s, i, j, DIR_LEFT).u,
5544:504:                                     getlinefromsurface (s, i, j,
5545:505:                                                         DIR_UP).u)));
5546:506:                if (i > 0 && j < s->l - 1)
5547:507:                    n = plus (n,
5548:508:                              unit (cross
5549:509:                                    (getlinefromsurface
5550:510:                                     (s, i, j, DIR_DOWN).u,
5551:511:                                     getlinefromsurface (s, i, j,
5552:512:                                                         DIR_LEFT).u)));
5553:513:                n = times (n, NORMAL_LENGTH / norm (n));
5554:514:                p->dirx = n.x;
5555:515:                p->diry = n.y;
5556:516:                (p++)->dirz = n.z;
5557:517:            }
5558:518:        }
5559:519:    }
5560:520:}
5561:1:/*
5562:2:   Copyright (C) 1996, 1997 Paul Sheer
5563:3:
5564:4:   This program is free software; you can redistribute it and/or modify
5565:5:   it under the terms of the GNU General Public License as published by
5566:6:   the Free Software Foundation; either version 2 of the License, or
5567:7:   (at your option) any later version.
5568:8:
5569:9:   This program is distributed in the hope that it will be useful,
5570:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
5571:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
5572:12:   GNU General Public License for more details.
5573:13:
5574:14:   You should have received a copy of the GNU General Public License
5575:15:   along with this program; if not, write to the Free Software
5576:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
5577:17: */
5578:18:#ifndef _JOIN_H
5579:19:#define _JOIN_H
5580:20:
5581:21:void join_up_surface_edges (TD_Solid * o, double t);
5582:22:void join_up_normals (TD_Solid * o, double t, double a);
5583:23:void join_up_normals_and_surface_edges (TD_Solid * o, double t, double a);
5584:24:void calc_all_normals (TD_Solid * o);
5585:25:
5586:26:#endif
5587:1:/*****************************************************************************************/
5588:2:/* loadcalfile.c - loads a calibration file into the desktop structure                   */
5589:3:/*****************************************************************************************/
5590:4:/*
5591:5:   Copyright (C) 1996, 1997 Paul Sheer
5592:6:
5593:7:   This program is free software; you can redistribute it and/or modify
5594:8:   it under the terms of the GNU General Public License as published by
5595:9:   the Free Software Foundation; either version 2 of the License, or
5596:10:   (at your option) any later version.
5597:11:
5598:12:   This program is distributed in the hope that it will be useful,
5599:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
5600:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
5601:15:   GNU General Public License for more details.
5602:16:
5603:17:   You should have received a copy of the GNU General Public License
5604:18:   along with this program; if not, write to the Free Software
5605:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
5606:20: */
5607:21:
5608:22:#include <config.h>
5609:23:#include "global.h"
5610:24:#include <stdlib.h>
5611:25:#include <stdio.h>
5612:26:#include <sys/types.h>
5613:27:
5614:28:#ifdef HAVE_UNISTD_H
5615:29:#include <unistd.h>
5616:30:#endif
5617:31:
5618:32:#include <my_string.h>
5619:33:#include <sys/stat.h>
5620:34:
5621:35:#ifdef HAVE_FCNTL_H
5622:36:#include <fcntl.h>
5623:37:#endif
5624:38:
5625:39:#include <stdlib.h>
5626:40:#include <stdarg.h>
5627:41:
5628:42:#ifdef HAVE_SYS_TIME_H
5629:43:#include <sys/time.h>
5630:44:#endif
5631:45:
5632:46:#include "regex.h"
5633:47:
5634:48:#include "display.h"
5635:49:#include "dialog.h"
5636:50:#include "my_string.h"
5637:51:#include "stringtools.h"
5638:52:
5639:53:#define MAX_CAL_POINTS 256
5640:54:
5641:55:int load_calibration_file (Desktop * d, const char *filename)
5642:56:{
5643:57:    FILE *f;
5644:58:    int n, i = 0;
5645:59:    Vec *v;
5646:60:
5647:61:    f = fopen (filename, "r");
5648:62:    if (!f) {
5649:63:        Cerrordialog (0, 0, 0, " Load Calibration File ",
5650:64:                      get_sys_error (" Error trying to load file. "));
5651:65:        return 1;
5652:66:    }
5653:67:    v = Cmalloc (MAX_CAL_POINTS * sizeof (Vec));
5654:68:
5655:69:    while (!feof (f)) {
5656:70:        n = fscanf (f, "%lf %lf %lf ", &v[i].x, &v[i].y, &v[i].z);
5657:71:        if (n == 3) {
5658:72:            i++;
5659:73:        } else {
5660:74:            Cerrordialog (0, 0, 0, " Load Calibration File ",
5661:75:                          " Format error in calibration file ");
5662:76:            i = 0;
5663:77:            break;
5664:78:        }
5665:79:    }
5666:80:    fclose (f);
5667:81:    if (i) {
5668:82:        d->num_cal_points = i;
5669:83:        destroy ((void *) &(d->cal_points));
5670:84:        d->cal_points = Cmalloc (i * sizeof (Vec));
5671:85:        memcpy (d->cal_points, v, i * sizeof (Vec));
5672:86:        destroy ((void *) &(d->cal_file));
5673:87:        d->cal_file = strdup (filename);
5674:88:    }
5675:89:/* else { cal points not changed */
5676:90:    destroy ((void *) &v);
5677:91:    /*   fclose (f);  TLD 2/6/08 */
5678:92:    return !i;
5679:93:}
5680:94:
5681:95:int load_calibration (Desktop * d)
5682:96:{
5683:97:    char *s;
5684:98:    s = Cgetfile (0, 0, 0, d->image_dir, d->cal_file ? d->cal_file : "",
5685:99:                  " Load Calibration File ");
5686:100:    if (s)
5687:101:        if (*s) {
5688:102:            load_calibration_file (d, s);
5689:103:            return 0;
5690:104:        }
5691:105:    return 1;
5692:106:}
5693:1:/*
5694:2:   Copyright (C) 1996, 1997 Paul Sheer
5695:3:
5696:4:   This program is free software; you can redistribute it and/or modify
5697:5:   it under the terms of the GNU General Public License as published by
5698:6:   the Free Software Foundation; either version 2 of the License, or
5699:7:   (at your option) any later version.
5700:8:
5701:9:   This program is distributed in the hope that it will be useful,
5702:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
5703:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
5704:12:   GNU General Public License for more details.
5705:13:
5706:14:   You should have received a copy of the GNU General Public License
5707:15:   along with this program; if not, write to the Free Software
5708:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
5709:17: */
5710:18:#ifndef _LOAD_CAL_FILE_H
5711:19:#define _LOAD_CAL_FILE_H
5712:20:
5713:21:int load_calibration (Desktop * d);
5714:22:int load_calibration_file (Desktop * d, const char *filename);
5715:23:
5716:24:#endif                          /*  _LOAD_CAL_FILE_H  */
5717:1:/*****************************************************************************************/
5718:2:/* marker.c - marker handling and finding real pointer positions in images               */
5719:3:/*****************************************************************************************/
5720:4:/*
5721:5:   Copyright (C) 1996, 1997 Paul Sheer
5722:6:
5723:7:   This program is free software; you can redistribute it and/or modify
5724:8:   it under the terms of the GNU General Public License as published by
5725:9:   the Free Software Foundation; either version 2 of the License, or
5726:10:   (at your option) any later version.
5727:11:
5728:12:   This program is distributed in the hope that it will be useful,
5729:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
5730:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
5731:15:   GNU General Public License for more details.
5732:16:
5733:17:   You should have received a copy of the GNU General Public License
5734:18:   along with this program; if not, write to the Free Software
5735:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
5736:20: */
5737:21:
5738:22:#include <config.h>
5739:23:#include "global.h"
5740:24:#include <stdlib.h>
5741:25:#include <stdio.h>
5742:26:#include <sys/types.h>
5743:27:
5744:28:#ifdef HAVE_UNISTD_H
5745:29:#include <unistd.h>
5746:30:#endif
5747:31:
5748:32:#include <my_string.h>
5749:33:#include <sys/stat.h>
5750:34:
5751:35:#ifdef HAVE_FCNTL_H
5752:36:#include <fcntl.h>
5753:37:#endif
5754:38:
5755:39:#include <stdlib.h>
5756:40:#include <stdarg.h>
5757:41:
5758:42:#ifdef HAVE_SYS_TIME_H
5759:43:#include <sys/time.h>
5760:44:#endif
5761:45:
5762:46:#include "regex.h"
5763:47:
5764:48:#include "display.h"
5765:49:#include "marker.h"
5766:50:#include "app_glob.c"
5767:51:#include "hugeimage.h"
5768:52:#include "widget3d.h"
5769:53:#include "main/marker.h"
5770:54:#include "main/displaycam.h"
5771:55:#include "picsetup.h"
5772:56:#include "dialog.h"
5773:57:#include "stringtools.h"
5774:58:#include "callback.h"
5775:59:
5776:60:#define LARGE 10e90
5777:61:
5778:62:/* \end{verbatim} \begin{verbatim} */
5779:63:
5780:64:static int dialog_error (const char *head, const char *mess)
5781:65:{
5782:66:    Cerrordialog (0, 0, 0, head, mess);
5783:67:    return 1;
5784:68:}
5785:69:
5786:70:int num_views_with_markers (Desktop * d)
5787:71:{
5788:72:    int i, v = 0;
5789:73:    for (i = 0; i < d->num_views; i++)
5790:74:        if (exists (d, i))
5791:75:            if (d->view[i].num_marks)
5792:76:                v++;
5793:77:    return v;
5794:78:}
5795:79:
5796:80:/* return 0 if not satisifed */
5797:81:static int markers_in_bounds (Desktop * d, int min_views, int max_views,
5798:82:                              int min_markers, int max_markers)
5799:83:{
5800:84:    int i, n, v;
5801:85:    for (i = 0; i < d->num_views; i++) {
5802:86:        if (exists (d, i)) {
5803:87:            n = d->view[i].num_marks;
5804:88:            if (n && (n < min_markers || n > max_markers))
5805:89:                return 0;
5806:90:        }
5807:91:    }
5808:92:    v = num_views_with_markers (d);
5809:93:    if (v < min_views || v > max_views)
5810:94:        return 0;
5811:95:    return 1;
5812:96:}
5813:97:
5814:98:/* returns the maximum number of markers in a view */
5815:99:int max_markers (Desktop * d)
5816:100:{
5817:101:    int i, max = 0;
5818:102:    for (i = 0; i < d->num_views; i++)
5819:103:        if (exists (d, i))
5820:104:            if (d->view[i].num_marks > max)
5821:105:                max = d->view[i].num_marks;
5822:106:    return max;
5823:107:}
5824:108:
5825:109:
5826:110:/* returned value must be freed with just free */
5827:111:Marker *get_all_markers (Desktop * d)
5828:112:{
5829:113:    int v, i, j;
5830:114:    Marker *m;
5831:115:
5832:116:    v = num_views_with_markers (d);
5833:117:    if (!v)
5834:118:        return 0;
5835:119:    m = Cmalloc ((v + 1) * sizeof (Marker)); /* allignment ? ***** */
5836:120:
5837:121:    i = 0;
5838:122:    for (j = 0; j < d->num_views; j++)
5839:123:        if (exists (d, j))
5840:124:            if (d->view[j].num_marks) {
5841:125:                m[i].cam = &d->view[j].cam;
5842:126:                m[i].v = d->view[j].mark;
5843:127:                m[i].n = d->view[j].num_marks;
5844:128:                i++;
5845:129:            }
5846:130:    m[i].v = 0;
5847:131:    m[i].n = 0;
5848:132:    return m;
5849:133:}
5850:134:
5851:135:
5852:136:
5853:137:/* returns 0 if any are not calibrated */
5854:138:int images_calibrated (Desktop * d)
5855:139:{
5856:140:    int i;
5857:141:    for (i = 0; i < d->num_views; i++)
5858:142:        if (exists (d, i))      /* exists */
5859:143:            if (d->view[i].num_marks) /* has markers */
5860:144:                if (!d->view[i].calibrated) /* is calibrated */
5861:145:                    return 0;
5862:146:    return 1;
5863:147:}
5864:148:
5865:149:/* reports an error message if there are not enough markers in enough views */
5866:150:/* returns 1 if all ok */
5867:151:int check_markers (Desktop * d, int min_views, int max_views,
5868:152:                   int min_markers, int max_markers, const char *head)
5869:153:{
5870:154:    if (!d->cal_points) {
5871:155:        dialog_error (head, " First load calibration points ");
5872:156:        return 0;
5873:157:    }
5874:158:    if (!images_calibrated (d)) {
5875:159:        dialog_error (head, " Not all images are calibrated ");
5876:160:        return 0;
5877:161:    }
5878:162:    if (!d->num_views) {
5879:163:        dialog_error (head, " No views open, no markers ");
5880:164:        return 0;
5881:165:    }
5882:166:    if (!markers_in_bounds
5883:167:        (d, min_views, max_views, min_markers, max_markers)) {
5884:168:        char *s;
5885:169:        s = sprintf_alloc (" Need %d-%d markers in each of %d-%d views ",
5886:170:                           min_markers, max_markers, min_views, max_views);
5887:171:        dialog_error (head, s);
5888:172:        free (s);
5889:173:        return 0;
5890:174:    }
5891:175:    return 1;
5892:176:}
5893:177:
5894:178:
5895:179:/* returns 1 on error */
5896:180:int set_current_view (Desktop * d, int i)
5897:181:{
5898:182:    if (i < 0 || i >= d->num_views)
5899:183:        return 1;
5900:184:    if (!exists (d, i))
5901:185:        return 1;
5902:186:    d->current_view = i;
5903:187:    return 0;
5904:188:}
5905:189:
5906:190:void clear_markers (Desktop * d)
5907:191:{
5908:192:    d->view[d->current_view].num_marks = 0;
5909:193:}
5910:194:
5911:195:int new_marker (Desktop * d, Vec x)
5912:196:{
5913:197:    int i;
5914:198:    i = d->view[d->current_view].num_marks++;
5915:199:    d->view[d->current_view].mark[i] = x;
5916:200:    return i;
5917:201:}
5918:202:
5919:203:int remove_last_marker (Desktop * d)
5920:204:{
5921:205:    if (d->view[d->current_view].num_marks)
5922:206:        return --d->view[d->current_view].num_marks;
5923:207:    return 0;
5924:208:}
5925:209:
5926:210:void remove_vec (Vec * vec, int i, int n)
5927:211:{
5928:212:    if (i < n && i >= 0 && n > 0)
5929:213:        memmove (vec + i, vec + i + 1, (n - 1 - i) * sizeof (Vec));
5930:214:}
5931:215:
5932:216:void remove_a_marker (Desktop * d, int i)
5933:217:{
5934:218:    remove_vec (d->view[d->current_view].mark, i,
5935:219:                d->view[d->current_view].num_marks--);
5936:220:}
5937:221:
5938:222:/* find the closest marker to x in the current view and returns its index */
5939:223:int find_closest_marker (Desktop * d, Vec x)
5940:224:{
5941:225:    int i;
5942:226:    double e = LARGE, f;
5943:227:    int min = 0;
5944:228:    if (!d->view[d->current_view].num_marks)
5945:229:        return -1;
5946:230:    for (i = 0; i < d->view[d->current_view].num_marks; i++) {
5947:231:        f = norm (minus (x, d->view[d->current_view].mark[i]));
5948:232:        if (f < e) {
5949:233:            min = i;
5950:234:            e = f;
5951:235:        }
5952:236:    }
5953:237:    return min;
5954:238:}
5955:239:
5956:240:void remove_closest_marker (Desktop * d, Vec x)
5957:241:{
5958:242:    int min;
5959:243:    min = find_closest_marker (d, x);
5960:244:    if (min >= 0)
5961:245:        remove_a_marker (d, min);
5962:246:}
5963:247:
5964:248:void move_closest_marker (Desktop * d, Vec x)
5965:249:{
5966:250:    int min;
5967:251:    min = find_closest_marker (d, x);
5968:252:    if (min >= 0)
5969:253:        d->view[d->current_view].mark[min] = x;
5970:254:}
5971:255:
5972:256:void undrawmarker (View * v)
5973:257:{
5974:258:    if (v->pic.main_markers) {
5975:259:        Csetdrawingtarget (v->pic.main_markers->ident);
5976:260:        Cclearpic ();
5977:261:        Csetdrawingtarget (v->pic.zoom_markers->ident);
5978:262:        Cclearpic ();
5979:263:    }
5980:264:}
5981:265:
5982:266:void draw_line_to_pic (Picture * p, double x1, double y1,
5983:267:                       double x2, double y2, unsigned long c)
5984:268:{
5985:269:    imagetopic (p, x1, y1);
5986:270:    imagetopic (p, x2, y2);
5987:271:
5988:272:    Csetdrawingtarget (p->main_markers->ident);
5989:273:    Cdrawline ((float) x1 * p->width / p->real_width,
5990:274:               (float) y1 * p->width / p->real_width,
5991:275:               (float) x2 * p->width / p->real_width,
5992:276:               (float) y2 * p->width / p->real_width, c);
5993:277:    Csetdrawingtarget (p->zoom_markers->ident);
5994:278:    Cdrawline (x1 * p->mag, y1 * p->mag, x2 * p->mag, y2 * p->mag, c);
5995:279:}
5996:280:
5997:281:/* draws two crosses, one in the zoom box, and on in the main image */
5998:282:static void draw_cross_to_pic (Picture * p, Vec x, int r, unsigned long c)
5999:283:{
6000:284:    draw_line_to_pic (p, x.x - r, x.y - r, x.x + r, x.y + r, c);
6001:285:    draw_line_to_pic (p, x.x + r, x.y - r, x.x - r, x.y + r, c);
6002:286:}
6003:287:
6004:288:/* draw the markers of one view */
6005:289:static void drawmarker (View * v)
6006:290:{
6007:291:    int i;
6008:292:    for (i = 0; i < v->num_marks; i++)
6009:293:        draw_cross_to_pic (&v->pic, v->mark[i], CROSS_SIZE, CROSS_COLOR);
6010:294:}
6011:295:
6012:296:/* redraw all the markers */
6013:297:void draw_markers (Desktop * d)
6014:298:{
6015:299:    int i;
6016:300:    for (i = 0; i < d->num_views; i++) {
6017:301:        if (exists (d, i)) {
6018:302:            undrawmarker (&d->view[i]);
6019:303:            drawmarker (&d->view[i]);
6020:304:        }
6021:305:    }
6022:306:}
6023:307:
6024:308:/* gets the view that the pointer is in. returns -1 if not found */
6025:309:int get_pointer_view (Desktop * d, CEvent * e)
6026:310:{
6027:311:    int i;
6028:312:    for (i = 0; i < d->num_views; i++) {
6029:313:        if (exists (d, i)) {
6030:314:            if (d->view[i].pic.main_image->winid == e->window)
6031:315:                return i;
6032:316:            if (d->view[i].pic.zoom_image->winid == e->window)
6033:317:                return i;
6034:318:            if (d->view[i].pic.main_win->winid ==
6035:319:                Cwidget (e->ident)->parentid)
6036:320:                return i;
6037:321:        }
6038:322:    }
6039:323:    return -1;
6040:324:}
6041:325:
6042:326:/* this sets the 'current_view' member to the view the pointer is in */
6043:327:/* this must be called before an marker operation on a view so that
6044:328:the operation will occur in the correct view */
6045:329:/* (otherwise you may get markers appearing in an image other than the
6046:330:on you clicked on, for example) */
6047:331:void set_current_from_pointer (Desktop * d, CEvent * e)
6048:332:{
6049:333:    int i;
6050:334:    i = get_pointer_view (d, e);
6051:335:    if (i >= 0)
6052:336:        set_current_view (d, i);
6053:337:}
6054:338:
6055:339:/* real position in zoom image */
6056:340:Vec get_zoom_pointer_pos (Picture * p, CEvent * ev)
6057:341:{
6058:342:    Vec x;
6059:343:    x.x = (double) p->xzoom + (double) (ev->x - 1) / p->mag;
6060:344:    x.y = (double) p->yzoom + (double) (ev->y - 1) / p->mag;;
6061:345:    x.z = 0;
6062:346:    return x;
6063:347:}
6064:348:
6065:349:/* real position in main image */
6066:350:Vec get_main_pointer_pos (Picture * p, CEvent * ev)
6067:351:{
6068:352:    Vec x;
6069:353:    x.x = (ev->x - 1) * p->real_width / p->width;
6070:354:    x.y = (ev->y - 1) * p->real_width / p->width;
6071:355:    x.z = 0;
6072:356:    return x;
6073:357:}
6074:358:
6075:359:Vec zoom_event_to_image_coord (Picture * p, CEvent * e)
6076:360:{
6077:361:    Vec v;
6078:362:    v.x = (double) p->xzoom + (double) (e->x - 1) / p->mag;
6079:363:    v.y = (double) p->yzoom + (double) (e->y - 1) / p->mag;
6080:364:    pictoimage (p, v.x, v.y);
6081:365:    v.z = 0;
6082:366:    return v;
6083:367:}
6084:1:/*
6085:2:   Copyright (C) 1996, 1997 Paul Sheer
6086:3:
6087:4:   This program is free software; you can redistribute it and/or modify
6088:5:   it under the terms of the GNU General Public License as published by
6089:6:   the Free Software Foundation; either version 2 of the License, or
6090:7:   (at your option) any later version.
6091:8:
6092:9:   This program is distributed in the hope that it will be useful,
6093:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
6094:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
6095:12:   GNU General Public License for more details.
6096:13:
6097:14:   You should have received a copy of the GNU General Public License
6098:15:   along with this program; if not, write to the Free Software
6099:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
6100:17: */
6101:18:#ifndef _MARKER_H
6102:19:#define _MARKER_H
6103:20:
6104:21:#include "quickmath.h"
6105:22:#include "display.h"
6106:23:
6107:24:#define CROSS_SIZE 10
6108:25:#define CROSS_COLOR Ccolor(6)
6109:26:
6110:27:/* checks if a view at that index has not been destroyed */
6111:28:#define exists(d,i) ((d)->view[(i)].filename)
6112:29:
6113:30:/* returns 0 if any are not calibrated */
6114:31:int images_calibrated (Desktop * d);
6115:32:
6116:33:/* reports an error message if there are not enough markers in enough views */
6117:34:int check_markers (Desktop * d, int min_views, int max_views,
6118:35:                   int min_markers, int max_markers, const char *head);
6119:36:
6120:37:/* returns 1 on error */
6121:38:int set_current_view (Desktop * d, int i);
6122:39:
6123:40:void clear_markers (Desktop * d);
6124:41:int new_marker (Desktop * d, Vec x);
6125:42:int remove_last_marker (Desktop * d);
6126:43:void remove_vec (Vec * vec, int i, int n);
6127:44:void remove_a_marker (Desktop * d, int i);
6128:45:void remove_closest_marker (Desktop * d, Vec x);
6129:46:void move_closest_marker (Desktop * d, Vec x);
6130:47:void undrawmarker (View * v);
6131:48:void draw_line_to_pic (Picture * p, double x1, double y1, double x2,
6132:49:                       double y2, unsigned long c);
6133:50:
6134:51:/* redraw all the markers */
6135:52:void draw_markers (Desktop * d);
6136:53:
6137:54:/* gets the view that the pointer is in. returns -1 if not found */
6138:55:int get_pointer_view (Desktop * d, CEvent * e);
6139:56:
6140:57:/* this sets the 'current' member to the view the pointer is in */
6141:58:void set_current_from_pointer (Desktop * d, CEvent * e);
6142:59:
6143:60:/* real position in zoom image */
6144:61:Vec get_zoom_pointer_pos (Picture * p, CEvent * ev);
6145:62:
6146:63:/* real position in main image */
6147:64:Vec get_main_pointer_pos (Picture * p, CEvent * ev);
6148:65:
6149:66:/* find the real pos of a mouse click on the zoom box */
6150:67:Vec zoom_event_to_image_coord (Picture * p, CEvent * e);
6151:68:
6152:69:/* void imagetopic (Picture *p, int x, int y); */
6153:70:#define imagetopic(p,x,y) { \
6154:71:    (x) += (p)->x0; \
6155:72:    (y) = -(y); \
6156:73:    (y) += (p)->y0; \
6157:74:}
6158:75:
6159:76:#define pictoimage(p,x,y) { \
6160:77:    (x) -= (p)->x0; \
6161:78:    (y) -= (p)->y0; \
6162:79:    (y) = -(y); \
6163:80:}
6164:81:
6165:82:int num_views_with_markers (Desktop * d);
6166:83:
6167:84:struct marker {
6168:85:    int n;                      /* number of markers */
6169:86:    Vec *v;                     /* markers */
6170:87:    Camera *cam;                /* Camera view of that 2D marker */
6171:88:};
6172:89:
6173:90:typedef struct marker Marker;
6174:91:
6175:92:Marker *get_all_markers (Desktop * d);
6176:93:
6177:94:#endif                          /* _MARKER_H */
6178:1:/*****************************************************************************************/
6179:2:/* matrix.c - a matrix manipulation library                                              */
6180:3:/*****************************************************************************************/
6181:4:/*
6182:5:   Copyright (C) 1996, 1997 Paul Sheer
6183:6:
6184:7:   This program is free software; you can redistribute it and/or modify
6185:8:   it under the terms of the GNU General Public License as published by
6186:9:   the Free Software Foundation; either version 2 of the License, or
6187:10:   (at your option) any later version.
6188:11:
6189:12:   This program is distributed in the hope that it will be useful,
6190:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
6191:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
6192:15:   GNU General Public License for more details.
6193:16:
6194:17:   You should have received a copy of the GNU General Public License
6195:18:   along with this program; if not, write to the Free Software
6196:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
6197:20: */
6198:21:
6199:22:#include <config.h>
6200:23:#include "global.h"
6201:24:#include <math.h>
6202:25:#include <stdlib.h>
6203:26:#include <stdio.h>
6204:27:#include <stdarg.h>
6205:28:#include "matrix.h"
6206:29:#include "string.h"
6207:30:#include "stringtools.h"
6208:31:
6209:32:#include "mad.h"
6210:33:
6211:34:
6212:35:/*
6213:36:   Rules:
6214:37:
6215:38:   (1) Always set matrix '->d' to NULL if you are going to 
6216:39:   allow some of the routines to auto initialise the matrix
6217:40:   and you intend passing the matrix to the routine
6218:41:   without it ever having been initialised
6219:42:
6220:43:   eg.  C = Maadd(NULL, A, B);  /+is OK +/
6221:44:       C = Maadd (C, A, B); /+ is fine provided C is either NULL or has been
6222:45:       previously 
6223:46:       Maallocmatrix'd or has C->d = NULL +/
6224:47:       Madd (NULL, A, B);      /+ NEVER, 'cos you won't be able to free the
6225:48:
6226:49:   allocated matrix if you don't store the
6227:50:   returned value. +/
6228:51:
6229:52:   (2)
6230:53: */
6231:54:
6232:55:static long total_elements = 0;
6233:56:
6234:57:long Magettotalelements ()
6235:58:{
6236:59:    return total_elements;
6237:60:}
6238:61:
6239:62:int Macheckmatrixbounds (int rows, int columns, int j, int i,
6240:63:                         const char *file, int line)
6241:64:{
6242:65:    if (j >= rows || i >= columns || j < 0 || i < 0) {
6243:66:        printf
6244:67:            ("Fatal error:\ntrying to access outside matrix bounds, %s:%d\n",
6245:68:             file, line);
6246:69:        abort ();
6247:70:    }
6248:71:    return 0;
6249:72:}
6250:73:
6251:74:void Maerror (const char *e)
6252:75:{
6253:76:    fprintf (stderr, e);
6254:77:    exit (1);
6255:78:}
6256:79:
6257:80:/*
6258:81:   This sets the size datatype and data of a matrix that has not
6259:82:   had data allocated to it. Low level function.
6260:83: */
6261:84:void Maset (Matrix * A, int rows, int columns, int datatype, void **d)
6262:85:{
6263:86:    A->rows = rows;
6264:87:    A->columns = columns;
6265:88:    A->datatype = 'd';
6266:89:    A->d = d;
6267:90:}
6268:91:
6269:92:void *Mamalloc (size_t size)
6270:93:{
6271:94:    void *p;
6272:95:    if ((p = malloc (size)) == NULL)
6273:96:        Maerror ("Cannot allocate memory for matrix operation.\n");
6274:97:    return p;
6275:98:}
6276:99:
6277:100:/*
6278:101:   Sets all the elements of a matrix to zero.
6279:102: */
6280:103:
6281:104:
6282:105:/*
6283:106:   void *Macalloc (size_t nmemb, size_t size)
6284:107:   {
6285:108:   void *p;
6286:109:   if ((p = calloc (nmemb, size)) == NULL)
6287:110:   Maerror ("Cannot allocate memory for matrix operation.\n");
6288:111:   return p;
6289:112:   }
6290:113: */
6291:114:
6292:115:/*rotates in following order:
6293:116:   phi about x, theta about y, tsi about z
6294:117:   for an aeroplane:
6295:118:   +x = toward nose along fuselage
6296:119:   +y = along right wing
6297:120:   +z = downward
6298:121:   rotation is roll then pitch and then yaw.
6299:122:
6300:123:   for a camera instead of a plane.
6301:124:   +x = East
6302:125:   +y = North
6303:126:   +z = Upward
6304:127:   rotation is roll about optical axis, elevation and then pan.
6305:128:
6306:129:   Hence with no rotation, x points into the image, y horizontal to the left
6307:130:   and z is vertical down (for camera view or forward view
6308:131:   from cockpit window). This an inconvinient definition, 
6309:132:   see below for 3dtocreen.
6310:133:
6311:134:   Usually a camera is not rotated, only panned and elevated up and down.
6312:135:   Hence the first rotation angle is close to zero.
6313:136: */
6314:137:
6315:138:
6316:139:
6317:140:Matrix *Magetrotationclassic (Matrix * m, double phi, double theta,
6318:141:                              double tsi)
6319:142:{
6320:143:    m = Mareinit (m, 3, 3, 'd');
6321:144:
6322:145:    Mard ((*m), 0, 0) = cos (theta) * cos (tsi);
6323:146:    Mard ((*m), 0, 1) = cos (theta) * sin (tsi);
6324:147:    Mard ((*m), 0, 2) = -sin (theta);
6325:148:
6326:149:    Mard ((*m), 1, 0) =
6327:150:        sin (phi) * sin (theta) * cos (tsi) - cos (phi) * sin (tsi);
6328:151:    Mard ((*m), 1, 1) =
6329:152:        sin (phi) * sin (theta) * sin (tsi) + cos (phi) * cos (tsi);
6330:153:    Mard ((*m), 1, 2) = sin (phi) * cos (theta);
6331:154:
6332:155:    Mard ((*m), 2, 0) =
6333:156:        cos (phi) * sin (theta) * cos (tsi) + sin (phi) * sin (tsi);
6334:157:    Mard ((*m), 2, 1) =
6335:158:        cos (phi) * sin (theta) * sin (tsi) - sin (phi) * cos (tsi);
6336:159:    Mard ((*m), 2, 2) = cos (phi) * cos (theta);
6337:160:
6338:161:    return m;
6339:162:}
6340:163:
6341:164:
6342:165:Matrix *Magetrotation (Matrix * m, double phi, double theta, double tsi)
6343:166:{
6344:167:    m = Mareinit (m, 3, 3, 'd');
6345:168:
6346:169:    Mard ((*m), 1, 1) = cos (theta) * cos (tsi);
6347:170:    Mard ((*m), 1, 0) = cos (theta) * sin (tsi);
6348:171:    Mard ((*m), 1, 2) = -sin (theta);
6349:172:
6350:173:    Mard ((*m), 0, 1) =
6351:174:        sin (phi) * sin (theta) * cos (tsi) - cos (phi) * sin (tsi);
6352:175:    Mard ((*m), 0, 0) =
6353:176:        sin (phi) * sin (theta) * sin (tsi) + cos (phi) * cos (tsi);
6354:177:    Mard ((*m), 0, 2) = sin (phi) * cos (theta);
6355:178:
6356:179:    Mard ((*m), 2, 1) =
6357:180:        cos (phi) * sin (theta) * cos (tsi) + sin (phi) * sin (tsi);
6358:181:    Mard ((*m), 2, 0) =
6359:182:        cos (phi) * sin (theta) * sin (tsi) - sin (phi) * cos (tsi);
6360:183:    Mard ((*m), 2, 2) = cos (phi) * cos (theta);
6361:184:
6362:185:    return m;
6363:186:}
6364:187:
6365:188:
6366:189:void getrotation (Vec * m0, Vec * m1, Vec * m2, double phi, double theta,
6367:190:                  double tsi)
6368:191:{
6369:192:    m1->y = cos (theta) * cos (tsi);
6370:193:    m1->x = cos (theta) * sin (tsi);
6371:194:    m1->z = -sin (theta);
6372:195:
6373:196:    m0->y = sin (phi) * sin (theta) * cos (tsi) - cos (phi) * sin (tsi);
6374:197:    m0->x = sin (phi) * sin (theta) * sin (tsi) + cos (phi) * cos (tsi);
6375:198:    m0->z = sin (phi) * cos (theta);
6376:199:
6377:200:    m2->y = cos (phi) * sin (theta) * cos (tsi) + sin (phi) * sin (tsi);
6378:201:    m2->x = cos (phi) * sin (theta) * sin (tsi) - sin (phi) * cos (tsi);
6379:202:    m2->z = cos (phi) * cos (theta);
6380:203:}
6381:204:
6382:205:
6383:206:/*calculates C =  AB
6384:207: */
6385:208:Matrix *Mamultiply (Matrix * C, Matrix * A, Matrix * B)
6386:209:{
6387:210:    int i, j, k;
6388:211:    int n = B->columns, m = A->rows, p;
6389:212:    double sum;
6390:213:
6391:214:    if ((p = A->columns) != B->rows) {
6392:215:        printf ("rows = %d, columns = %d and rows = %d, columns = %d.\n",
6393:216:                A->rows, A->columns, B->rows, B->columns);
6394:217:        Maerror ("trying to multiply matrices of incompatable size.\n");
6395:218:    }
6396:219:    C = Mareinit (C, m, n, 'd');
6397:220:
6398:221:    for (i = 0; i < n; i++)
6399:222:        for (j = 0; j < m; j++) {
6400:223:            sum = 0;
6401:224:            for (k = 0; k < p; k++)
6402:225:                sum += Mard ((*A), j, k) * Mard ((*B), k, i);
6403:226:            Mard ((*C), j, i) = sum;
6404:227:        }
6405:228:    return C;
6406:229:}
6407:230:
6408:231:/*calculates C = A+B
6409:232: */
6410:233:Matrix *Maadd (Matrix * C, Matrix * A, Matrix * B)
6411:234:{
6412:235:    int i, j;
6413:236:    int n = A->columns, m = A->rows;
6414:237:
6415:238:    if (n != B->columns || m != B->rows) {
6416:239:        printf ("rows = %d, columns = %d and rows = %d, columns = %d.\n",
6417:240:                A->rows, A->columns, B->rows, B->columns);
6418:241:        Maerror ("trying to add matrices of incompatable size.\n");
6419:242:    }
6420:243:    C = Mareinit (C, m, n, 'd');
6421:244:
6422:245:    for (i = 0; i < n; i++)
6423:246:        for (j = 0; j < m; j++)
6424:247:            Mard ((*C), j, i) = Mard ((*A), j, i) + Mard ((*B), j, i);
6425:248:
6426:249:    return C;
6427:250:}
6428:251:
6429:252:/*calculates C = A-B
6430:253: */
6431:254:Matrix *Masubtract (Matrix * C, Matrix * A, Matrix * B)
6432:255:{
6433:256:    int i, j;
6434:257:    int n = A->columns, m = A->rows;
6435:258:
6436:259:    if (n != B->columns || m != B->rows) {
6437:260:        printf ("rows = %d, columns = %d and rows = %d, columns = %d.\n",
6438:261:                A->rows, A->columns, B->rows, B->columns);
6439:262:        Maerror ("trying to subtract matrices of incompatable size.\n");
6440:263:    }
6441:264:    C = Mareinit (C, m, n, 'd');
6442:265:
6443:266:    for (i = 0; i < n; i++)
6444:267:        for (j = 0; j < m; j++)
6445:268:            Mard ((*C), j, i) = Mard ((*A), j, i) - Mard ((*B), j, i);
6446:269:    return C;
6447:270:}
6448:271:
6449:272:
6450:273:/*
6451:274:   For a camera view, with no rotation, this is routine effectively
6452:275:
6453:276:   phi and theta. With no rotation y is into the screen
6454:277:   x is to the right ans z upward.
6455:278:   Increasing theta rotates the view. Increasing phi tilts the view upward
6456:279:   (scrolls downward), and increasing tsi panns to the left (scrolls right).
6457:280:
6458:281:   This calculates the screen postion of a 3D position vector in space.
6459:282:   m is rotation matrix, v is 3D position vector, V is camera position vector,
6460:283:   f is focal length.
6461:284:
6462:285:   returns
6463:286:   x = -f(m_row1(v + V))/(m_row2(v + V))
6464:287:   y = -f(m_row3(v + V))/(m_row2(v + V))
6465:288:   return z = m_row2(v + V);
6466:289:
6467:290:   z(into the screen) and is y before rotation,
6468:291:   x(screen position) is x before rotation, and
6469:292:   y(screen position) is z before rotation.
6470:293:
6471:294:   "As if" the screen was the front windscreen of the aeroplane,
6472:295:   or the camera was pointing north.
6473:296:
6474:297:   Don't forget that y might have to be changed to -y for
6475:298:   a raster display with the origin at top-left.
6476:299: */
6477:300:
6478:301:double Ma3dtoscreen (Matrix * m, Matrix * v, Matrix * V, double f,
6479:302:                     double *x, double *y)
6480:303:{
6481:304:    Matrix *X = NULL;
6482:305:    Matrix *C = NULL;
6483:306:    Matrix *D = NULL;
6484:307:    double *q;
6485:308:
6486:309:    C = Masubtract (C, v, V);
6487:310:
6488:311:    if (C->rows == 1) {
6489:312:        D = Matranspose (NULL, C);
6490:313:        Mafreematrix (C);
6491:314:        C = D;
6492:315:    }
6493:316:    X = Mamultiply (X, m, C);
6494:317:
6495:318:    q = &(Mard ((*X), 0, 0));
6496:319:
6497:320:    if (q[1] <= 0)
6498:321:        q[1] = -1e-10;
6499:322:
6500:323:    *x = -f * q[0] / q[1];
6501:324:    *y = -f * q[2] / q[1];
6502:325:
6503:326:    Mafreematrix (C);
6504:327:    Mafreematrix (X);
6505:328:
6506:329:    return q[1];
6507:330:}
6508:331:
6509:332:Vec Mamatrixtovec (Matrix * V)
6510:333:{
6511:334:    double *p = &Mard (*V, 0, 0);
6512:335:    Vec v;
6513:336:    v.x = *p;
6514:337:    v.y = *(p + 1);
6515:338:    v.z = *(p + 2);
6516:339:    return v;
6517:340:}
6518:341:
6519:342:/* returns a column vector */
6520:343:Matrix *Mavectomatrix (Vec v)
6521:344:{
6522:345:    return Madoublestomatrix (1, 3, v.x, v.y, v.z);
6523:346:}
6524:347:
6525:348:/*
6526:349:   inline Vec times3x3(Matrix *m, Vec c)
6527:350:   {
6528:351:   Vec v;
6529:352:   v.x = Mard(*m, 0, 0) * c.x + Mard(*m, 0, 1) * c.y + Mard(*m, 0, 2) * c.z;
6530:353:   v.y = Mard(*m, 1, 0) * c.x + Mard(*m, 1, 1) * c.y + Mard(*m, 1, 2) * c.z;
6531:354:   v.z = Mard(*m, 2, 0) * c.x + Mard(*m, 2, 1) * c.y + Mard(*m, 2, 2) * c.z;
6532:355:   return v;
6533:356:   }
6534:357: */
6535:358:
6536:359:
6537:360:
6538:361:
6539:362:/*returns the sum of all the element of A squared */
6540:363:double Manormal (Matrix * A)
6541:364:{
6542:365:    int i, j;
6543:366:    double sum = 0;
6544:367:
6545:368:    for (i = 0; i < A->columns; i++)
6546:369:        for (j = 0; j < A->rows; j++)
6547:370:            sum += pow (Mard ((*A), j, i), 2);
6548:371:    return sum;
6549:372:}
6550:373:
6551:374:
6552:375:
6553:376:/*performs guass jordan elimination (with partial pivoting)
6554:377:   to diagonalise an augmented square matrix.
6555:378:   matrix must be of size n+1 columns by n rows.
6556:379:   The results are hence left in the last column of
6557:380:   C, and the rest of C is an identity matrix. */
6558:381:
6559:382:Matrix *Madiag (Matrix * C)
6560:383:{
6561:384:    int i, j, k, matrixsize, max;
6562:385:    double temp;
6563:386:
6564:387:    if (C->rows + 1 != C->columns)
6565:388:        Maerror ("Matrix not square augmented in call to Madiag.\n");
6566:389:
6567:390:    matrixsize = C->rows;
6568:391:
6569:392:/*Guass-Jordan elimination with partial pivotting: */
6570:393:
6571:394:    for (i = 0; i < matrixsize; i++) {
6572:395:        max = i;
6573:396:/*Pivot: */
6574:397:        for (j = i + 1; j < matrixsize; j++) {
6575:398:            if (fabs (Mard ((*C), j, i)) >= fabs (Mard ((*C), max, i)))
6576:399:                max = j;
6577:400:        }
6578:401:        for (k = i; k < matrixsize + 1; k++) {
6579:402:            temp = Mard ((*C), i, k);
6580:403:            Mard ((*C), i, k) = Mard ((*C), max, k);
6581:404:            Mard ((*C), max, k) = temp;
6582:405:        }
6583:406:/*Resolve into uppertriangular form: */
6584:407:        for (j = i + 1; j < matrixsize; j++)
6585:408:            for (k = matrixsize; k >= i; k--) {
6586:409:#ifdef CHECK_MATRIX_SINGULAR
6587:410:                if (Mard ((*C), i, i) == 0)
6588:411:                    return NULL;
6589:412:/*                  Maerror ("Matrix singular in call to Madiag\n"); */
6590:413:#endif
6591:414:                Mard ((*C), j, k) -=
6592:415:                    Mard ((*C), i, k) * Mard ((*C), j, i) / Mard ((*C), i,
6593:416:                                                                  i);
6594:417:            }
6595:418:    }
6596:419:
6597:420:/*Perform back substitution: */
6598:421:    for (i = matrixsize - 1; i > 0; i--)
6599:422:        for (j = i - 1; j >= 0; j--) {
6600:423:#ifdef CHECK_MATRIX_SINGULAR
6601:424:            if (Mard ((*C), i, i) == 0)
6602:425:                return NULL;
6603:426:/*              Maerror ("Matrix singular in call to Madiag\n"); */
6604:427:#endif
6605:428:            Mard ((*C), j, matrixsize) -= Mard ((*C), j, i) /
6606:429:                Mard ((*C), i, i) * Mard ((*C), i, matrixsize);
6607:430:            Mard ((*C), j, i) = 0;
6608:431:        }
6609:432:
6610:433:/*Normalise diagonal to 1: */
6611:434:    for (i = 0; i < matrixsize; i++) {
6612:435:#ifdef CHECK_MATRIX_SINGULAR
6613:436:        if (Mard ((*C), i, i) == 0)
6614:437:            return NULL;
6615:438:/*          Maerror ("Matrix singular in call to Madiag\n"); */
6616:439:#endif
6617:440:        Mard ((*C), i, matrixsize) /= Mard ((*C), i, i);
6618:441:        Mard ((*C), i, i) = 1;
6619:442:    }
6620:443:
6621:444:    return C;
6622:445:}
6623:446:
6624:447:/*
6625:448:   Re-initialises a matrix if differs in size or type from the given
6626:449:   values. If the given matrix is a NULL pointer than reinit 
6627:450:   allocates a matrix of the required size and returns a pointer
6628:451:   to it
6629:452: */
6630:453:Matrix *Mareinit (Matrix * A, int rows, int columns, int datatype)
6631:454:{
6632:455:    if (!A)
6633:456:        return Maallocmatrix (rows, columns, 'd');
6634:457:    if (A->rows != rows || A->columns != columns ||
6635:458:        A->datatype != datatype) {
6636:459:        Madestroymatrix (A);
6637:460:        Mainitmatrix (A, rows, columns, 'd');
6638:461:    }
6639:462:    return A;
6640:463:}
6641:464:
6642:465:
6643:466:/*calculates C = A^T */
6644:467:Matrix *Matranspose (Matrix * C, Matrix * A)
6645:468:{
6646:469:    int i, j;
6647:470:    int n = A->rows, m = A->columns;
6648:471:
6649:472:    C = Mareinit (C, m, n, 'd');
6650:473:
6651:474:    for (i = 0; i < n; i++)
6652:475:        for (j = 0; j < m; j++)
6653:476:            Mard ((*C), j, i) = Mard ((*A), i, j);
6654:477:
6655:478:    return C;
6656:479:}
6657:480:
6658:481:
6659:482:/* calculates C = [A:Y] */
6660:483:Matrix *Maaugment (Matrix * C, Matrix * A, Matrix * Y)
6661:484:{
6662:485:    int i, j;
6663:486:    int n, m, o;
6664:487:
6665:488:    C = Mareinit (C, m = A->rows, n = (o = A->columns) + Y->columns, 'd');
6666:489:
6667:490:    for (i = 0; i < o; i++)
6668:491:        for (j = 0; j < m; j++)
6669:492:            Mard ((*C), j, i) = Mard ((*A), j, i);
6670:493:    for (i = o; i < n; i++)
6671:494:        for (j = 0; j < m; j++)
6672:495:            Mard ((*C), j, i) = Mard ((*Y), j, i - o);
6673:496:
6674:497:    return C;
6675:498:}
6676:499:
6677:500:/*
6678:501:   Extracts a matrix C numrows by numcolumns from a larger matrix A
6679:502:   starting at the position row, column of A
6680:503: */
6681:504:Matrix *Masubmatrix (Matrix * C, Matrix * A, int row, int column,
6682:505:                     int numrows, int numcolumns)
6683:506:{
6684:507:    int i, j;
6685:508:    int n, m;
6686:509:
6687:510:    C = Mareinit (C, m = numrows, n = numcolumns, 'd');
6688:511:
6689:512:    for (i = 0; i < n; i++)
6690:513:        for (j = 0; j < m; j++)
6691:514:            Mard ((*C), j, i) = Mard ((*A), j + row, i + column);
6692:515:
6693:516:    return C;
6694:517:}
6695:518:
6696:519:
6697:520:
6698:521:/*
6699:522:   The following finds the least squares solution to X where
6700:523:
6701:524:   AX = Y
6702:525:
6703:526:   where A has more rows than columns. I.e. it solves
6704:527:   an overconstrained linear system by least squares.
6705:528:
6706:529:   if A is square Madiag is called. This consumes more memory than a direct call to
6707:530:   Madiag as an augmented matrix has to be created first.
6708:531:
6709:532:   This does not change A or Y.
6710:533:
6711:534:   returns NULL if A is singular
6712:535: */
6713:536:
6714:537:Matrix *Maminimize (Matrix * X, Matrix * A, Matrix * Y)
6715:538:{
6716:539:    int m = A->rows, n = A->columns;
6717:540:    Matrix *AT = NULL, *C = NULL, *ATY = NULL;
6718:541:
6719:542:    if (m < n)
6720:543:/*could do a minimum entropy thing here */
6721:544:        Maerror
6722:545:            ("Number of rows less than or equal to number of columns in call to Maminimise\n");
6723:546:
6724:547:    if (m == n) {
6725:548:/*      AT = Maallocmatrix(n, n + 1, 'd'); */
6726:549:        AT = Maaugment (NULL, A, Y);
6727:550:    } else {
6728:551:/*      AT = Maallocmatrix(n, m, 'd'); */
6729:552:/*      C = Maallocmatrix(n, n, 'd'); */
6730:553:/*      ATY = Maallocmatrix(n, 1, 'd'); */
6731:554:
6732:555:        C = Mamultiply (NULL, AT = Matranspose (NULL, A), A);
6733:556:        ATY = Mamultiply (NULL, AT, Y);
6734:557:
6735:558:/*now we'll use AT to hold the augmented matrix. */
6736:559:        Maaugment (AT, C, ATY);
6737:560:        Mafreematrix (ATY);
6738:561:        Mafreematrix (C);
6739:562:/*This is almost to simple. */
6740:563:    }
6741:564:
6742:565:/*AT now holds a square augmented matrix */
6743:566:    if (Madiag (AT) == NULL) {
6744:567:        return NULL;
6745:568:    }
6746:569:    X = Masubmatrix (X, AT, 0, n, n, 1);
6747:570:    Mafreematrix (AT);
6748:571:    return X;
6749:572:}
6750:573:
6751:574:
6752:575:void Maprint (Matrix * Y)
6753:576:{
6754:577:    int i, j;
6755:578:    for (j = 0; j < Y->rows; j++) {
6756:579:        for (i = 0; i < Y->columns; i++)
6757:580:            printf ("% 9.8g ", Mard ((*Y), j, i));
6758:581:        printf ("\n");
6759:582:    }
6760:583:    printf ("\n");
6761:584:}
6762:585:
6763:586:
6764:587:void Maprintmatrix (Matrix * Y)
6765:588:{
6766:589:    int i, j;
6767:590:    for (j = 0; j < Y->rows; j++) {
6768:591:        for (i = 0; i < Y->columns; i++)
6769:592:            printf ("% 9.8g ", Mard ((*Y), j, i));
6770:593:        printf ("\n");
6771:594:    }
6772:595:    printf ("\n");
6773:596:}
6774:597:
6775:598:
6776:599:/*find sqrt of the sum squared diference of A and B
6777:600:   using the smaller of A and B as the extents to which it
6778:601:   compares */
6779:602:double Madistance (Matrix * A, Matrix * B)
6780:603:{
6781:604:    int i, j, n, m;
6782:605:    double d = 0;
6783:606:
6784:607:    n = min (A->rows, B->rows);
6785:608:    m = min (A->columns, B->columns);
6786:609:
6787:610:    for (j = 0; j < n; j++)
6788:611:        for (i = 0; i < m; i++)
6789:612:            d += pow (Mard ((*A), j, i) - Mard ((*B), j, i), 2);
6790:613:
6791:614:    return sqrt (d);
6792:615:}
6793:616:
6794:617:Matrix *Macross (Matrix * a, Matrix * b)
6795:618:{
6796:619:    Matrix *r = Maallocmatrix (1, 3, 'd');
6797:620:    Mard (*r, 0, 0) = Mard (*r, 0, 1) * Mard (*r, 0, 2) -
6798:621:        Mard (*r, 0, 2) * Mard (*r, 0, 1);
6799:622:    Mard (*r, 0, 1) = Mard (*r, 0, 2) * Mard (*r, 0, 0) -
6800:623:        Mard (*r, 0, 0) * Mard (*r, 0, 2);
6801:624:    Mard (*r, 0, 2) = Mard (*r, 0, 0) * Mard (*r, 0, 1) -
6802:625:        Mard (*r, 0, 1) * Mard (*r, 0, 0);
6803:626:    return r;
6804:627:}
6805:628:
6806:629:/*returns the sum of the product of every corresponding element */
6807:630:double Madot (Matrix * A, Matrix * B)
6808:631:{
6809:632:    int i, j, n, m;
6810:633:    double d = 0;
6811:634:
6812:635:    n = min (A->rows, B->rows);
6813:636:    m = min (A->columns, B->columns);
6814:637:
6815:638:    for (j = 0; j < n; j++)
6816:639:        for (i = 0; i < m; i++)
6817:640:            d += Mard ((*A), j, i) * Mard ((*B), j, i);
6818:641:
6819:642:    return d;
6820:643:}
6821:644:
6822:645:
6823:646:Matrix *Mascale (Matrix * A, double s)
6824:647:{
6825:648:    Maallelements (*A, double, *=s);
6826:649:    return A;
6827:650:}
6828:651:
6829:652:/*
6830:653:   Matrix *Mascalemany (Matrix * A, double *s,...)
6831:654:   {
6832:655:   double S, *d;
6833:656:   va_list ap;
6834:657:
6835:658:   if (!s)
6836:659:   return 0;
6837:660:
6838:661:   S = *s;
6839:662:
6840:663:   va_start (ap, s);
6841:664:
6842:665:   while ((d = va_arg (ap, double *))!=NULL)
6843:666:   S *= *d;
6844:667:
6845:668:   Maallelements(*A, double, *=S);
6846:669:
6847:670:   va_end (ap);
6848:671:
6849:672:   return A;
6850:673:   }
6851:674: */
6852:675:
6853:676:Matrix *Maaddscalar (Matrix * A, double s)
6854:677:{
6855:678:    Maallelements (*A, double, +=s);
6856:679:    return A;
6857:680:}
6858:681:
6859:682:/* args terminated by zero */
6860:683:Matrix *Maaddmanyscalar (Matrix * A, double *s, ...)
6861:684:{
6862:685:    double S, *d;
6863:686:    va_list ap;
6864:687:
6865:688:    if (!s)
6866:689:        return 0;
6867:690:
6868:691:    S = *s;
6869:692:
6870:693:    va_start (ap, s);
6871:694:
6872:695:    while ((d = va_arg (ap, double *)) != NULL)
6873:696:         S += *d;
6874:697:
6875:698:    Maallelements (*A, double, +=S);
6876:699:
6877:700:/*    for (j = 0; j < A->rows; j++)
6878:701:   for (i = 0; i < A->columns; i++)
6879:702:   Mard ((*A), j, i) += S;
6880:703: */
6881:704:
6882:705:    va_end (ap);
6883:706:
6884:707:    return A;
6885:708:}
6886:709:
6887:710:
6888:711:/*inserts smaller matrix A into larger matrix C at the given position */
6889:712:Matrix *Mainsert (Matrix * C, Matrix * A, int row, int column)
6890:713:{
6891:714:    int i, j;
6892:715:    for (j = 0; j < A->rows; j++)
6893:716:        for (i = 0; i < A->columns; i++)
6894:717:            Mard ((*C), j + row, i + column) = Mard ((*A), j, i);
6895:718:    return C;
6896:719:}
6897:720:
6898:721:void Masetupdata (Matrix * A, int rows, int columns, int datatype,
6899:722:                  int type_size)
6900:723:{
6901:724:    int i;
6902:725:
6903:726:    Maset (A, rows, columns, datatype, Mamalloc (rows * sizeof (void *)));
6904:727:
6905:728:    *(A->d) = Mamalloc (rows * columns * type_size);
6906:729:    total_elements += rows * columns;
6907:730:    if (rows > 1)
6908:731:        for (i = 1; i < rows; i++)
6909:732:            *(A->d + i) = (byte *) * (A->d) + i * columns * type_size;
6910:733:}
6911:734:
6912:735:/*
6913:736:   sets up the row pointers A.d[i]. Must be called only
6914:737:   after A.d has been alloc'ated an array of pointers (obviously).
6915:738:   p must point to the first byte of the data.
6916:739: */
6917:740:
6918:741:void Mainitrows (Matrix * A, int rows, int columns, int sizeoftype,
6919:742:                 void *p)
6920:743:{
6921:744:    int i = 0;
6922:745:    total_elements += rows * columns;
6923:746:    for (; i < rows; i++)
6924:747:        *(A->d + i) = (byte *) p + i * columns * sizeoftype;
6925:748:}
6926:749:
6927:750:int Masizeof (int datatype)
6928:751:{
6929:752:    switch (datatype) {
6930:753:    case 'd':
6931:754:        return (sizeof (double));
6932:755:        break;
6933:756:    case 'f':
6934:757:        return (sizeof (float));
6935:758:        break;
6936:759:    case 'l':
6937:760:        return (sizeof (long));
6938:761:        break;
6939:762:    case 'c':
6940:763:        return (sizeof (char));
6941:764:        break;
6942:765:    case 's':
6943:766:        return (sizeof (short));
6944:767:        break;
6945:768:    case 'i':
6946:769:        return (sizeof (short));
6947:770:        break;
6948:771:    default:
6949:772:        Maerror ("This matrix type is invalid or not supported.");
6950:773:        return 0;
6951:774:    }
6952:775:}
6953:776:
6954:777:void Maclearmatrix (Matrix * A)
6955:778:{
6956:779:    memset (&(Mard ((*A), 0, 0)), 0,
6957:780:            Masizeof (A->datatype) * A->columns * A->rows);
6958:781:}
6959:782:
6960:783:
6961:784:/*
6962:785:   Initializes an existing matrix structure with the passed values,
6963:786:   allocates memory for its data, and initialises that memory to zero
6964:787:   Use for initialising a matrix declared as a constant.
6965:788: */
6966:789:Matrix *Mainitmatrix (Matrix * A, int rows, int columns, int datatype)
6967:790:{
6968:791:    int s = Masizeof (datatype);
6969:792:    Maset (A, rows, columns, datatype, Mamalloc (rows * sizeof (void *)));
6970:793:    Mainitrows (A, rows, columns, s, Mamalloc (rows * columns * s));
6971:794:    Maclearmatrix (A);
6972:795:    return A;
6973:796:}
6974:797:
6975:798:
6976:799:/*
6977:800:   Allocates memory for a matrix structure, intialises it with the
6978:801:   passed values, allocates memory for matrix data, sets matrix data to zero.
6979:802:   Use for initialising a matrix declared as a pointer.
6980:803: */
6981:804:Matrix *Maallocmatrix (int rows, int columns, int datatype)
6982:805:{
6983:806:    Matrix *A = Mamalloc (sizeof (Matrix));
6984:807:    return Mainitmatrix (A, rows, columns, datatype);
6985:808:}
6986:809:
6987:810:/*
6988:811:   Here you can make a matrix from a list of data
6989:812:   eg for a 2x3:
6990:813:   R = Maallocdata (&x, &y, &z, NULL, &a, &b, &c, NULL, NULL);
6991:814:
6992:815:   each row ends with a NULL and the final rows ends with two NULL's.
6993:816:
6994:817: */
6995:818:
6996:819:/* do not terminate by zero */
6997:820:/* used like this: 
6998:821:        Matrix *Madoublestomatrix (int rows, int columns, double first,...) */
6999:822:Matrix *Madoublestomatrix (int rows, double first, ...)
7000:823:{
7001:824:    va_list ap;
7002:825:
7003:826:    Matrix *R = Maallocmatrix (rows, (int) first, 'd');
7004:827:
7005:828:    va_start (ap, first);
7006:829:    Maallelements (*R, double, = va_arg (ap, double));
7007:830:    va_end (ap);
7008:831:
7009:832:    return R;
7010:833:}
7011:834:
7012:835:
7013:836:/*
7014:837:   This COPIES an existing TWO DIMENSIONAL array p[][] into
7015:838:   a matrix. p must be larger than or equal to 'rows' and 'columns'.
7016:839:   If the data is a large contigous block, then rather use Maallocuser
7017:840:   or Mainituser, to avoid duplicating the data. p may be free'd after
7018:841:   calling these functions. The returned matrix must be Mafreenatrix'd.
7019:842: */
7020:843:
7021:844:Matrix *Mainitarray (Matrix * A, int rows, int columns, int datatype,
7022:845:                     void **p)
7023:846:{
7024:847:    int j = 0;
7025:848:    int s = Masizeof (datatype);
7026:849:    Maset (A, rows, columns, datatype, Mamalloc (rows * sizeof (void *)));
7027:850:    Mainitrows (A, rows, columns, s, Mamalloc (rows * columns * s));
7028:851:
7029:852:    for (; j < rows; j++)
7030:853:        memcpy (A->d[j], p[j], columns * s);
7031:854:
7032:855:    return A;
7033:856:}
7034:857:
7035:858:Matrix *Maallocarray (int rows, int columns, int d, void **p)
7036:859:{
7037:860:    Matrix *R = Mamalloc (sizeof (Matrix));
7038:861:    Mainitarray (R, rows, columns, d, p);
7039:862:    return R;
7040:863:}
7041:864:
7042:865:/*
7043:866:   This initialises a matrix to the values of a ONE DIMENSIONAL
7044:867:   array q[]. q must have sufficient space allocated to it
7045:868:   or be of sufficient size.
7046:869:   The matrix may have width or height greater than one, but
7047:870:   then the data will scan the matrix from left to right and then
7048:871:   from top to bottom. q may be free'd after the matrix
7049:872:   has been Madestroyuser'd or Mafreeuser'd. If q is a
7050:873:   constant, the matrix must be destoyed only with Madestroyuser()
7051:874:   or Mafreeuser(). In this case be weary of commands that may like to
7052:875:   change the size of the matrix by re-malloc'ating it.
7053:876:   If q is allocated then the resulting matrix will be no different
7054:877:   (at least in this version) to a matrix created by any of the
7055:878:   other routines.
7056:879:
7057:880:   This is useful for turning a structure into a matrix.
7058:881:   eg.
7059:882:
7060:883:   typedef struct {
7061:884:   double x,
7062:885:   double y,
7063:886:   double z,
7064:887:   double a,
7065:888:   double b,
7066:889:   double c,
7067:890:   } Vector
7068:891:
7069:892:   .
7070:893:   .
7071:894:   .
7072:895:
7073:896:   Vector v;
7074:897:
7075:898:   Matrix *V = Maallocuser(2,3,'d',&(v.x));
7076:899:
7077:900:   Mard((*V),1,2) = THE_VALUE_OF_B;
7078:901:   .
7079:902:   .
7080:903:   .
7081:904:
7082:905:   Mafreeuser(V);
7083:906:
7084:907: */
7085:908:
7086:909:Matrix *Mainituser (Matrix * R, int rows, int columns, int d, void *q)
7087:910:{
7088:911:    Maset (R, rows, columns, d, Mamalloc (rows * sizeof (void *)));
7089:912:    Mainitrows (R, rows, columns, Masizeof (d), q);
7090:913:    return R;
7091:914:}
7092:915:
7093:916:Matrix *Maallocuser (int rows, int columns, int d, void *q)
7094:917:{
7095:918:    Matrix *R = Mamalloc (sizeof (Matrix));
7096:919:    Mainituser (R, rows, columns, 'd', q);
7097:920:    return R;
7098:921:}
7099:922:
7100:923:
7101:924:/*frees the data in A. Initialise the matrix structure and
7102:925:   frees the data, but does not free the matrix structure itself. */
7103:926:/*use for freeing a matrix declared as a constant */
7104:927:void Madestroymatrix (Matrix * A)
7105:928:{
7106:929:    if (A) {
7107:930:        if (*(A->d))
7108:931:            free (*(A->d));
7109:932:        if (A->d)
7110:933:            free (A->d);
7111:934:
7112:935:        total_elements -= A->rows * A->columns;
7113:936:        Maset (A, 0, 0, 0, NULL);
7114:937:    } else
7115:938:        printf
7116:939:            ("Warning: trying to destroy a matrix that is a NULL pointer.\n");
7117:940:}
7118:941:
7119:942:
7120:943:/* free's the entire matrix, structure and data */
7121:944:/* for freeing matrices that are declared as pointers */
7122:945:void Mafreematrix (Matrix * A)
7123:946:{
7124:947:    if (A) {
7125:948:        Madestroymatrix (A);
7126:949:        free (A);
7127:950:    }
7128:951:}
7129:952:
7130:953:void Mafreeuser (Matrix * A)
7131:954:{
7132:955:    *(A->d) = NULL;
7133:956:    Mafreematrix (A);
7134:957:}
7135:958:
7136:959:void Madestroyuser (Matrix * A)
7137:960:{
7138:961:    *(A->d) = NULL;
7139:962:    Madestroymatrix (A);
7140:963:}
7141:964:
7142:965:/*
7143:966:   example:
7144:967:
7145:968:
7146:969:   main()
7147:970:   {
7148:971:
7149:972:   Matrix *A;
7150:973:   Matrix B;
7151:974:
7152:975:   Mainitmatrix(B, 3, 4, 'd');
7153:976:   Maallocmatrix(A, 3, 4, 'd'); /+ type double +/
7154:977:
7155:978:   .
7156:979:   .
7157:980:   .
7158:981:
7159:982:
7160:983:   Madestroymatrix(B);
7161:984:   Mafreematrix(A);
7162:985:
7163:986:   }
7164:987:
7165:988: */
7166:989:
7167:990:
7168:991:
7169:992:
7170:993:/*
7171:994:   Converts a table of ascii doubles to a matrix.
7172:995:   The table can be delimited by almost any character that wouldn't
7173:996:   be in a number. Rows must be delimited by newlines. The last
7174:997:   line must not end with a newline, or an extra row of zeros will
7175:998:   be added.
7176:999:   The number of doubles on the first line dictate the number of
7177:1000:   columns. The remainder of the matrix will be padded with zeros
7178:1001:   where there are not enough doubles on a line. The number of
7179:1002:   lines dictates the number of rows. If there are a greater
7180:1003:   number of columns than suggested by the first line, then
7181:1004:   these will be ignored.
7182:1005:
7183:1006:   Returns matrix pointer which must be Mafree'd --- see Mafree().
7184:1007:   Returns NULL on error or empty file --- although it will attempt
7185:1008:   to convert almost anything.
7186:1009: */
7187:1010:
7188:1011:Matrix *Maasciitomatrix (const char *text)
7189:1012:{
7190:1013:    int rows = strcountlines (text, 0, strlen (text), 32000) + 1, columns =
7191:1014:        0;
7192:1015:    Matrix *X;
7193:1016:
7194:1017:    char *endptr = (char *) text, *nptr;
7195:1018:
7196:1019:    int i = 0, j = 0;
7197:1020:
7198:1021:    do {
7199:1022:        columns++;
7200:1023:        nptr = endptr + strcspn (endptr, "+-1234567890.\n");
7201:1024:        if (!(*nptr) || *nptr == '\n')
7202:1025:            break;
7203:1026:        strtod (nptr, &endptr);
7204:1027:    } while (nptr != endptr);
7205:1028:
7206:1029:    columns--;
7207:1030:
7208:1031:    if (!columns)
7209:1032:        return NULL;
7210:1033:
7211:1034:    nptr = (char *) text;
7212:1035:
7213:1036:    X = Maallocmatrix (rows, columns, 'd');
7214:1037:    Maclearmatrix (X);
7215:1038:
7216:1039:    while (*nptr && i < rows) {
7217:1040:        j = 0;
7218:1041:        endptr = nptr;
7219:1042:        do {
7220:1043:            j++;
7221:1044:            nptr = endptr + strcspn (endptr, "+-1234567890.\n");
7222:1045:            if (!(*nptr) || *nptr == '\n')
7223:1046:                break;
7224:1047:            Mard ((*X), i, j - 1) = strtod (nptr, &endptr);
7225:1048:        } while (nptr != endptr && j <= columns);
7226:1049:        nptr += strmovelines (nptr, 0, 1, 32000);
7227:1050:        i++;
7228:1051:    }
7229:1052:
7230:1053:    return X;
7231:1054:}
7232:1:/*
7233:2:   Copyright (C) 1996, 1997 Paul Sheer
7234:3:
7235:4:   This program is free software; you can redistribute it and/or modify
7236:5:   it under the terms of the GNU General Public License as published by
7237:6:   the Free Software Foundation; either version 2 of the License, or
7238:7:   (at your option) any later version.
7239:8:
7240:9:   This program is distributed in the hope that it will be useful,
7241:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
7242:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
7243:12:   GNU General Public License for more details.
7244:13:
7245:14:   You should have received a copy of the GNU General Public License
7246:15:   along with this program; if not, write to the Free Software
7247:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
7248:17: */
7249:18:#ifndef MATRIX_H
7250:19:#define MATRIX_H
7251:20:
7252:21:#include "../config.h"
7253:22:#include <stdlib.h>
7254:23:#include <math.h>
7255:24:#include <quickmath.h>
7256:25:
7257:26:/*
7258:27:   Uncomment this line to let any matrix reference check whether it is within
7259:28:   bounds of the matrix. This will easily show up code that references
7260:29:   outside the dimensions of the matrix. It gives the responce:
7261:30:   Fatal error: trying to access outside matrix bounds, <file>:<line>
7262:31:*/
7263:32:/* #define CHECK_MATRIX_BOUNDS */
7264:33:
7265:34:/*uncomment to let the matrix diagonalisation pick up zero divides*/
7266:35:#define CHECK_MATRIX_SINGULAR 1
7267:36:
7268:37:/*all matrix operations start with Ma */
7269:38:
7270:39:
7271:40:typedef struct {
7272:41:    int rows;                   /* size */
7273:42:    int columns;                /* of matrix */
7274:43:    int datatype;               /* is one of 'd', 'f', 'l', 'c', 's', or 'i' */
7275:44:    /* see below for definitions */
7276:45:    void **d;
7277:46:} Matrix;
7278:47:
7279:48:int Macheckmatrixbounds (int rows, int columns, int j, int i,
7280:49:                         const char *file, int line);
7281:50:
7282:51:
7283:52:#ifdef CHECK_MATRIX_BOUNDS
7284:53:
7285:54:/* Macheckmatrixbounds always returns zero or aborts if out of bounds */
7286:55:
7287:56:/* eg: 'Ma'trix 'r'eturn 'd'ouble */
7288:57:#define Mard(m,j,i) (*((double *) *((m).d + j) + i \
7289:58:        + Macheckmatrixbounds((m).rows, (m).columns, j, i, __FILE__, __LINE__)))
7290:59:#define Marf(m,j,i) (*((float *) *((m).d + j) + i \
7291:60:        + Macheckmatrixbounds((m).rows, (m).columns, j, i, __FILE__, __LINE__)))
7292:61:#define Marl(m,j,i) (*((long *) *((m).d + j) + i \
7293:62:        + Macheckmatrixbounds((m).rows, (m).columns, j, i, __FILE__, __LINE__)))
7294:63:#define Marc(m,j,i) (*((unsigned char *) *((m).d + j) + i \
7295:64:        + Macheckmatrixbounds((m).rows, (m).columns, j, i, __FILE__, __LINE__)))
7296:65:/* 's'hort unsigned */
7297:66:#define Mars(m,j,i) (*((unsigned short *) *((m).d + j) + i \
7298:67:        + Macheckmatrixbounds((m).rows, (m).columns, j, i, __FILE__, __LINE__)))
7299:68:/* short 'i'nteger: */
7300:69:#define Mari(m,j,i) (*((signed short *) *((m).d + j) + i \
7301:70:        + Macheckmatrixbounds((m).rows, (m).columns, j, i, __FILE__, __LINE__)))
7302:71:
7303:72:#else
7304:73:
7305:74:#define Mard(m,j,i) (*((double *) *((m).d + j) + i))
7306:75:#define Marf(m,j,i) (*((float *) *((m).d + j) + i))
7307:76:#define Marl(m,j,i) (*((long *) *((m).d + j) + i))
7308:77:#define Marc(m,j,i) (*((unsigned char *) *((m).d + j) + i))
7309:78:/* 's'hort */
7310:79:#define Mars(m,j,i) (*((unsigned short *) *((m).d + j) + i))
7311:80:/* 'i'nteger: */
7312:81:#define Mari(m,j,i) (*((signed short *) *((m).d + j) + i))
7313:82:
7314:83:#endif
7315:84:
7316:85:/*
7317:86:    do operation 'o' to all elements in a matrix.
7318:87:    This is as fast as its going to get;
7319:88:*/
7320:89:#define Maallelements(m, t, o) \
7321:90:                { \
7322:91:                    t *p_to_element = (t *) (*(m).d); \
7323:92:                    long num_elements = (long) (m).rows * (m).columns; \
7324:93:                    do { \
7325:94:                        *(p_to_element++) o; \
7326:95:                    } while (--num_elements); \
7327:96:                }
7328:97:
7329:98:
7330:99:Matrix *Magetrotation (Matrix * m, double phi, double theta, double tsi);
7331:100:
7332:101:Matrix *Mamultiply (Matrix * C, Matrix * A, Matrix * B);
7333:102:
7334:103:Matrix *Maadd (Matrix * C, Matrix * A, Matrix * B);
7335:104:
7336:105:Matrix *Masubtract (Matrix * C, Matrix * A, Matrix * B);
7337:106:
7338:107:double Ma3dtoscreen (Matrix * m, Matrix * v, Matrix * V, double f,
7339:108:                     double *x, double *y);
7340:109:
7341:110:double Manormal (Matrix * A);
7342:111:
7343:112:Matrix *Madiag (Matrix * C);
7344:113:
7345:114:Matrix *Matranspose (Matrix * C, Matrix * A);
7346:115:
7347:116:Matrix *Maaugment (Matrix * C, Matrix * A, Matrix * Y);
7348:117:
7349:118:Matrix *Masubmatrix (Matrix * C, Matrix * A, int row, int column,
7350:119:                     int numrows, int numcolumns);
7351:120:
7352:121:Matrix *Maminimize (Matrix * X, Matrix * A, Matrix * Y);
7353:122:
7354:123:void Maprintmatrix (Matrix * Y);
7355:124:
7356:125:void Maprint (Matrix * Y);
7357:126:
7358:127:double Madistance (Matrix * A, Matrix * B);
7359:128:
7360:129:Matrix *Macross (Matrix * a, Matrix * b);
7361:130:
7362:131:double Madot (Matrix * A, Matrix * B);
7363:132:
7364:133:Matrix *Mascale (Matrix * A, double s);
7365:134:
7366:135:Matrix *Maaddscalar (Matrix * A, double s);
7367:136:
7368:137:Matrix *Mainsert (Matrix * C, Matrix * A, int row, int column);
7369:138:
7370:139:Matrix *Mainitmatrix (Matrix * A, int rows, int columns, int datatype);
7371:140:
7372:141:Matrix *Maallocmatrix (int rows, int columns, int datatype);
7373:142:
7374:143:void Madestroymatrix (Matrix * A);
7375:144:
7376:145:void Mafreematrix (Matrix * A);
7377:146:
7378:147:Matrix *Maasciitomatrix (const char *text);
7379:148:
7380:149:void *Mamalloc (size_t size);
7381:150:
7382:151:
7383:152:Matrix *Madoublestomatrix (int rows, double first, ...);
7384:153:
7385:154:Matrix *Mainitarray (Matrix * R, int rows, int columns, int d, void **p);
7386:155:
7387:156:Matrix *Maallocarray (int rows, int columns, int d, void **p);
7388:157:
7389:158:Matrix *Mainituser (Matrix * R, int rows, int columns, int d, void *q);
7390:159:
7391:160:Matrix *Maallocuser (int rows, int columns, int d, void *q);
7392:161:
7393:162:void Mafreeuser (Matrix * A);
7394:163:
7395:164:void Madestroyuser (Matrix * A);
7396:165:
7397:166:void Maerror (const char *e);
7398:167:
7399:168:Matrix *Mareinit (Matrix * A, int rows, int columns, int data_type);
7400:169:
7401:170:long Magettotalelements ();
7402:171:
7403:172:Matrix *Maaddmanyscalar (Matrix * A, double *s, ...);
7404:173:
7405:174:void Maclearmatrix (Matrix * A);
7406:175:
7407:176:Vec Mamatrixtovec (Matrix * V);
7408:177:
7409:178:Matrix *Mavectomatrix (Vec v);
7410:179:
7411:180:void getrotation (Vec * m0, Vec * m1, Vec * m2, double phi, double theta,
7412:181:                  double tsi);
7413:182:
7414:183:#endif
7415:1:/*****************************************************************************************/
7416:2:/* output.c - this outputs an object (line, circle, etc) to the editor                   */
7417:3:/*****************************************************************************************/
7418:4:/*
7419:5:   Copyright (C) 1996, 1997 Paul Sheer
7420:6:
7421:7:   This program is free software; you can redistribute it and/or modify
7422:8:   it under the terms of the GNU General Public License as published by
7423:9:   the Free Software Foundation; either version 2 of the License, or
7424:10:   (at your option) any later version.
7425:11:
7426:12:   This program is distributed in the hope that it will be useful,
7427:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
7428:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
7429:15:   GNU General Public License for more details.
7430:16:
7431:17:   You should have received a copy of the GNU General Public License
7432:18:   along with this program; if not, write to the Free Software
7433:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
7434:20: */
7435:21:
7436:22:#include "display.h"
7437:23:#include "imagefit.h"
7438:24:#include "app_glob.c"
7439:25:#include "hugeimage.h"
7440:26:#include "widget3d.h"
7441:27:#include "marker.h"
7442:28:#include "displaycam.h"
7443:29:#include "picsetup.h"
7444:30:#include "dialog.h"
7445:31:#include "stringtools.h"
7446:32:#include "callback.h"
7447:33:#include "matrix.h"
7448:34:#include "edit.h"
7449:35:
7450:36:/* \end{verbatim} \begin{verbatim} */
7451:37:
7452:38:int edit_print_string (WEdit * e, const char *s);
7453:39:
7454:40:void oprint (const char *fmt, ...)
7455:41:{
7456:42:    char *s;
7457:43:    va_list ap;
7458:44:    va_start (ap, fmt);
7459:45:    s = vsprintf_alloc (fmt, ap);
7460:46:    edit_print_string (Cwidget ("editor")->editor, s);
7461:47:    free (s);
7462:48:    va_end (ap);
7463:49:}
7464:50:
7465:51:
7466:52:
7467:53:void print_surface (Surface * s)
7468:54:{
7469:55:    int i;
7470:56:    oprint ("\nsurface %d %d ", s->w, s->h);
7471:57:    for (i = 0; i < s->w * s->h; i++)
7472:58:        oprint ("%f %f %f\n", (float) s->p[i].x, (float) s->p[i].y,
7473:59:                (float) s->p[i].z);
7474:60:    oprint ("\n");
7475:61:}
7476:62:
7477:63:void print_circle (Circle * c)
7478:64:{
7479:65:    oprint ("\ncircle %f %f %f %f\n", c->p.x, c->p.y, c->p.z, c->r);
7480:66:}
7481:67:
7482:68:void print_cylinder (Cylinder * c)
7483:69:{
7484:70:    Vec join;
7485:71:    join = minus (c->l.p2, c->l.p1);
7486:72:    oprint ("\ncappedcylinder %f %f %f %f %f %f %f\n",
7487:73:            join.x, join.y, join.z, c->l.p1.x, c->l.p1.y, c->l.p1.z, c->r);
7488:74:}
7489:75:
7490:76:#define LINE_CYL_RADIUS 100
7491:77:
7492:78:void print_line (LineSegment * l)
7493:79:{
7494:80:    Vec join;
7495:81:    join = minus (l->p2, l->p1);
7496:82:    oprint ("\ncappedcylinder %f %f %f %f %f %f %f\n",
7497:83:            join.x, join.y, join.z, l->p1.x, l->p1.y, l->p1.z,
7498:84:            LINE_CYL_RADIUS);
7499:85:}
7500:86:
7501:87:void print_all_object_data (Object * o)
7502:88:{
7503:89:    switch (o->type) {
7504:90:    case NO_TYPE:
7505:91:        oprint ("# NO_TYPE\n");
7506:92:        break;
7507:93:    case VECTOR:
7508:94:        oprint ("# p = (%f, %f, %f), direction = (%f, %f, %f)\n",
7509:95:                (float) o->vector.p.x, (float) o->vector.p.y,
7510:96:                (float) o->vector.p.z, (float) o->vector.u.x,
7511:97:                (float) o->vector.u.y, (float) o->vector.u.z);
7512:98:        break;
7513:99:    case POINT:
7514:100:        oprint ("# p = (%f, %f, %f)\n",
7515:101:                (float) o->point.p.x, (float) o->point.p.y,
7516:102:                (float) o->point.p.z);
7517:103:        break;
7518:104:    case LINE_SEGMENT:
7519:105:        oprint ("# p1 = (%f, %f, %f), ",
7520:106:                (float) o->line.p1.x, (float) o->line.p1.y,
7521:107:                (float) o->line.p1.z);
7522:108:        oprint (" p2 = (%f, %f, %f) \n", (float) o->line.p2.x,
7523:109:                (float) o->line.p2.y, (float) o->line.p2.z);
7524:110:        oprint ("# l = %f ", (float) o->line.l);
7525:111:        oprint (" direction = (%f, %f, %f) \n",
7526:112:                (float) o->line.u.x, (float) o->line.u.y,
7527:113:                (float) o->line.u.z);
7528:114:        break;
7529:115:    case CYLINDER:
7530:116:        oprint ("# p1 = (%f, %f, %f), ",
7531:117:                (float) o->cylinder.l.p1.x, (float) o->cylinder.l.p1.y,
7532:118:                (float) o->cylinder.l.p1.z);
7533:119:        oprint (" p2 = (%f, %f, %f) \n", (float) o->cylinder.l.p2.x,
7534:120:                (float) o->cylinder.l.p2.y, (float) o->cylinder.l.p2.z);
7535:121:        oprint ("# l = %f ", (float) o->cylinder.l.l);
7536:122:        oprint (" direction = (%f, %f, %f) \n",
7537:123:                (float) o->cylinder.l.u.x, (float) o->cylinder.l.u.y,
7538:124:                (float) o->cylinder.l.u.z);
7539:125:        oprint ("# radius = %f \n", (float) o->cylinder.r);
7540:126:        break;
7541:127:    case CIRCLE:
7542:128:        oprint ("# p = (%f, %f, %f), ",
7543:129:                (float) o->circle.u.x, (float) o->circle.u.y,
7544:130:                (float) o->circle.u.z);
7545:131:        oprint ("direction = (%f, %f, %f) \n", (float) o->circle.p.x,
7546:132:                (float) o->circle.p.y, (float) o->circle.p.z);
7547:133:        oprint ("# radius = %f \n", (float) o->circle.r);
7548:134:        break;
7549:135:    case PLANE_SEGMENT:
7550:136:        break;
7551:137:    case ELLIPSE:
7552:138:        break;
7553:139:    }
7554:140:}
7555:141:
7556:142:void output_object (Object * o)
7557:143:{
7558:144:    print_all_object_data (o);
7559:145:    switch (o->type) {
7560:146:    case VECTOR:
7561:147:        break;
7562:148:    case POINT:
7563:149:        break;
7564:150:    case LINE_SEGMENT:
7565:151:        print_line (&(o->line));
7566:152:        break;
7567:153:    case CYLINDER:
7568:154:        print_cylinder (&(o->cylinder));
7569:155:        break;
7570:156:    case CIRCLE:
7571:157:        break;
7572:158:    case PLANE_SEGMENT:
7573:159:        break;
7574:160:    case SURFACE:
7575:161:        print_surface (&(o->surface));
7576:162:        break;
7577:163:    }
7578:164:}
7579:1:/*
7580:2:   Copyright (C) 1996, 1997 Paul Sheer
7581:3:
7582:4:   This program is free software; you can redistribute it and/or modify
7583:5:   it under the terms of the GNU General Public License as published by
7584:6:   the Free Software Foundation; either version 2 of the License, or
7585:7:   (at your option) any later version.
7586:8:
7587:9:   This program is distributed in the hope that it will be useful,
7588:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
7589:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
7590:12:   GNU General Public License for more details.
7591:13:
7592:14:   You should have received a copy of the GNU General Public License
7593:15:   along with this program; if not, write to the Free Software
7594:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
7595:17: */
7596:18:#ifndef  _OUTPUT_OBJECT_H
7597:19:#define  _OUTPUT_OBJECT_H
7598:20:
7599:21:void output_object (Object * o);
7600:22:
7601:23:
7602:24:#endif
7603:1:/*****************************************************************************************/
7604:2:/* picsetup.c - setup and destroy pictures and views                                    */
7605:3:/*****************************************************************************************/
7606:4:/*
7607:5:   Copyright (C) 1996, 1997 Paul Sheer
7608:6:
7609:7:   This program is free software; you can redistribute it and/or modify
7610:8:   it under the terms of the GNU General Public License as published by
7611:9:   the Free Software Foundation; either version 2 of the License, or
7612:10:   (at your option) any later version.
7613:11:
7614:12:   This program is distributed in the hope that it will be useful,
7615:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
7616:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
7617:15:   GNU General Public License for more details.
7618:16:
7619:17:   You should have received a copy of the GNU General Public License
7620:18:   along with this program; if not, write to the Free Software
7621:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
7622:20: */
7623:21:
7624:22:#include <config.h>
7625:23:#include "global.h"
7626:24:#include <stdlib.h>
7627:25:#include <stdio.h>
7628:26:#include <sys/types.h>
7629:27:
7630:28:#ifdef HAVE_UNISTD_H
7631:29:#include <unistd.h>
7632:30:#endif
7633:31:
7634:32:#include <my_string.h>
7635:33:#include <sys/stat.h>
7636:34:
7637:35:#ifdef HAVE_FCNTL_H
7638:36:#include <fcntl.h>
7639:37:#endif
7640:38:
7641:39:#include <stdlib.h>
7642:40:#include <stdarg.h>
7643:41:
7644:42:#ifdef HAVE_SYS_TIME_H
7645:43:#include <sys/time.h>
7646:44:#endif
7647:45:
7648:46:#include "regex.h"
7649:47:
7650:48:#include "display.h"
7651:49:#include "app_glob.c"
7652:50:#include "hugeimage.h"
7653:51:#include "widget3d.h"
7654:52:#include "main/marker.h"
7655:53:#include "main/displaycam.h"
7656:54:#include "picsetup.h"
7657:55:#include "dialog.h"
7658:56:#include "stringtools.h"
7659:57:#include "callback.h"
7660:58:
7661:59:
7662:60:/* returns 1 on error */
7663:61:int setup_picture (const char *ident, Picture * image, int x, int y,
7664:62:                   int width, const char *file)
7665:63:{
7666:64:    Window win;
7667:65:    int h;
7668:66:    image->width = width;
7669:67:    image->height = 0;
7670:68:    image->mag = 4;
7671:69:
7672:70:    win = Cdrawwindow (catstrs (ident, ".main_win", 0), CMain,
7673:71:                       x, y, image->width + 16, image->width, "");
7674:72:    image->main_win = Cwidget (catstrs (ident, ".main_win", 0));
7675:73:    image->main_image =
7676:74:        Cdrawhugebwimage (catstrs (ident, ".main_image", 0), win, 6, 6,
7677:75:                          &(image->width), &(image->height), file);
7678:76:
7679:77:    if (image->main_image == 0) {
7680:78:        Cundrawwidget (catstrs (ident, ".main_win", 0));
7681:79:        memset (image, 0, sizeof (struct picwithzoom));
7682:80:        return 1;
7683:81:    }
7684:82:    Csetwidgetsize (Cwidget (catstrs (ident, ".main_win", 0))->ident,
7685:83:                    image->width + 16, h = image->height + 16 + 150);
7686:84:
7687:85:    image->Ttext =
7688:86:        Cdrawtext (catstrs (ident, ".text", 0), win, 10, h - 30, file);
7689:87:    image->Binfo =
7690:88:        Cdrawbutton (catstrs (ident, ".caminfo", 0), win, 10, h - 150, 100,
7691:89:                     20, " Cam Info ");
7692:90:    image->Blast =
7693:91:        Cdrawbutton (catstrs (ident, ".lastM", 0), win, 120, h - 150, 100,
7694:92:                     20, " Remove Last ");
7695:93:    image->Ball =
7696:94:        Cdrawbutton (catstrs (ident, ".allM", 0), win, 230, h - 150, 100,
7697:95:                     20, " Remove All ");
7698:96:    image->Bcalibrate =
7699:97:        Cdrawbutton (catstrs (ident, ".calibrate", 0), win, 10, h - 120,
7700:98:                     100, 20, " Calibrate ");
7701:99:    image->Bkill =
7702:100:        Cdrawbutton (catstrs (ident, ".kill", 0), win, 120, h - 120, 100,
7703:101:                     20, " Kill View ");
7704:102:    image->Bleave =
7705:103:        Cdrawbutton (catstrs (ident, ".leave", 0), win, 10, h - 90, 100,
7706:104:                     20, " Leave Out: ");
7707:105:    image->Tleave =
7708:106:        Cdrawtext (catstrs (ident, ".text", 0), win, 120, h - 90, " 0 ");
7709:107:    image->Ssig =
7710:108:        Cdrawbutton (catstrs (ident, ".sig", 0), win, 10, h - 60, 100, 20,
7711:109:                     " Aspect Rat: ");
7712:110:
7713:111:    win = Cdrawwindow (catstrs (ident, ".zoom_win", 0), CMain, x, y,
7714:112:                       ZOOMSIZE + 16, ZOOMSIZE + 16, ".zoom_win");
7715:113:    image->zoom_win = Cwidget (catstrs (ident, ".zoom_win", 0));
7716:114:    image->zoom_image = Cdrawzoombox (catstrs (ident, ".zoom_image", 0),
7717:115:                                      catstrs (ident, ".main_image", 0),
7718:116:                                      win, 6, 6, ZOOMSIZE, ZOOMSIZE, 0, 0,
7719:117:                                      image->mag);
7720:118:
7721:119:    Caddcallback (image->main_image->ident, cb_mainimage);
7722:120:    Caddcallback (image->zoom_image->ident, cb_zoomimage);
7723:121:
7724:122:    image->main_rect = Cdrawpicture (catstrs (ident, ".main_rect", 0),
7725:123:                                     image->main_image->winid, 2, 2, 2);
7726:124:    image->zoom_rect = Cdrawpicture (catstrs (ident, ".zoom_rect", 0),
7727:125:                                     image->zoom_image->winid, 2, 2, 2);
7728:126:    image->main_markers =
7729:127:        Cdrawpicture (catstrs (ident, ".main_markers", 0),
7730:128:                      image->main_image->winid, 2, 2, 1024);
7731:129:    image->zoom_markers =
7732:130:        Cdrawpicture (catstrs (ident, ".zoom_markers", 0),
7733:131:                      image->zoom_image->winid, 2, 2, 1024);
7734:132:
7735:133:    Caddcallback (image->Binfo->ident, cb_draw_cam_data);
7736:134:    Caddcallback (image->Blast->ident, cb_removelastmarker);
7737:135:    Caddcallback (image->Ball->ident, cb_clearallmarkers);
7738:136:    Caddcallback (image->Bcalibrate->ident, cb_calibrate);
7739:137:    Caddcallback (image->Bleave->ident, cb_leave);
7740:138:    Caddcallback (image->Ssig->ident, cb_sigma);
7741:139:    Caddcallback (image->Bkill->ident, cb_killimage);
7742:140:
7743:141:    image->xzoom = image->yzoom = 0;
7744:142:    image->real_width = CHugeImageRealWidth (image->main_image->ident);
7745:143:    image->real_height = CHugeImageRealHeight (image->main_image->ident);
7746:144:    image->x0 = image->real_width / 2;
7747:145:    image->y0 = image->real_height / 2;
7748:146:
7749:147:    return 0;
7750:148:}
7751:149:
7752:150:
7753:151:
7754:152:void destroy_pic (Picture * p)
7755:153:{
7756:154:    if (p && p->main_image) {
7757:155:        Cundrawwidget (p->main_markers->ident);
7758:156:        Cundrawwidget (p->zoom_markers->ident);
7759:157:        Cundrawwidget (p->main_rect->ident);
7760:158:        Cundrawwidget (p->zoom_rect->ident);
7761:159:        Cundrawwidget (p->main_win->ident);
7762:160:        Cundrawwidget (p->zoom_win->ident);
7763:161:    }
7764:162:    clear (p, Picture);
7765:163:}
7766:164:
7767:165:
7768:166:void init_view (View * v)
7769:167:{
7770:168:    clear (v, View);
7771:169:}
7772:170:
7773:171:void destroy_view (View * v)
7774:172:{
7775:173:    if (!v->filename)
7776:174:        return;
7777:175:    destroy ((void *) &(v->filename));
7778:176:    destroy_pic (&(v->pic));
7779:177:    init_view (v);
7780:178:}
7781:179:
7782:180:void destroy_current_view (Desktop * d)
7783:181:{
7784:182:    if (!d->num_views)
7785:183:        return;
7786:184:    destroy_view (&(d->view[d->current_view]));
7787:185:    if (d->current_view == d->num_views - 1 && d->num_views > 0)
7788:186:        d->num_views--;
7789:187:}
7790:188:
7791:189:int setup_view (Desktop * d, char *filename, int x, int y, int i)
7792:190:{
7793:191:    static long count = 0;
7794:192:    count++;
7795:193:    clear (&d->view[i].pic, Picture);
7796:194:    return setup_picture (catstrs ("picture", itoa (count), 0),
7797:195:                          &(d->view[i].pic), x, y, 380, filename);
7798:196:}
7799:197:
7800:198:/* return 1 on error */
7801:199:int new_view (Desktop * d, char *filename)
7802:200:{
7803:201:    int x = 50, y = 50;
7804:202:    int i = 0;
7805:203:
7806:204:    if (exists (d, d->current_view)) {
7807:205:        x = d->view[d->current_view].pic.main_win->x + 20;
7808:206:        y = d->view[d->current_view].pic.main_win->y + 20;
7809:207:    }
7810:208:    if (d->num_views)
7811:209:        for (i = 0; i < d->num_views; i++)
7812:210:            if (!exists (d, i))
7813:211:                break;
7814:212:    if (i == d->num_views)
7815:213:        d->num_views++;
7816:214:    set_current_view (d, i);
7817:215:
7818:216:    init_view (&(d->view[i]));
7819:217:    if (setup_view (d, filename, x, y, i))
7820:218:        return 1;
7821:219:
7822:220:    d->view[i].filename = strdup (filename);
7823:221:
7824:222:    return 0;
7825:223:}
7826:224:
7827:225:void load_view (Desktop * d)
7828:226:{
7829:227:    char *s;
7830:228:    s = Cgetfile (0, 0, 0, d->image_dir, "", " Load Image ");
7831:229:    if (s)
7832:230:        if (*s)
7833:231:            new_view (d, s);
7834:232:}
7835:1:/*
7836:2:   Copyright (C) 1996, 1997 Paul Sheer
7837:3:
7838:4:   This program is free software; you can redistribute it and/or modify
7839:5:   it under the terms of the GNU General Public License as published by
7840:6:   the Free Software Foundation; either version 2 of the License, or
7841:7:   (at your option) any later version.
7842:8:
7843:9:   This program is distributed in the hope that it will be useful,
7844:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
7845:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
7846:12:   GNU General Public License for more details.
7847:13:
7848:14:   You should have received a copy of the GNU General Public License
7849:15:   along with this program; if not, write to the Free Software
7850:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
7851:17: */
7852:18:#ifndef _PIC_SETUP_H
7853:19:#define _PIC_SETUP_H
7854:20:
7855:21:/* returns 1 on error */
7856:22:int setup_picture (const char *ident, Picture * image,
7857:23:                   int x, int y, int width, const char *file);
7858:24:void destroy_pic (Picture * p);
7859:25:void destroy_view (View * v);
7860:26:void destroy_current_view (Desktop * d);
7861:27:int new_view (Desktop * d, char *filename);
7862:28:void load_view (Desktop * d);
7863:29:
7864:30:#endif                          /* _PIC_SETUP_H */
7865:1:/*****************************************************************************************/
7866:2:/* savewindow.c - saves the rendered 3D scene as a targa file                            */
7867:3:/*****************************************************************************************/
7868:4:/*
7869:5:   Copyright (C) 1996, 1997 Paul Sheer
7870:6:
7871:7:   This program is free software; you can redistribute it and/or modify
7872:8:   it under the terms of the GNU General Public License as published by
7873:9:   the Free Software Foundation; either version 2 of the License, or
7874:10:   (at your option) any later version.
7875:11:
7876:12:   This program is distributed in the hope that it will be useful,
7877:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
7878:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
7879:15:   GNU General Public License for more details.
7880:16:
7881:17:   You should have received a copy of the GNU General Public License
7882:18:   along with this program; if not, write to the Free Software
7883:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
7884:20: */
7885:21:
7886:22:#include "display.h"
7887:23:#include "imagewidget.h"
7888:24:#include "../global.h"
7889:25:#include "app_glob.c"
7890:26:#include "dialog.h"
7891:27:
7892:28:/* \end{verbatim} \begin{verbatim} */
7893:29:
7894:30:/* returns 1 on error */
7895:31:int save_window (Window win, int x, int y, int width, int height,
7896:32:                 const char *file)
7897:33:{
7898:34:    XImage *image;
7899:35:    byte *p_byte;
7900:36:    byte *p, *q, *pix;
7901:37:    word *p_word;
7902:38:    quad_t *p_quad;
7903:39:
7904:40:    Colormap cmap;
7905:41:
7906:42:    int i, j, n;
7907:43:
7908:44:    image = XGetImage (CDisplay, win, x, y, width, height,
7909:45:                       (unsigned long) -1, ZPixmap);
7910:46:    if (!image) {
7911:47:        Cerrordialog (0, 0, 0, " Save Window ",
7912:48:                      " Unable to create XImage ");
7913:49:        return 1;
7914:50:    }
7915:51:    p = image->data;
7916:52:    p_byte = p;
7917:53:    p_word = (word *) p;
7918:54:    p_quad = (quad_t *) p;
7919:55:
7920:56:    pix = Cmalloc (width * height * 3);
7921:57:    q = pix;
7922:58:
7923:59:    switch (image->bits_per_pixel) {
7924:60:    case 8:{
7925:61:            XColor *c;
7926:62:            n = DisplayCells (CDisplay, DefaultScreen (CDisplay));
7927:63:            c = Cmalloc (n * sizeof (XColor));
7928:64:            for (i = 0; i < n; i++)
7929:65:                c[i].pixel = i;
7930:66:            cmap = DefaultColormap (CDisplay, DefaultScreen (CDisplay));
7931:67:            XQueryColors (CDisplay, cmap, c, n);
7932:68:
7933:69:            for (i = 0; i < height; i++) {
7934:70:                p_byte = p;
7935:71:                for (j = 0; j < width; j++) {
7936:72:                    *q++ = c[*p_byte].blue >> 8;
7937:73:                    *q++ = c[*p_byte].green >> 8;
7938:74:                    *q++ = c[*p_byte].red >> 8;
7939:75:                    p_byte++;
7940:76:                }
7941:77:                p += image->bytes_per_line;
7942:78:            }
7943:79:            free (c);
7944:80:            break;
7945:81:        }
7946:82:    case 16:{
7947:83:            XColor c;
7948:84:            c.flags = DoRed | DoGreen | DoBlue;
7949:85:            cmap = DefaultColormap (CDisplay, DefaultScreen (CDisplay));
7950:86:            for (i = 0; i < height; i++) {
7951:87:                p_word = (word *) p;
7952:88:                for (j = 0; j < width; j++) {
7953:89:                    c.pixel = *p_word;
7954:90:                    XQueryColor (CDisplay, cmap, &c);
7955:91:                    *q++ = c.blue >> 8;
7956:92:                    *q++ = c.green >> 8;
7957:93:                    *q++ = c.red >> 8;
7958:94:                    p_word++;
7959:95:                }
7960:96:                p += image->bytes_per_line;
7961:97:            }
7962:98:            break;
7963:99:        }
7964:100:    case 24:
7965:101:        free (pix);
7966:102:        Cerrordialog (0, 0, 0, " Save Window ",
7967:103:                      " %s:%d 24bpp images not supported, use 8, 16 or 32bpp. \n"
7968:104:                      " This may mean changing your display. ");
7969:105:        return 1;
7970:106:    case 32:{
7971:107:            XColor c;
7972:108:            c.flags = DoRed | DoGreen | DoBlue;
7973:109:            cmap = DefaultColormap (CDisplay, DefaultScreen (CDisplay));
7974:110:            for (i = 0; i < height; i++) {
7975:111:                p_quad = (quad_t *) p;
7976:112:                for (j = 0; j < width; j++) {
7977:113:                    c.pixel = *p_quad;
7978:114:                    XQueryColor (CDisplay, cmap, &c);
7979:115:                    *q++ = c.blue >> 8;
7980:116:                    *q++ = c.green >> 8;
7981:117:                    *q++ = c.red >> 8;
7982:118:                    p_quad++;
7983:119:                }
7984:120:                p += image->bytes_per_line;
7985:121:            }
7986:122:            break;
7987:123:        }
7988:124:    }
7989:125:    writetarga (pix, file, width, height, 0);
7990:126:    free (pix);
7991:127:    return 0;
7992:128:}
7993:129:
7994:130:
7995:131:int save_window_to_file (Window win, int x, int y, int width, int height)
7996:132:{
7997:133:    char *filename;
7998:134:    filename = Cgetfile (0, 0, 0, home_dir, "", " Save Window ");
7999:135:    if (filename)
8000:136:        if (*filename) {
8001:137:            save_window (win, x, y, width, height, filename);
8002:138:            free (filename);
8003:139:            return 0;
8004:140:        }
8005:141:    return 1;
8006:142:}
8007:1:/*****************************************************************************************/
8008:2:/* simplex.c - simplex optimisation algorithm                                            */
8009:3:/*****************************************************************************************/
8010:4:/*
8011:5:   Copyright (C) 1996, 1997 Paul Sheer
8012:6:
8013:7:   This program is free software; you can redistribute it and/or modify
8014:8:   it under the terms of the GNU General Public License as published by
8015:9:   the Free Software Foundation; either version 2 of the License, or
8016:10:   (at your option) any later version.
8017:11:
8018:12:   This program is distributed in the hope that it will be useful,
8019:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
8020:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
8021:15:   GNU General Public License for more details.
8022:16:
8023:17:   You should have received a copy of the GNU General Public License
8024:18:   along with this program; if not, write to the Free Software
8025:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
8026:20: */
8027:21:
8028:22:#include <config.h>
8029:23:#include "global.h"
8030:24:#include <math.h>
8031:25:#include <stdio.h>
8032:26:#include "matrix.h"
8033:27:
8034:28:/*
8035:29:   Finds an n'th dimensional simplex about the origin.
8036:30:   The n+1 vertices of the simplex are stored as rows
8037:31:   in the returned matrix. Each vertex is d units
8038:32:   euclidian distance from the origin.
8039:33: */
8040:34:Matrix *Mageneratesimplex (int n, double d)
8041:35:{
8042:36:    Matrix *A = Maallocmatrix (n + 1, n, 'd');
8043:37:    Matrix *v1 = NULL, *v2 = NULL;
8044:38:    double s, a, b;
8045:39:    int i, j;
8046:40:
8047:41:    d *= d;
8048:42:
8049:43:    Mard ((*A), 0, 0) = 1;
8050:44:    Mard ((*A), 1, 0) = -1;
8051:45:
8052:46:    for (i = 1; i < n; i++) {
8053:47:
8054:48:        v1 = Masubmatrix (v1, A, i - 1, 0, 1, i);
8055:49:        v2 = Masubmatrix (v2, A, i, 0, 1, i);
8056:50:
8057:51:        s = Madistance (v1, v2);
8058:52:        s *= s;
8059:53:
8060:54:        b = 0.5 * (s - 2 * d) / (sqrt (s - d));
8061:55:        a = sqrt (d / (d + b * b));
8062:56:
8063:57:        Mascale (A, a);
8064:58:
8065:59:        a *= b;
8066:60:
8067:61:        for (j = 0; j < i; j++) {
8068:62:            Mard ((*A), j, i) = -a;
8069:63:            Mard ((*A), i + 1, j) = 0;
8070:64:        }
8071:65:
8072:66:        Mard ((*A), i, i) = -a;
8073:67:        Mard ((*A), i + 1, i) = sqrt (d);
8074:68:
8075:69:    }
8076:70:
8077:71:    Mafreematrix (v2);
8078:72:    Mafreematrix (v1);
8079:73:
8080:74:    return A;
8081:75:}
8082:76:
8083:77:/*
8084:78:   Same as above, but r (row vector) is added to each vertice (i.e. row).
8085:79:   Matrix must be Mafreematrix'd
8086:80: */
8087:81:Matrix *Mageneratesimplexabout (Matrix * r, int n, double d)
8088:82:{
8089:83:    int i, j;
8090:84:    Matrix *A;
8091:85:
8092:86:    A = Mageneratesimplex (n, d);
8093:87:
8094:88:    for (i = 0; i < n + 1; i++)
8095:89:        for (j = 0; j < n; j++)
8096:90:            Mard ((*A), i, j) += Mard ((*r), 0, j);
8097:91:
8098:92:    return A;
8099:93:}
8100:94:
8101:95:#define NMAX 5000
8102:96:#define GET_PSUM \
8103:97:        for(j=0;j<ndim;j++) { \
8104:98:            for(sum=0.0,i=0;i<mpts;i++) sum += p[i][j]; \
8105:99:            psum[j]=sum; \
8106:100:        }
8107:101:
8108:102:int amoeba (double **p, double y[], int ndim, double ftol,
8109:103:            double (*funk) (double[]),
8110:104:            int (*callback) (double, double, double *, int), int *nfunk)
8111:105:{
8112:106:    double amotry (double **p, double y[], double psum[], int ndim,
8113:107:                   double (*funk) (double[]), int ihi, double fac);
8114:108:    int i, ihi, ilo, inhi, j, mpts = ndim + 1, ret_val = 0;
8115:109:    double rtol, sum, ysave, ytry, *psum;
8116:110:
8117:111:    psum = Mamalloc ((ndim + 2) * sizeof (double));
8118:112:    *nfunk = 0;
8119:113:    GET_PSUM;
8120:114:    for (;;) {
8121:115:        ilo = 0;
8122:116:        ihi = y[0] > y[1] ? (inhi = 1, 0) : (inhi = 0, 1);
8123:117:        for (i = 0; i < mpts; i++) {
8124:118:            if (y[i] <= y[ilo])
8125:119:                ilo = i;
8126:120:            if (y[i] > y[ihi]) {
8127:121:                inhi = ihi;
8128:122:                ihi = i;
8129:123:            } else if (y[i] > y[inhi] && i != ihi)
8130:124:                inhi = i;
8131:125:        }
8132:126:
8133:127:        rtol =
8134:128:            2.0 * fabs (y[ihi] - y[ilo]) / (fabs (y[ihi]) + fabs (y[ilo]));
8135:129:
8136:130:        if (*nfunk >= NMAX) {
8137:131:            fprintf (stderr, "Warning:stereo:%s:%d:"
8138:132:                     " %d functional evalutations exceeded in optimisation - returning\n",
8139:133:                     __FILE__, __LINE__, (int) NMAX);
8140:134:            goto fin;
8141:135:        }
8142:136:        if (rtol < ftol || fabs (y[ilo]) < ftol * ftol)
8143:137:            goto fin;
8144:138:        if (callback) {
8145:139:            if ((*callback) (rtol, y[ilo], p[ilo], *nfunk)) {
8146:140:                ret_val = 1;
8147:141:              fin:
8148:142:                fswap (y[0], y[ilo]);
8149:143:                for (i = 0; i < ndim; i++)
8150:144:                    fswap (p[0][i], p[ilo][i]);
8151:145:                break;
8152:146:            }
8153:147:        }
8154:148:/*      if (*nfunk >= NMAX)
8155:149:   Maerror ("NMAX exceeded");
8156:150: */
8157:151:        *nfunk += 2;
8158:152:        ytry = amotry (p, y, psum, ndim, funk, ihi, -1.0);
8159:153:        if (ytry <= y[ilo])
8160:154:            ytry = amotry (p, y, psum, ndim, funk, ihi, 2.0);
8161:155:        else if (ytry >= y[inhi]) {
8162:156:            ysave = y[ihi];
8163:157:            ytry = amotry (p, y, psum, ndim, funk, ihi, 0.5);
8164:158:            if (ytry >= ysave) {
8165:159:                for (i = 0; i < mpts; i++) {
8166:160:                    if (i != ilo) {
8167:161:                        for (j = 0; j < ndim; j++)
8168:162:                            p[i][j] = psum[j] =
8169:163:                                0.5 * (p[i][j] + p[ilo][j]);
8170:164:                        y[i] = (*funk) (psum);
8171:165:                    }
8172:166:                }
8173:167:                *nfunk += ndim;
8174:168:                GET_PSUM;
8175:169:            }
8176:170:        } else
8177:171:            --(*nfunk);
8178:172:    }
8179:173:    free (psum);
8180:174:    return ret_val;
8181:175:}
8182:176:
8183:177:double amotry (double **p, double y[], double psum[], int ndim,
8184:178:               double (*funk) (double[]), int ihi, double fac)
8185:179:{
8186:180:    int j;
8187:181:    double fac1, fac2, ytry, *ptry;
8188:182:
8189:183:    ptry = Mamalloc ((ndim + 2) * sizeof (double));
8190:184:    fac1 = (1.0 - fac) / ndim;
8191:185:    fac2 = fac1 - fac;
8192:186:    for (j = 0; j < ndim; j++)
8193:187:        ptry[j] = psum[j] * fac1 - p[ihi][j] * fac2;
8194:188:    ytry = (*funk) (ptry);
8195:189:    if (ytry < y[ihi]) {
8196:190:        y[ihi] = ytry;
8197:191:        for (j = 0; j < ndim; j++) {
8198:192:            psum[j] += ptry[j] - p[ihi][j];
8199:193:            p[ihi][j] = ptry[j];
8200:194:        }
8201:195:    }
8202:196:    free (ptry);
8203:197:    return ytry;
8204:198:}
8205:199:
8206:200:
8207:201:
8208:202:/*
8209:203:   Does Nelder and Mead (Downhill Simplex Method) minimisation of
8210:204:   the function funk.
8211:205:   returns minimising vector in result. ftol is the final tolerance
8212:206:   and itol is the initial tolerance (these are actually the size of the
8213:207:   final or initial simplexes. funk takes an ndim dimensional vector
8214:208:   of doubles and returns a function value.
8215:209:   Returns the number of functional iterations performed.
8216:210:   callback can be used by the user to to intermediate
8217:211:   processes during the optimisation --- for example monotoring
8218:212:   by graphical display. A NULL value my be given if you
8219:213:   have no use for it.
8220:214:   callback takes four values: the current tolerance, the current error,
8221:215:   the vertex associated with that error, and the number of times funk
8222:216:   has been called. It must return 0. A non-zero return value signals
8223:217:   for the itteration to stop and the current lowest point to be
8224:218:   returned.
8225:219: */
8226:220:
8227:221:int simplex_optimise (double *result, int ndim, double ftol, double itol,
8228:222:                      double (*funk) (double *), int (*callback) (double,
8229:223:                                                                  double,
8230:224:                                                                  double *,
8231:225:                                                                  int))
8232:226:{
8233:227:    Matrix *r = Maallocmatrix (1, ndim, 'd');
8234:228:    Matrix *start_simplex;
8235:229:    int stop = 1;
8236:230:
8237:231:    double *y = Mamalloc ((ndim + 1) * sizeof (double));
8238:232:    int i, j, nfunk[3] = { 0, 0, 0 };
8239:233:
8240:234:    memcpy (&(Mard ((*r), 0, 0)), result, ndim * sizeof (double));
8241:235:
8242:236:    for (j = 0; j < 3 && stop; j++) { /* restart the algorithm three times to ensure
8243:237:                                         that there is a true minumim */
8244:238:
8245:239:        start_simplex = Mageneratesimplexabout (r, ndim, itol);
8246:240:
8247:241:        for (i = 0; i < ndim + 1; i++)
8248:242:            y[i] = funk (&(Mard ((*start_simplex), i, 0)));
8249:243:
8250:244:        if (amoeba ((double **) start_simplex->d, y, ndim,
8251:245:                    ftol, funk, callback, &(nfunk[j])))
8252:246:            stop = 0;
8253:247:
8254:248:/* amoeba always returns with the first simplex point having least error */
8255:249:        for (i = 0; i < ndim; i++)
8256:250:            Mard ((*r), 0, i) = Mard ((*start_simplex), 0, i);
8257:251:/* r now contains the point */
8258:252:
8259:253:        Mafreematrix (start_simplex); /*Mageneratsimplexabout */
8260:254:
8261:255:        itol = ftol;
8262:256:    }
8263:257:
8264:258:    memcpy (result, &(Mard ((*r), 0, 0)), ndim * sizeof (double));
8265:259:
8266:260:    free (y);
8267:261:    Mafreematrix (r);
8268:262:
8269:263:    return nfunk[0] + nfunk[1] + nfunk[2];
8270:264:}
8271:1:/*
8272:2:   Copyright (C) 1996, 1997 Paul Sheer
8273:3:
8274:4:   This program is free software; you can redistribute it and/or modify
8275:5:   it under the terms of the GNU General Public License as published by
8276:6:   the Free Software Foundation; either version 2 of the License, or
8277:7:   (at your option) any later version.
8278:8:
8279:9:   This program is distributed in the hope that it will be useful,
8280:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
8281:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
8282:12:   GNU General Public License for more details.
8283:13:
8284:14:   You should have received a copy of the GNU General Public License
8285:15:   along with this program; if not, write to the Free Software
8286:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
8287:17: */
8288:18:#ifndef SIMPLEX_H
8289:19:#define SIMPLEX_H
8290:20:
8291:21:Matrix *Mageneratesimplex (int n, double d);
8292:22:
8293:23:Matrix *Mageneratesimplexabout (Matrix * r, int n, double d);
8294:24:
8295:25:int amoeba (double **p, double y[], int ndim, double ftol,
8296:26:            double (*funk) (double[]),
8297:27:            int (*callback) (double, double, double *, int), int *nfunk);
8298:28:
8299:29:int simplex_optimise (double *result, int ndim, double ftol, double itol,
8300:30:                      double (*funk) (double *),
8301:31:                      int (*callback) (double, double, double *, int));
8302:32:
8303:33:#endif                          /* SIMPLEX_H */
8304:34:
8305:35:/* \end{verbatim} */
