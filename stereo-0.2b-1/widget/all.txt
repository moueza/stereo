




1:1:/*
2:2:
3:3:    3DKIT   version   1.2
4:4:    High speed 3D graphics and rendering library for Linux.
5:5:
6:6:    Copyright (C) 1996  Paul Sheer   psheer@hertz.mech.wits.ac.za
7:7:
8:8:    This library is free software; you can redistribute it and/or
9:9:    modify it under the terms of the GNU Library General Public
10:10:    License as published by the Free Software Foundation; either
11:11:    version 2 of the License, or (at your option) any later version.
12:12:
13:13:    This library is distributed in the hope that it will be useful,
14:14:    but WITHOUT ANY WARRANTY; without even the implied warranty of
15:15:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
16:16:    Library General Public License for more details.
17:17:
18:18:    You should have received a copy of the GNU Library General Public
19:19:    License along with this library; if not, write to the Free
20:20:    Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
21:21:    MA 02111-1307, USA
22:22:
23:23:*/
24:24:
25:25:
26:26:/*
27:27:
28:28:File: 3dinit.c
29:29:
30:30:Contains the utility function initcolor for initialising the normal color
31:31:vectors of a surface, and the a function to initialise a 3D ellipse.
32:32:
33:33:
34:34:This file is incomplete and should contain a number of useful
35:35:tools to initialise different 3D primitives. 
36:36:
37:37:*/
38:38:
39:39:
40:40:
41:41:
42:42:#include <config.h>
43:43:#include <math.h>
44:44:#include <stdlib.h>
45:45:#include <stdio.h>
46:46:
47:47:#ifndef DO_NOT_USE_VGALIB
48:48:#include <vga.h>
49:49:#endif
50:50:
51:51:#include <vgagl.h>
52:52:#include "./3dkit.h"
53:53:#include "./3dinit.h"
54:54:
55:55:
56:56:
57:57:double mag (Vec v)
58:58:{
59:59:    double r;
60:60:    if ((r = sqrt (v.x * v.x + v.y * v.y + v.z * v.z)) == 0)
61:61:        return 1;
62:62:    return r;
63:63:}
64:64:
65:65:
66:66:/*  adds the normal vector to v at point (i,j), calculated from the
67:67:    panel d. d is one of the four panels at (i,j). 
68:68: i
69:69:-->
70:70:
71:71:0|3  |
72:72:-+-  | j
73:73:1|2  v
74:74:
75:75:*/
76:76:
77:77:
78:78:void norm_vec (TD_Surface * surf, int i, int j, Vec * v, int d)
79:79:{
80:80:    int i1 = 0, i2 = 0, j1 = 0, j2 = 0, w = surf->w;
81:81:    double x, y, z, r;
82:82:    double x1, y1, z1;
83:83:    double x2, y2, z2;
84:84:    Vec u;
85:85:
86:86:    switch (d & 3) {
87:87:    case 0:
88:88:        j1 = -1;
89:89:        i2 = -1;
90:90:        break;
91:91:    case 1:
92:92:        i1 = -1;
93:93:        j2 = 1;
94:94:        break;
95:95:    case 2:
96:96:        j1 = 1;
97:97:        i2 = 1;
98:98:        break;
99:99:    case 3:
100:100:        i1 = 1;
101:101:        j2 = -1;
102:102:        break;
103:103:    }
104:104:
105:105:    x = surf->point[i + j * w].x;
106:106:    y = surf->point[i + j * w].y;
107:107:    z = surf->point[i + j * w].z;
108:108:
109:109:    x1 = surf->point[i + i1 + (j + j1) * w].x - x;
110:110:    y1 = surf->point[i + i1 + (j + j1) * w].y - y;
111:111:    z1 = surf->point[i + i1 + (j + j1) * w].z - z;
112:112:
113:113:    x2 = surf->point[i + i2 + (j + j2) * w].x - x;
114:114:    y2 = surf->point[i + i2 + (j + j2) * w].y - y;
115:115:    z2 = surf->point[i + i2 + (j + j2) * w].z - z;
116:116:
117:117:    u.x = y1 * z2 - z1 * y2;
118:118:    u.y = z1 * x2 - x1 * z2;
119:119:    u.z = x1 * y2 - y1 * x2;
120:120:
121:121:    r = mag (u);
122:122:
123:123:    v->x += u.x / r;
124:124:    v->y += u.y / r;
125:125:    v->z += u.z / r;
126:126:
127:127:}
128:128:
129:129:/*Following routine initialise a surface's normal vectors*/
130:130:/*(FIXME: this doesn't work 100% at the edges, I think it 
131:131:    needs Frenet-Sneret (spelling?) formula) */
132:132:
133:133:/* n gives the brightness of the surface and the direction of the normal.
134:134:   normally +256 or -256 (can be less to give a darker surface) */
135:135:
136:136:void TD_initcolor (TD_Surface * surf, int n)
137:137:{
138:138:    int i, j, k, w = surf->w, l = surf->l, m;
139:139:
140:140:    double r, ru;
141:141:    int w0, ww;
142:142:    int l0, ll;
143:143:
144:144:    Vec v, u;
145:145:
146:146:
147:147:    if (w > 2) {
148:148:        w0 = 1;
149:149:        ww = w - 1;
150:150:    } else {
151:151:        w0 = 0;
152:152:        ww = w;
153:153:    }
154:154:
155:155:
156:156:    if (l > 2) {
157:157:        l0 = 1;
158:158:        ll = l - 1;
159:159:    } else {
160:160:        l0 = 0;
161:161:        ll = l;
162:162:    }
163:163:
164:164:
165:165:    for (j = 0; j < l; j++)
166:166:        for (i = 0; i < w; i++) {
167:167:
168:168:/* normal at a point is the average of the four cross products
169:169:   except at the edge points where the gradient of the normal near 
170:170:   the edge is considered as well */
171:171:
172:172:            v.x = v.y = v.z = 0;
173:173:            u.x = u.y = u.z = 0;
174:174:            m = 0;
175:175:
176:176:            if (i == 0) {
177:177:                m = 1;
178:178:                if (j != 0) {
179:179:                    norm_vec (surf, i, j, &v, 3);
180:180:                    norm_vec (surf, w0, j, &u, 3);
181:181:                }
182:182:                if (j != (l - 1)) {
183:183:                    norm_vec (surf, i, j, &v, 2);
184:184:                    norm_vec (surf, w0, j, &u, 2);
185:185:                }
186:186:            }
187:187:            if (i == (w - 1)) {
188:188:                m = 1;
189:189:                if (j != 0) {
190:190:                    norm_vec (surf, i, j, &v, 0);
191:191:                    norm_vec (surf, ww, j, &u, 0);
192:192:                }
193:193:                if (j != (l - 1)) {
194:194:                    norm_vec (surf, i, j, &v, 1);
195:195:                    norm_vec (surf, ww, j, &u, 1);
196:196:                }
197:197:            }
198:198:            if (j == 0) {
199:199:                m = 1;
200:200:                if (i != 0) {
201:201:                    norm_vec (surf, i, j, &v, 1);
202:202:                    norm_vec (surf, i, l0, &u, 1);
203:203:                }
204:204:                if (i != (w - 1)) {
205:205:                    norm_vec (surf, i, j, &v, 2);
206:206:                    norm_vec (surf, i, l0, &u, 2);
207:207:                }
208:208:            }
209:209:            if (j == (l - 1)) {
210:210:                m = 1;
211:211:                if (i != 0) {
212:212:                    norm_vec (surf, i, j, &v, 0);
213:213:                    norm_vec (surf, i, ll, &u, 0);
214:214:                }
215:215:                if (i != (w - 1)) {
216:216:                    norm_vec (surf, i, j, &v, 3);
217:217:                    norm_vec (surf, i, ll, &u, 3);
218:218:                }
219:219:            }
220:220:            if (m) {
221:221:
222:222:                r = mag (v);
223:223:                ru = mag (u);
224:224:
225:225:                v.x = (float) 3 *v.x / (2 * r) - u.x / (2 * ru);
226:226:                v.y = (float) 3 *v.y / (2 * r) - u.y / (2 * ru);
227:227:                v.z = (float) 3 *v.z / (2 * r) - u.z / (2 * ru);
228:228:
229:229:            } else {
230:230:                for (k = 0; k < 4; k++)
231:231:                    norm_vec (surf, i, j, &v, k);
232:232:
233:233:            }
234:234:
235:235:            r = mag (v);
236:236:
237:237:            surf->point[i + j * w].dirx = (double) v.x * n / r;
238:238:            surf->point[i + j * w].diry = (double) v.y * n / r;
239:239:            surf->point[i + j * w].dirz = (double) v.z * n / r;
240:240:        }
241:241:
242:242:}
243:243:
244:244:
245:245:
246:246:static inline void fxchg (double *a, double *b)
247:247:{
248:248:    double t = *a;
249:249:    *a = *b;
250:250:    *b = t;
251:251:}
252:252:
253:253:
254:254:void TD_initellipsoidpart (TD_Surface * surf, long x, long y, long z,
255:255:                           long a, long b, long c, int w, int dir, int col)
256:256:{
257:257:    int i, j;
258:258:    Vec v;
259:259:    float r;
260:260:    surf->w = surf->l = 2 * w + 1;
261:261:
262:262:    for (i = -w; i <= w; i++)
263:263:        for (j = -w; j <= w; j++) {
264:264:            v.x = (float) j / w;
265:265:            v.y = (float) i / w;
266:266:            v.z = 1;
267:267:
268:268:            switch (dir) {
269:269:            case 0:
270:270:                v.z = -v.z;
271:271:                fxchg (&v.x, &v.y);
272:272:                break;
273:273:            case 1:
274:274:                v.y = -v.y;
275:275:                fxchg (&v.x, &v.z);
276:276:                break;
277:277:            case 2:
278:278:                v.z = -v.z;
279:279:                fxchg (&v.x, &v.z);
280:280:                break;
281:281:            case 3:
282:282:                v.y = -v.y;
283:283:                fxchg (&v.y, &v.z);
284:284:                break;
285:285:            case 4:
286:286:                v.z = -v.z;
287:287:                fxchg (&v.y, &v.z);
288:288:                break;
289:289:            }
290:290:
291:291:            r = mag (v);
292:292:            v.x *= (float) a / r;
293:293:            v.y *= (float) b / r;
294:294:            v.z *= (float) c / r;
295:295:
296:296:            surf->point[i + w + (j + w) * surf->w].x = v.x + x;
297:297:            surf->point[i + w + (j + w) * surf->w].y = v.y + y;
298:298:            surf->point[i + w + (j + w) * surf->w].z = v.z + z;
299:299:
300:300:            v.x /= (float) a *a; /*normal vector */
301:301:            v.y /= (float) b *b;
302:302:            v.z /= (float) c *c;
303:303:
304:304:            r = mag (v);
305:305:
306:306:            surf->point[i + w + (j + w) * surf->w].dirx =
307:307:                (float) col *v.x / r;
308:308:            surf->point[i + w + (j + w) * surf->w].diry =
309:309:                (float) col *v.y / r;
310:310:            surf->point[i + w + (j + w) * surf->w].dirz =
311:311:                (float) col *v.z / r;
312:312:
313:313:        }
314:314:}
315:315:
316:316:
317:317:
318:318:void TD_initellipsoid (TD_Surface * surf1, TD_Surface * surf2,
319:319:                       TD_Surface * surf3, TD_Surface * surf4,
320:320:                       TD_Surface * surf5, TD_Surface * surf6, long x,
321:321:                       long y, long z, long a, long b, long c, int w,
322:322:                       int col)
323:323:{
324:324:    TD_initellipsoidpart (surf1, x, y, z, a, b, c, w, 0, col);
325:325:    TD_initellipsoidpart (surf2, x, y, z, a, b, c, w, 1, col);
326:326:    TD_initellipsoidpart (surf3, x, y, z, a, b, c, w, 2, col);
327:327:    TD_initellipsoidpart (surf4, x, y, z, a, b, c, w, 3, col);
328:328:    TD_initellipsoidpart (surf5, x, y, z, a, b, c, w, 4, col);
329:329:    TD_initellipsoidpart (surf6, x, y, z, a, b, c, w, 5, col);
330:330:}
331:331:
332:332:
333:333:void TD_initsellipsoid (TD_Solid * s, int n, long x,
334:334:                        long y, long z, long a, long b, long c, int w,
335:335:                        int col)
336:336:{
337:337:    TD_initellipsoid (&s->surf[n], &s->surf[n + 1], &s->surf[n + 2],
338:338:                      &s->surf[n + 3], &s->surf[n + 4], &s->surf[n + 5], x,
339:339:                      y, z, a, b, c, w, col);
340:340:}
341:1:/*
342:2:
343:3:    3DKIT   version   1.2
344:4:    High speed 3D graphics and rendering library for Linux.
345:5:
346:6:    Copyright (C) 1996  Paul Sheer   psheer@hertz.mech.wits.ac.za
347:7:
348:8:    This library is free software; you can redistribute it and/or
349:9:    modify it under the terms of the GNU Library General Public
350:10:    License as published by the Free Software Foundation; either
351:11:    version 2 of the License, or (at your option) any later version.
352:12:
353:13:    This library is distributed in the hope that it will be useful,
354:14:    but WITHOUT ANY WARRANTY; without even the implied warranty of
355:15:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
356:16:    Library General Public License for more details.
357:17:
358:18:    You should have received a copy of the GNU Library General Public
359:19:    License along with this library; if not, write to the Free
360:20:    Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
361:21:    MA 02111-1307, USA
362:22:
363:23:*/
364:24:
365:25:/*
366:26:
367:27:File: 3dinit.h
368:28:
369:29:*/
370:30:
371:31:#include "quickmath.h"
372:32:
373:33:
374:34:void TD_initcolor (TD_Surface * surf, int n);
375:35:
376:36:void TD_initellipsoidpart (TD_Surface * surf, long x, long y, long z,
377:37:                           long a, long b, long c, int w, int dir,
378:38:                           int col);
379:39:void TD_initellipsoid (TD_Surface * surf1, TD_Surface * surf2,
380:40:                       TD_Surface * surf3, TD_Surface * surf4,
381:41:                       TD_Surface * surf5, TD_Surface * surf6, long x,
382:42:                       long y, long z, long a, long b, long c, int w,
383:43:                       int col);
384:44:void TD_initsellipsoid (TD_Solid * s, int n, long x, long y, long z,
385:45:                        long a, long b, long c, int w, int col);
386:1:/*
387:2:
388:3:    3DKIT   version   1.2
389:4:    High speed 3D graphics and rendering library for Linux.
390:5:
391:6:    Copyright (C) 1996  Paul Sheer   psheer@hertz.mech.wits.ac.za
392:7:
393:8:    This library is free software; you can redistribute it and/or
394:9:    modify it under the terms of the GNU Library General Public
395:10:    License as published by the Free Software Foundation; either
396:11:    version 2 of the License, or (at your option) any later version.
397:12:
398:13:    This library is distributed in the hope that it will be useful,
399:14:    but WITHOUT ANY WARRANTY; without even the implied warranty of
400:15:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
401:16:    Library General Public License for more details.
402:17:
403:18:    You should have received a copy of the GNU Library General Public
404:19:    License along with this library; if not, write to the Free
405:20:    Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
406:21:    MA 02111-1307, USA
407:22:
408:23:*/
409:24:
410:25:
411:26:/*
412:27:
413:28:File: 3dkit.c
414:29:
415:30:Comments or suggestions welcome.
416:31:
417:32:This 3D graphics tool prints an object in three dimensions on the screen.
418:33:The object must be made up of one or more surfaces passed in a structure.
419:34:The algorithm calculates the light intensity at each point and does a color
420:35:interpolation so that surfaces appear uniform with smooth colour
421:36:graduations.
422:37:
423:38:The TD_Object structure contains an array of surfaces comprising the object.
424:39:When printing, the surfaces are sorted from furthest to closest by
425:40:determining the distance from the eye point of their respective centres.
426:41:This removes hidden features.
427:42:
428:43:The points of a surface are assumed to form a contorted rectangular mesh
429:44:having a length and a width - the number of points along the longitudinal
430:45:edges and lateral edges respectively. Although the surfaces are restricted
431:46:to rectangles, they can be infinitely contorted into spheres, triangles
432:47:etc., possibly with a whole side compressed into a single point.
433:48:It is advisable however to make up complex surfaces out of several less
434:49:contorted surfaces so that the sorting routine can place the correct parts 
435:50:of the surface in front of one another. A sphere for example can be
436:51:defined as eight surfaces, each a triangular octant.
437:52:
438:53:Besides defining each 3D coord point of each surface array, the user must
439:54:also define the unit normal at each point. so that shading can be calculated.
440:55:The function TD_initcolor may be called to do this for you.
441:56:
442:57:The surfaces are drawn on the screen using one of the following methods.
443:58:The integer surf.render determines the method.
444:59:
445:60:0 : Interpolated trangles are drawn with each rectangle outlined.
446:61:1 : A wire frame is drawn of the edges of the surface only.
447:62:2 : Interpolated triangles only.
448:63:3 : Mesh - each rectangle outlined only.
449:64:
450:65:The demo planukit.c demostrates usage in detail.
451:66:
452:67:This code represents a complete re-write of the previous version, which
453:68:I wrote when I was first learning C (an excuse). It is far more structured,
454:69:efficient and readable. An important additional feature is that the 3D
455:70:camera position can now be defined, so that this code can be used as a
456:71:VR tool. Hence an object can be displayed as an object at the screen
457:72:centre, or as a 3D world. (See plane.h for how to modify the demo).
458:73:
459:74:
460:75:*/
461:76:
462:77:
463:78:#define TD_MULCONSTANT 4096
464:79:
465:80:#include <config.h>
466:81:#include <math.h>
467:82:#include <stdlib.h>
468:83:#include <stdio.h>
469:84:#include <vgagl.h>
470:85:#include "3dkit.h"
471:86:
472:87:#define max(x,y)     (((x) > (y)) ? (x) : (y))
473:88:#define min(x,y)     (((x) < (y)) ? (x) : (y))
474:89:
475:90:
476:91:/*global for holding a surface temporarily:*/
477:92:TD_Short_Point *temp;
478:93:
479:94:
480:95:#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
481:96:
482:97:/* The optimisation comes from svgalib-1.2.9/gl/line.c: */
483:98:
484:99:/* Framebuffer Graphics Libary for Linux, Copyright 1993 Harm Hanemaayer */
485:100:/* line.c       Line drawing */
486:101:
487:102:#ifdef __alpha__
488:103:
489:104:static inline int muldiv64 (int m1, int m2, int d)
490:105:{
491:106:    return (long) m1 *(long) m2 / (long) d;
492:107:}
493:108:
494:109:#else
495:110:
496:111:#ifdef __i686__
497:112:
498:113:/* We use the 32-bit to 64-bit multiply and 64-bit to 32-bit divide of the */
499:114:/* 386 (which gcc doesn't know well enough) to efficiently perform integer */
500:115:/* scaling without having to worry about overflows. */
501:116:
502:117:static inline int muldiv64 (int m1, int m2, int d)
503:118:{
504:119:/* int32 * int32 -> int64 / int32 -> int32 */
505:120:    int result;
506:121:  __asm__ ("imull %%edx\n\t" "idivl %3\n\t":"=a" (result)
507:122:                                /* out */
508:123:  :         "a" (m1), "d" (m2), "g" (d) /* in */
509:124:  :         "ax", "dx"         /* mod */
510:125:        );
511:126:    return result;
512:127:}
513:128:
514:129:#else
515:130:
516:131:static inline int muldiv64 (int m1, int m2, int d)
517:132:{
518:133:    return (double) m1 *(double) m2 / ((double) d);
519:134:}
520:135:
521:136:#endif                          /* !__i386__ */
522:137:#endif                          /* !__alpha__ */
523:138:
524:139:#else
525:140:
526:141:#define muldiv64(a,b,c) ((long) ((double) a * (double) b / ((double) c)))
527:142:
528:143:#endif
529:144:
530:145:void TD_translate (TD_Solid * s, TD_Point * p, TD_Short_Point * scr)
531:146:{
532:147:/* the following rotational transformation avoids floating point
533:148:   calculations entirely */
534:149:
535:150:    if (s->option_flags & TDOPTION_32BIT_SURFACES) {
536:151:/* for super accuracy */
537:152:        double x = p->x + s->x_cam;
538:153:        double y = p->y + s->y_cam;
539:154:        double z = p->z + s->z_cam;
540:155:        double yt = x * s->a21 + y * s->a22 + z * s->a23 + s->s_cam;
541:156:
542:157:        if (yt < 1) {
543:158:            scr->x = scr->y = 32767;
544:159:            return;
545:160:        } else {
546:161:            double xt = x * s->a11 + y * s->a12 + z * s->a13;
547:162:            double zt = x * s->a31 + y * s->a32 + z * s->a33;
548:163:            scr->x =
549:164:                ((long) ((double) s->posx + xt * s->xscale / yt)) >> 16;
550:165:            scr->y =
551:166:                ((long) ((double) s->posy - zt * s->yscale / yt)) >> 16;
552:167:            return;
553:168:        }
554:169:    } else {
555:170:        long x = p->x + s->x_cam;
556:171:        long y = p->y + s->y_cam;
557:172:        long z = p->z + s->z_cam;
558:173:        long yt = x * s->a21 + y * s->a22 + z * s->a23 + s->s_cam;
559:174:
560:175:/*(FIXME:) There may be problems if yt overflows, this just checks if the point
561:176:   is behind the cam: */
562:177:        if (yt < 1) {
563:178:            scr->x = scr->y = 32767; /*line and triangle routines must 
564:179:                                        reject these values. */
565:180:            return;
566:181:        } else {
567:182:            long xt = x * s->a11 + y * s->a12 + z * s->a13;
568:183:            long zt = x * s->a31 + y * s->a32 + z * s->a33;
569:184:            scr->x = s->posx + muldiv64 (xt, s->xscale, yt);
570:185:            scr->y = s->posy - muldiv64 (zt, s->yscale, yt);
571:186:            return;
572:187:        }
573:188:    }
574:189:}
575:190:
576:191:
577:192:
578:193:long TD_finddistance (TD_Solid * s, TD_Point * p)
579:194:{
580:195:/* the following rotational transformation avoids floating point
581:196:   calculations entirely */
582:197:
583:198:    if (s->option_flags & TDOPTION_32BIT_SURFACES) {
584:199:/* for super accuracy */
585:200:        double x = p->x + s->x_cam;
586:201:        double y = p->y + s->y_cam;
587:202:        double z = p->z + s->z_cam;
588:203:        return ((long)
589:204:                ((double) x * s->a21 + y * s->a22 + z * s->a23 +
590:205:                 s->s_cam)) >> 16;
591:206:    } else {
592:207:        long x = p->x + s->x_cam;
593:208:        long y = p->y + s->y_cam;
594:209:        long z = p->z + s->z_cam;
595:210:        return (x * s->a21 + y * s->a22 + z * s->a23 + s->s_cam);
596:211:    }
597:212:}
598:213:
599:214:
600:215:
601:216:long TD_findcolor (TD_Solid * s, TD_Point * p, int which)
602:217:{
603:218:    long c, shadow = s->surf[which].shadow;
604:219:
605:220:    /*this you can fool around with to get different shadowing effects. */
606:221:    /*c starts off as a signed 28 bit integer. Brightest = -2^28, darkest = +2^28 */
607:222:
608:223:    if (s->option_flags & TDOPTION_LIGHT_SOURCE_CAM) {
609:224:/* do product of translated normal vector with lighting vector: */
610:225:        c = ((p->dirx * s->a11 + p->diry * s->a12 +
611:226:              p->dirz * s->a13) * s->xlight + (p->dirx * s->a21 +
612:227:                                               p->diry * s->a22 +
613:228:                                               p->dirz * s->a23) *
614:229:             s->ylight + (p->dirx * s->a31 + p->diry * s->a32 +
615:230:                          p->dirz * s->a33) * s->zlight);
616:231:        c = (c >> 20) + 256;
617:232:    } else {
618:233:        c = p->dirx * s->xlight +
619:234:            p->diry * s->ylight + p->dirz * s->zlight;
620:235:        c = (c >> 8) + 256;
621:236:    }
622:237:
623:238:    /*c now 9 bits */
624:239:
625:240:/*
626:241:    c = s->surf[which].maxcolor
627:242:        - ((c * c) >> (16 - s->surf[which].depth_per_color));
628:243:*/
629:244:    /*:responds quadratically to light or. */
630:245:
631:246:    c = s->surf[which].maxcolor -
632:247:        (c >> (8 - s->surf[which].depth_per_color));
633:248:
634:249:    /*:responds linearly to light. */
635:250:
636:251:    if (c < shadow)
637:252:        return shadow;
638:253:    else
639:254:        return c;
640:255:}
641:256:
642:257:
643:258:void TD_calc_rotation_matrix (TD_Solid * s)
644:259:{
645:260:/* This matrix comes from "Dynamics of Atmospheric Flight" by Bernard Etkin,
646:261:   John Wiley & Sons, Inc., and is much easier to copy down than to 
647:262:   derive yourself. */
648:263:
649:264:    float tsi = s->alpha, theta = s->beta, phi = s->gamma;
650:265:
651:266:    s->a22 = (float) TD_MULCONSTANT *(cos (theta) * cos (tsi));
652:267:    s->a21 = (float) TD_MULCONSTANT *(cos (theta) * sin (tsi));
653:268:    s->a23 = (float) TD_MULCONSTANT *(-sin (theta));
654:269:
655:270:    s->a12 =
656:271:        (float) TD_MULCONSTANT *(sin (phi) * sin (theta) * cos (tsi) -
657:272:                                 cos (phi) * sin (tsi));
658:273:    s->a11 =
659:274:        (float) TD_MULCONSTANT *(sin (phi) * sin (theta) * sin (tsi) +
660:275:                                 cos (phi) * cos (tsi));
661:276:    s->a13 = (float) TD_MULCONSTANT *(sin (phi) * cos (theta));
662:277:
663:278:    s->a32 =
664:279:        (float) TD_MULCONSTANT *(cos (phi) * sin (theta) * cos (tsi) +
665:280:                                 sin (phi) * sin (tsi));
666:281:    s->a31 =
667:282:        (float) TD_MULCONSTANT *(cos (phi) * sin (theta) * sin (tsi) -
668:283:                                 sin (phi) * cos (tsi));
669:284:    s->a33 = (float) TD_MULCONSTANT *(cos (phi) * cos (theta));
670:285:
671:286:/* this is the classical rotations matrix of aerodynamics */
672:287:/*
673:288:    s->a11 = (float) TD_MULCONSTANT * (cos (s->alpha) * cos (s->gamma));
674:289:    s->a12 = (float) TD_MULCONSTANT * (cos (s->alpha) * sin (s->gamma));
675:290:    s->a13 = (float) TD_MULCONSTANT * (-sin (s->alpha));
676:291:
677:292:    s->a21 = (float) TD_MULCONSTANT * (sin (s->beta) * sin (s->alpha) * cos (s->gamma) - cos (s->beta) * sin (s->gamma));
678:293:    s->a22 = (float) TD_MULCONSTANT * (sin (s->beta) * sin (s->alpha) * sin (s->gamma) - cos (s->beta) * cos (s->gamma));
679:294:    s->a23 = (float) TD_MULCONSTANT * (sin (s->beta) * cos (s->alpha));
680:295:
681:296:    s->a31 = (float) TD_MULCONSTANT * (cos (s->beta) * sin (s->alpha) * cos (s->gamma) + sin (s->beta) * sin (s->gamma));
682:297:    s->a32 = (float) TD_MULCONSTANT * (cos (s->beta) * sin (s->alpha) * sin (s->gamma) + sin (s->beta) * cos (s->gamma));
683:298:    s->a33 = (float) TD_MULCONSTANT * (cos (s->beta) * cos (s->alpha));
684:299:*/
685:300:
686:301:/*results are 14 bit + sign integers*/
687:302:}
688:303:
689:304:
690:305:void TD_drawwire (TD_Solid * s, int which)
691:306:{
692:307:    TD_Surface *surf = &s->surf[which];
693:308:    int w = surf->w;
694:309:    int l = surf->l;
695:310:    int i = 0, j = 0, c = surf->mesh_color;
696:311:    void (*dl) (int, int, int, int, int) = s->draw_line;
697:312:
698:313:    while (j < w - 1)
699:314:        TD_translate (s, &surf->point[j++], &temp[i++]);
700:315:
701:316:    while (j < (w * l - 1)) {
702:317:        TD_translate (s, &surf->point[j], &temp[i++]);
703:318:        j += w;
704:319:    }
705:320:
706:321:    while (j > w * (l - 1))
707:322:        TD_translate (s, &surf->point[j--], &temp[i++]);
708:323:
709:324:    while (j >= 0) {
710:325:        TD_translate (s, &surf->point[j], &temp[i++]);
711:326:        j -= w;
712:327:    }
713:328:
714:329:    for (j = 0; j < i - 1; j++) {
715:330:        (*dl) (temp[j].x, temp[j].y, temp[j + 1].x, temp[j + 1].y, c);
716:331:
717:332:    }
718:333:}
719:334:
720:335:
721:336:void TD_drawmesh (TD_Solid * s, int which)
722:337:{
723:338:    TD_Surface *surf = &s->surf[which];
724:339:    int w = surf->w;
725:340:    int l = surf->l;
726:341:    int i = 0, j = 0, k = 0, c = surf->mesh_color;
727:342:    void (*dl) (int, int, int, int, int) = s->draw_line;
728:343:
729:344:    while (j < l * w) {
730:345:        TD_translate (s, &surf->point[j], &temp[j]);
731:346:        j++;
732:347:    }
733:348:
734:349:    for (j = 0; j < l - 1; j++, k++) {
735:350:        for (i = 0; i < w - 1; i++, k++) {
736:351:            (*dl) (temp[k + 1].x, temp[k + 1].y, temp[k].x, temp[k].y, c);
737:352:            (*dl) (temp[k + w].x, temp[k + w].y, temp[k].x, temp[k].y, c);
738:353:        }
739:354:        (*dl) (temp[k + w].x, temp[k + w].y, temp[k].x, temp[k].y, c);
740:355:
741:356:    }
742:357:
743:358:    for (i = 0; i < w - 1; i++, k++)
744:359:        (*dl) (temp[k + 1].x, temp[k + 1].y, temp[k].x, temp[k].y, c);
745:360:
746:361:}
747:362:
748:363:
749:364:void xchg (int *a, int *b)
750:365:{
751:366:    int t = *a;
752:367:    *a = *b;
753:368:    *b = t;
754:369:}
755:370:
756:371:
757:372:void TD_drawsurface (TD_Solid * s, int which)
758:373:{
759:374:
760:375:    TD_Surface *surf = &s->surf[which];
761:376:    int w = surf->w;
762:377:    int l = surf->l;
763:378:    int i = 0, j = 0, k = 0, c = surf->mesh_color;
764:379:    void (*dl) (int, int, int, int, int) = s->draw_line;
765:380:    void (*dt) (int, int, int, int, int, int, int, int, int, int) =
766:381:        s->draw_triangle;
767:382:    void (*ds) (int, int, int, int, int, int, int, int) =
768:383:        s->draw_striangle;
769:384:    int mesh;
770:385:    long d1, d2, d3, d4, d;
771:386:    long x1, y1, c1;
772:387:    long x2, y2, c2;
773:388:    long x3, y3, c3;
774:389:    long x4, y4, c4;
775:390:    int furthest, clockwise = 0;
776:391:    TD_tridata tri;
777:392:
778:393:    tri.bitmap1 = surf->bitmap1;
779:394:    tri.bitmap2 = surf->bitmap2;
780:395:
781:396:    if (s->option_flags & TDOPTION_ALL_SAME_RENDER)
782:397:        mesh = (s->render == TD_MESH_AND_SOLID);
783:398:    else
784:399:        mesh = (surf->render == TD_MESH_AND_SOLID);
785:400:
786:401:/*distance of four corners (numbered clockwise): */
787:402:    d1 = TD_finddistance (s, &surf->point[0]);
788:403:    d2 = TD_finddistance (s, &surf->point[w - 1]);
789:404:    d3 = TD_finddistance (s, &surf->point[w * l - 1]);
790:405:    d4 = TD_finddistance (s, &surf->point[w * (l - 1)]);
791:406:
792:407:/*find furthest point */
793:408:    furthest = 1;
794:409:
795:410:    d = d1;
796:411:
797:412:    if (d2 > d) {
798:413:        furthest = 2;
799:414:        d = d2;
800:415:    }
801:416:    if (d3 > d) {
802:417:        furthest = 3;
803:418:        d = d3;
804:419:    }
805:420:    if (d4 > d)
806:421:        furthest = 4;
807:422:
808:423:
809:424:/*draw scanning from the furthest point to the second furthest point */
810:425:/*there are eight possibilities: */
811:426:
812:427:    switch (furthest) {
813:428:    case 1:
814:429:        if (d2 > d4) {
815:430:            clockwise = 0;
816:431:            for (j = 0; j < l; j++)
817:432:                for (i = 0; i < w; i++) {
818:433:                    TD_translate (s, &surf->point[i + j * w], &temp[k]);
819:434:                    temp[k].c =
820:435:                        TD_findcolor (s, &surf->point[i + j * w], which);
821:436:                    k++;
822:437:                }
823:438:        } else {
824:439:            xchg (&l, &w);
825:440:            clockwise = 1;
826:441:            for (j = 0; j < l; j++)
827:442:                for (i = 0; i < w; i++) {
828:443:                    TD_translate (s, &surf->point[i * l + j], &temp[k]);
829:444:                    temp[k].c =
830:445:                        TD_findcolor (s, &surf->point[i * l + j], which);
831:446:                    k++;
832:447:                }
833:448:        }
834:449:        break;
835:450:
836:451:    case 2:
837:452:        if (d1 > d3) {
838:453:            clockwise = 1;
839:454:            for (j = 0; j < l; j++)
840:455:                for (i = w - 1; i >= 0; i--) {
841:456:                    TD_translate (s, &surf->point[i + j * w], &temp[k]);
842:457:                    temp[k].c =
843:458:                        TD_findcolor (s, &surf->point[i + j * w], which);
844:459:                    k++;
845:460:                }
846:461:        } else {
847:462:            xchg (&l, &w);
848:463:            clockwise = 0;
849:464:            for (j = l - 1; j >= 0; j--)
850:465:                for (i = 0; i < w; i++) {
851:466:                    TD_translate (s, &surf->point[i * l + j], &temp[k]);
852:467:                    temp[k].c =
853:468:                        TD_findcolor (s, &surf->point[i * l + j], which);
854:469:                    k++;
855:470:                }
856:471:        }
857:472:        break;
858:473:
859:474:    case 3:
860:475:        if (d4 > d2) {
861:476:            clockwise = 0;
862:477:            for (j = l - 1; j >= 0; j--)
863:478:                for (i = w - 1; i >= 0; i--) {
864:479:                    TD_translate (s, &surf->point[i + j * w], &temp[k]);
865:480:                    temp[k].c =
866:481:                        TD_findcolor (s, &surf->point[i + j * w], which);
867:482:                    k++;
868:483:                }
869:484:        } else {
870:485:            xchg (&l, &w);
871:486:            clockwise = 1;
872:487:            for (j = l - 1; j >= 0; j--)
873:488:                for (i = w - 1; i >= 0; i--) {
874:489:                    TD_translate (s, &surf->point[i * l + j], &temp[k]);
875:490:                    temp[k].c =
876:491:                        TD_findcolor (s, &surf->point[i * l + j], which);
877:492:                    k++;
878:493:                }
879:494:        }
880:495:        break;
881:496:
882:497:    case 4:
883:498:        if (d3 > d1) {
884:499:            clockwise = 1;
885:500:            for (j = l - 1; j >= 0; j--)
886:501:                for (i = 0; i < w; i++) {
887:502:                    TD_translate (s, &surf->point[i + j * w], &temp[k]);
888:503:                    temp[k].c =
889:504:                        TD_findcolor (s, &surf->point[i + j * w], which);
890:505:                    k++;
891:506:                }
892:507:        } else {
893:508:            xchg (&l, &w);
894:509:            clockwise = 0;
895:510:            for (j = 0; j < l; j++)
896:511:                for (i = w - 1; i >= 0; i--) {
897:512:                    TD_translate (s, &surf->point[i * l + j], &temp[k]);
898:513:                    temp[k].c =
899:514:                        TD_findcolor (s, &surf->point[i * l + j], which);
900:515:                    k++;
901:516:                }
902:517:        }
903:518:        break;
904:519:    }
905:520:
906:521:    if (!surf->backfacing)
907:522:        clockwise = 2;
908:523:
909:524:    for (k = 0, j = 0; j < l - 1; j++, k++) {
910:525:        for (i = 0; i < w - 1; i++, k++) {
911:526:
912:527:/*define the grid square we are currently drawing: */
913:528:            x1 = temp[k].x;
914:529:            y1 = temp[k].y;
915:530:            c1 = temp[k].c;
916:531:
917:532:            x2 = temp[k + 1].x;
918:533:            y2 = temp[k + 1].y;
919:534:            c2 = temp[k + 1].c;
920:535:
921:536:            x3 = temp[k + w + 1].x;
922:537:            y3 = temp[k + w + 1].y;
923:538:            c3 = temp[k + w + 1].c;
924:539:
925:540:            x4 = temp[k + w].x;
926:541:            y4 = temp[k + w].y;
927:542:            c4 = temp[k + w].c;
928:543:
929:544:            /*draw with two triangles */
930:545:
931:546:
932:547:
933:548:
934:549:            if (furthest & 1) { /*draw with hypotenuse from point 1 to point 3 */
935:550:                if (s->option_flags & TDOPTION_FLAT_TRIANGLE) {
936:551:                    c1 = (c1 + c2 + c3 + c4) >> 2;
937:552:                    (*ds) (x1, y1, x2, y2, x3, y3, c1, clockwise);
938:553:                    (*ds) (x1, y1, x3, y3, x4, y4, c1, clockwise);
939:554:                } else {
940:555:                    (*dt) (x1, y1, c1, x2, y2, c2, x3, y3, c3, clockwise);
941:556:                    (*dt) (x1, y1, c1, x3, y3, c3, x4, y4, c4, clockwise);
942:557:                }
943:558:            } else {            /*draw with hypotenuse from point 2 to point 4 */
944:559:                if (s->option_flags & TDOPTION_FLAT_TRIANGLE) {
945:560:                    c1 = (c1 + c2 + c3 + c4) >> 2;
946:561:                    (*ds) (x1, y1, x2, y2, x4, y4, c1, clockwise);
947:562:                    (*ds) (x2, y2, x3, y3, x4, y4, c1, clockwise);
948:563:                } else {
949:564:                    (*dt) (x1, y1, c1, x2, y2, c2, x4, y4, c4, clockwise);
950:565:                    (*dt) (x2, y2, c2, x3, y3, c3, x4, y4, c4, clockwise);
951:566:                }
952:567:            }
953:568:
954:569:            if (mesh) {
955:570:                (*dl) (x1, y1, x2, y2, c);
956:571:                (*dl) (x1, y1, x4, y4, c);
957:572:            }
958:573:        }
959:574:        if (mesh)
960:575:            (*dl) (temp[k + w].x, temp[k + w].y, temp[k].x, temp[k].y, c);
961:576:    }
962:577:
963:578:    if (mesh) {
964:579:        for (i = 0; i < w - 1; i++, k++)
965:580:            (*dl) (temp[k + 1].x, temp[k + 1].y, temp[k].x, temp[k].y, c);
966:581:    }
967:582:}
968:583:
969:584:
970:585:int compare (const void *vp, const void *vq)
971:586:{
972:587:    const int *p = vp;
973:588:    const int *q = vq;
974:589:    int diff = *p - *q;
975:590:    return ((diff >= 0) ? ((diff > 0) ? -1 : 0) : +1);
976:591:}
977:592:
978:593:struct disttype {
979:594:    long distance;
980:595:    int number;
981:596:};
982:597:
983:598:
984:599:void TD_draw_solid (TD_Solid * s)
985:600:{
986:601:    int n = s->num_surfaces, w, l, i, j, render, num_existing_surfaces;
987:602:    long max = 0;
988:603:
989:604:    struct disttype *sortarray = NULL;
990:605:    temp = NULL;
991:606:
992:607:    gl_trisetdrawpoint (s->draw_point);
993:608:
994:609:    if ((sortarray =
995:610:         malloc (s->num_surfaces * sizeof (struct disttype))) == NULL) {
996:611:        fprintf (stderr, "1. Error allocating memory.\n");
997:612:        goto fin;
998:613:    }
999:614:    if (s->option_flags & TDOPTION_INIT_ROTATION_MATRIX)
1000:615:        TD_calc_rotation_matrix (s);
1001:616:
1002:617:    for (j = 0, i = 0; i < n; i++) {
1003:618:        if ((s->surf[i].point)) {
1004:619:            sortarray[j++].number = i;
1005:620:            w = s->surf[i].w;
1006:621:            if (max < w)
1007:622:                max = w;
1008:623:            l = s->surf[i].l;   /*find the largest surface */
1009:624:            if (max < l)
1010:625:                max = l;
1011:626:        }
1012:627:    }
1013:628:
1014:629:    num_existing_surfaces = j;
1015:630:    if (!num_existing_surfaces)
1016:631:        goto fin;
1017:632:
1018:633:    if (s->option_flags & TDOPTION_SORT_SURFACES) {
1019:634:        for (j = 0, i = 0; i < n; i++) {
1020:635:            if ((s->surf[i].point)) {
1021:636:                sortarray[j++].distance =
1022:637:                    TD_finddistance (s, &s->surf[i].point[s->surf[i].w / 2
1023:638:                                                          +
1024:639:                                                          s->surf[i].w *
1025:640:                                                          (s->surf[i].l /
1026:641:                                                           2)]);
1027:642:                /*the distance of the middle point of the surface */
1028:643:            }
1029:644:        }
1030:645:        qsort (sortarray, num_existing_surfaces, sizeof (struct disttype),
1031:646:               compare);
1032:647:    }
1033:648:
1034:649:    max++;
1035:650:
1036:651:    if ((temp = malloc (max * max * sizeof (TD_Short_Point))) == NULL) {
1037:652:        fprintf (stderr, "2. Error allocating memory.\n");
1038:653:        goto fin;
1039:654:    }
1040:655:    if (s->option_flags & TDOPTION_ROTATE_OBJECT) {
1041:656:        s->x_cam = 0;
1042:657:        s->y_cam = 0;
1043:658:        s->z_cam = 0;
1044:659:        s->s_cam = s->distance * TD_MULCONSTANT;
1045:660:    } else {
1046:661:        s->s_cam = 0;
1047:662:    }
1048:663:
1049:664:
1050:665:    for (i = 0; i < num_existing_surfaces; i++) {
1051:666:        if (s->option_flags & TDOPTION_ALL_SAME_RENDER)
1052:667:            render = s->render;
1053:668:        else
1054:669:            render = s->surf[sortarray[i].number].render;
1055:670:
1056:671:        switch (render) {
1057:672:        case TD_SOLID:
1058:673:        case TD_MESH_AND_SOLID:
1059:674:            if ((long) s->surf[sortarray[i].number].bitmap1
1060:675:                | (long) s->surf[sortarray[i].number].bitmap2)
1061:676:                TD_drawwrapsurface (s, sortarray[i].number);
1062:677:            else
1063:678:                TD_drawsurface (s, sortarray[i].number);
1064:679:            break;
1065:680:        case TD_EDGES_ONLY:
1066:681:            TD_drawwire (s, sortarray[i].number);
1067:682:            break;
1068:683:        case TD_MESH:
1069:684:            TD_drawmesh (s, sortarray[i].number);
1070:685:            break;
1071:686:        default:
1072:687:            TD_drawmesh (s, sortarray[i].number);
1073:688:        }
1074:689:    }
1075:690:
1076:691:  fin:
1077:692:
1078:693:    if (temp)
1079:694:        free (temp);
1080:695:    if (sortarray)
1081:696:        free (sortarray);
1082:697:
1083:698:}
1084:1:/*
1085:2:
1086:3:    3DKIT   version   1.2
1087:4:    High speed 3D graphics and rendering library for Linux.
1088:5:
1089:6:    Copyright (C) 1996  Paul Sheer   psheer@hertz.mech.wits.ac.za
1090:7:
1091:8:    This library is free software; you can redistribute it and/or
1092:9:    modify it under the terms of the GNU Library General Public
1093:10:    License as published by the Free Software Foundation; either
1094:11:    version 2 of the License, or (at your option) any later version.
1095:12:
1096:13:    This library is distributed in the hope that it will be useful,
1097:14:    but WITHOUT ANY WARRANTY; without even the implied warranty of
1098:15:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
1099:16:    Library General Public License for more details.
1100:17:
1101:18:    You should have received a copy of the GNU Library General Public
1102:19:    License along with this library; if not, write to the Free
1103:20:    Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
1104:21:    MA 02111-1307, USA
1105:22:
1106:23:*/
1107:24:
1108:25:
1109:26:/*
1110:27:
1111:28:File 3dkit.h
1112:29:
1113:30:*/
1114:31:
1115:32:#ifndef THREEDKIT_H
1116:33:#define THREEDKIT_H 1
1117:34:
1118:35:#include "triangle.h"
1119:36:
1120:37:#define TD_DEFAULT_MAXCOLOR 63
1121:38:#define TD_DEFAULT_COLOR 0
1122:39:#define TD_DEFAULT_SHADOW 7
1123:40:
1124:41:#define TD_MESH 1
1125:42:#define TD_MESH_AND_SOLID 2
1126:43:#define TD_SOLID 3
1127:44:#define TD_EDGES_ONLY 4
1128:45:#define TD_PI 3.14159
1129:46:#define TDOPTION_INIT_ROTATION_MATRIX 1
1130:47:#define TDOPTION_ALL_SAME_RENDER 2
1131:48:#define TDOPTION_SORT_SURFACES 4
1132:49:
1133:50:/*Two ways to display the object:
1134:51:1. Angles refer to camera view; camera position is specified 
1135:52:        in x_cam, y_cam, z_cam.
1136:53:2. Origin at screen centre; object s_cam away; angles refer to
1137:54:        rotation of object:*/
1138:55:#define TDOPTION_ROTATE_OBJECT 8
1139:56:
1140:57:/* Tells that the surface data are signed 32 bit values.
1141:58:   otherwise ussumes 16 bit values.
1142:59:   This can be used to avoid working with cumbersome 32 bits 
1143:60:   unless the surface arrays have some other use and need the
1144:61:   accuracy, eg. CAD.
1145:62:   If set, distance x_cam, y_cam and z_cam are also treated as 32 bit.
1146:63:   (32/16 bit has nothing to do with the code itself) */
1147:64:#define TDOPTION_32BIT_SURFACES 16
1148:65:
1149:66:/* The light source is relative to the angle of the camera: */
1150:67:#define TDOPTION_LIGHT_SOURCE_CAM 32
1151:68:/* Otherwise it is fixed relative to the object. */
1152:69:
1153:70:/*use flat triangle instead of interpolated triangles (slight speed increase)*/
1154:71:#define TDOPTION_FLAT_TRIANGLE 64
1155:72:
1156:73:typedef struct {
1157:74:    long x;
1158:75:    long y;
1159:76:    long z;
1160:77:    long dirx;
1161:78:    long diry;
1162:79:    long dirz;
1163:80:} TD_Point;
1164:81:
1165:82:
1166:83:typedef struct {
1167:84:    int w;                      /*grid width and length */
1168:85:    int l;
1169:86:    int bitmapwidth;            /*bitmap width and length */
1170:87:    int bitmaplength;
1171:88:    int maxcolor;               /*There 256 colors divided into n scales.
1172:89:                                   maxcolor must point to the top of the scale you want
1173:90:                                   less a few for roundoff */
1174:91:    int shadow;                 /*must point to the bottom of the scale plus a few for roundoff
1175:92:                                   so that none of the previous scale is printed. */
1176:93:    int depth_per_color;        /*number of colors in a scale = depth_per_color ^ 2 */
1177:94:    int mesh_color;             /*color of mesh if mesh is drawn */
1178:95:    int render;                 /*how it must be rendered */
1179:96:    int backfacing;             /*enable backfacing */
1180:97:    unsigned char *bitmap1;     /*1 byte per pixel bitmap data: triangle front side */
1181:98:    unsigned char *bitmap2;     /*1 byte per pixel bitmap data: triangle back side */
1182:99:    TD_Point *point;            /*3D data and normals */
1183:100:} TD_Surface;
1184:101:
1185:102:
1186:103:typedef struct {
1187:104:    int num_surfaces;           /*number of surfaces */
1188:105:
1189:106:    TD_Surface *surf;           /*array of surfaces */
1190:107:
1191:108:    long a11, a12, a13;         /*rotation matrix */
1192:109:    long a21, a22, a23;
1193:110:    long a31, a32, a33;
1194:111:
1195:112:    float alpha, beta, gamma;   /*eulerian rotation angles in radians */
1196:113:
1197:114:    long xlight, ylight, zlight; /*lighting vector. Magnitude of this
1198:115:                                    vector must be less than 255 */
1199:116:
1200:117:    long xscale;                /*determines the size of the object */
1201:118:    long yscale;
1202:119:
1203:120:    long distance;              /* distance of the camera from origin (always 16 bit) */
1204:121:
1205:122:    long x_cam;                 /* position of the camera */
1206:123:    long y_cam;
1207:124:    long z_cam;
1208:125:
1209:126:    long s_cam;
1210:127:
1211:128:    int posx;                   /*position of camera optical axis on screen */
1212:129:    int posy;
1213:130:
1214:131:    long option_flags;
1215:132:
1216:133:    int render;                 /*if option ALL_SAME_RENDER is set then all surfaces are rendered
1217:134:                                   using this var. Else render is checked on each surface. */
1218:135:
1219:136:    void (*draw_point) (int, int, int);
1220:137:
1221:138:    void (*draw_wtriangle) (int, int, int, int, int,
1222:139:                            int, int, int, int, int,
1223:140:                            int, int, int, int, int, TD_tridata *);
1224:141:
1225:142:    void (*draw_swtriangle) (int, int, int, int,
1226:143:                             int, int, int, int,
1227:144:                             int, int, int, int, int, TD_tridata *);
1228:145:
1229:146:    void (*draw_striangle) (int, int, int, int, int, int, int, int);
1230:147:    void (*draw_triangle) (int, int, int, int, int, int, int, int, int,
1231:148:                           int);
1232:149:    void (*draw_line) (int, int, int, int, int);
1233:150:
1234:151:} TD_Solid;
1235:152:
1236:153:
1237:154:
1238:155:typedef struct {
1239:156:    long x;
1240:157:    long y;
1241:158:    int color;
1242:159:} TD_temppoint;
1243:160:
1244:161:
1245:162:/*used internally*/
1246:163:typedef struct {
1247:164:    long x, y, c, u, v;
1248:165:} TD_Short_Point;
1249:166:
1250:167:
1251:168:/*used internally*/
1252:169:void TD_translate (TD_Solid * s, TD_Point * p, TD_Short_Point * scr);
1253:170:long TD_finddistance (TD_Solid * s, TD_Point * p);
1254:171:long TD_findcolor (TD_Solid * s, TD_Point * p, int which);
1255:172:void TD_calc_rotation_matrix (TD_Solid * s);
1256:173:void TD_drawwire (TD_Solid * s, int which);
1257:174:void TD_drawmesh (TD_Solid * s, int which);
1258:175:void TD_drawsurface (TD_Solid * s, int which);
1259:176:void TD_drawwrapsurface (TD_Solid * s, int which);
1260:177:
1261:178:
1262:179:/*Draws a 3D solid object composed of a number of surfaces, with
1263:180:hidden surface elimination*/
1264:181:void TD_draw_solid (TD_Solid * s);
1265:182:
1266:183:/*initialises the color normal vectors to a surface*/
1267:184:void TD_initcolor (TD_Surface * surf, int n);
1268:185:
1269:186:
1270:187:#endif
1271:1:/*
1272:2:   Copyright (C) 1996 Paul Sheer
1273:3:
1274:4:   This program is free software; you can redistribute it and/or modify
1275:5:   it under the terms of the GNU General Public License as published by
1276:6:   the Free Software Foundation; either version 2 of the License, or
1277:7:   (at your option) any later version.
1278:8:
1279:9:   This program is distributed in the hope that it will be useful,
1280:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
1281:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
1282:12:   GNU General Public License for more details.
1283:13:
1284:14:   You should have received a copy of the GNU General Public License
1285:15:   along with this program; if not, write to the Free Software
1286:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
1287:17: */
1288:18:
1289:19:
1290:20:/* 3dtext */
1291:21:
1292:22:#include <config.h>
1293:23:#include <stdlib.h>
1294:24:#include <math.h>
1295:25:#include <my_string.h>
1296:26:#include <stdio.h>
1297:27:#include <stdarg.h>
1298:28:
1299:29:#include <X11/Xlib.h>
1300:30:#include <X11/Xutil.h>
1301:31:#include <X11/Xresource.h>
1302:32:
1303:33:#include "app_glob.c"
1304:34:#include "coolwidget.h"
1305:35:#include "widget3d.h"
1306:36:#include "quickmath.h"
1307:37:#include "dialog.h"
1308:38:
1309:39:/*
1310:40:
1311:41: this processes a text file into a 3d world
1312:42: the text file contains the following commands seperated
1313:43: by zero or more newlines. Charaacters after a # at the
1314:44: beginning of a line are ignored.
1315:45:
1316:46:
1317:47:# x, y, z, a, b, h, w, and c are floats. (x,y,z) is a vector.
1318:48:
1319:49:scale a
1320:50:# specifies the absolute value of the maximum extent of the scene in 3D space
1321:51:# (after offset has been subtracted (see next)). This must come first.
1322:52:
1323:53:offset x y z
1324:54:# specifies the a vector that is to be subtracted from the given position of
1325:55:# forthcoming object. Must also come before any drawing commands.
1326:56:
1327:57:cylinder x y z a b c r
1328:58:# draws a cylinder beginning at (a,b,c) ending at (a,b,c)+(x,y,z) of radius r
1329:59:
1330:60:cappedcylinder x y z a b c r
1331:61:# draws a cylinder beginning at (a,b,c) ending at (a,b,c)+(x,y,z) of radius r
1332:62:# with closed ends.
1333:63:
1334:64:surface a b x y z x y z x y z ... x y z
1335:65:# draws a surface of grid size a by b there must be a*b (x, y, z) points.
1336:66:
1337:67:trapezium x y z a b c u v w p q r
1338:68:# draws a trapezium with one corner at (x,y,z) and the other three at (x,y,z)+(a,b,c) etc.
1339:69:
1340:70:pipe r a x y z x y z x y z x y z ... x y z
1341:71:# draw a pipe with corners at (x,y,z) the pipe diameter is r and the corner radii are a
1342:72:* the first (x,y,z) is the start the last is the finish. Points mus be more than 2a appart
1343:73:
1344:74:cappedpipe  r a x y z x y z x y z x y z ... x y z
1345:75:# same with closed ends
1346:76:
1347:77:rectangle a b c x y z
1348:78:# rectangle with (height,width,depth) = (x,y,z), corner at (a,b,c)
1349:79:
1350:80:ellipse a b c x y z
1351:81:# an ellipse with (height,width,depth) = (x,y,z), centre at (a,b,c)
1352:82:
1353:83:density a
1354:84:# will set the density of the grid making up any of the specific surfaces above.
1355:85:# can be called before each surface command.
1356:86:
1357:87:*/
1358:88:
1359:89:/* globals: */
1360:90:
1361:91:int GridDensity = 6;
1362:92:double DimensionScale = 1;
1363:93:Vec DimensionOffset = { 0, 0, 0 };
1364:94:
1365:95:static inline void assignTD (TD_Point * p, Vec v)
1366:96:{
1367:97:    p->x = (double) (v.x + DimensionOffset.x) * DimensionScale;
1368:98:    p->y = (double) (v.y + DimensionOffset.y) * DimensionScale;
1369:99:    p->z = (double) (v.z + DimensionOffset.z) * DimensionScale;
1370:100:}
1371:101:
1372:102:
1373:103:
1374:104:
1375:105:static void third_cyl (double t, TD_Point * p, Vec A, Vec X, Vec r1,
1376:106:                       Vec r2, int g, double f)
1377:107:{
1378:108:    int i = 0;
1379:109:    double h;
1380:110:    double alpha = t;
1381:111:    Vec rv;
1382:112:    while (alpha < (2 * PI / 3 + t + 0.001)) {
1383:113:        for (h = 0; h <= 1; h += 0.5) {
1384:114:            rv = plus (plus
1385:115:                       (plus
1386:116:                        (times (r1, cos (alpha) * (1 + h * (f - 1))),
1387:117:                         times (r2, sin (alpha) * (1 + h * (f - 1)))), A),
1388:118:                       times (X, h));
1389:119:            assignTD (&(p[i]), rv);
1390:120:            i++;
1391:121:        }
1392:122:        alpha += (2 * PI / 3) / g;
1393:123:    }
1394:124:}
1395:125:
1396:126:
1397:127:
1398:128:void Cdraw3d_cone (const char *ident, double x, double y, double z,
1399:129:                   double a, double b, double c, double ra, double rb)
1400:130:{
1401:131:    int g = 4 * GridDensity / 3;
1402:132:    TD_Point *p = Cmalloc ((g + 1) * 3 * sizeof (TD_Point));
1403:133:    Vec r1;
1404:134:    Vec r2;
1405:135:    Vec A, X;
1406:136:    double f = rb / ra;
1407:137:    A.x = a;
1408:138:    A.y = b;
1409:139:    A.z = c;
1410:140:    X.x = x;
1411:141:    X.y = y;
1412:142:    X.z = z;
1413:143:
1414:144:    orth_vectors (X, &r1, &r2, ra);
1415:145:
1416:146:    third_cyl (0, p, A, X, r1, r2, g, f);
1417:147:    Cinit_surf_points (ident, 3, g + 1, p);
1418:148:    third_cyl (2 * PI / 3, p, A, X, r1, r2, g, f);
1419:149:    Cinit_surf_points (ident, 3, g + 1, p);
1420:150:    third_cyl (4 * PI / 3, p, A, X, r1, r2, g, f);
1421:151:    Cinit_surf_points (ident, 3, g + 1, p);
1422:152:
1423:153:    free (p);
1424:154:}
1425:155:
1426:156:
1427:157:
1428:158:
1429:159:void Cdraw3d_cylinder (const char *ident, double x, double y, double z,
1430:160:                       double a, double b, double c, double r)
1431:161:{
1432:162:    Cdraw3d_cone (ident, x, y, z, a, b, c, r, r);
1433:163:}
1434:164:
1435:165:
1436:166:
1437:167:void Cdraw3d_roundplate (const char *ident, double x, double y, double z,
1438:168:                         double a, double b, double c, double r)
1439:169:{
1440:170:    TD_Point *p = Cmalloc ((GridDensity * 4 + 1) * 2 * sizeof (TD_Point));
1441:171:    double alpha = 0;
1442:172:    Vec r1;
1443:173:    Vec r2;
1444:174:    Vec rv;
1445:175:    Vec A;
1446:176:    Vec X;
1447:177:    int i = 0;
1448:178:    A.x = a;
1449:179:    A.y = b;
1450:180:    A.z = c;
1451:181:    X.x = x;
1452:182:    X.y = y;
1453:183:    X.z = z;
1454:184:
1455:185:    orth_vectors (X, &r1, &r2, r);
1456:186:
1457:187:    while (alpha < (2 * PI + 0.001)) {
1458:188:        rv = plus (plus (times (r1, cos (alpha)), times (r2, sin (alpha))),
1459:189:                   A);
1460:190:        assignTD (&p[i], rv);
1461:191:        i++;
1462:192:        assignTD (&p[i], A);
1463:193:        i++;
1464:194:        alpha += (2 * PI) / (GridDensity * 4);
1465:195:    }
1466:196:    Cinit_surf_points (ident, 2, GridDensity * 4 + 1, p);
1467:197:    free (p);
1468:198:}
1469:199:
1470:200:
1471:201:void Cdraw3d_cappedcylinder (const char *ident, double x, double y,
1472:202:                             double z, double a, double b, double c,
1473:203:                             double r)
1474:204:{
1475:205:    Cdraw3d_cylinder (ident, x, y, z, a, b, c, r);
1476:206:    Cdraw3d_roundplate (ident, -x, -y, -z, a, b, c, r);
1477:207:    Cdraw3d_roundplate (ident, x, y, z, x + a, y + b, z + c, r);
1478:208:}
1479:209:
1480:210:
1481:211:void textformaterror (int line, const char *ident)
1482:212:{
1483:213:    Cerrordialog (CMain, 20, 20, " Compile text to 3D ",
1484:214:                  " A text format error was encounted at line %d,\nwhile trying to draw 3d item to widget %s.\n ",
1485:215:                  line, ident);
1486:216:}
1487:217:
1488:218:
1489:219:void Cdraw3d_scale (const char *ident, double a)
1490:220:{
1491:221:    DimensionScale = 32767 / a;
1492:222:}
1493:223:
1494:224:void Cdraw3d_offset (const char *ident, double x, double y, double z)
1495:225:{
1496:226:    DimensionOffset.x = x;
1497:227:    DimensionOffset.y = y;
1498:228:    DimensionOffset.z = z;
1499:229:}
1500:230:
1501:231:void Cdraw3d_density (const char *ident, double a)
1502:232:{
1503:233:    GridDensity = a;
1504:234:}
1505:235:
1506:236:void draw3d_surface (const char *ident, int w, int h, Vec * v)
1507:237:{
1508:238:    int i;
1509:239:    TD_Point *p = Cmalloc (w * h * sizeof (TD_Point));
1510:240:    for (i = 0; i < w * h; i++)
1511:241:        assignTD (&p[i], v[i]);
1512:242:    Cinit_surf_points (ident, w, h, p);
1513:243:    free (p);
1514:244:}
1515:245:
1516:246:
1517:247:void Cdraw3d_surface (const char *ident, int w, int h, ...)
1518:248:{
1519:249:    va_list pa;
1520:250:    int i;
1521:251:    TD_Point *p = Cmalloc (w * h * sizeof (TD_Point));
1522:252:
1523:253:    va_start (pa, h);
1524:254:    for (i = 0; i < w * h; i++) {
1525:255:        p[i].x = va_arg (pa, double);
1526:256:        p[i].y = va_arg (pa, double);
1527:257:        p[i].z = va_arg (pa, double);
1528:258:        p[i].dirx = 0;
1529:259:        p[i].diry = 0;
1530:260:        p[i].dirz = 0;
1531:261:    }
1532:262:    va_end (pa);
1533:263:    Cinit_surf_points (ident, w, h, p);
1534:264:    free (p);
1535:265:}
1536:266:
1537:267:
1538:268:
1539:269:
1540:270:
1541:271:static void fxchg (double *a, double *b)
1542:272:{
1543:273:    double t = *a;
1544:274:    *a = *b;
1545:275:    *b = t;
1546:276:}
1547:277:
1548:278:
1549:279:void initellipsoidpart (TD_Point * p, double x, double y, double z,
1550:280:                        double a, double b, double c, int w, int dir,
1551:281:                        double f)
1552:282:{
1553:283:    int i, j;
1554:284:    Vec v;
1555:285:    double r;
1556:286:    int d = 2 * w + 1;
1557:287:    Vec X;
1558:288:    X.x = x;
1559:289:    X.y = y;
1560:290:    X.z = z;
1561:291:
1562:292:
1563:293:    for (i = -w; i <= w; i++)
1564:294:        for (j = -w; j <= w; j++) {
1565:295:            v.x = (double) j / w;
1566:296:            v.y = (double) i / w;
1567:297:            v.z = 1;
1568:298:
1569:299:            switch (dir) {
1570:300:            case 0:
1571:301:                v.z = -v.z;
1572:302:                fxchg (&v.x, &v.y);
1573:303:                break;
1574:304:            case 1:
1575:305:                v.y = -v.y;
1576:306:                fxchg (&v.x, &v.z);
1577:307:                break;
1578:308:            case 2:
1579:309:                v.z = -v.z;
1580:310:                fxchg (&v.x, &v.z);
1581:311:                break;
1582:312:            case 3:
1583:313:                v.y = -v.y;
1584:314:                fxchg (&v.y, &v.z);
1585:315:                break;
1586:316:            case 4:
1587:317:                v.z = -v.z;
1588:318:                fxchg (&v.y, &v.z);
1589:319:                break;
1590:320:            }
1591:321:
1592:322:            r = norm (v);
1593:323:            v.x *= (f + (1 - f) / r) * a;
1594:324:            v.y *= (f + (1 - f) / r) * b;
1595:325:            v.z *= (f + (1 - f) / r) * c;
1596:326:
1597:327:            assignTD (&p[i + w + (j + w) * d], plus (v, X));
1598:328:        }
1599:329:}
1600:330:
1601:331:void Cdraw3d_ellipsoid (const char *ident, double x, double y, double z,
1602:332:                        double a, double b, double c, double f)
1603:333:{
1604:334:    int w = GridDensity / 2;
1605:335:    int g = 2 * w + 1;
1606:336:    TD_Point *p = Cmalloc (g * g * sizeof (TD_Point));
1607:337:
1608:338:    initellipsoidpart (p, x, y, z, a, b, c, w, 0, f);
1609:339:    Cinit_surf_points (ident, g, g, p);
1610:340:    initellipsoidpart (p, x, y, z, a, b, c, w, 1, f);
1611:341:    Cinit_surf_points (ident, g, g, p);
1612:342:    initellipsoidpart (p, x, y, z, a, b, c, w, 2, f);
1613:343:    Cinit_surf_points (ident, g, g, p);
1614:344:    initellipsoidpart (p, x, y, z, a, b, c, w, 3, f);
1615:345:    Cinit_surf_points (ident, g, g, p);
1616:346:    initellipsoidpart (p, x, y, z, a, b, c, w, 4, f);
1617:347:    Cinit_surf_points (ident, g, g, p);
1618:348:    initellipsoidpart (p, x, y, z, a, b, c, w, 5, f);
1619:349:    Cinit_surf_points (ident, g, g, p);
1620:350:    free (p);
1621:351:}
1622:352:
1623:353:void Cdraw3d_cappedcone (const char *ident, double x, double y, double z,
1624:354:                         double a, double b, double c, double ra,
1625:355:                         double rb)
1626:356:{
1627:357:    Cdraw3d_cone (ident, x, y, z, a, b, c, ra, rb);
1628:358:    Cdraw3d_roundplate (ident, -x, -y, -z, a, b, c, ra);
1629:359:    Cdraw3d_roundplate (ident, x, y, z, x + a, y + b, z + c, rb);
1630:360:}
1631:361:
1632:362:
1633:363:void Cdraw3d_rectangle (const char *ident, double x, double y, double z,
1634:364:                        double a, double b, double c)
1635:365:{
1636:366:    Cdraw3d_ellipsoid (ident, x, y, z, a, b, c, 1);
1637:367:}
1638:368:
1639:369:
1640:370:void Cdraw3d_sphere (const char *ident, double x, double y, double z,
1641:371:                     double r)
1642:372:{
1643:373:    Cdraw3d_ellipsoid (ident, x, y, z, r, r, r, 0);
1644:374:}
1645:375:
1646:376:
1647:377:/* returns -1 on error, zero on success */
1648:378:int Cdraw3d_from_text (const char *ident, const char *text)
1649:379:{
1650:380:    char *p = (char *) text;
1651:381:    int line = 1;
1652:382:    double x, y, z, a, b, c, r, r2;
1653:383:    Vec *v;
1654:384:    int w, h, i, k;
1655:385:
1656:386:    do {
1657:387:        p += strspn (p, " \t\r");
1658:388:        if (!*p)
1659:389:            break;
1660:390:        if (*p == '#' || *p == '\n') {
1661:391:            /* comment, do nothing */ ;
1662:392:        } else if (!strncmp (p, "scale ", 6)) {
1663:393:            if (sscanf (p, "scale %lf", &x) == 1)
1664:394:                Cdraw3d_scale (ident, x);
1665:395:            else {
1666:396:                textformaterror (line, ident);
1667:397:                return -1;
1668:398:            }
1669:399:        } else if (!strncmp (p, "offset ", 7)) {
1670:400:            if (sscanf (p, "offset %lf %lf %lf", &x, &y, &z) == 3)
1671:401:                Cdraw3d_offset (ident, x, y, z);
1672:402:            else {
1673:403:                textformaterror (line, ident);
1674:404:                return -1;
1675:405:            }
1676:406:        } else if (!strncmp (p, "density ", 7)) {
1677:407:            if (sscanf (p, "density %lf", &x) == 1)
1678:408:                Cdraw3d_density (ident, x);
1679:409:            else {
1680:410:                textformaterror (line, ident);
1681:411:                return -1;
1682:412:            }
1683:413:        } else if (!strncmp (p, "cylinder ", 8)) {
1684:414:            if (sscanf
1685:415:                (p, "cylinder %lf %lf %lf %lf %lf %lf %lf", &x, &y, &z, &a,
1686:416:                 &b, &c, &r) == 7)
1687:417:                Cdraw3d_cylinder (ident, x, y, z, a, b, c, r);
1688:418:            else {
1689:419:                textformaterror (line, ident);
1690:420:                return -1;
1691:421:            }
1692:422:        } else if (!strncmp (p, "roundplate ", 11)) {
1693:423:            if (sscanf
1694:424:                (p, "roundplate %lf %lf %lf %lf %lf %lf %lf", &x, &y, &z,
1695:425:                 &a, &b, &c, &r) == 7) {
1696:426:                Cdraw3d_roundplate (ident, x, y, z, a, b, c, r);
1697:427:                Cdraw3d_roundplate (ident, -x, -y, -z, a, b, c, r);
1698:428:            } else {
1699:429:                textformaterror (line, ident);
1700:430:                return -1;
1701:431:            }
1702:432:        } else if (!strncmp (p, "cone ", 5)) {
1703:433:            if (sscanf
1704:434:                (p, "cone %lf %lf %lf %lf %lf %lf %lf %lf", &x, &y, &z, &a,
1705:435:                 &b, &c, &r, &r2) == 8)
1706:436:                Cdraw3d_cone (ident, x, y, z, a, b, c, r, r2);
1707:437:            else {
1708:438:                textformaterror (line, ident);
1709:439:                return -1;
1710:440:            }
1711:441:        } else if (!strncmp (p, "cappedcone ", 11)) {
1712:442:            if (sscanf
1713:443:                (p, "cappedcone %lf %lf %lf %lf %lf %lf %lf %lf", &x, &y,
1714:444:                 &z, &a, &b, &c, &r, &r2) == 8)
1715:445:                Cdraw3d_cappedcone (ident, x, y, z, a, b, c, r, r2);
1716:446:            else {
1717:447:                textformaterror (line, ident);
1718:448:                return -1;
1719:449:            }
1720:450:        } else if (!strncmp (p, "cappedcylinder ", 15)) {
1721:451:            if (sscanf
1722:452:                (p, "cappedcylinder %lf %lf %lf %lf %lf %lf %lf", &x, &y,
1723:453:                 &z, &a, &b, &c, &r) == 7) {
1724:454:                Cdraw3d_cappedcylinder (ident, x, y, z, a, b, c, r);
1725:455:            } else {
1726:456:                textformaterror (line, ident);
1727:457:                return -1;
1728:458:            }
1729:459:        } else if (!strncmp (p, "ellipsoid ", 10)) {
1730:460:            if (sscanf
1731:461:                (p, "ellipsoid %lf %lf %lf %lf %lf %lf %lf", &x, &y, &z,
1732:462:                 &a, &b, &c, &r) == 7) {
1733:463:                Cdraw3d_ellipsoid (ident, x, y, z, a, b, c, r);
1734:464:            } else {
1735:465:                textformaterror (line, ident);
1736:466:                return -1;
1737:467:            }
1738:468:        } else if (!strncmp (p, "rectangle ", 10)) {
1739:469:            if (sscanf
1740:470:                (p, "rectangle %lf %lf %lf %lf %lf %lf", &x, &y, &z, &a,
1741:471:                 &b, &c) == 6) {
1742:472:                Cdraw3d_rectangle (ident, x, y, z, a, b, c);
1743:473:            } else {
1744:474:                textformaterror (line, ident);
1745:475:                return -1;
1746:476:            }
1747:477:        } else if (!strncmp (p, "sphere ", 7)) {
1748:478:            if (sscanf (p, "sphere %lf %lf %lf %lf ", &x, &y, &z, &r) == 4) {
1749:479:                Cdraw3d_sphere (ident, x, y, z, r);
1750:480:            } else {
1751:481:                textformaterror (line, ident);
1752:482:                return -1;
1753:483:            }
1754:484:        } else if (!strncmp (p, "surface ", 8)) {
1755:485:            if (sscanf (p, "surface %d %d %n", &w, &h, &i) == 2) {
1756:486:                v = Cmalloc (w * h * sizeof (Vec));
1757:487:                for (k = 0; k < w * h; k++) {
1758:488:                    p += i;
1759:489:                    if (sscanf
1760:490:                        (p, "%lf %lf %lf %n", &(v[k].x), &(v[k].y),
1761:491:                         &(v[k].z), &i) != 3) {
1762:492:                        textformaterror (line, ident);
1763:493:                        free (v);
1764:494:                        return -1;
1765:495:                    }
1766:496:                }
1767:497:                draw3d_surface (ident, w, h, v);
1768:498:                free (v);
1769:499:            } else {
1770:500:                textformaterror (line, ident);
1771:501:                return -1;
1772:502:            }
1773:503:        } else {
1774:504:            textformaterror (line, ident);
1775:505:            return -1;
1776:506:        }
1777:507:
1778:508:        while (*p != '\n' && *p)
1779:509:            p++;
1780:510:        line++;
1781:511:    } while (*(p++));
1782:512:
1783:513:    Credraw3dobject (ident, 1);
1784:514:    return 0;
1785:515:}
1786:1:/* app_glob.c: Declare the common global variables for X applications.
1787:2:
1788:3:   Copyright (C) 1996 Paul Sheer
1789:4:
1790:5:   This program is free software; you can redistribute it and/or modify
1791:6:   it under the terms of the GNU General Public License as published by
1792:7:   the Free Software Foundation; either version 2 of the License, or
1793:8:   (at your option) any later version.
1794:9:
1795:10:   This program is distributed in the hope that it will be useful,
1796:11:   but WITHOUT ANY WARRANTY; without even the implied warranty of
1797:12:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
1798:13:   GNU General Public License for more details.
1799:14:
1800:15:   You should have received a copy of the GNU General Public License
1801:16:   along with this program; if not, write to the Free Software
1802:17:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
1803:18: */
1804:19:
1805:20:
1806:21:#ifndef APP_GLOB_C              /* To ensure that it is included once */
1807:22:#define APP_GLOB_C
1808:23:
1809:24:#include "my_string.h"
1810:25:
1811:26:#define max(x,y)     (((x) > (y)) ? (x) : (y))
1812:27:#define min(x,y)     (((x) < (y)) ? (x) : (y))
1813:28:
1814:29:#ifdef DEF_APP_GLOB             /* Defined in the initapp.c file */
1815:30:
1816:31:XWMHints *p_XWMH;               /* Hints for the window manager  */
1817:32:XSizeHints *p_XSH;              /* Size hints for window manager */
1818:33:XClassHint *p_CH;               /* Class hint for window manager */
1819:34:XTextProperty WName;            /* Window name for title bar     */
1820:35:XTextProperty IName;            /* Icon name for icon label      */
1821:36:Display *CDisplay = NULL;       /* Connection to X display     */
1822:37:GC CGC = 0;                     /* The graphics context for main */
1823:38:int AppDone = 0;                /* Flag to indicate when done   */
1824:39:XFontStruct *CFontStruct;       /* Info on the default font */
1825:40:unsigned long Cpixel[256];      /*for pixel */
1826:41:unsigned long Cplane[256];      /*and plane values from alloccolor. */
1827:42:char *CAppName;                 /* Application's name    */
1828:43:Window CMain = 0;               /* Application's main window */
1829:44:Visual *Cvisual;
1830:45:int Cdepth;
1831:46:int CXimageLSBFirst;
1832:47:int Cusinggreyscale;
1833:48:int Cfont_is_proportional;
1834:49:int CMean_font_width;
1835:50:char *home_dir = 0;
1836:51:char *temp_dir = 0;
1837:52:char current_dir[MAX_PATH_LEN + 1];
1838:53:XWindowAttributes MainXWA;      /* Attributes of main window */
1839:54:
1840:55:#include "bitmap/cross.bitmap"
1841:56:#include "bitmap/tick.bitmap"
1842:57:#include "bitmap/switchon.bitmap"
1843:58:#include "bitmap/switchoff.bitmap"
1844:59:#include "bitmap/exclam.bitmap"
1845:60:
1846:61:#else
1847:62:
1848:63:extern XWMHints *p_XWMH;
1849:64:extern XSizeHints *p_XSH;
1850:65:extern XClassHint *p_CH;
1851:66:extern XTextProperty WName;
1852:67:extern XTextProperty IName;
1853:68:extern Display *CDisplay;
1854:69:extern GC CGC;
1855:70:extern int AppDone;
1856:71:extern XFontStruct *CFontStruct;
1857:72:extern unsigned long Cpixel[256]; /*for pixel */
1858:73:extern unsigned long Cplane[256]; /*and plane values from alloccolor. */
1859:74:extern char *CAppName;
1860:75:extern Window CMain;
1861:76:extern Visual *Cvisual;
1862:77:extern int Cdepth;
1863:78:extern int CXimageLSBFirst;
1864:79:extern int Cusinggreyscale;
1865:80:extern int Cfont_is_proportional;
1866:81:extern int CMean_font_width;
1867:82:extern char *home_dir;
1868:83:extern char *temp_dir;
1869:84:extern char current_dir[MAX_PATH_LEN + 1];
1870:85:extern XWindowAttributes MainXWA;
1871:86:
1872:87:extern unsigned char cross_bits[];
1873:88:extern unsigned char tick_bits[];
1874:89:extern unsigned char switchon_bits[];
1875:90:extern unsigned char switchoff_bits[];
1876:91:extern unsigned char exclam_bits[];
1877:92:
1878:93:#endif                          /* #ifdef DEF_APP_GLOB */
1879:94:#endif                          /* #ifndef APP_GLOB_C  */
1880:1:/*
1881:2:   Copyright (C) 1996 Paul Sheer
1882:3:
1883:4:   This program is free software; you can redistribute it and/or modify
1884:5:   it under the terms of the GNU General Public License as published by
1885:6:   the Free Software Foundation; either version 2 of the License, or
1886:7:   (at your option) any later version.
1887:8:
1888:9:   This program is distributed in the hope that it will be useful,
1889:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
1890:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
1891:12:   GNU General Public License for more details.
1892:13:
1893:14:   You should have received a copy of the GNU General Public License
1894:15:   along with this program; if not, write to the Free Software
1895:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
1896:17: */
1897:18:
1898:19:#include <config.h>
1899:20:#include <stdio.h>
1900:21:#include <my_string.h>
1901:22:#include <stdlib.h>
1902:23:#include <stdarg.h>
1903:24:
1904:25:#include <X11/Xlib.h>
1905:26:#include <X11/Xutil.h>
1906:27:#include <X11/Xresource.h>
1907:28:#include "lkeysym.h"
1908:29:
1909:30:#include "stringtools.h"
1910:31:#include "app_glob.c"
1911:32:#include "dirtools.h"
1912:33:
1913:34:#include "coolwidget.h"
1914:35:
1915:36:#include "mad.h"
1916:37:
1917:38:
1918:39:void Crenderroundedbevel (Window win, int x1, int y1, int x2, int y2,
1919:40:                          int radius, int thick, int sunken);
1920:41:
1921:42:CWidget *Cdrawbitmapbutton (const char *identifier, Window parent, int x,
1922:43:                            int y, int width, int height, unsigned long fg,
1923:44:                            unsigned long bg, const unsigned char data[])
1924:45:{
1925:46:    CWidget *w = Csetupwidget (identifier, parent, x, y,
1926:47:                               width + 8, height + 8, CBITMAPBUTTON_WIDGET,
1927:48:                               INPUT_BUTTON, bg, 1);
1928:49:    Pixmap pixmap;
1929:50:
1930:51:    pixmap =
1931:52:        XCreateBitmapFromData (CDisplay, w->winid, (char *) data, width,
1932:53:                               height);
1933:54:    w->pixmap = pixmap;
1934:55:    w->fg = fg;
1935:56:    w->bg = bg;
1936:57:
1937:58:    Csethintpos (x + width + 8 + WIDGET_SPACING,
1938:59:                 y + height + 8 + WIDGET_SPACING);
1939:60:
1940:61:    return w;
1941:62:}
1942:63:
1943:64:CWidget *Cdrawbitmap (const char *identifier, Window parent, int x, int y,
1944:65:                      int width, int height, unsigned long fg,
1945:66:                      unsigned long bg, const unsigned char data[])
1946:67:{
1947:68:    CWidget *w = Csetupwidget (identifier, parent, x, y,
1948:69:                               width + 8, height + 8, CBITMAP_WIDGET,
1949:70:                               INPUT_EXPOSE, bg, 0);
1950:71:    Pixmap pixmap;
1951:72:
1952:73:    pixmap =
1953:74:        XCreateBitmapFromData (CDisplay, w->winid, (char *) data, width,
1954:75:                               height);
1955:76:    w->pixmap = pixmap;
1956:77:    w->fg = fg;
1957:78:    w->bg = bg;
1958:79:
1959:80:    Csethintpos (x + width + 8 + WIDGET_SPACING,
1960:81:                 height + 8 + WIDGET_SPACING);
1961:82:
1962:83:    return w;
1963:84:}
1964:85:
1965:86:Pixmap Cswitchon = 0;
1966:87:Pixmap Cswitchoff = 0;
1967:88:
1968:89:CWidget *Cdrawswitch (const char *identifier, Window parent, int x, int y,
1969:90:                      unsigned long fg, unsigned long bg, int on)
1970:91:{
1971:92:    CWidget *w = Csetupwidget (identifier, parent, x, y,
1972:93:                               32, 32, CSWITCH_WIDGET, INPUT_BUTTON, bg,
1973:94:                               1);
1974:95:
1975:96:    if (!Cswitchon) {
1976:97:        Cswitchon =
1977:98:            XCreateBitmapFromData (CDisplay, w->winid,
1978:99:                                   (char *) switchon_bits, 32, 32);
1979:100:        Cswitchoff =
1980:101:            XCreateBitmapFromData (CDisplay, w->winid,
1981:102:                                   (char *) switchoff_bits, 32, 32);
1982:103:    }
1983:104:    w->fg = fg;
1984:105:    w->bg = bg;
1985:106:    w->keypressed = on;
1986:107:
1987:108:    Csethintpos (x + 32 + WIDGET_SPACING, y + 32 + WIDGET_SPACING);
1988:109:
1989:110:    return w;
1990:111:}
1991:112:
1992:113:void Crenderbitmapbutton (CWidget * wdt, int state)
1993:114:{
1994:115:    int w = wdt->width, h = wdt->height;
1995:116:    int x = 0, y = 0;
1996:117:    Window win = wdt->winid;
1997:118:
1998:119:    if (render_focus_ring (wdt))
1999:120:        x = y = FOCUS_RING;
2000:121:
2001:122:    if (state == 3)
2002:123:        Csetcolor (wdt->bg);
2003:124:    else
2004:125:        Csetcolor (C_FLAT);
2005:126:    Crect (win, x + 1, y + 1, w - 2, h - 2);
2006:127:
2007:128:
2008:129:    switch (state) {
2009:130:    case 0:
2010:131:        Crenderbevel (win, x, y, x + w - 1, y + h - 1, 2, 0);
2011:132:        break;
2012:133:    case 1:
2013:134:        Crenderbevel (win, x, y, x + w - 1, y + h - 1, 1, 0);
2014:135:        break;
2015:136:    case 2:
2016:137:        Crenderbevel (win, x, y, x + w - 1, y + h - 1, 2, 1);
2017:138:        break;
2018:139:    case 3:
2019:140:        Crenderbevel (win, x, y, x + w - 1, y + h - 1, 1, 1);
2020:141:        break;
2021:142:    }
2022:143:
2023:144:    Csetcolor (wdt->fg);
2024:145:    Csetbackcolor (wdt->bg);
2025:146:    XCopyPlane (CDisplay, wdt->pixmap, win, CGC, 0, 0,
2026:147:                w - 8, h - 8, 4 + x, 4 + y, 1);
2027:148:}
2028:149:
2029:150:void Crenderswitch (CWidget * wdt, int state)
2030:151:{
2031:152:    int w = wdt->width, h = wdt->height;
2032:153:    Window win = wdt->winid;
2033:154:    int x = 0, y = 0;
2034:155:
2035:156:    if (render_focus_ring (wdt))
2036:157:        x = y = FOCUS_RING;
2037:158:
2038:159:    Csetcolor (C_FLAT);
2039:160:    Crect (win, x, y, w - 1, h - 1);
2040:161:
2041:162:
2042:163:    Csetcolor (wdt->fg);
2043:164:    Csetbackcolor (wdt->bg);
2044:165:    if (wdt->keypressed)
2045:166:        XCopyPlane (CDisplay, Cswitchon, win, CGC, 0, 0, w, h, x, y, 1);
2046:167:    else
2047:168:        XCopyPlane (CDisplay, Cswitchoff, win, CGC, 0, 0, w, h, x, y, 1);
2048:169:
2049:170:    switch (state) {
2050:171:    case 0:
2051:172:        Crenderroundedbevel (win, x, y, x + w - 1, y + h - 1, 7, 1, 0);
2052:173:        break;
2053:174:    case 1:
2054:175:        Crenderroundedbevel (win, x, y, x + w - 1, y + h - 1, 7, 1, 1);
2055:176:        break;
2056:177:    case 2:
2057:178:        Crenderroundedbevel (win, x, y, x + w - 1, y + h - 1, 7, 1, 1);
2058:179:        break;
2059:180:    }
2060:181:}
2061:182:
2062:183:
2063:184:/*
2064:185:   void Crenderroundedbevel (Window win, int x1, int y1, int x2, int y2, int radius, int thick, int sunken)
2065:186:   {
2066:187:   unsigned long cn, cs, cnw, cne, cse;
2067:188:   int i;
2068:189:
2069:190:   if((sunken & 2)) {
2070:191:   Csetcolor(C_FLAT);
2071:192:   Crect(win,x1+thick,y1+thick,x2-x1-2*thick+1, y2-y1-2*thick+1);
2072:193:   }
2073:194:
2074:195:   sunken &= 1;
2075:196:
2076:197:   cn = sunken ? Cwidgetcolor(4) : Cwidgetcolor(11);
2077:198:   cs = sunken ? Cwidgetcolor(11) : Cwidgetcolor(4);
2078:199:   cnw = Cwidgetcolor(14);
2079:200:   cse = Cwidgetcolor(2);
2080:201:
2081:202:   if(sunken) {cne = cnw; cnw = cse; cse = cne;}
2082:203:
2083:204:   cne = Cwidgetcolor(8);
2084:205:
2085:206:   #define Carc(win,x,y,w,h,a,b) XDrawArc(CDisplay,win,CGC,x,y,w,h,a,b)
2086:207:
2087:208:   for (i = 0; i < thick; i++) {
2088:209:   Csetcolor (cnw);
2089:210:   Carc(win, x1 + i, y1 + i, (radius - i) * 2, (radius - i) * 2, 90*64, 90*64);
2090:211:   Csetcolor (cse);
2091:212:   Carc(win, x2 + i - radius*2, y2 + i - radius*2, (radius - i) * 2, (radius - i) * 2, 270*64, 90*64);
2092:213:   Csetcolor (cne);
2093:214:   Carc(win, x1 + i, y2 + i - radius*2, (radius - i) * 2, (radius - i) * 2, 180*64, 90*64);
2094:215:   Carc(win, x2 + i - radius*2, y1 + i, (radius - i) * 2, (radius - i) * 2, 0, 90*64);
2095:216:
2096:217:   Csetcolor (cn);
2097:218:   Cline (win, x1 + i, y1 + radius, x1 + i, y2  - radius);
2098:219:   Cline (win, x1 + radius, y1 + i, x2 - radius, y1 + i);
2099:220:   Csetcolor (cs);
2100:221:   Cline (win, x2 - radius, y2 - i, x1 + radius, y2 - i);
2101:222:   Cline (win, x2 - i, y1 + radius, x2 - i, y2 - radius);
2102:223:   }
2103:224:   Csetcolor (C_BLACK);
2104:225:   }
2105:226: */
2106:227:
2107:228:
2108:229:
2109:230:void Crenderroundedbevel (Window win, int xs1, int ys1, int xs2, int ys2,
2110:231:                          int radius, int thick, int sunken)
2111:232:{
2112:233:    unsigned long cn, cs, cnw, cne, cse;
2113:234:    int i;
2114:235:    int x1, y1, x2, y2;
2115:236:
2116:237:    if ((sunken & 2)) {
2117:238:        Csetcolor (C_FLAT);
2118:239:        Crect (win, xs1, ys1, xs2 - xs1 + 1, ys2 - ys1 + 1);
2119:240:    }
2120:241:    sunken &= 1;
2121:242:
2122:243:    cn = sunken ? Cwidgetcolor (4) : Cwidgetcolor (11);
2123:244:    cs = sunken ? Cwidgetcolor (11) : Cwidgetcolor (4);
2124:245:    cnw = Cwidgetcolor (14);
2125:246:    cse = Cwidgetcolor (2);
2126:247:
2127:248:    if (sunken) {
2128:249:        cne = cnw;
2129:250:        cnw = cse;
2130:251:        cse = cne;
2131:252:    }
2132:253:    cne = Cwidgetcolor (8);
2133:254:
2134:255:#define Carc(win,x,y,w,h,a,b) XDrawArc(CDisplay,win,CGC,x,y,w,h,a,b)
2135:256:
2136:257:    for (x1 = xs1; x1 < xs1 + thick; x1++)
2137:258:        for (y1 = ys1; y1 < ys1 + thick; y1++) {
2138:259:            x2 = x1 + (xs2 - xs1 - thick + 1);
2139:260:            y2 = y1 + (ys2 - ys1 - thick + 1);
2140:261:            Csetcolor (cnw);
2141:262:            Carc (win, x1, y1, (radius) * 2, (radius) * 2, 90 * 64,
2142:263:                  90 * 64);
2143:264:            Csetcolor (cse);
2144:265:            Carc (win, x2 - radius * 2, y2 - radius * 2, (radius) * 2,
2145:266:                  (radius) * 2, 270 * 64, 90 * 64);
2146:267:            Csetcolor (cne);
2147:268:            Carc (win, x1, y2 - radius * 2, (radius) * 2, (radius) * 2,
2148:269:                  180 * 64, 90 * 64);
2149:270:            Carc (win, x2 - radius * 2, y1, (radius) * 2, (radius) * 2, 0,
2150:271:                  90 * 64);
2151:272:        }
2152:273:
2153:274:
2154:275:    if (radius)
2155:276:        radius--;
2156:277:    for (i = 0; i < thick; i++) {
2157:278:        Csetcolor (cn);
2158:279:        Cline (win, xs1 + i, ys1 + radius, xs1 + i, ys2 - radius);
2159:280:        Cline (win, xs1 + radius, ys1 + i, xs2 - radius, ys1 + i);
2160:281:        Csetcolor (cs);
2161:282:        Cline (win, xs2 - radius, ys2 - i, xs1 + radius, ys2 - i);
2162:283:        Cline (win, xs2 - i, ys1 + radius, xs2 - i, ys2 - radius);
2163:284:        Csetcolor (C_WHITE);
2164:285:        if (sunken)
2165:286:            XDrawPoint (CDisplay, win, CGC,
2166:287:                        xs2 - i - (radius + 1) * 300 / 1024,
2167:288:                        ys2 - i - (radius + 1) * 300 / 1024);
2168:289:        else
2169:290:            XDrawPoint (CDisplay, win, CGC,
2170:291:                        xs1 + i + (radius + 1) * 300 / 1024,
2171:292:                        ys1 + i + (radius + 1) * 300 / 1024);
2172:293:    }
2173:294:
2174:295:
2175:296:    Csetcolor (C_BLACK);
2176:297:}
2177:1:/*
2178:2:   Copyright (C) 1996 Paul Sheer
2179:3:
2180:4:   This program is free software; you can redistribute it and/or modify
2181:5:   it under the terms of the GNU General Public License as published by
2182:6:   the Free Software Foundation; either version 2 of the License, or
2183:7:   (at your option) any later version.
2184:8:
2185:9:   This program is distributed in the hope that it will be useful,
2186:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
2187:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
2188:12:   GNU General Public License for more details.
2189:13:
2190:14:   You should have received a copy of the GNU General Public License
2191:15:   along with this program; if not, write to the Free Software
2192:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
2193:17: */
2194:18:
2195:19:#include <config.h>
2196:20:#include <stdio.h>
2197:21:#include <my_string.h>
2198:22:#include <stdlib.h>
2199:23:#include <stdarg.h>
2200:24:
2201:25:#include <X11/Xlib.h>
2202:26:#include <X11/Xutil.h>
2203:27:#include <X11/Xresource.h>
2204:28:#include "lkeysym.h"
2205:29:
2206:30:#include "stringtools.h"
2207:31:#include "app_glob.c"
2208:32:#include "dirtools.h"
2209:33:
2210:34:#include "coolwidget.h"
2211:35:
2212:36:#include "mad.h"
2213:37:/*
2214:38:#ifndef XPointer
2215:39:#define XPointer char *
2216:40:#endif
2217:41:*/
2218:42:/*this processes all remaining widget events (usually expose) in the event
2219:43:   queue at the time it was called. */
2220:44:
2221:45:/*This routine does NOT wait if there are no events left */
2222:46:
2223:47:/*it returns true if the widget event is associated with the given
2224:48:   event identifier 'compare' and in this case, will return the entire
2225:49:   cw event string in return event. */
2226:50:
2227:51:/*NULL vars can be given if you just want it to process the remaining
2228:52:   events */
2229:53:
2230:54:
2231:55:int Ccheckifevent (XEvent * xevent, CEvent * cwevent)
2232:56:{
2233:57:    char ident[32];
2234:58:    int found = 0;
2235:59:    CEvent eventcw;
2236:60:    XEvent eventx;
2237:61:
2238:62:    while (CPending ()) {
2239:63:        CNextEvent (&eventx, &eventcw);
2240:64:        if (cwevent && xevent) {
2241:65:            strcpy (ident, eventcw.ident);
2242:66:            if (!strcmp (ident, cwevent->ident)) {
2243:67:                memcpy (cwevent, &eventcw, sizeof (CEvent));
2244:68:                memcpy (xevent, &eventx, sizeof (XEvent));
2245:69:                found = 1;
2246:70:            }
2247:71:        }
2248:72:    }
2249:73:
2250:74:    if (!found && cwevent && xevent) {
2251:75:        memset (cwevent, 0, sizeof (CEvent));
2252:76:        memset (xevent, 0, sizeof (XEvent));
2253:77:    }
2254:78:
2255:79:    return found;
2256:80:}
2257:81:
2258:82:Bool keypredicate (Display * d, XEvent * xevent, XPointer w)
2259:83:{
2260:84:    if (xevent->xany.type == KeyPress || xevent->xany.type == KeyRelease)
2261:85:        if (((CWidget *) w)->winid == xevent->xany.window)
2262:86:            return 1;
2263:87:    return 0;
2264:88:}
2265:89:
2266:90:
2267:91:int CKeyPending (const char *ident)
2268:92:{
2269:93:    XEvent xevent;
2270:94:    int i = 0;
2271:95:    if (CPending ())
2272:96:        i = XCheckIfEvent (CDisplay, &xevent, keypredicate,
2273:97:                           (XPointer) Cwidget (ident));
2274:98:    if (i)
2275:99:        XPutBackEvent (CDisplay, &xevent);
2276:100:    return i;
2277:101:}
2278:102:
2279:103:
2280:104:
2281:105:Bool mousepredicate (Display * d, XEvent * xevent, XPointer w)
2282:106:{
2283:107:    if (((CWidget *) w)->winid == xevent->xany.window)
2284:108:        if (xevent->xany.type == ButtonPress
2285:109:            || xevent->xany.type == ButtonRelease
2286:110:            || (xevent->xany.type == MotionNotify
2287:111:                && (xevent->xmotion.state
2288:112:                    & (Button1Mask | Button2Mask | Button3Mask
2289:113:                       | Button4Mask | Button5Mask))))
2290:114:            return 1;
2291:115:    return 0;
2292:116:}
2293:117:
2294:118:
2295:119:int CMousePending (const char *ident)
2296:120:{
2297:121:    XEvent xevent;
2298:122:    int i = 0;
2299:123:    if (CPending ())
2300:124:        i = XCheckIfEvent (CDisplay, &xevent, mousepredicate,
2301:125:                           (XPointer) Cwidget (ident));
2302:126:    if (i)
2303:127:        XPutBackEvent (CDisplay, &xevent);
2304:128:    return i;
2305:129:}
2306:1:/* $XConsortium: ClientWin.c,v 1.4 94/04/17 20:15:50 rws Exp $ */
2307:2:
2308:3:/* 
2309:4: 
2310:5:Copyright (c) 1989  X Consortium
2311:6:
2312:7:Permission is hereby granted, free of charge, to any person obtaining a copy
2313:8:of this software and associated documentation files (the "Software"), to deal
2314:9:in the Software without restriction, including without limitation the rights
2315:10:to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
2316:11:copies of the Software, and to permit persons to whom the Software is
2317:12:furnished to do so, subject to the following conditions:
2318:13:
2319:14:The above copyright notice and this permission notice shall be included in
2320:15:all copies or substantial portions of the Software.
2321:16:
2322:17:THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
2323:18:IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
2324:19:FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
2325:20:X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
2326:21:AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
2327:22:CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
2328:23:
2329:24:Except as contained in this notice, the name of the X Consortium shall not be
2330:25:used in advertising or otherwise to promote the sale, use or other dealings
2331:26:in this Software without prior written authorization from the X Consortium.
2332:27:
2333:28:*/
2334:29:
2335:30:#include <X11/Xlib.h>
2336:31:#include <X11/Xatom.h>
2337:32:
2338:33:static Window TryChildren ();
2339:34:
2340:35:/* Find a window with WM_STATE, else return win itself, as per ICCCM */
2341:36:
2342:37:Window my_XmuClientWindow (dpy, win)
2343:38:Display *dpy;
2344:39:Window win;
2345:40:{
2346:41:    Atom WM_STATE;
2347:42:    Atom type = None;
2348:43:    int format;
2349:44:    unsigned long nitems, after;
2350:45:    unsigned char *data;
2351:46:    Window inf;
2352:47:
2353:48:    WM_STATE = XInternAtom (dpy, "WM_STATE", True);
2354:49:    if (!WM_STATE)
2355:50:        return win;
2356:51:    XGetWindowProperty (dpy, win, WM_STATE, 0, 0, False, AnyPropertyType,
2357:52:                        &type, &format, &nitems, &after, &data);
2358:53:    if (type)
2359:54:        return win;
2360:55:    inf = TryChildren (dpy, win, WM_STATE);
2361:56:    if (!inf)
2362:57:        inf = win;
2363:58:    return inf;
2364:59:}
2365:60:
2366:61:static
2367:62:Window TryChildren (dpy, win, WM_STATE)
2368:63:Display *dpy;
2369:64:Window win;
2370:65:Atom WM_STATE;
2371:66:{
2372:67:    Window root, parent;
2373:68:    Window *children;
2374:69:    unsigned int nchildren;
2375:70:    unsigned int i;
2376:71:    Atom type = None;
2377:72:    int format;
2378:73:    unsigned long nitems, after;
2379:74:    unsigned char *data;
2380:75:    Window inf = 0;
2381:76:
2382:77:    if (!XQueryTree (dpy, win, &root, &parent, &children, &nchildren))
2383:78:        return 0;
2384:79:    for (i = 0; !inf && (i < nchildren); i++) {
2385:80:        XGetWindowProperty (dpy, children[i], WM_STATE, 0, 0, False,
2386:81:                            AnyPropertyType, &type, &format, &nitems,
2387:82:                            &after, &data);
2388:83:        if (type)
2389:84:            inf = children[i];
2390:85:    }
2391:86:    for (i = 0; !inf && (i < nchildren); i++)
2392:87:        inf = TryChildren (dpy, children[i], WM_STATE);
2393:88:    if (children)
2394:89:        XFree ((char *) children);
2395:90:    return inf;
2396:91:}
2397:1:/*
2398:2:   cmdlineopt.c and cmdlineopt.h are for processing command line options.
2399:3:
2400:4:   Copyright (C) 1996 the Free Software Foundation
2401:5:
2402:6:   Authors: 1996 Paul Sheer
2403:7:
2404:8:   This program is free software; you can redistribute it and/or modify
2405:9:   it under the terms of the GNU General Public License as published by
2406:10:   the Free Software Foundation; either version 2 of the License, or
2407:11:   (at your option) any later version.
2408:12:
2409:13:   This program is distributed in the hope that it will be useful,
2410:14:   but WITHOUT ANY WARRANTY; without even the implied warranty of
2411:15:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
2412:16:   GNU General Public License for more details.
2413:17:
2414:18:   You should have received a copy of the GNU General Public License
2415:19:   along with this program; if not, write to the Free Software
2416:20:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
2417:21: */
2418:22:
2419:23:#include <stdlib.h>
2420:24:#include <stdio.h>
2421:25:#include <string.h>
2422:26:#include "cmdlineopt.h"
2423:27:
2424:28:#define our_malloc malloc
2425:29:
2426:30:
2427:31:int get_cmdline_options (int argc, char **argv, struct prog_options *args)
2428:32:{
2429:33:    int i, j, c;
2430:34:    int other = 0;
2431:35:    for (i = 1; i < argc; i++) {
2432:36:        if (*argv[i] != '-') {  /* something that is not an option */
2433:37:            for (j = 0; args[j].type; j++)
2434:38:                if (args[j].char_opt == ' ') {
2435:39:                    args[j].strs[other] =
2436:40:                        our_malloc (strlen (argv[i]) + 1);
2437:41:                    strcpy (args[j].strs[other], argv[i]);
2438:42:                    other++;
2439:43:                    goto cont;
2440:44:                }
2441:45:            return i;
2442:46:        }
2443:47:        c = 0;
2444:48:        while (++c > 0) {       /* try each letter in a combined option eg 'tar -xvzf' */
2445:49:            for (j = 0; args[j].type; j++) {
2446:50:                if (!strcmp (args[j].long_opt, argv[i])
2447:51:                    || !strcmp (args[j].short_opt, argv[i])) {
2448:52:                    c = -1;     /* not a combined option */
2449:53:                    goto valid_opt;
2450:54:                }
2451:55:                if (argv[i][0] == '-' && argv[i][c] == args[j].char_opt) {
2452:56:                    if (!argv[i][c + 1]) /* this must be the last letter in the combined option */
2453:57:                        c = -1;
2454:58:                    goto valid_opt;
2455:59:                }
2456:60:                continue;
2457:61:
2458:62:              valid_opt:;
2459:63:                switch (args[j].type) {
2460:64:                case ARG_SET:{
2461:65:                        int *t;
2462:66:                        t = (int *) args[j].option;
2463:67:                        *t = 1;
2464:68:                        goto next;
2465:69:                    }
2466:70:                case ARG_CLEAR:{
2467:71:                        int *t;
2468:72:                        t = (int *) args[j].option;
2469:73:                        *t = 0;
2470:74:                        goto next;
2471:75:                    }
2472:76:                case ARG_IGNORE:
2473:77:                    /* do nothing with this option */
2474:78:                    goto next;
2475:79:                }
2476:80:
2477:81:                if (i + 1 != argc && argv[i + 1]
2478:82:                    && c < 0    /* must be the last option if a combined option */
2479:83:                    ) {
2480:84:                    ++i;
2481:85:                    switch (args[j].type) {
2482:86:                        int *t;
2483:87:                        double *f;
2484:88:                    case ARG_ON_OFF:
2485:89:                        if (strcmp (argv[i], "on") == 0) {
2486:90:                            t = (int *) args[j].option;
2487:91:                            *t = 1;
2488:92:                        } else if (strcmp (argv[++i], "off") == 0) {
2489:93:                            t = (int *) args[j].option;
2490:94:                            *t = 0;
2491:95:                        } else
2492:96:                            return i;
2493:97:                        goto next;
2494:98:                    case ARG_YES_NO:
2495:99:                        if (strcmp (argv[i], "yes") == 0) {
2496:100:                            t = (int *) args[j].option;
2497:101:                            *t = 1;
2498:102:                        } else if (strcmp (argv[++i], "no") == 0) {
2499:103:                            t = (int *) args[j].option;
2500:104:                            *t = 0;
2501:105:                        } else
2502:106:                            return i;
2503:107:                        goto next;
2504:108:                    case ARG_STRING:
2505:109:                        *(args[j].str) = our_malloc (strlen (argv[i]) + 1);
2506:110:                        strcpy (*(args[j].str), argv[i]);
2507:111:                        goto next;
2508:112:                    case ARG_STRINGS:{
2509:113:                            /* get all argv's after this option until we reach another option */
2510:114:                            int k = 0;
2511:115:                            while (i < argc && *argv[i] != '-') {
2512:116:                                args[j].strs[k] =
2513:117:                                    our_malloc (strlen (argv[i]) + 1);
2514:118:                                strcpy (args[j].strs[k], argv[i]);
2515:119:                                k++;
2516:120:                                i++;
2517:121:                            }
2518:122:                            i--; /* will be incremented at end of loop */
2519:123:                            goto next;
2520:124:                        }
2521:125:                    case ARG_INT:
2522:126:                        t = (int *) args[j].option;
2523:127:                        *t = atoi (argv[i]);
2524:128:                        goto next;
2525:129:                    case ARG_DOUBLE:
2526:130:                        f = (double *) args[j].option;
2527:131:                        *f = atof (argv[i]);
2528:132:                        goto next;
2529:133:                    }
2530:134:                    i--;
2531:135:                }
2532:136:                return i;       /* option parameter not found */
2533:137:            }                   /* j */
2534:138:            return i;           /* option not found */
2535:139:          next:;
2536:140:        }                       /* c */
2537:141:      cont:;
2538:142:    }
2539:143:    return 0;
2540:144:}
2541:1:/*
2542:2:   cmdlineopt.c and cmdlineopt.h are for processing command line options.
2543:3:
2544:4:   Copyright (C) 1996, 1997 the Free Software Foundation
2545:5:   
2546:6:   Authors: 1996 Paul Sheer
2547:7:
2548:8:   This program is free software; you can redistribute it and/or modify
2549:9:   it under the terms of the GNU General Public License as published by
2550:10:   the Free Software Foundation; either version 2 of the License, or
2551:11:   (at your option) any later version.
2552:12:   
2553:13:   This program is distributed in the hope that it will be useful,
2554:14:   but WITHOUT ANY WARRANTY; without even the implied warranty of
2555:15:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
2556:16:   GNU General Public License for more details.
2557:17:
2558:18:   You should have received a copy of the GNU General Public License
2559:19:   along with this program; if not, write to the Free Software
2560:20:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
2561:21: */
2562:22:
2563:23:/*
2564:24:    The kind of options it processes are summaries as follows:
2565:25:
2566:26:        1. on-off switch: -X|--longX on|off
2567:27:            eg
2568:28:            --sound on
2569:29:            --sound off
2570:30:            -s on
2571:31:            -s off
2572:32:        
2573:33:        2. yes-no switch: (same as on-off)
2574:34:        
2575:35:        3. Ordinary option: -X|--longX
2576:36:            eg
2577:37:            --verbose
2578:38:            -v
2579:39:        
2580:40:        4. String options: -X|--longX <some_string>
2581:41:            eg
2582:42:            --file program.c
2583:43:            -f program.c
2584:44:        
2585:45:        5. Integer or float options: -X|--longX N
2586:46:            eg
2587:47:            --count 20
2588:48:            -C 20
2589:49:        
2590:50:        6. String list options: -X|--longX <file1> <file2> <file3> ...
2591:51:            eg
2592:52:            --files hello.c whereis.c prog.c
2593:53:            -f hello.c whereis.c prog.c
2594:54:        
2595:55:        an example of usage follows:
2596:56:        
2597:57:        Suppose your program requires the following info to be set on the command line:
2598:58:            1. a list of files
2599:59:            2. a list of libraries
2600:60:            3. a device filename
2601:61:            4. an integer to repeat the operation N times.
2602:62:            5. whether verbose output is needed.
2603:63:            6. whether case sensitivity is on.
2604:64:            7. whether debugging mode is needed.
2605:65:
2606:66:        You would store this data as global variables. The defaults would
2607:67:        be set at compile time:
2608:68:
2609:69:        char *libraries[] =
2610:70:            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
2611:71:        char *files[] =
2612:72:            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
2613:73:        char *device = "";
2614:74:        int option_verbose_output = 0;
2615:75:        int option_debug = 1;
2616:76:        int option_case_sensitive = 1;
2617:77:        int option_repeat = 1;
2618:78:        
2619:79:        Then create a prog_args structure. Each entry contains an abbreviated
2620:80:        option, and then two synonyms that my be used for the options.
2621:81:        (See the prog_options structure below).
2622:82:        
2623:83:        struct prog_options arg_opts[] =
2624:84:        {
2625:85:            {' ', "", "", ARG_STRINGS, 0, files, 0},
2626:86:            {'L', "", "--libraries", ARG_STRINGS, 0, libraries, 0},
2627:87:            {'d', "", "--device", ARG_STRING, &device, 0, 0},
2628:88:            {'v', "-verb", "--verbose", ARG_SET, 0, 0, &option_verbose_output},
2629:89:            {'b', "-debug", "--debug", ARG_CLEAR, 0, 0, &option_debug},
2630:90:            {0, "-cs", "--case-sensitivity", ARG_ON_OFF, &option_case_sensitive, 0, 0},
2631:91:            {'r', "-rep", "--repeat", ARG_INT, 0, 0, &count},
2632:92:            {0, 0, 0, 0, 0, 0, 0}
2633:93:        };
2634:94:        
2635:95:        
2636:96:        and call get_cmdline_options as follows:
2637:97:        
2638:98:        main (int argc, char **argv)
2639:99:        {
2640:100:            int i;
2641:101:            i = get_cmdline_options (argc, argv, arg_opts);
2642:102:        .
2643:103:        .
2644:104:        .
2645:105:
2646:106:        }
2647:107:
2648:108:        On return, 'i' will be zero if there were no errors, or it will
2649:109:        be set to the number of the parameter that the error occured at.
2650:110:
2651:111:
2652:112:        Notes:
2653:113:        ------
2654:114:
2655:115:        The type member indicates the kind of option.
2656:116:        The type member ARG_SET causes the 'option_verbose_output' to be
2657:117:        set to 1 if the switch is encountered. ARG_CLEAR causes it
2658:118:        to be set to zero. ARG_ON_OFF causes 'option_case_sensitivity'
2659:119:        to be set to 1 or 0, depending if its parameter
2660:120:        is 'yes' or 'no' respectively. ARG_INT uses 'atoi' to get
2661:121:        the integer after the option into 'count'.
2662:122:
2663:123:        If the char_opt member is set to ' ' (as above) it means that any
2664:124:        isolated parameters on the command line (strings that are not
2665:125:        options or option parameters) must be recorded into
2666:126:        the specified list. Hence in the above (crude) example, any thing
2667:127:        on the command line that is not an option, or does not belong
2668:128:        to an option, is considered to be a filename, and is put into 
2669:129:        the list 'files[]'.
2670:130:
2671:131:        Libraries is the list of parameters that come after a '-L' or
2672:132:        '--libraries'. A list is specified with ARG_STRINGS. A list is
2673:133:        terminated by any parameter beginning with '-'.
2674:134:
2675:135:        The char_opt member contains the abbreviated option. eg if
2676:136:        char_opt contains 'x' then the command line parameter is '-x'.
2677:137:        It is not the same as the short_opt member, as multiple of these
2678:138:        can be used together like in the tar command: 'tar -xvzf <file>' etc.
2679:139:
2680:140:        Usually 'short_opt' would just contain a two letter version
2681:141:        of the option if a one letter version isn't possible
2682:142:        (in this case char_opt would be set to zero). You do
2683:143:        not have to have both a long, a short and a character option.
2684:144:
2685:145:
2686:146:        an example command line would be:
2687:147:            progname file1 file2 file3 -L lib1 lib2 lib3 -cs on -vbd /dev/par1 -r 5
2688:148:        which would be the same as
2689:149:            progname file1 --libraries lib1 lib2 lib3 --repeat 5
2690:150:                --device /dev/par1 file2 --verbose --case-sensitivity on file3 --debug
2691:151:
2692:152:        This library cannot be used to process any kind of command line,
2693:153:        put it should be useful for most applications.
2694:154:*/
2695:155:
2696:156:#ifndef _COMMAND_LINE_H
2697:157:#define _COMMAND_LINE_H
2698:158:
2699:159:#define ARG_ON_OFF        1
2700:160:#define ARG_STRING        2
2701:161:#define ARG_STRINGS        3
2702:162:#define ARG_SET                4
2703:163:#define ARG_CLEAR        5
2704:164:#define ARG_YES_NO        6
2705:165:
2706:166:#define ARG_IGNORE        7
2707:167:    /* ARG_IGNORE causes an option to be ignored. */
2708:168:
2709:169:#define ARG_INT                8
2710:170:#define ARG_DOUBLE        9
2711:171:
2712:172:
2713:173:struct prog_options {
2714:174:    char char_opt;
2715:175:    char *short_opt;
2716:176:    char *long_opt;
2717:177:    int type;                   /* one of the #define's above */
2718:178:    char **str;                 /* pointer to a single string */
2719:179:    char **strs;                /* pointer to an array of strings */
2720:180:    void *option;               /* an integer or double */
2721:181:#if 0
2722:182:    char *dummy_opt;            /* for the help text */
2723:183:    char *help;                 /* help line */
2724:184:#endif
2725:185:};
2726:186:
2727:187:int get_cmdline_options (int argc, char **argv, struct prog_options *args);
2728:188:
2729:189:#if 0
2730:190:void print_cmdline_options (char *progname, struct prog_options *args);
2731:191:#endif
2732:192:
2733:193:#endif                          /* !_COMMAND_LINE_H */
2734:1:/* compatable.c - these are substitute string and memory functions
2735:2:   for when the configure script can't find them on the system.
2736:3:   They may not work properly.
2737:4:
2738:5:   Copyright (C) 1996 Paul Sheer
2739:6:
2740:7:   This program is free software; you can redistribute it and/or modify
2741:8:   it under the terms of the GNU General Public License as published by
2742:9:   the Free Software Foundation; either version 2 of the License, or
2743:10:   (at your option) any later version.
2744:11:
2745:12:   This program is distributed in the hope that it will be useful,
2746:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
2747:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
2748:15:   GNU General Public License for more details.
2749:16:
2750:17:   You should have received a copy of the GNU General Public License
2751:18:   along with this program; if not, write to the Free Software
2752:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
2753:20: */
2754:21:
2755:22:#include <config.h>
2756:23:#include <stdio.h>
2757:24:#include <stdlib.h>
2758:25:#include <stdarg.h>
2759:26:#include <sys/types.h>
2760:27:#include "my_string.h"
2761:28:#include "stringtools.h"
2762:29:
2763:30:
2764:31:#ifndef HAVE_MEMSET
2765:32:void *memset (void *dest, int c, size_t n)
2766:33:{
2767:34:    char *d = (char *) dest;
2768:35:#ifdef HAVE_BZERO
2769:36:    if (!c) {
2770:37:        bzero (dest, n);
2771:38:        return dest;
2772:39:    }
2773:40:#endif
2774:41:    while (n--)
2775:42:        *d++ = c;
2776:43:    return dest;
2777:44:}
2778:45:#endif
2779:46:
2780:47:#ifndef HAVE_MEMCHR
2781:48:void *memchr (const void *s, int c, size_t n)
2782:49:{
2783:50:    unsigned char *m = (unsigned char *) s;
2784:51:    while (n--) {
2785:52:        if (*m == c)
2786:53:            return m;
2787:54:        m++;
2788:55:    }
2789:56:    return 0;
2790:57:}
2791:58:#endif
2792:59:
2793:60:#ifndef HAVE_MEMCMP
2794:61:int memcmp (const void *m1, const void *m2, size_t n)
2795:62:{
2796:63:    const unsigned char *s1, *s2;
2797:64:    signed char t = 0;
2798:65:
2799:66:    if (!n)
2800:67:        return 0;
2801:68:    for (s1 = m1, s2 = m2; 0 < n; ++s2, ++s1, n--)
2802:69:        if ((t = *s1 - *s2) != 0)
2803:70:            break;
2804:71:    return t;
2805:72:}
2806:73:#endif
2807:74:
2808:75:
2809:76:#ifndef HAVE_STRSTR
2810:77:char *strstr (const char *s1, const char *s2)
2811:78:{
2812:79:    int l1, l2;
2813:80:
2814:81:    l2 = strlen (s2);
2815:82:    if (!l2)
2816:83:        return (char *) s1;
2817:84:    l1 = strlen (s1);
2818:85:    while (l1 >= l2) {
2819:86:        l1--;
2820:87:        if (!memcmp (s1, s2, l2))
2821:88:            return (char *) s1;
2822:89:        s1++;
2823:90:    }
2824:91:    return NULL;
2825:92:}
2826:93:#endif
2827:94:
2828:95:
2829:96:#ifndef HAVE_STRSPN
2830:97:size_t strspn (const char *s, const char *accept)
2831:98:{
2832:99:    const char *p;
2833:100:    const char *a;
2834:101:    size_t count = 0;
2835:102:
2836:103:    for (p = s; *p != '\0'; ++p) {
2837:104:        for (a = accept; *a != '\0'; ++a) {
2838:105:            if (*p == *a)
2839:106:                break;
2840:107:        }
2841:108:        if (*a == '\0')
2842:109:            return count;
2843:110:        ++count;
2844:111:    }
2845:112:    return count;
2846:113:}
2847:114:#endif
2848:115:
2849:116:
2850:117:#ifndef HAVE_MEMMOVE
2851:118:void *memmove (void *dest, const void *src, size_t n)
2852:119:{
2853:120:    char *t, *s;
2854:121:
2855:122:    if (dest <= src) {
2856:123:        t = (char *) dest;
2857:124:        s = (char *) src;
2858:125:        while (n--)
2859:126:            *t++ = *s++;
2860:127:    } else {
2861:128:        t = (char *) dest + n;
2862:129:        s = (char *) src + n;
2863:130:        while (n--)
2864:131:            *--t = *--s;
2865:132:    }
2866:133:    return dest;
2867:134:}
2868:135:#endif
2869:136:
2870:137:#define my_lower_case(x) ((x) < 'a' ? (x) - 'A' + 'a' : (x))
2871:138:
2872:139:
2873:140:#ifndef HAVE_STRCASECMP
2874:141:int strcasecmp (const char *s1, const char *s2)
2875:142:{
2876:143:    signed char c;
2877:144:    for (;;)
2878:145:        if ((c = my_lower_case (*s1) - my_lower_case (*s2)) != 0 || !*s1++
2879:146:            || !*s2++)
2880:147:            break;
2881:148:    return c;
2882:149:}
2883:150:#endif
2884:151:
2885:152:#ifndef HAVE_STRNCASECMP
2886:153:int strncasecmp (const char *s1, const char *s2, size_t n)
2887:154:{
2888:155:    signed char c = 0;
2889:156:    while (n--)
2890:157:        if ((c = my_lower_case (*s1) - my_lower_case (*s2)) != 0 || !*s1++
2891:158:            || !*s2++)
2892:159:            break;
2893:160:    return c;
2894:161:}
2895:162:#endif
2896:163:
2897:164:
2898:165:#ifndef HAVE_STRDUP
2899:166:char *strdup (const char *s)
2900:167:{
2901:168:    char *p = malloc (strlen (s) + 1);
2902:169:    if (!p)
2903:170:        return 0;
2904:171:    strcpy (p, s);
2905:172:    return p;
2906:173:}
2907:174:#endif
2908:175:
2909:176:
2910:177:#ifndef HAVE_VPRINTF
2911:178:
2912:179:#define is_digit(x) ((x) >= '0' && (x) <= '9')
2913:180:
2914:181:#define snprintf(v) { \
2915:182:                *p1++ = *p++; \
2916:183:                *p1++ = '%'; \
2917:184:                *p1++ = 'n'; \
2918:185:                *p1 = '\0'; \
2919:186:                sprintf(s,q1,v,&n); \
2920:187:                s += n; \
2921:188:            }
2922:189:
2923:190:/* this function uses the sprintf command to do a vsprintf */
2924:191:int vsprintf (char *str, const char *fmt, va_list ap)
2925:192:{
2926:193:    char *q, *p, *s = str;
2927:194:    int n;
2928:195:    char q1[32];
2929:196:    char *p1;
2930:197:
2931:198:    p = q = (char *) fmt;
2932:199:
2933:200:    while ((p = strchr (p, '%'))) {
2934:201:        n = (int) ((unsigned long) p - (unsigned long) q);
2935:202:        strncpy (s, q, n);      /* copy stuff between format specifiers */
2936:203:        s += n;
2937:204:        *s = 0;
2938:205:        q = p;
2939:206:        p1 = q1;
2940:207:        *p1++ = *p++;
2941:208:        if (*p == '%') {
2942:209:            p++;
2943:210:            *s++ = '%';
2944:211:            q = p;
2945:212:            continue;
2946:213:        }
2947:214:        if (*p == 'n') {
2948:215:            p++;
2949:216:/* print nothing */
2950:217:            q = p;
2951:218:            *va_arg (ap, int *) =
2952:219:                (int) ((unsigned long) s - (unsigned long) str);
2953:220:            continue;
2954:221:        }
2955:222:        if (*p == '#')
2956:223:            *p1++ = *p++;
2957:224:        if (*p == '0')
2958:225:            *p1++ = *p++;
2959:226:        if (*p == '-')
2960:227:            *p1++ = *p++;
2961:228:        if (*p == '+')
2962:229:            *p1++ = *p++;
2963:230:        if (*p == '*') {
2964:231:            p++;
2965:232:            strcpy (p1, itoa (va_arg (ap, int))); /* replace field width with a number */
2966:233:            p1 += strlen (p1);
2967:234:        } else {
2968:235:            while (is_digit (*p))
2969:236:                *p1++ = *p++;
2970:237:        }
2971:238:        if (*p == '.')
2972:239:            *p1++ = *p++;
2973:240:        if (*p == '*') {
2974:241:            p++;
2975:242:            strcpy (p1, itoa (va_arg (ap, int))); /* replace precision with a number */
2976:243:            p1 += strlen (p1);
2977:244:        } else {
2978:245:            while (is_digit (*p))
2979:246:                *p1++ = *p++;
2980:247:        }
2981:248:/* flags done, now get argument */
2982:249:        if (*p == 's') {
2983:250:            snprintf (va_arg (ap, char *));
2984:251:        } else if (*p == 'h') {
2985:252:            if (strchr ("diouxX", *p))
2986:253:                snprintf (va_arg (ap, short));
2987:254:        } else if (*p == 'l') {
2988:255:            *p1++ = *p++;
2989:256:            if (strchr ("diouxX", *p))
2990:257:                snprintf (va_arg (ap, long));
2991:258:        } else if (strchr ("cdiouxX", *p)) {
2992:259:            snprintf (va_arg (ap, int));
2993:260:        } else if (*p == 'L') {
2994:261:            *p1++ = *p++;
2995:262:            if (strchr ("EefgG", *p))
2996:263:                snprintf (va_arg (ap, double)); /* should be long double, but gives warnings on some machines */
2997:264:        } else if (strchr ("EefgG", *p)) {
2998:265:            snprintf (va_arg (ap, double));
2999:266:        } else if (strchr ("DOU", *p)) {
3000:267:            snprintf (va_arg (ap, long));
3001:268:        } else if (*p == 'p') {
3002:269:            snprintf (va_arg (ap, void *));
3003:270:        }
3004:271:        q = p;
3005:272:    }
3006:273:    va_end (ap);
3007:274:    sprintf (s, q);             /* print trailing leftover */
3008:275:    return ((unsigned long) s - (unsigned long) str) + strlen (s);
3009:276:}
3010:277:
3011:278:#endif
3012:1:void Crenderbutton (CWidget * w);
3013:2:void Crendertextinput (CWidget * w);
3014:3:void Cinputtobox (CWidget * w, CWidget * box);
3015:4:void Crenderwindow (CWidget * w);
3016:5:void Crenderbar (CWidget * w);
3017:6:void Crendertext (CWidget * w);
3018:7:void Crenderscrollbar (CWidget * w);
3019:8:void Crendersunken (CWidget * w);
3020:9:int Cscrollwhereis (int bx, int by, CWidget * w);
3021:10:long Csettextboxpos (CWidget * w, int which, long p);
3022:11:long Ccounttextboxlines (CWidget * w, int all);
3023:12:void Crenderprogress (CWidget * w);
3024:13:void Crenderswitch (CWidget * w, int state);
3025:14:int (*Cdefaulthandler (int kindofwidget)) (CWidget *, XEvent *, CEvent *);
3026:15:CWidget **Cfindemptywidgetentry ();
3027:16:CWidget *Callocatewidget (Window newwin,
3028:17:                          const char *ident, Window parent, int x, int y,
3029:18:                          int width, int height, int kindofwidget);
3030:19:int eh_picture (struct cool_widget *w, XEvent * xevent, CEvent * cwevent);
3031:1:/*
3032:2:   Copyright (C) 1996 Paul Sheer
3033:3:
3034:4:   This program is free software; you can redistribute it and/or modify
3035:5:   it under the terms of the GNU General Public License as published by
3036:6:   the Free Software Foundation; either version 2 of the License, or
3037:7:   (at your option) any later version.
3038:8:
3039:9:   This program is distributed in the hope that it will be useful,
3040:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
3041:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
3042:12:   GNU General Public License for more details.
3043:13:
3044:14:   You should have received a copy of the GNU General Public License
3045:15:   along with this program; if not, write to the Free Software
3046:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
3047:17: */
3048:18:
3049:19:/* #define DEBUG */
3050:20:
3051:21:#include <config.h>
3052:22:#include <stdio.h>
3053:23:#include <my_string.h>
3054:24:#include <stdlib.h>
3055:25:#include <stdarg.h>
3056:26:
3057:27:#include <X11/Xlib.h>
3058:28:#include <X11/Xutil.h>
3059:29:#include <X11/Xresource.h>
3060:30:#include "lkeysym.h"
3061:31:
3062:32:#include "stringtools.h"
3063:33:#include "app_glob.c"
3064:34:#include "dirtools.h"
3065:35:
3066:36:#include "coolwidget.h"
3067:37:#include "coollocal.h"
3068:38:
3069:39:#include "drawings.h"
3070:40:#include "edit.h"
3071:41:#include "editcmddef.h"
3072:42:#include "widget3d.h"
3073:43:
3074:44:#include "mad.h"
3075:45:
3076:46:int last_region = 0;
3077:47:
3078:48:
3079:49:int (*global_alarm_callback) (CWidget *, XEvent *, CEvent *);
3080:50:extern Pixmap Cswitchon, Cswitchoff;
3081:51:extern Window current_focus;
3082:52:extern Atom DndProtocol;
3083:53:
3084:54:void add_to_focus_stack (Window w);
3085:55:
3086:56:static Window window_is_resizing = 0;
3087:57:
3088:58:/* converts button presses from buttons 2 through 5 to button presses from 2 only, also gets double clicks */
3089:59:void Cresolvebutton (XEvent * xevent, CEvent * cwevent)
3090:60:{
3091:61:    static Time time = 0;
3092:62:    static Window window = 0;
3093:63:    static int x, y;
3094:64:    long t;
3095:65:    unsigned long s;
3096:66:    switch (xevent->type) {
3097:67:    case ButtonRelease:
3098:68:    case ButtonPress:
3099:69:        cwevent->state = s = xevent->xbutton.state;
3100:70:        if (s & (Button2Mask | Button3Mask | Button4Mask | Button5Mask))
3101:71:            cwevent->state |= Button2Mask;
3102:72:        cwevent->button = xevent->xbutton.button;
3103:73:        if (cwevent->button == Button2 || cwevent->button == Button3 ||
3104:74:            cwevent->button == Button4 || cwevent->button == Button5)
3105:75:            cwevent->button = Button2;
3106:76:        cwevent->x = xevent->xbutton.x;
3107:77:        cwevent->y = xevent->xbutton.y;
3108:78:        t = xevent->xmotion.time - time;
3109:79:        if (abs (t) < 250 &&
3110:80:            window == xevent->xany.window &&
3111:81:            abs (x - cwevent->x) < 4 && abs (y - cwevent->y) < 4)
3112:82:            cwevent->double_click = 1;
3113:83:        x = xevent->xbutton.x;
3114:84:        y = xevent->xbutton.y;
3115:85:        time = xevent->xbutton.time;
3116:86:        break;
3117:87:    case MotionNotify:
3118:88:        cwevent->state = s = xevent->xmotion.state;
3119:89:        if (s & (Button2Mask | Button3Mask | Button4Mask | Button5Mask))
3120:90:            cwevent->state |= Button2Mask;
3121:91:        x = cwevent->x = xevent->xmotion.x;
3122:92:        y = cwevent->y = xevent->xmotion.y;
3123:93:        break;
3124:94:    }
3125:95:    window = xevent->xany.window;
3126:96:}
3127:97:
3128:98:/*sends all windows that are marked top_bottom = 1 to the bottom */
3129:99:void Clowerwindows ()
3130:100:{
3131:101:    int j = 0;
3132:102:    while (CLastwidget > j++)
3133:103:        if (CW (j) != NULL)
3134:104:            if (CW (j)->position & CALWAYS_ON_BOTTOM)
3135:105:                XLowerWindow (CDisplay, CW (j)->winid);
3136:106:}
3137:107:
3138:108:/*sends all windows that are marked top_bottom = 2 to the top */
3139:109:void Craisewindows ()
3140:110:{
3141:111:    int j = 0;
3142:112:    while (CLastwidget > j++)
3143:113:        if (CW (j) != NULL)
3144:114:            if (CW (j)->position & CALWAYS_ON_TOP)
3145:115:                XRaiseWindow (CDisplay, CW (j)->winid);
3146:116:}
3147:117:
3148:118:
3149:119:
3150:120:/* {{{ here is an internal event queue handler to send events without going through XLib */
3151:121:
3152:122:/*
3153:123:   We want to be able to send our own events internally
3154:124:   because XSendEvent sometimes doesn't force the an
3155:125:   event to be processed and the event sits on the queue
3156:126:   with its thumb up its arse.
3157:127: */
3158:128:
3159:129:#define NUM_EVENTS_CACHED (1 << 9)
3160:130:
3161:131:static unsigned int event_send_last = 0;
3162:132:static unsigned int event_read_last = 0;
3163:133:static XEvent event_sent[NUM_EVENTS_CACHED];
3164:134:
3165:135:#define queue_size (event_send_last - event_read_last >= 0 ? \
3166:136:            event_send_last - event_read_last : \
3167:137:            NUM_EVENTS_CACHED + event_send_last - event_read_last)
3168:138:
3169:139:/* returns 0, if buffer is full, else returns 1 */
3170:140:int push_event (XEvent * ev)
3171:141:{
3172:142:    if (event_read_last == (event_send_last + 1) % NUM_EVENTS_CACHED) { /* no more space */
3173:143:#ifdef DEBUG
3174:144:        fprintf (stderr, "cooledit:%s:%d: warning event stack full\n",
3175:145:                 __FILE__, __LINE__);
3176:146:#endif
3177:147:        /* we are just going to ignore this */
3178:148:        return 0;
3179:149:    }
3180:150:    if (ev->type == Expose || ev->type == InternalExpose) { /* must handle expose counts also */
3181:151:        unsigned int i = (event_send_last - 1) % NUM_EVENTS_CACHED;
3182:152:        XEvent *e;
3183:153:        ev->xexpose.count = 0;  /* this is the very last expose by definition */
3184:154:        while (i != ((event_read_last - 1) % NUM_EVENTS_CACHED)) { /* search backwards until a similar event is found */
3185:155:            if ((e = &(event_sent[i]))->xany.window == ev->xany.window) {
3186:156:                if (e->type == ev->type) {
3187:157:                    e->xexpose.count = 1; /* we are not going to actually "count", but we must indicate if the queue isn't empty with a "1" */
3188:158:                    break;
3189:159:                }
3190:160:            }
3191:161:            i = (i - 1) % NUM_EVENTS_CACHED;
3192:162:        }
3193:163:    }
3194:164:    memcpy (&event_sent[event_send_last], ev, sizeof (XEvent));
3195:165:    event_send_last = (event_send_last + 1) % NUM_EVENTS_CACHED;
3196:166:    return 1;
3197:167:}
3198:168:
3199:169:
3200:170:
3201:171:/* pops the oldest event, returns 0 if empty */
3202:172:int pop_event (XEvent * ev)
3203:173:{
3204:174:    if (event_read_last == event_send_last)
3205:175:        return 0;               /* "stack" is empty */
3206:176:    memcpy (ev, &event_sent[event_read_last], sizeof (XEvent));
3207:177:    event_read_last = (event_read_last + 1) % NUM_EVENTS_CACHED;
3208:178:    return 1;
3209:179:}
3210:180:
3211:181:/* use this instead of XSextEvent to send an event to your own application */
3212:182:int CSendEvent (XEvent * e)
3213:183:{
3214:184:    return push_event (e);
3215:185:}
3216:186:
3217:187:int CQueueSize ()
3218:188:{
3219:189:    return queue_size;
3220:190:}
3221:191:
3222:192:/* returns nonzero if pending on either internal or X queue */
3223:193:int CPending ()
3224:194:{
3225:195:    if (queue_size)
3226:196:        return 1;
3227:197:    if (XPending (CDisplay))
3228:198:        return 1;
3229:199:    return 0;
3230:200:}
3231:201:
3232:202:/* searches the local queue for an event matching the window */
3233:203:/* does not remove the event, returns non-zero if found */
3234:204:int CWindowPending (Window w)
3235:205:{
3236:206:    unsigned int i = (event_send_last - 1) % NUM_EVENTS_CACHED;
3237:207:    while (i != ((event_read_last - 1) % NUM_EVENTS_CACHED)) {
3238:208:        if ((&(event_sent[i]))->xany.window == w)
3239:209:            return 1;
3240:210:        i = (i - 1) % NUM_EVENTS_CACHED;
3241:211:    }
3242:212:    return 0;
3243:213:}
3244:214:
3245:215:
3246:216:
3247:217:/* 
3248:218:   does checks for expose events pending, if there is one on either queue then
3249:219:   it removes it and returns it.
3250:220: */
3251:221:int CExposePending (Window w, XEvent * ev)
3252:222:{
3253:223:    XEvent *e;
3254:224:    unsigned int i = event_read_last;
3255:225:
3256:226:    while (i != event_send_last) {
3257:227:        if ((e = &(event_sent[i]))->xany.window == w)
3258:228:            if (e->type == Expose) {
3259:229:                memcpy (ev, e, sizeof (XEvent));
3260:230:                e->type = 0;
3261:231:                return 1;
3262:232:            }
3263:233:        i = (i + 1) % NUM_EVENTS_CACHED;
3264:234:    }
3265:235:    return XCheckWindowEvent (CDisplay, w, ExposureMask, ev);
3266:236:}
3267:237:
3268:238:
3269:239:
3270:240:
3271:241:/* send an expose event via the internal queue */
3272:242:int CSendExpose (Window win, int x, int y, int w, int h)
3273:243:{
3274:244:    XEvent e;
3275:245:    e.xexpose.type = Expose;
3276:246:    e.xexpose.serial = 0;
3277:247:    e.xexpose.send_event = 1;
3278:248:    e.xexpose.display = CDisplay;
3279:249:    e.xexpose.window = win;
3280:250:    e.xexpose.x = x;
3281:251:    e.xexpose.y = y;
3282:252:    e.xexpose.width = w;
3283:253:    e.xexpose.height = h;
3284:254:    return CSendEvent (&e);
3285:255:}
3286:256:
3287:257:
3288:258:/* }}} end of internal queue handler */
3289:259:
3290:260:
3291:261:/* {{{ here is an expose caching-amalgamating stack system */
3292:262:
3293:263:typedef struct {
3294:264:    short x1, y1, x2, y2;
3295:265:    Window w;
3296:266:    long error;
3297:267:    int count;
3298:268:} CRegion;
3299:269:
3300:270:#define MAX_NUM_REGIONS 63
3301:271:static CRegion regions[MAX_NUM_REGIONS + 1];
3302:272:
3303:273:#define area(c) abs(((c).x1-(c).x2)*((c).y1-(c).y2))
3304:274:
3305:275:static CRegion add_regions (CRegion r1, CRegion r2)
3306:276:{
3307:277:    CRegion r;
3308:278:    r.x2 = max (max (r1.x1, r1.x2), max (r2.x1, r2.x2));
3309:279:    r.x1 = min (min (r1.x1, r1.x2), min (r2.x1, r2.x2));
3310:280:    r.y2 = max (max (r1.y1, r1.y2), max (r2.y1, r2.y2));
3311:281:    r.y1 = min (min (r1.y1, r1.y2), min (r2.y1, r2.y2));
3312:282:    r.w = r2.w;
3313:283:    r.error = (long) area (r) - area (r1) - area (r2);
3314:284:    r.error = max (r.error, 0);
3315:285:    r.error += r1.error + r2.error;
3316:286:    r.count = min (r1.count, r2.count);
3317:287:    return r;
3318:288:}
3319:289:
3320:290:/* returns 1 when the stack is full, 0 otherwise */
3321:291:static int push_region (XExposeEvent * e)
3322:292:{
3323:293:    CRegion p;
3324:294:
3325:295:
3326:296:    p.x1 = e->x;
3327:297:    p.x2 = e->x + e->width;
3328:298:    p.y1 = e->y;
3329:299:    p.y2 = e->y + e->height;
3330:300:    p.w = e->window;
3331:301:    p.error = 0;
3332:302:    p.count = e->count;
3333:303:
3334:304:    if (last_region) {          /* this amalgamates p with a region on the stack of the same window */
3335:305:        CRegion q;
3336:306:        int i;
3337:307:        for (i = last_region - 1; i >= 0; i--) {
3338:308:            if (regions[i].w == p.w) {
3339:309:                q = add_regions (regions[i], p);
3340:310:                if (q.error < 100) {
3341:311:                    regions[i] = q; /* amalgamate region, else... */
3342:312:                    return 0;
3343:313:                }
3344:314:            }
3345:315:        }
3346:316:    }
3347:317:
3348:318:    regions[last_region++] = p; /* ...store a completely new region */
3349:319:    if (last_region >= MAX_NUM_REGIONS) {
3350:320:        printf ("push_region(): last_region >= MAX_NUM_REGIONS\n");
3351:321:        return 1;
3352:322:    }
3353:323:    return 0;
3354:324:}
3355:325:
3356:326:/*
3357:327:   Pops the first region matching w, if w == 0 then pops 
3358:328:   the first region, returns 1 on empty . (It actually 
3359:329:   searches the "stack" from the bottom to the top so
3360:330:   that exposes are returned in order.)
3361:331: */
3362:332:static int pop_region (XExposeEvent * e, Window w)
3363:333:{
3364:334:    e->type = 0;
3365:335:    if (last_region) {
3366:336:        int i = 0;
3367:337:        if (w == 0)
3368:338:            goto any_window;
3369:339:        for (i = last_region - 1; i >= 0; i--) {
3370:340:            if (regions[i].w == w) {
3371:341:              any_window:;
3372:342:                e->type = Expose;
3373:343:                e->serial = e->send_event = 0;
3374:344:                e->display = CDisplay;
3375:345:                e->window = regions[i].w;
3376:346:                e->x = min (regions[i].x1, regions[i].x2);
3377:347:                e->y = min (regions[i].y1, regions[i].y2);
3378:348:                e->width = abs (regions[i].x1 - regions[i].x2);
3379:349:                e->height = abs (regions[i].y1 - regions[i].y2);
3380:350:                e->count = regions[i].count;
3381:351:                last_region--;
3382:352:                memmove (&(regions[i]), &(regions[i + 1]),
3383:353:                         (last_region - i) * sizeof (CRegion));
3384:354:                return 0;
3385:355:            }
3386:356:        }
3387:357:    }
3388:358:    return 1;
3389:359:}
3390:360:
3391:361:static void pop_all_regions (Window w)
3392:362:{
3393:363:    XEvent e;
3394:364:    while (!pop_region (&(e.xexpose), w)) {
3395:365:        e.type = InternalExpose;
3396:366:        CSendEvent (&e);
3397:367:    }
3398:368:}
3399:369:
3400:370:
3401:371:/* }}} end expose amalgamation stack system */
3402:372:
3403:373:
3404:374:/* {{{ key conversion utuilities */
3405:375:
3406:376:/* just get a keysym (one of eg XK_... in keysymdef.h */
3407:377:KeySym CKeySym (XEvent * e)
3408:378:{
3409:379:    char xlat;
3410:380:    KeySym key;
3411:381:    if (e->type == KeyPress || e->type == KeyRelease) {
3412:382:        XLookupString (&(e->xkey), &xlat, 1, &key, NULL);
3413:383:        return key;
3414:384:    } else
3415:385:        return 0;
3416:386:}
3417:387:
3418:388:static unsigned long toggle_bit (unsigned long x, unsigned long mask)
3419:389:{
3420:390:    unsigned long m = -1;
3421:391:    if (x & mask)
3422:392:        return x & (m - mask);
3423:393:    else
3424:394:        return x | mask;
3425:395:}
3426:396:
3427:397:
3428:398:/* get a 15 bit "almost unique" key sym that includes keyboard modifier
3429:399:   info in the top 3 bits */
3430:400:short CKeySymMod (XEvent * ev)
3431:401:{
3432:402:    KeySym p;
3433:403:    XEvent e;
3434:404:    int state;
3435:405:    e = *ev;
3436:406:    state = e.xkey.state;
3437:407:    e.xkey.state = 0;           /* want the raw key */
3438:408:    p = CKeySym (&e);
3439:409:    if (p && p != XK_Control_L && p != XK_Control_R && p != XK_Shift_L
3440:410:        && p != XK_Shift_R && p != XK_Alt_L && p != XK_Alt_R) {
3441:411:        p = toggle_bit (p, 0x1000 * ((state & ShiftMask) != 0));
3442:412:        p = toggle_bit (p, 0x2000 * ((state & ControlMask) != 0));
3443:413:        p = toggle_bit (p, 0x4000 * ((state & Mod1Mask) != 0));
3444:414:        p &= 0x7FFF;
3445:415:    } else
3446:416:        p = 0;
3447:417:    return p;
3448:418:}
3449:419:
3450:420:/* }}} key conversion utilities */
3451:421:
3452:422:
3453:423:/* {{{ focus cycling */
3454:424:
3455:425:#define is_focus_change_key(k) \
3456:426:    ((k) == XK_Tab || (k) == XK_KP_Tab || (k) == XK_ISO_Left_Tab || (k) == XK_Down || \
3457:427:    (k) == XK_Up || (k) == XK_Left || (k) == XK_Right || (k) == XK_KP_Down || \
3458:428:    (k) == XK_KP_Up || (k) == XK_KP_Left || (k) == XK_KP_Right)
3459:429:
3460:430:#define is_focus_prev_key(k,state) \
3461:431:    ((k) == XK_ISO_Left_Tab || (((state) & ShiftMask) && \
3462:432:    ((k) == XK_Tab || (k) == XK_KP_Tab)) || (k) == XK_Left \
3463:433:    || (k) == XK_Up || (k) == XK_KP_Left || (k) == XK_KP_Up)
3464:434:
3465:435:#define is_focus_next_key(k,state) not_needed
3466:436:
3467:437:/*
3468:438:   This shifts focus to the previous or next sibling widget.
3469:439:   (usually the tab key is used, but also responds to up, down,
3470:440:   left and right.)
3471:441: */
3472:442:static int CCheckTab (XEvent * xevent, CEvent * cwevent)
3473:443:{
3474:444:    if (xevent->type == KeyPress) {
3475:445:        KeySym k;
3476:446:        CWidget *w;
3477:447:        k = CKeySym (xevent);
3478:448:        if (!is_focus_change_key (k))
3479:449:            return 0;
3480:450:
3481:451:        w = CW (CWidgetOf (xevent->xany.window));
3482:452:
3483:453:        if (!w)
3484:454:            CFocus (CFindFirstDescendent (xevent->xany.window));
3485:455:        else if (!w->takes_focus)
3486:456:            CFocus (CChildFocus (w));
3487:457:        else if (is_focus_prev_key (k, xevent->xkey.state))
3488:458:            CFocus (CPreviousFocus (w));
3489:459:        else
3490:460:            CFocus (CNextFocus (w));
3491:461:        return 1;
3492:462:    }
3493:463:    return 0;
3494:464:}
3495:465:
3496:466:#define r_lcase(x) (((x) >= 'A' && (x) <= 'Z') ? (x) + 'a' - 'A' : (x))
3497:467:
3498:468:/*
3499:469:   Check for hot keys of buttons, sends a ButtonPress to the button if the key found.
3500:470: */
3501:471:static int CCheckButtonHotKey (XEvent * xevent, CEvent * cwevent)
3502:472:{
3503:473:    if (xevent->type == KeyPress) {
3504:474:        KeySym k;
3505:475:        CWidget *w, *p;
3506:476:        char xlat;
3507:477:        XLookupString (&(xevent->xkey), &xlat, 1, &k, NULL);
3508:478:        if (xlat < ' ' || xlat > '~')
3509:479:            return 0;
3510:480:        w = CW (CWidgetOf (xevent->xany.window));
3511:481:        if (!w)
3512:482:            w = CFindFirstDescendent (xevent->xany.window);
3513:483:        else if (!w->takes_focus)
3514:484:            w = CChildFocus (w);
3515:485:        p = w;
3516:486:        do {
3517:487:            if (!w)
3518:488:                return 0;
3519:489:            if (r_lcase (w->hotkey) == r_lcase (xlat)) {
3520:490:                XEvent e;
3521:491:                CFocus (w);
3522:492:                memset (&e, 0, sizeof (XEvent));
3523:493:                e.xbutton.type = ButtonPress;
3524:494:                e.xbutton.display = CDisplay;
3525:495:                e.xbutton.window = w->winid;
3526:496:                e.xbutton.button = Button1;
3527:497:                CSendEvent (&e);
3528:498:                e.xbutton.type = ButtonRelease;
3529:499:                CSendEvent (&e);
3530:500:                return 1;
3531:501:            }
3532:502:            w = CNextFocus (w); /* check all sibling buttons for a hotkey */
3533:503:        } while ((unsigned long) w != (unsigned long) p);
3534:504:    }
3535:505:    return 0;
3536:506:}
3537:507:
3538:508:/* checks all widgets for a hotkey if alt is pressed */
3539:509:static int CCheckGlobalHotKey (XEvent * xevent, CEvent * cwevent)
3540:510:{
3541:511:    if (xevent->type == KeyPress && (xevent->xkey.state & Mod1Mask)) {
3542:512:        int i = CLastwidget;
3543:513:        KeySym k;
3544:514:        CWidget *w;
3545:515:        char xlat;
3546:516:        XLookupString (&(xevent->xkey), &xlat, 1, &k, NULL);
3547:517:        if (xlat < ' ' || xlat > '~')
3548:518:            return 0;
3549:519:
3550:520:        while (--i > 0)
3551:521:            if ((w = CW (i)) != NULL)
3552:522:                if (w->takes_focus && !w->disabled)
3553:523:                    if (r_lcase (w->hotkey) == r_lcase (xlat)) {
3554:524:                        XEvent e;
3555:525:                        CFocus (w);
3556:526:                        memset (&e, 0, sizeof (XEvent));
3557:527:                        e.xbutton.type = ButtonPress;
3558:528:                        e.xbutton.display = CDisplay;
3559:529:                        e.xbutton.window = w->winid;
3560:530:                        e.xbutton.button = Button1;
3561:531:                        CSendEvent (&e);
3562:532:                        e.xbutton.type = ButtonRelease;
3563:533:                        CSendEvent (&e);
3564:534:                        return 1;
3565:535:                    }
3566:536:    }
3567:537:    return 0;
3568:538:}
3569:539:
3570:540:
3571:541:/* }}} */
3572:542:
3573:543:/* sets the mapped member of widget whose window is w, returning the previous state */
3574:544:static int set_mapped (Window w, int i)
3575:545:{
3576:546:    int x, y;
3577:547:    x = CWidgetOf (w);
3578:548:    if (!x)
3579:549:        return i;
3580:550:    y = CW (x)->mapped;
3581:551:    CW (x)->mapped = i;
3582:552:    return y;
3583:553:}
3584:554:
3585:555:
3586:556:/*
3587:557:   This is the core of the library. CNextEvent must be called continually.
3588:558:   The calling application must only use CNextEvent as a block.
3589:559:   CNextEvent does the following in sequence:
3590:560:
3591:561:   1 check if event is AlarmEvent, yes: toggle cursor and return
3592:562:   2 check MappingNotify and return
3593:563:   3 cache expose event for later handling. No "raw" exposes are ever processed.
3594:564:   they are first merged into courser exposes and resent via the internal
3595:565:   queue; return
3596:566:   4 check if an internal expose resulting from 3 above. If so rename it to Expose
3597:567:   and continue
3598:568:   5 look for a widget whose window matches .xany.window. If the widget is not
3599:569:   a picture widget then call the widget event handling routine: eh_*
3600:570:   Then call the widgets user event handler: ->callback
3601:571:   6 do the same for picture widgets. These must come last so that the get drawn
3602:572:   on top of other things if there is for exampla a image and a picture in
3603:573:   the same window.
3604:574:   8 if the event was a key event, and none of the handlers returned 1
3605:575:   check the tab key for focus cycling.
3606:576: */
3607:577:
3608:578:
3609:579:/* xevent or cwevent or both my be passed as NULL */
3610:580:void CNextEvent (XEvent * xevent, CEvent * cwevent)
3611:581:{
3612:582:    static char idle = 1;
3613:583:    static char no_ident[33];
3614:584:    int i = 0;
3615:585:    int handled = 0;
3616:586:    CWidget *w;
3617:587:    XEvent private_xevent;
3618:588:    CEvent private_cwevent;
3619:589:    Window win;
3620:590:    static Window drop_window = 0;
3621:591:    int type;
3622:592:    static Window last_events_window1 = -2;
3623:593:    static Window last_events_window2 = -2;
3624:594:    static int last_widget1 = 0;
3625:595:    static int last_widget2 = 0;
3626:596:
3627:597:    if (!xevent)
3628:598:        xevent = &private_xevent;
3629:599:    if (!cwevent)
3630:600:        cwevent = &private_cwevent;
3631:601:
3632:602:    if (!CPending ()) {         /* We want to make sure XNextEvent never blocks waiting for an event */
3633:603:        pop_all_regions (0);    /* just make sure not outstanding exposes */
3634:604:        pause ();
3635:605:    }
3636:606:    if (!pop_event (xevent))    /* first check our own events */
3637:607:        XNextEvent (CDisplay, xevent); /* if none of our own coming, _then_ we look at the server */
3638:608:
3639:609:    memset (cwevent, 0, sizeof (CEvent));
3640:610:    memset (no_ident, 0, 33);
3641:611:    cwevent->text = no_ident;
3642:612:    cwevent->ident = no_ident;
3643:613:
3644:614:    win = xevent->xany.window;
3645:615:    type = xevent->type;
3646:616:
3647:617:    switch (type) {
3648:618:    case TickEvent:
3649:619:        if (idle == 1)          /* this will XSync at the end of a burst of events */
3650:620:            XSync (CDisplay, 0); /* this is the only place in the library where XSync is called */
3651:621:        idle++;
3652:622:        return;
3653:623:    case AlarmEvent:
3654:624:        cwevent->type = AlarmEvent;
3655:625:        Ctoggle_cursor ();
3656:626:        if (global_alarm_callback) {
3657:627:            cwevent->type = type;
3658:628:            cwevent->kind = CALARM_WIDGET;
3659:629:            (*(global_alarm_callback)) (0, xevent, cwevent);
3660:630:        }
3661:631:        return;
3662:632:    case MappingNotify:
3663:633:        XRefreshKeyboardMapping (&(xevent->xmapping));
3664:634:        break;
3665:635:    case Expose:{
3666:636:            XEvent eev;
3667:637:/* here we amalgamate exposes of the same window together and re-send them as InternalExpose events */
3668:638:            if (push_region (&(xevent->xexpose))) {
3669:639:                pop_all_regions (win);
3670:640:            } else {
3671:641:                for (;;) {
3672:642:                    if (CExposePending (win, &eev)) {
3673:643:                        if (!push_region (&(eev.xexpose)))
3674:644:                            continue;
3675:645:                    }
3676:646:                    pop_all_regions (win);
3677:647:                    break;
3678:648:                }
3679:649:            }
3680:650:        }
3681:651:        return;
3682:652:    case InternalExpose:
3683:653:        type = xevent->type = Expose;
3684:654:        break;
3685:655:    case EnterNotify:
3686:656:/* The dnd drag will trap all events except enter and leave. These can
3687:657:   be used to trace which window the pointer has gotten into during
3688:658:   a drag. */
3689:659:        drop_window = xevent->xbutton.window;
3690:660:        break;
3691:661:    case MapNotify:
3692:662:        if (set_mapped (xevent->xmap.window, MAPPED) & FOCUS_WHEN_MAPPED)
3693:663:            CFocusWindow (xevent->xmap.window);
3694:664:        break;
3695:665:    case FocusOut:
3696:666:        if (current_focus == win)
3697:667:            current_focus = -1;
3698:668:        break;
3699:669:    case FocusIn:              /* if some other app caused a focus,
3700:670:                                   we must update our local focus history */
3701:671:        {
3702:672:            CWidget *w;
3703:673:            w = CW (CWidgetOf (win));
3704:674:            if (w)
3705:675:                if (w->takes_focus && !w->disabled) {
3706:676:                    add_to_focus_stack (win);
3707:677:                    current_focus = win;
3708:678:                    break;
3709:679:                }
3710:680:            break;
3711:681:        }
3712:682:/* here we want key presses to go to our idea of what window is focussed,
3713:683:   no the window manager's, or the X Server's idea. */
3714:684:    case KeyPress:
3715:685:    case KeyRelease:{
3716:686:            Window w;
3717:687:            w = CGetFocus ();
3718:688:            if (w != -1 && w)
3719:689:                win = xevent->xany.window = w;
3720:690:            break;
3721:691:        }
3722:692:    case UnmapNotify:
3723:693:        set_mapped (xevent->xmap.window, 0);
3724:694:        break;
3725:695:    case ClientMessage:
3726:696:/* If we recieve a drop from dnd, we need to find the window in which the
3727:697:   drop occurred. This will be the last window with an EnterNotify (above).
3728:698:   Now we find the pointer coords relative to that window, and change the
3729:699:   event to go to that window */
3730:700:        if (xevent->xclient.message_type == DndProtocol
3731:701:            && xevent->xclient.data.l[4] == 1) {
3732:702:            int x, y, rx, ry;
3733:703:            Window root, child;
3734:704:            unsigned int mask;
3735:705:            win = xevent->xclient.window = drop_window;
3736:706:            XQueryPointer (CDisplay, drop_window, &root, &child, &rx, &ry,
3737:707:                           &x, &y, &mask);
3738:708:            xevent->xclient.data.l[3] = (long) x + (long) y *65536L;
3739:709:        }
3740:710:        break;
3741:711:    }
3742:712:
3743:713:    idle = 0;
3744:714:
3745:715:    if (last_events_window1 == win && CW (last_widget1)) /* this will speed up the search a bit */
3746:716:        i = last_widget1 - 1;   /* by remembering the last two windows */
3747:717:    else if (last_events_window2 == win && CW (last_widget2))
3748:718:        i = last_widget2 - 1;
3749:719:
3750:720:/*Now find if the event belongs to any of the widgets */
3751:721:    while (CLastwidget > i++) {
3752:722:        if (!(w = CW (i)))
3753:723:            continue;
3754:724:        if (w->winid != win)
3755:725:            continue;
3756:726:        if (w->disabled && type != Expose)
3757:727:            break;
3758:728:        if (w->kind == CPICTURE_WIDGET)
3759:729:            continue;
3760:730:
3761:731:        last_widget2 = last_widget1;
3762:732:        last_widget1 = i;
3763:733:        last_events_window2 = last_events_window1;
3764:734:        last_events_window1 = win;
3765:735:
3766:736:        cwevent->type = type;
3767:737:        cwevent->kind = w->kind;
3768:738:        cwevent->window = win;
3769:739:
3770:740:        if (w->eh)
3771:741:            handled |= (*(w->eh)) (w, xevent, cwevent);
3772:742:        if (w->callback && cwevent->ident[0]) { /*irrelevent eh's won't set ident */
3773:743:            handled |= (*(w->callback)) (w, xevent, cwevent);
3774:744:        }
3775:745:
3776:746:        break;
3777:747:    }
3778:748:
3779:749:#ifdef HAVE_PICTURE
3780:750:
3781:751:    i = 0;
3782:752:/* picture exposes must come last so that they can be drawn on top of
3783:753:   other widgets */
3784:754:    while (CLastwidget > i++) {
3785:755:        if (!(w = CW (i)))
3786:756:            continue;
3787:757:        if (w->kind != CPICTURE_WIDGET)
3788:758:            continue;
3789:759:        if (w->parentid != xevent->xany.window)
3790:760:            continue;
3791:761:        if (w->disabled && type != Expose)
3792:762:            continue;
3793:763:        cwevent->type = type;
3794:764:        cwevent->kind = w->kind;
3795:765:        cwevent->window = xevent->xany.window;
3796:766:
3797:767:        if (w->eh)
3798:768:            handled |= (*(w->eh)) (w, xevent, cwevent);
3799:769:        if (w->callback && cwevent->ident[0]) { /*relevent events will set ident */
3800:770:            handled |= (*(w->callback)) (w, xevent, cwevent);
3801:771:        }
3802:772:        /*break; *//*no break here 'cos there may be two picture widgets in the same window */
3803:773:    }
3804:774:
3805:775:#endif                          /* ! HAVE_PICTURE */
3806:776:
3807:777:    if (type == KeyPress) {
3808:778:        cwevent->handled = handled;
3809:779:        if (!handled)
3810:780:            handled = CCheckTab (xevent, cwevent);
3811:781:        if (!handled)
3812:782:            handled = CCheckButtonHotKey (xevent, cwevent);
3813:783:        if (!handled)
3814:784:            handled = CCheckGlobalHotKey (xevent, cwevent);
3815:785:    }
3816:786:#ifdef DEBUG
3817:787:    Ccheck ();
3818:788:#endif
3819:789:}
3820:790:
3821:791:
3822:792:
3823:793:
3824:794:
3825:795:/*-----------------------------------------------------------------------*/
3826:796:int eh_button (CWidget * w, XEvent * xevent, CEvent * cwevent)
3827:797:{
3828:798:    switch (xevent->type) {
3829:799:    case FocusIn:
3830:800:        Crenderbutton (w);
3831:801:    case FocusOut:
3832:802:        Crenderbutton (w);
3833:803:        Cexposewindowarea (w->parentid, 0, w->x - FOCUS_RING,
3834:804:                           w->y - FOCUS_RING, w->width + FOCUS_RING * 2,
3835:805:                           w->height + FOCUS_RING * 2);
3836:806:        break;
3837:807:    case MotionNotify:
3838:808:        break;
3839:809:    case ButtonPress:
3840:810:        w->options = CBUTTON_PRESSED;
3841:811:        CFocus (w);
3842:812:        Crenderbutton (w);
3843:813:        break;
3844:814:    case KeyPress:{
3845:815:            int c = CKeySym (xevent);
3846:816:            cwevent->key = c;
3847:817:            if (c != XK_Return && c != XK_space)
3848:818:                break;
3849:819:        }
3850:820:    case ButtonRelease:
3851:821:        w->options = CBUTTON_HIGHLIGHT;
3852:822:        Crenderbutton (w);
3853:823:        cwevent->ident = w->ident; /* return the event */
3854:824:        return 1;
3855:825:    case EnterNotify:
3856:826:        w->options = CBUTTON_HIGHLIGHT;
3857:827:        Crenderbutton (w);
3858:828:        break;
3859:829:    case Expose:
3860:830:        if (xevent->xexpose.count)
3861:831:            break;
3862:832:    case LeaveNotify:
3863:833:        w->options = 0;
3864:834:        Crenderbutton (w);
3865:835:        break;
3866:836:    }
3867:837:    return 0;
3868:838:}
3869:839:
3870:840:/*-----------------------------------------------------------------------*/
3871:841:int eh_bitmapbutton (CWidget * w, XEvent * xevent, CEvent * cwevent)
3872:842:{
3873:843:    switch (xevent->type) {
3874:844:    case ResizeNotify:
3875:845:        if (w->options == TEXT_CENTRED)
3876:846:            Csetwidgetposition (w->ident,
3877:847:                                (xevent->xconfigure.width - w->width) / 2 -
3878:848:                                4, w->y);
3879:849:        break;
3880:850:    case FocusIn:
3881:851:        Crenderbitmapbutton (w, 0);
3882:852:    case FocusOut:
3883:853:        Crenderbitmapbutton (w, 0);
3884:854:        Cexposewindowarea (w->parentid, 0, w->x - FOCUS_RING,
3885:855:                           w->y - FOCUS_RING, w->width + FOCUS_RING * 2,
3886:856:                           w->height + FOCUS_RING * 2);
3887:857:        break;
3888:858:    case MotionNotify:
3889:859:        CFocus (w);
3890:860:        break;
3891:861:    case ButtonPress:
3892:862:        CFocus (w);
3893:863:        Crenderbitmapbutton (w, 2);
3894:864:        break;
3895:865:    case KeyPress:{
3896:866:            int c = CKeySym (xevent);
3897:867:            cwevent->key = c;
3898:868:            if (c != XK_Return && c != XK_space)
3899:869:                break;
3900:870:        }
3901:871:    case ButtonRelease:
3902:872:        Crenderbitmapbutton (w, 1);
3903:873:        cwevent->ident = w->ident;
3904:874:        return 1;
3905:875:    case EnterNotify:
3906:876:        Crenderbitmapbutton (w, 1);
3907:877:        break;
3908:878:    case Expose:
3909:879:        if (xevent->xexpose.count)
3910:880:            break;
3911:881:    case LeaveNotify:
3912:882:        Crenderbitmapbutton (w, 0);
3913:883:        break;
3914:884:    }
3915:885:    return 0;
3916:886:}
3917:887:
3918:888:/*-----------------------------------------------------------------------*/
3919:889:int eh_switch (CWidget * w, XEvent * xevent, CEvent * cwevent)
3920:890:{
3921:891:    switch (xevent->type) {
3922:892:    case FocusIn:
3923:893:        Crenderswitch (w, 0);
3924:894:    case FocusOut:
3925:895:        Crenderswitch (w, 0);
3926:896:        Cexposewindowarea (w->parentid, 0, w->x - FOCUS_RING,
3927:897:                           w->y - FOCUS_RING, w->width + FOCUS_RING * 2,
3928:898:                           w->height + FOCUS_RING * 2);
3929:899:        break;
3930:900:    case MotionNotify:
3931:901:        break;
3932:902:    case ButtonPress:
3933:903:        CFocus (w);
3934:904:        Crenderswitch (w, 2);
3935:905:        break;
3936:906:    case KeyPress:{
3937:907:            int c = CKeySym (xevent);
3938:908:            cwevent->key = c;
3939:909:            if (c != XK_space)
3940:910:                break;
3941:911:        }
3942:912:    case ButtonRelease:
3943:913:        w->keypressed = !w->keypressed;
3944:914:        cwevent->ident = w->ident;
3945:915:        cwevent->key = w->keypressed;
3946:916:        Crenderswitch (w, 1);
3947:917:        return 1;
3948:918:    case EnterNotify:
3949:919:        Crenderswitch (w, 1);
3950:920:        break;
3951:921:    case Expose:
3952:922:        if (xevent->xexpose.count)
3953:923:            break;
3954:924:    case LeaveNotify:
3955:925:        Crenderswitch (w, 0);
3956:926:        break;
3957:927:    }
3958:928:    return 0;
3959:929:}
3960:930:
3961:931:/*-----------------------------------------------------------------------*/
3962:932:int eh_bitmap (CWidget * w, XEvent * xevent, CEvent * cwevent)
3963:933:{
3964:934:    switch (xevent->type) {
3965:935:    case Expose:
3966:936:        if (!xevent->xexpose.count)
3967:937:            Crenderbitmapbutton (w, 3);
3968:938:        break;
3969:939:    }
3970:940:    return 0;
3971:941:}
3972:942:
3973:943:
3974:944:
3975:945:/*-----------------------------------------------------------------------*/
3976:946:int eh_window (CWidget * w, XEvent * xevent, CEvent * cwevent)
3977:947:{
3978:948:    static int windowx, windowy;
3979:949:    static int wx = 0, wy = 0;
3980:950:    static int wwidth = 0, wheight = 0;
3981:951:    static int allowwindowmove = 0;
3982:952:    static int allowwindowresize = 0;
3983:953:
3984:954:    switch (xevent->type) {
3985:955:    case Expose:
3986:956:        if (!xevent->xexpose.count)
3987:957:            Crenderwindow (w);
3988:958:        break;
3989:959:    case ButtonRelease:
3990:960:        window_is_resizing = 0;
3991:961:        Cresolvebutton (xevent, cwevent);
3992:962:        allowwindowmove = 0;
3993:963:        allowwindowresize = 0;
3994:964:        break;
3995:965:    case ButtonPress:
3996:966:        Cresolvebutton (xevent, cwevent);
3997:967:        if (cwevent->double_click == 1) {
3998:968:            CWidget *c = CChildFocus (w);
3999:969:            if (c)
4000:970:                CFocus (c);
4001:971:        }
4002:972:        if (cwevent->button == Button1
4003:973:            && !(w->position & CALWAYS_ON_BOTTOM)) {
4004:974:            XRaiseWindow (CDisplay, w->winid);
4005:975:            Craisewindows ();
4006:976:        } else if (cwevent->button == Button2
4007:977:                   && !(w->position & CALWAYS_ON_TOP)) {
4008:978:            XLowerWindow (CDisplay, w->winid);
4009:979:            Clowerwindows ();
4010:980:        }
4011:981:        windowx = xevent->xbutton.x_root - w->x;
4012:982:        windowy = xevent->xbutton.y_root - w->y;
4013:983:        wx = xevent->xbutton.x;
4014:984:        wy = xevent->xbutton.y;
4015:985:        wwidth = w->width;
4016:986:        wheight = w->height;
4017:987:        if (wx + wy > w->width + w->height - 40
4018:988:            && w->position & CRESIZABLE)
4019:989:            allowwindowresize = 1;
4020:990:        else
4021:991:            allowwindowmove = 1;
4022:992:        break;
4023:993:    case MotionNotify:
4024:994:        Cresolvebutton (xevent, cwevent);
4025:995:        if (!(w->position & CFIXED_POSITION) && allowwindowmove
4026:996:            && (cwevent->state & (Button1Mask | Button2Mask))) {
4027:997:            w->x = xevent->xmotion.x_root - windowx;
4028:998:            w->y = xevent->xmotion.y_root - windowy;
4029:999:            if (w->x + xevent->xmotion.x < 2)
4030:1000:                w->x = -wx + 2;
4031:1001:            if (w->y + xevent->xmotion.y < 2)
4032:1002:                w->y = -wy + 2;
4033:1003:            XMoveWindow (CDisplay, w->winid, w->x, w->y);
4034:1004:        }
4035:1005:        if ((w->position & CRESIZABLE) && allowwindowresize
4036:1006:            && (cwevent->state & (Button1Mask | Button2Mask))) {
4037:1007:            int wi, he;
4038:1008:            window_is_resizing = w->winid;
4039:1009:            wi = wwidth + xevent->xmotion.x_root - windowx - w->x;
4040:1010:            he = wheight + xevent->xmotion.y_root - windowy - w->y;
4041:1011:
4042:1012:/* this is actually for the edit windows, and needs to be generalized */
4043:1013:            if (wi < w->mark1)
4044:1014:                wi = w->mark1;
4045:1015:            if (he < w->mark2)
4046:1016:                he = w->mark2;
4047:1017:
4048:1018:            wi -= w->firstcolumn;
4049:1019:            wi -= wi % w->textlength;
4050:1020:            wi += w->firstcolumn;
4051:1021:            he -= w->firstline;
4052:1022:            he -= he % w->numlines;
4053:1023:            he += w->firstline;
4054:1024:
4055:1025:            Csetwidgetsize (w->ident, wi, he);
4056:1026:        }
4057:1027:        break;
4058:1028:    }
4059:1029:    return 0;
4060:1030:}
4061:1031:
4062:1032:/*-----------------------------------------------------------------------*/
4063:1033:int eh_bar (CWidget * w, XEvent * xevent, CEvent * cwevent)
4064:1034:{
4065:1035:    switch (xevent->type) {
4066:1036:    case ResizeNotify:
4067:1037:        Csetwidgetsize (w->ident,
4068:1038:                        xevent->xconfigure.width - WIDGET_SPACING * 2, 3);
4069:1039:        break;
4070:1040:    case Expose:
4071:1041:        if (!xevent->xexpose.count)
4072:1042:            Crenderbar (w);
4073:1043:        break;
4074:1044:    }
4075:1045:    return 0;
4076:1046:}
4077:1047:
4078:1048:/*-----------------------------------------------------------------------*/
4079:1049:int eh_progress (CWidget * w, XEvent * xevent, CEvent * cwevent)
4080:1050:{
4081:1051:    switch (xevent->type) {
4082:1052:    case Expose:
4083:1053:        if (!xevent->xexpose.count)
4084:1054:            Crenderprogress (w);
4085:1055:        break;
4086:1056:    }
4087:1057:    return 0;
4088:1058:}
4089:1059:
4090:1060:
4091:1061:/*-----------------------------------------------------------------------*/
4092:1062:int eh_text (CWidget * w, XEvent * xevent, CEvent * cwevent)
4093:1063:{
4094:1064:    switch (xevent->type) {
4095:1065:    case ResizeNotify:
4096:1066:        if (w->options == TEXT_CENTRED)
4097:1067:            Csetwidgetposition (w->ident,
4098:1068:                                (xevent->xconfigure.width - w->width) / 2 -
4099:1069:                                1 - TEXT_RELIEF, w->y);
4100:1070:        break;
4101:1071:    case Expose:
4102:1072:        if (!xevent->xexpose.count)
4103:1073:            Crendertext (w);
4104:1074:        break;
4105:1075:    }
4106:1076:    return 0;
4107:1077:}
4108:1078:
4109:1079:/*-----------------------------------------------------------------------*/
4110:1080:int eh_sunken (CWidget * w, XEvent * xevent, CEvent * cwevent)
4111:1081:{
4112:1082:    switch (xevent->type) {
4113:1083:    case Expose:
4114:1084:        if (!xevent->xexpose.count)
4115:1085:            Crendersunken (w);
4116:1086:        break;
4117:1087:    }
4118:1088:    return 0;
4119:1089:}
4120:1090:
4121:1091:/*-----------------------------------------------------------------------*/
4122:1092:int eh_bwimage (CWidget * w, XEvent * xevent, CEvent * cwevent)
4123:1093:{
4124:1094:/*      case C8BITIMAGE_WIDGET:
4125:1095:   case CBWIMAGE_WIDGET: */
4126:1096:#ifdef HAVE_BWIMAGE
4127:1097:    switch (xevent->type) {
4128:1098:    case Expose:
4129:1099:        Crenderbwimage (w, xevent->xexpose.x, xevent->xexpose.y,
4130:1100:                        xevent->xexpose.width, xevent->xexpose.height);
4131:1101:        break;
4132:1102:    case ButtonRelease:
4133:1103:    case ButtonPress:
4134:1104:    case MotionNotify:
4135:1105:        Cresolvebutton (xevent, cwevent);
4136:1106:        cwevent->x -= 2;        /*subtract border */
4137:1107:        cwevent->y -= 2;
4138:1108:        cwevent->ident = w->ident;
4139:1109:        break;
4140:1110:    }
4141:1111:#endif
4142:1112:    return 0;
4143:1113:}
4144:1114:
4145:1115:/*-----------------------------------------------------------------------*/
4146:1116:int eh_textinput (CWidget * w, XEvent * xevent, CEvent * cwevent)
4147:1117:{
4148:1118:    int handled = 0;
4149:1119:    char *intext;
4150:1120:    char xlat = 0;
4151:1121:    int cmd, ch;
4152:1122:    KeySym key;
4153:1123:
4154:1124:    switch (xevent->type) {
4155:1125:    case ButtonPress:
4156:1126:        Cresolvebutton (xevent, cwevent);
4157:1127:        CFocusWindow (w->winid);
4158:1128:    case Expose:
4159:1129:        if (xevent->xexpose.count)
4160:1130:            break;
4161:1131:    case FocusIn:
4162:1132:    case FocusOut:
4163:1133:        Crendertextinput (w);
4164:1134:        break;
4165:1135:    case KeyPress:
4166:1136:        XLookupString (&(xevent->xkey), &xlat, 1, &key, NULL);
4167:1137:        cwevent->ident = w->ident;
4168:1138:        cwevent->key = key;
4169:1139:        cwevent->xlat = xlat;
4170:1140:        cwevent->state = xevent->xkey.state;
4171:1141:        intext = w->text;
4172:1142:        if (edit_translate_key
4173:1143:            (0, xevent->xkey.keycode, key, xevent->xkey.state, &cmd,
4174:1144:             &ch)) {
4175:1145:            cwevent->command = cmd;
4176:1146:            if (ch > 0) {
4177:1147:                if (w->keypressed) {
4178:1148:                    if (strlen (intext) < w->textlength) {
4179:1149:                        memmove (intext + w->cursor + 1,
4180:1150:                                 intext + w->cursor,
4181:1151:                                 strlen (intext) - w->cursor + 1);
4182:1152:                        intext[w->cursor] = ch;
4183:1153:                        w->cursor++;
4184:1154:                    }
4185:1155:                } else {
4186:1156:                    w->cursor = 1;
4187:1157:                    intext[0] = ch;
4188:1158:                    intext[1] = 0;
4189:1159:                }
4190:1160:                handled = 1;
4191:1161:            } else {
4192:1162:                switch (cmd) {
4193:1163:                case CK_BackSpace:
4194:1164:                    if (w->cursor > 0) {
4195:1165:                        memmove (intext + w->cursor - 1,
4196:1166:                                 intext + w->cursor,
4197:1167:                                 strlen (intext) - w->cursor + 1);
4198:1168:                        w->cursor--;
4199:1169:                    }
4200:1170:                    w->keypressed = 1;
4201:1171:                    handled = 1;
4202:1172:                    break;
4203:1173:                case CK_Left:
4204:1174:                    if (w->cursor > 0)
4205:1175:                        w->cursor--;
4206:1176:                    handled = 1;
4207:1177:                    break;
4208:1178:                case CK_Right:
4209:1179:                    if (w->cursor < strlen (intext))
4210:1180:                        w->cursor++;
4211:1181:                    handled = 1;
4212:1182:                    break;
4213:1183:                case CK_Delete:
4214:1184:                    if (w->cursor < strlen (intext))
4215:1185:                        memmove (intext + w->cursor,
4216:1186:                                 intext + w->cursor + 1,
4217:1187:                                 strlen (intext) - w->cursor + 1);
4218:1188:                    handled = 1;
4219:1189:                    break;
4220:1190:                case CK_Home:
4221:1191:                    w->cursor = 0;
4222:1192:                    handled = 1;
4223:1193:                    break;
4224:1194:                case CK_End:
4225:1195:                    w->cursor = strlen (intext);
4226:1196:                    handled = 1;
4227:1197:                    break;
4228:1198:                }
4229:1199:            }
4230:1200:            w->keypressed |= handled;
4231:1201:        }
4232:1202:        cwevent->text = w->text;
4233:1203:    }
4234:1204:
4235:1205:    Crendertextinput (w);
4236:1206:    return handled;
4237:1207:}
4238:1208:
4239:1209:/*-----------------------------------------------------------------------*/
4240:1210:int eh_3d (CWidget * w, XEvent * xevent, CEvent * cwevent)
4241:1211:{
4242:1212:#ifdef HAVE_THREE_D
4243:1213:/* case CTHREED_WIDGET: */
4244:1214:    switch (xevent->type) {
4245:1215:    case Expose:
4246:1216:        Crender3dwidget (w, xevent->xexpose.x, xevent->xexpose.y,
4247:1217:                         xevent->xexpose.width, xevent->xexpose.height);
4248:1218:        break;
4249:1219:    case ButtonRelease:
4250:1220:    case ButtonPress:
4251:1221:    case MotionNotify:
4252:1222:        Cresolvebutton (xevent, cwevent);
4253:1223:        cwevent->x -= 2;        /*subtract border */
4254:1224:        cwevent->y -= 2;
4255:1225:        cwevent->ident = w->ident;
4256:1226:        break;
4257:1227:    }
4258:1228:#endif
4259:1229:    return 0;
4260:1230:}
4261:1231:
4262:1232:/*-----------------------------------------------------------------------*/
4263:1233:
4264:1234:
4265:1235:void linkscrollbartotextbox (CWidget * w, CWidget * textbox,
4266:1236:                             XEvent * xevent, CEvent * cwevent,
4267:1237:                             int whichscrbutton)
4268:1238:{
4269:1239:    int redrawtext = 0;
4270:1240:    if (w->firstline > 65535)
4271:1241:        w->firstline = 65535;
4272:1242:    if (xevent->type == MotionNotify && whichscrbutton == 3) {
4273:1243:        Csettextboxpos (textbox, TEXT_SETLINE,
4274:1244:                        (double) w->firstline * textbox->numlines /
4275:1245:                        65535.0);
4276:1246:        redrawtext = 1;
4277:1247:    } else if (xevent->type == ButtonPress
4278:1248:               && (cwevent->button == Button1
4279:1249:                   || cwevent->button == Button2)) {
4280:1250:        switch (whichscrbutton) {
4281:1251:        case 1:
4282:1252:            Csettextboxpos (textbox, TEXT_SETLINE,
4283:1253:                            textbox->firstline -
4284:1254:                            (textbox->height / TEXT_PIX_PER_LINE - 2));
4285:1255:            break;
4286:1256:        case 2:
4287:1257:            Csettextboxpos (textbox, TEXT_SETLINE, textbox->firstline - 1);
4288:1258:            break;
4289:1259:        case 5:
4290:1260:            Csettextboxpos (textbox, TEXT_SETLINE, textbox->firstline + 1);
4291:1261:            break;
4292:1262:        case 4:
4293:1263:            Csettextboxpos (textbox, TEXT_SETLINE,
4294:1264:                            textbox->firstline +
4295:1265:                            (textbox->height / TEXT_PIX_PER_LINE - 2));
4296:1266:            break;
4297:1267:        }
4298:1268:        redrawtext = 1;
4299:1269:    }
4300:1270:    {
4301:1271:        int count;
4302:1272:        w->firstline =
4303:1273:            (double) 65535.0 *textbox->firstline / textbox->numlines;
4304:1274:        if (redrawtext) {
4305:1275:            char *input = catstrs ("sprinp", textbox->ident, 0);
4306:1276:            Cundrawwidget (input);
4307:1277:            count = Crendertextbox (textbox, 0);
4308:1278:        } else
4309:1279:            count = Ccounttextboxlines (textbox, 0);
4310:1280:        w->numlines = (double) 65535.0 *count / textbox->numlines;
4311:1281:    }
4312:1282:}
4313:1283:
4314:1284:void linkscrollbartoeditor (CWidget * w, CWidget * editor, XEvent * xevent,
4315:1285:                            CEvent * cwevent, int whichscrbutton);
4316:1286:
4317:1287:int eh_vertscroll (CWidget * w, XEvent * xevent, CEvent * cwevent)
4318:1288:{
4319:1289:    static int buttonypos;
4320:1290:    static int y;
4321:1291:    static int whichscrbutton = 0; /*which of the five scroll bar buttons was pressed */
4322:1292:
4323:1293:    switch (xevent->type) {
4324:1294:    case LeaveNotify:
4325:1295:    case Expose:
4326:1296:        w->options = 0;
4327:1297:        break;
4328:1298:    case ButtonRelease:
4329:1299:        w->options =
4330:1300:            32 + Cscrollwhereis (xevent->xmotion.x, xevent->xmotion.y, w);
4331:1301:        break;
4332:1302:    case ButtonPress:
4333:1303:        Cresolvebutton (xevent, cwevent);
4334:1304:        if (cwevent->button == Button1 || cwevent->button == Button2) {
4335:1305:            buttonypos = xevent->xbutton.y;
4336:1306:            y = w->firstline;
4337:1307:            w->options = whichscrbutton =
4338:1308:                Cscrollwhereis (cwevent->x, cwevent->y, w);
4339:1309:            cwevent->ident = w->ident;
4340:1310:        }
4341:1311:        break;
4342:1312:    case MotionNotify:
4343:1313:        Cresolvebutton (xevent, cwevent);
4344:1314:        if (cwevent->state & (Button1Mask | Button2Mask)) {
4345:1315:            w->options = whichscrbutton;
4346:1316:            if (whichscrbutton == 3) {
4347:1317:                y += (double) (xevent->xmotion.y -
4348:1318:                               buttonypos) * (double) 65535.0 /
4349:1319:                    (w->height - 10 * w->width / 3 - 10);
4350:1320:                w->firstline = y;
4351:1321:                buttonypos = xevent->xmotion.y;
4352:1322:            }
4353:1323:        } else
4354:1324:            w->options =
4355:1325:                32 + Cscrollwhereis (xevent->xmotion.x, xevent->xmotion.y,
4356:1326:                                     w);
4357:1327:        break;
4358:1328:    default:
4359:1329:        return 0;
4360:1330:    }
4361:1331:
4362:1332:    if (cwevent->state & (Button1Mask | Button2Mask)
4363:1333:        || cwevent->type == ButtonPress) {
4364:1334:        CWidget *editor = (void *) w->editor;
4365:1335:        CWidget *textbox = w->textbox;
4366:1336:/*now check to see if there is a textbox associated with this scrollbar */
4367:1337:        if (textbox)
4368:1338:            linkscrollbartotextbox (w, textbox, xevent, cwevent,
4369:1339:                                    whichscrbutton);
4370:1340:/*now check to see if there is a editor associated with this scrollbar */
4371:1341:        if (editor)
4372:1342:            linkscrollbartoeditor (w, editor, xevent, cwevent,
4373:1343:                                   whichscrbutton);
4374:1344:    }
4375:1345:    if (w->numlines < 0)
4376:1346:        w->numlines = 0;
4377:1347:    if (w->firstline < 0)
4378:1348:        w->firstline = 0;
4379:1349:    if (w->firstline > 65535)
4380:1350:        w->firstline = 65535;
4381:1351:    if (w->firstline + w->numlines >= 65535)
4382:1352:        w->numlines = 65535 - w->firstline;
4383:1353:
4384:1354:    if (xevent->type != Expose || !xevent->xexpose.count)
4385:1355:        Crenderscrollbar (w);
4386:1356:
4387:1357:    return 0;
4388:1358:}
4389:1359:
4390:1360:/*-----------------------------------------------------------------------*/
4391:1361:
4392:1362:extern int eh_textbox (CWidget * w, XEvent * xevent, CEvent * cwevent);
4393:1363:
4394:1364:int (*Cdefaulthandler (int i)) (CWidget *, XEvent *, CEvent *) {
4395:1365:    switch (i) {
4396:1366:    case CBUTTON_WIDGET:
4397:1367:        return eh_button;
4398:1368:        break;
4399:1369:    case CWINDOW_WIDGET:
4400:1370:        return eh_window;
4401:1371:        break;
4402:1372:    case CBAR_WIDGET:
4403:1373:        return eh_bar;
4404:1374:        break;
4405:1375:    case CSUNKEN_WIDGET:
4406:1376:        return eh_sunken;
4407:1377:        break;
4408:1378:    case CHORSCROLL_WIDGET:
4409:1379:    case CVERTSCROLL_WIDGET:
4410:1380:        return eh_vertscroll;
4411:1381:        break;
4412:1382:    case CTEXTINPUT_WIDGET:
4413:1383:        return eh_textinput;
4414:1384:        break;
4415:1385:    case CTEXTBOX_WIDGET:
4416:1386:        return eh_textbox;
4417:1387:        break;
4418:1388:    case CTEXT_WIDGET:
4419:1389:        return eh_text;
4420:1390:        break;
4421:1391:    case CTHREED_WIDGET:
4422:1392:        return eh_3d;
4423:1393:        break;
4424:1394:    case C8BITIMAGE_WIDGET:
4425:1395:    case CBWIMAGE_WIDGET:
4426:1396:        return eh_bwimage;
4427:1397:        break;
4428:1398:    case CPROGRESS_WIDGET:
4429:1399:        return eh_progress;
4430:1400:        break;
4431:1401:    case CBITMAP_WIDGET:
4432:1402:        return eh_bitmap;
4433:1403:        break;
4434:1404:    case CBITMAPBUTTON_WIDGET:
4435:1405:        return eh_bitmapbutton;
4436:1406:        break;
4437:1407:    case CSWITCH_WIDGET:
4438:1408:        return eh_switch;
4439:1409:        break;
4440:1410:#ifdef HAVE_PICTURE
4441:1411:    case CPICTURE_WIDGET:
4442:1412:        return eh_picture;
4443:1413:        break;
4444:1414:#endif
4445:1415:    case CEDITOR_WIDGET:
4446:1416:        return eh_editor;
4447:1417:    }
4448:1418:    return NULL;
4449:1419:}
4450:1:#define get_byte(x,i)
4451:2:
4452:3:
4453:4:{
4454:5:    for (; row < height && from < view->last_byte; from++) {
4455:6:        c = get_byte (view, from);
4456:7:        if ((c == '\n') || (col == width && wrap_mode)) {
4457:8:            col = frame_shift;
4458:9:            row++;
4459:10:            if (c == '\n' || row >= height)
4460:11:                continue;
4461:12:        }
4462:13:        if (c == '\r')
4463:14:            continue;
4464:15:        if (c == '\t') {
4465:16:            col = ((col - frame_shift) / 8) * 8 + 8 + frame_shift;
4466:17:            continue;
4467:18:        }
4468:19:        if (view->viewer_nroff_flag && c == '\b') {
4469:20:            if (from + 1 < view->last_byte
4470:21:                && is_printable (get_byte (view, from + 1)) &&
4471:22:                from > view->first
4472:23:                && is_printable (get_byte (view, from - 1))) {
4473:24:                if (col <= frame_shift) {
4474:25:                    /* So it has to be wrap_mode - do not need to check for it */
4475:26:                    if (row == 1 + frame_shift) {
4476:27:                        from++;
4477:28:                        continue; /* There had to be a bold character on the rightmost position
4478:29:                                     of the previous undisplayed line */
4479:30:                    }
4480:31:                    row--;
4481:32:                    col = width;
4482:33:                }
4483:34:                col--;
4484:35:                boldflag = 1;
4485:36:                if (get_byte (view, from - 1) == '_'
4486:37:                    && get_byte (view, from + 1) != '_')
4487:38:                    set_color (UNDERLINE_COLOR);
4488:39:                else
4489:40:                    set_color (BOLD_COLOR);
4490:41:                continue;
4491:42:            }
4492:43:        }
4493:44:        if (view->found_len && from >= view->search_start
4494:45:            && from < view->search_start + view->found_len) {
4495:46:            boldflag = 1;
4496:47:            set_color (MARK_COLOR);
4497:48:        }
4498:49:        if (col >= frame_shift - view->start_col
4499:50:            && col < width - view->start_col) {
4500:51:            view_gotoyx (view, row, col + view->start_col);
4501:52:            add_character (view, c);
4502:53:        }
4503:54:        col++;
4504:55:        if (boldflag) {
4505:56:            boldflag = 0;
4506:57:            set_color (DEF_COLOR);
4507:58:        }
4508:59:    }
4509:60:}
4510:1:/* coolwidget.c - routines for simple widgets. Widget setup and destruction
4511:2:   Copyright (C) 1996 Paul Sheer
4512:3:
4513:4:   This program is free software; you can redistribute it and/or modify
4514:5:   it under the terms of the GNU General Public License as published by
4515:6:   the Free Software Foundation; either version 2 of the License, or
4516:7:   (at your option) any later version.
4517:8:
4518:9:   This program is distributed in the hope that it will be useful,
4519:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
4520:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
4521:12:   GNU General Public License for more details.
4522:13:
4523:14:   You should have received a copy of the GNU General Public License
4524:15:   along with this program; if not, write to the Free Software
4525:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
4526:17: */
4527:18:
4528:19:#define COOL_WIDGET_C
4529:20:
4530:21:#include "coolwidget.h"
4531:22:#include "coollocal.h"
4532:23:#include "dialog.h"
4533:24:
4534:25:#include "mad.h"
4535:26:
4536:27:/* call this for fatal errors */
4537:28:void Cerror (const char *fmt, ...)
4538:29:{
4539:30:    va_list s;
4540:31:    char *str;
4541:32:    va_start (s, fmt);
4542:33:    str = vsprintf_alloc (catstrs (" ", fmt, " ", 0), s);
4543:34:    Cfatalerrordialog (20, 20, str);
4544:35:    free (str);
4545:36:}
4546:37:
4547:38:
4548:39:
4549:40:/* an malloc with an error check */
4550:41:
4551:42:#ifndef HAVE_MAD
4552:43:
4553:44:#ifndef Cmalloc
4554:45:void *Cmalloc (size_t size)
4555:46:{
4556:47:    void *p;
4557:48:    if ((p = malloc (size)) == NULL)
4558:49:        Cerror ("Unable to allocate memory.\n");
4559:50:    return p;
4560:51:}
4561:52:#endif
4562:53:
4563:54:void *CDebugMalloc (size_t x, int line, const char *file)
4564:55:{
4565:56:    void *p;
4566:57:    if ((p = malloc (x)) == NULL)
4567:58:        Cerror ("Unable to allocate memory: line %d, file %s.\n", line,
4568:59:                file);
4569:60:    return p;
4570:61:}
4571:62:
4572:63:#endif
4573:64:
4574:65:
4575:66:struct cw_cursor {
4576:67:    int x, y, h, w;
4577:68:    Window window;
4578:69:    int state;
4579:70:    int type;
4580:71:    char chr;
4581:72:    unsigned long bg, fg;
4582:73:};
4583:74:
4584:75:struct cw_cursor CursorState = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
4585:76:
4586:77:void Cdrawcursor (Window window);
4587:78:
4588:79:void Csetcursor (Window win, int x, int y, int w, int h, int type, int chr,
4589:80:                 unsigned long bg, unsigned long fg)
4590:81:{
4591:82:    if (win == CGetFocus ()) {
4592:83:        CursorState.x = x;
4593:84:        CursorState.y = y;
4594:85:        CursorState.h = h;
4595:86:        CursorState.w = w;
4596:87:        CursorState.window = win;
4597:88:        CursorState.type = type;
4598:89:        CursorState.chr = chr;
4599:90:        CursorState.bg = bg;
4600:91:        CursorState.fg = fg;
4601:92:        Cdrawcursor (win);
4602:93:    } else {
4603:94:        if (!(win | h | w))
4604:95:            CursorState.window = 0;
4605:96:    }
4606:97:}
4607:98:
4608:99:
4609:100:
4610:101:void render_cursor (struct cw_cursor c, int clear_cursor)
4611:102:{
4612:103:    if (c.type == EDITOR_CURSOR) {
4613:104:        if (!c.state || clear_cursor)
4614:105:            Csetcolor (c.bg);
4615:106:        else
4616:107:            Csetcolor (Ccolor (19));
4617:108:        Cline (c.window, c.x,
4618:109:               c.y + CFontStruct->descent + IN_FONT_OFFSET_Y, c.x,
4619:110:               c.y + c.h - 1 + IN_FONT_OFFSET_Y);
4620:111:        Cline (c.window, c.x + 1,
4621:112:               c.y + CFontStruct->descent + IN_FONT_OFFSET_Y, c.x + 1,
4622:113:               c.y + c.h - 1 + IN_FONT_OFFSET_Y);
4623:114:        Cline (c.window, c.x + 2,
4624:115:               c.y + CFontStruct->descent + IN_FONT_OFFSET_Y,
4625:116:               c.x + c.w - 1,
4626:117:               c.y + CFontStruct->descent + IN_FONT_OFFSET_Y);
4627:118:        Cline (c.window, c.x + 2,
4628:119:               c.y + CFontStruct->descent + IN_FONT_OFFSET_Y + 1,
4629:120:               c.x + c.w - 1,
4630:121:               c.y + CFontStruct->descent + 1 + IN_FONT_OFFSET_Y);
4631:122:        if (!c.state || clear_cursor) {
4632:123:            Csetbackcolor (c.bg);
4633:124:            Csetcolor (c.fg);
4634:125:            XDrawImageString (CDisplay, c.window, CGC, c.x + FONT_OFFSET_X,
4635:126:                              c.y + FONT_OFFSET_Y, &(c.chr), 1);
4636:127:        }
4637:128:    } else {
4638:129:        if (CursorState.state) {
4639:130:            Csetcolor (C_FLAT);
4640:131:            Cline (c.window, c.x, c.y, c.x, c.y + c.h - 6);
4641:132:            Crenderbevel (c.window, c.x - 1, c.y - 1, c.x + 1,
4642:133:                          c.y + c.h - 5, 1, 0);
4643:134:        } else {
4644:135:            Csetcolor (C_FLAT);
4645:136:            Cline (c.window, c.x, c.y, c.x, c.y + c.h - 6); /*cursor bar flat */
4646:137:            Crenderbevel (c.window, c.x - 1, c.y - 1, c.x + 1, c.y + c.h - 5, 1, -1); /*cursor bar bevel */
4647:138:        }
4648:139:    }
4649:140:}
4650:141:
4651:142:
4652:143:/* this draws a full cursor if its window is focussed and draws a thin line otherwise. */
4653:144:void Cdrawcursor (Window window)
4654:145:{
4655:146:    if (CursorState.window == CGetFocus () && CursorState.window)
4656:147:        render_cursor (CursorState, 0);
4657:148:}
4658:149:
4659:150:
4660:151:/* this is called from CNextEvent if an alarm event comes */
4661:152:void Ctoggle_cursor ()
4662:153:{
4663:154:    CursorState.state = 1 - CursorState.state;
4664:155:    Cdrawcursor (0);            /* Cdrawcursor above does nothing if no window is focussed */
4665:156:}
4666:157:
4667:158:
4668:159:
4669:160:/*
4670:161:   These two routines are not much slower than doing the same
4671:162:   thing with integers as identifiers instead of strings.
4672:163:   It returns the index in the global array of widgets of
4673:164:   the widget named ident. Returns 0 if not found.
4674:165: */
4675:166:static inline int _CW_i (const char *ident)
4676:167:{
4677:168:    int i = CLastwidget + 1;
4678:169:    quad_t p;
4679:170:
4680:171:    memcpy (&p, ident, sizeof (quad_t)); /* we need four byte alignment for some machines */
4681:172:
4682:173:    if (ident[2]) {             /* can compare first four bytes at once */
4683:174:        while (--i)
4684:175:            if (CW (i))
4685:176:                if (*((quad_t *) CW (i)->ident) == p)
4686:177:                    if (!strcmp (CW (i)->ident, ident))
4687:178:                        return i;
4688:179:        return 0;
4689:180:    } else {
4690:181:        word s = *((word *) (&p));
4691:182:        while (--i)
4692:183:            if (CW (i))
4693:184:                if (*((word *) CW (i)->ident) == s)
4694:185:                    if (!strcmp (CW (i)->ident, ident))
4695:186:                        return i;
4696:187:
4697:188:    }
4698:189:    return 0;
4699:190:}
4700:191:
4701:192:int Ci (const char *ident)
4702:193:{
4703:194:    return _CW_i (ident);
4704:195:}
4705:196:
4706:197:CWidget *Cwidget (const char *ident)
4707:198:{
4708:199:    return CW (_CW_i (ident));
4709:200:}
4710:201:
4711:202:int Csystem (const char *string)
4712:203:{
4713:204:    int r;
4714:205:    CDisableAlarm ();
4715:206:    r = system (string);
4716:207:    CEnableAlarm ();
4717:208:    return r;
4718:209:}
4719:210:
4720:211:extern int (*global_alarm_callback) (CWidget *, XEvent *, CEvent *);
4721:212:
4722:213:void Caddcallback (const char *ident,
4723:214:                   int (*callback) (CWidget *, XEvent *, CEvent *))
4724:215:{
4725:216:    CWidget *w = Cwidget (ident);
4726:217:    if (w)
4727:218:        w->callback = callback;
4728:219:    else {
4729:220:        if (!strcmp (ident, "AlarmCallback"))
4730:221:            global_alarm_callback = callback;
4731:222:    }
4732:223:}
4733:224:
4734:225:/* checks the magic numbers */
4735:226:int Ccheck ()
4736:227:{
4737:228:    int i = 0;
4738:229:
4739:230:    while (CLastwidget > i++)
4740:231:        if (CW (i) != NULL)
4741:232:            if (CW (i)->magic_begin != CMAGIC_BEGIN
4742:233:                || CW (i)->magic_end != CMAGIC_END)
4743:234:                Cerror
4744:235:                    ("Cool widget internal error - magic number overwritten overwritten.\n");
4745:236:    return 0;
4746:237:}
4747:238:
4748:239:/* sends a full expose event to the widget */
4749:240:void Cexpose (const char *ident)
4750:241:{
4751:242:    CWidget *w = Cwidget (ident);
4752:243:    if (w)
4753:244:        CSendExpose (w->winid, 0, 0, w->width, w->height);
4754:245:}
4755:246:
4756:247:/* Returns the widgets window or 0 if not found */
4757:248:Window Cwin (const char *ident)
4758:249:{
4759:250:    CWidget *w = Cwidget (ident);
4760:251:    if (w)
4761:252:        return w->winid;
4762:253:    else
4763:254:        return 0;
4764:255:}
4765:256:
4766:257:/* send an expose event to the internel queue */
4767:258:void Cexposewindowarea (Window win, int count, int x, int y, int w, int h)
4768:259:{
4769:260:    if (x < 0) {
4770:261:        w = x + w;
4771:262:        x = 0;
4772:263:    }
4773:264:    if (y < 0) {
4774:265:        h = y + h;
4775:266:        y = 0;
4776:267:    }
4777:268:    if (w <= 0 || h <= 0)
4778:269:        return;
4779:270:
4780:271:    CSendExpose (win, x, y, w, h);
4781:272:}
4782:273:
4783:274:
4784:275:/* Returns the first NULL list entry. Exits if list full. */
4785:276:CWidget **Cfindemptywidgetentry ()
4786:277:{
4787:278:    int i = 0;
4788:279:
4789:280:/* widget can be added to an empty point in the list (created from an
4790:281:   undraw command, or to the end of the list. */
4791:282:    while (CLastwidget > i++) {
4792:283:        if (CW (i) == NULL)
4793:284:            break;
4794:285:    }
4795:286:
4796:287:    if (i == MAX_NUMBER_OF_WIDGETS - 2)
4797:288:        Cerror
4798:289:            ("No more space in widget list\nIncrease MAX_NUMBER_OF_WIDGETS in coolwidget.h\n");
4799:290:
4800:291:    if (i == CLastwidget)
4801:292:        CLastwidget++;          /* increase list length if an entry was added to the end */
4802:293:
4803:294:    return &(CW (i));
4804:295:}
4805:296:
4806:297:
4807:298:/* fills in the widget structure */
4808:299:CWidget *Callocatewidget (Window newwin, const char *ident, Window parent,
4809:300:                          int x, int y, int width, int height,
4810:301:                          int kindofwidget)
4811:302:{
4812:303:    CWidget *w = Cmalloc (sizeof (CWidget));
4813:304:    memset (w, 0, sizeof (CWidget)); /*: important, 'cos free's check if NULL before freeing many parems */
4814:305:
4815:306:    w->magic_begin = CMAGIC_BEGIN;
4816:307:    w->winid = newwin;
4817:308:    w->parentid = parent;
4818:309:    w->width = width;
4819:310:    w->height = height;
4820:311:    w->x = x;
4821:312:    w->y = y;
4822:313:    strncpy (w->ident, ident, 32);
4823:314:
4824:315:    w->kind = kindofwidget;
4825:316:    w->magic_end = CMAGIC_END;
4826:317:    return w;
4827:318:}
4828:319:
4829:320:
4830:321:/*
4831:322:   Sets up the widget's window and calls Callocatewidget()
4832:323:   to allocate space and set up the data structures.
4833:324:   What is set up here is common to all widgets, so
4834:325:   it will always be the first routine called by a Cdrawthis()
4835:326:   function.
4836:327: */
4837:328:CWidget *Csetupwidget (const char *identifier, Window parent, int x, int y,
4838:329:                       int width, int height, int kindofwidget,
4839:330:                       unsigned long input, unsigned long bgcolor,
4840:331:                       int takes_focus)
4841:332:{
4842:333:    Window newwin;
4843:334:    CWidget **w;
4844:335:
4845:336:    if (Cwidget (identifier) && kindofwidget == CBUTTON_WIDGET)
4846:337:        Cerror
4847:338:            ("Trying to create a button with the same identifier as an existing widget.\n");
4848:339:
4849:340:    newwin = XCreateSimpleWindow (CDisplay, parent, x, y, width,
4850:341:                                  height, 0, C_BLACK, bgcolor);
4851:342:
4852:343:    XSelectInput (CDisplay, newwin, input);
4853:344:
4854:345:    XMapWindow (CDisplay, newwin); /* shows the window */
4855:346:
4856:347:    w = Cfindemptywidgetentry (); /* find first unused list entry in list of widgets */
4857:348:    *w = Callocatewidget (newwin, identifier, parent, x, y,
4858:349:                          width, height, kindofwidget);
4859:350:    (*w)->eh = Cdefaulthandler (kindofwidget);
4860:351:    (*w)->takes_focus = takes_focus;
4861:352:
4862:353:    return (*w);
4863:354:}
4864:355:
4865:356:Window Cdrawwindow (const char *identifier, Window parent, int x, int y,
4866:357:                    int width, int height, const char *label)
4867:358:{
4868:359:    Window w;
4869:360:    w = (Csetupwidget (identifier, parent, x, y,
4870:361:                       width, height, CWINDOW_WIDGET, INPUT_MOTION, C_FLAT,
4871:362:                       0))->winid;
4872:363:    Cresethintpos (WIDGET_SPACING + 2, WIDGET_SPACING + 2);
4873:364:    return w;
4874:365:}
4875:366:
4876:367:Window Cdrawheadedwindow (const char *identifier, Window parent, int x,
4877:368:                          int y, int width, int height, const char *label)
4878:369:{
4879:370:    int w, h;
4880:371:    Window win;
4881:372:    CWidget *wdt;
4882:373:
4883:374:    Ctextsize (&w, &h, label);
4884:375:    win = Cdrawwindow (identifier, parent, x, y,
4885:376:                       width, height + h + WIDGET_SPACING * 3 + 3, label);
4886:377:    wdt =
4887:378:        Cdrawtext (catstrs (identifier, "header", 0), win,
4888:379:                   (width - w) / 2 - 1 - TEXT_RELIEF, WIDGET_SPACING,
4889:380:                   label);
4890:381:    wdt->options = TEXT_CENTRED;
4891:382:    Cgethintpos (&x, &y);
4892:383:    Cdrawbar (win, WIDGET_SPACING, y, width - WIDGET_SPACING * 2,
4893:384:              BAR_WINDOW_WIDTH);
4894:385:    Cgethintpos (&x, &y);
4895:386:    Cresethintpos (WIDGET_SPACING + 2, y);
4896:387:    return win;
4897:388:}
4898:389:
4899:390:#define r_lcase(x) (((x) >= 'A' && (x) <= 'Z') ? (x) + 'a' - 'A' : (x))
4900:391:
4901:392:int find_hotkey (CWidget * w)
4902:393:{
4903:394:    char used_keys[32], *label;
4904:395:    int j, n = -1;
4905:396:    CWidget *p = w;
4906:397:    int c;
4907:398:
4908:399:    if (!*(label = w->label))
4909:400:        return 0;
4910:401:
4911:402:    do {
4912:403:        w = CNextFocus (w);
4913:404:        if (!w || n == 32)
4914:405:            return 0;
4915:406:        used_keys[++n] = r_lcase (w->hotkey);
4916:407:    } while ((unsigned long) w != (unsigned long) p);
4917:408:
4918:409:    c = r_lcase (label[0]);
4919:410:    if (c >= 'a' && c <= 'z')
4920:411:        if (!memchr (used_keys, c, n)) /* check if first letter has not already been used */
4921:412:            return label[0];
4922:413:
4923:414:    for (j = 1; label[j]; j++) { /* check for letters at start of words that have not already been used */
4924:415:        c = r_lcase (label[j]);
4925:416:        if (label[j - 1] == ' ' && c >= 'a' && c <= 'z')
4926:417:            if (!memchr (used_keys, c, n))
4927:418:                return label[j];
4928:419:    }
4929:420:
4930:421:    for (j = 1; label[j]; j++) { /* check for any letters that have not already been used */
4931:422:        c = r_lcase (label[j]);
4932:423:        if (c >= 'a' && c <= 'z')
4933:424:            if (!memchr (used_keys, c, n))
4934:425:                return label[j];
4935:426:    }
4936:427:    return 0;
4937:428:}
4938:429:
4939:430:
4940:431:CWidget *Cdrawbutton (const char *identifier, Window parent, int x, int y,
4941:432:                      int width, int height, const char *label)
4942:433:{
4943:434:    CWidget *wdt;
4944:435:    int w, h;
4945:436:    if (width == AUTO_WIDTH || height == AUTO_HEIGHT)
4946:437:        Ctextsize (&w, &h, label);
4947:438:    if (width == AUTO_WIDTH)
4948:439:        width = w + 4 + BUTTON_RELIEF * 2;
4949:440:    if (height == AUTO_HEIGHT)
4950:441:        height = h + 4 + BUTTON_RELIEF * 2;
4951:442:    wdt = Csetupwidget (identifier, parent, x, y,
4952:443:                        width, height, CBUTTON_WIDGET, INPUT_BUTTON,
4953:444:                        C_FLAT, 1);
4954:445:    wdt->label = strdup (label);
4955:446:    wdt->hotkey = find_hotkey (wdt);
4956:447:    Csethintpos (x + width + WIDGET_SPACING, y + height + WIDGET_SPACING);
4957:448:    return wdt;
4958:449:}
4959:450:
4960:451:CWidget *Cdrawprogress (const char *identifier, Window parent, int x,
4961:452:                        int y, int width, int height, int p)
4962:453:{
4963:454:    CWidget *w;
4964:455:    if ((w = Cwidget (identifier))) {
4965:456:        w->cursor = p;
4966:457:        Csetwidgetposition (identifier, x, y);
4967:458:        Csetwidgetsize (identifier, width, height);
4968:459:        Cexpose (identifier);
4969:460:    } else {
4970:461:        w = Csetupwidget (identifier, parent, x, y,
4971:462:                          width, height, CPROGRESS_WIDGET, INPUT_EXPOSE,
4972:463:                          C_FLAT, 0);
4973:464:        w->cursor = p;
4974:465:        Csethintpos (x + width + WIDGET_SPACING,
4975:466:                     y + height + WIDGET_SPACING);
4976:467:    }
4977:468:    return w;
4978:469:}
4979:470:
4980:471:
4981:472:void Crendertextinput (CWidget * w);
4982:473:
4983:474:/*
4984:475:   This will reallocate a previous draw of the same identifier.
4985:476:   so you can draw the same widget over and over without flicker
4986:477: */
4987:478:CWidget *Cdrawtextinput (const char *identifier, Window parent, int x,
4988:479:                         int y, int width, int height, int maxlen,
4989:480:                         const char *text)
4990:481:{
4991:482:    CWidget *wdt;
4992:483:
4993:484:    if (!(wdt = Cwidget (identifier))) {
4994:485:
4995:486:        int w, h;
4996:487:        if (width == AUTO_WIDTH || height == AUTO_HEIGHT)
4997:488:            Ctextsize (&w, &h, text);
4998:489:        if (width == AUTO_WIDTH)
4999:490:            width = w + 6 + TEXT_INPUT_RELIEF * 2;
5000:491:        if (height == AUTO_HEIGHT)
5001:492:            height = h + 6 + TEXT_INPUT_RELIEF * 2;
5002:493:
5003:494:        Csethintpos (x + width + WIDGET_SPACING,
5004:495:                     y + height + WIDGET_SPACING);
5005:496:
5006:497:        wdt = Csetupwidget (identifier, parent, x, y,
5007:498:                            width, height, CTEXTINPUT_WIDGET, INPUT_KEY,
5008:499:                            C_FLAT, 1);
5009:500:
5010:501:/* For the text input widget we need enough memory allocated to the label
5011:502:   for it to grow to maxlen, so reallocate it */
5012:503:
5013:504:        wdt->text = Cmalloc (maxlen + 16);
5014:505:        strcpy (wdt->text, text);
5015:506:        wdt->cursor = strlen (text);
5016:507:        wdt->firstcolumn = 0;
5017:508:        wdt->textlength = maxlen;
5018:509:    } else {                    /*redraw the thing so it doesn't flicker if its redrawn in the same place.
5019:510:                                   Also, this doesn't need an undraw */
5020:511:        Csetwidgetsize (identifier, width, height);
5021:512:        wdt->x = x;
5022:513:        wdt->y = y;
5023:514:        XMoveWindow (CDisplay, wdt->winid, x, y);
5024:515:        free (wdt->text);
5025:516:        wdt->text = Cmalloc (maxlen + 16);
5026:517:        strcpy (wdt->text, text);
5027:518:        wdt->cursor = strlen (text);
5028:519:        wdt->firstcolumn = 0;
5029:520:        wdt->textlength = maxlen;
5030:521:        wdt->keypressed = 0;
5031:522:        Crendertextinput (wdt);
5032:523:    }
5033:524:
5034:525:    return wdt;
5035:526:}
5036:527:
5037:528:
5038:529:CWidget *Cdrawvertscrollbar (const char *identifier, Window parent, int x,
5039:530:                             int y, int length, int width, int pos,
5040:531:                             int prop)
5041:532:{
5042:533:    CWidget *w;
5043:534:    if (width == AUTO_WIDTH)
5044:535:        width = 20;
5045:536:    w = Csetupwidget (identifier, parent, x, y,
5046:537:                      width, length, CVERTSCROLL_WIDGET,
5047:538:                      ExposureMask | ButtonPressMask |
5048:539:                      ButtonReleaseMask | ButtonMotionMask |
5049:540:                      PointerMotionMask | EnterWindowMask |
5050:541:                      LeaveWindowMask, C_FLAT, 0);
5051:542:    w->firstline = pos;
5052:543:    w->numlines = prop;
5053:544:    Csethintpos (x + width + WIDGET_SPACING, y + length + WIDGET_SPACING);
5054:545:    return w;
5055:546:}
5056:547:
5057:548:
5058:549:CWidget *Cdrawbar (Window parent, int x, int y, int w, int options)
5059:550:{
5060:551:    CWidget *wdt;
5061:552:    wdt = Csetupwidget ("hbar", parent, x, y,
5062:553:                        w, 3, CBAR_WIDGET, INPUT_EXPOSE, C_FLAT, 0);
5063:554:    wdt->options = options;
5064:555:    Csethintpos (x + w + WIDGET_SPACING, y + 3 + WIDGET_SPACING);
5065:556:    return wdt;
5066:557:}
5067:558:
5068:559:/* returns the text size. The result is one descent greater than the actual size */
5069:560:void Ctextsize (int *w, int *h, const char *str)
5070:561:{
5071:562:    char *r, *p, *q;
5072:563:    int w1, h1;
5073:564:
5074:565:    if (!w)
5075:566:        w = &w1;
5076:567:    if (!h)
5077:568:        h = &h1;
5078:569:
5079:570:    *w = *h = 0;
5080:571:
5081:572:    r = q = catstrs (str, "\n", NULL);
5082:573:
5083:574:    while ((p = strchr (q, '\n'))) {
5084:575:        *h += TEXT_PIX_PER_LINE;
5085:576:        *w = max (XTextWidth
5086:577:                  (CFontStruct, q, (unsigned long) p - (unsigned long) q),
5087:578:                  *w);
5088:579:        q = p + 1;
5089:580:    }
5090:581:}
5091:582:
5092:583:
5093:584:CWidget *Cdrawtext (const char *identifier, Window parent, int x, int y,
5094:585:                    const char *fmt, ...)
5095:586:{
5096:587:    va_list pa;
5097:588:    char *str;
5098:589:    int w, h;
5099:590:    CWidget *wdt;
5100:591:
5101:592:    va_start (pa, fmt);
5102:593:    str = vsprintf_alloc (fmt, pa);
5103:594:    va_end (pa);
5104:595:
5105:596:    Ctextsize (&w, &h, str);
5106:597:    w += TEXT_RELIEF * 2 + 2;
5107:598:    h += TEXT_RELIEF * 2 + 2;
5108:599:    wdt = Csetupwidget (identifier, parent, x, y,
5109:600:                        w, h, CTEXT_WIDGET, INPUT_EXPOSE, C_FLAT, 0);
5110:601:    wdt->text = strdup (str);
5111:602:    free (str);
5112:603:    Csethintpos (x + w + WIDGET_SPACING, y + h + WIDGET_SPACING);
5113:604:    return wdt;
5114:605:}
5115:606:
5116:607:
5117:608:void Crendertext (CWidget * w);
5118:609:void Crerendertext (CWidget * wdt);
5119:610:
5120:611:CWidget *Credrawtext (const char *identifier, const char *fmt, ...)
5121:612:{
5122:613:    va_list pa;
5123:614:    char *str;
5124:615:    CWidget *wdt;
5125:616:    int w, h;
5126:617:
5127:618:    wdt = Cwidget (identifier);
5128:619:    if (!wdt)
5129:620:        return 0;
5130:621:
5131:622:    va_start (pa, fmt);
5132:623:    str = vsprintf_alloc (fmt, pa);
5133:624:    va_end (pa);
5134:625:
5135:626:    free (wdt->text);
5136:627:    wdt->text = strdup (str);
5137:628:
5138:629:    Ctextsize (&w, &h, str);
5139:630:    w += TEXT_RELIEF * 2 + 2;
5140:631:    h += TEXT_RELIEF * 2 + 2;
5141:632:
5142:633:    Csetwidgetsize (identifier, w, h);
5143:634:    Crerendertext (wdt);
5144:635:    free (str);
5145:636:    return wdt;
5146:637:}
5147:638:
5148:639:void focus_stack_remove_window (Window w);
5149:640:
5150:641:/*
5151:642:   Unmaps and destroys widget and frees memory.
5152:643:   Only for a widget that has no children.
5153:644: */
5154:645:int Cfreesinglewidget (int i)
5155:646:{
5156:647:    if (i && CW (i)) {
5157:648:        if (CW (i)->winid) {
5158:649:            if (CursorState.window == CW (i)->winid)
5159:650:                Csetcursor (0, 0, 0, 0, 0, 0, 0, 0, 0);
5160:651:            XUnmapWindow (CDisplay, CW (i)->winid);
5161:652:            XDestroyWindow (CDisplay, CW (i)->winid);
5162:653:            focus_stack_remove_window (CW (i)->winid); /* removes the window from the focus history stack */
5163:654:        }
5164:655:        if (CW (i)->label)
5165:656:            free (CW (i)->label);
5166:657:        if (CW (i)->headings)
5167:658:            free (CW (i)->headings);
5168:659:        if (CW (i)->gl_graphicscontext)
5169:660:            free (CW (i)->gl_graphicscontext);
5170:661:
5171:662:#ifndef HAVE_MAD
5172:663:        if (CW (i)->ximage) {
5173:664:            if ((long) CW (i)->ximage->data == (long) CW (i)->graphic)
5174:665:                CW (i)->graphic = NULL;
5175:666:            XDestroyImage (CW (i)->ximage);
5176:667:        }
5177:668:#else
5178:669:        if (CW (i)->ximage) {
5179:670:            if ((long) CW (i)->ximage->data == (long) CW (i)->graphic)
5180:671:                CW (i)->graphic = NULL;
5181:672:            free (CW (i)->ximage->data);
5182:673:        }
5183:674:#endif
5184:675:        if (CW (i)->graphic)
5185:676:            free (CW (i)->graphic);
5186:677:
5187:678:        if (CW (i)->tab)
5188:679:            free (CW (i)->tab);
5189:680:
5190:681:        if (CW (i)->text)
5191:682:            free (CW (i)->text);
5192:683:
5193:684:        if (CW (i)->destroy)
5194:685:            (*(CW (i)->destroy)) (CW (i));
5195:686:
5196:687:        free (CW (i));
5197:688:        CW (i) = NULL;
5198:689:        if (i == CLastwidget - 1)
5199:690:            CLastwidget--;
5200:691:
5201:692:        return 1;
5202:693:    } else
5203:694:        return 0;
5204:695:}
5205:696:
5206:697:/*searches for the first widget in the list that has win as its parent
5207:698:   and returns index */
5208:699:int Cfindfirstchildof (Window win)
5209:700:{
5210:701:    int i = 0;
5211:702:    while (CLastwidget > i++)
5212:703:        if (CW (i) != NULL)
5213:704:            if (CW (i)->parentid == win)
5214:705:                return i;
5215:706:    return 0;
5216:707:}
5217:708:
5218:709:int Cfindlastchildof (Window win)
5219:710:{
5220:711:    int i = CLastwidget;
5221:712:    while (--i > 0)
5222:713:        if (CW (i) != NULL)
5223:714:            if (CW (i)->parentid == win)
5224:715:                return i;
5225:716:    return 0;
5226:717:}
5227:718:
5228:719:int CWidgetOf (Window win)
5229:720:{
5230:721:    int i = 0;
5231:722:    while (CLastwidget > i++)
5232:723:        if (CW (i) != NULL)
5233:724:            if (CW (i)->winid == win)
5234:725:                return i;
5235:726:    return 0;
5236:727:}
5237:728:
5238:729:int Cfindnextchildof (Window win, Window child)
5239:730:{
5240:731:    int i = CWidgetOf (child);
5241:732:    if (i)
5242:733:        while (CLastwidget > i++)
5243:734:            if (CW (i) != NULL)
5244:735:                if (CW (i)->parentid == win)
5245:736:                    return i;
5246:737:    return 0;
5247:738:}
5248:739:
5249:740:int Cfindpreviouschildof (Window win, Window child)
5250:741:{
5251:742:    int i = CWidgetOf (child);
5252:743:    if (i)
5253:744:        while (--i > 0)
5254:745:            if (CW (i) != NULL)
5255:746:                if (CW (i)->parentid == win)
5256:747:                    return i;
5257:748:    return 0;
5258:749:}
5259:750:
5260:751:/*recursively destroys a widget and all its descendants */
5261:752:void Crecursivedestroy (int i)
5262:753:{
5263:754:    int j;
5264:755:    while ((j = Cfindfirstchildof (CW (i)->winid)))
5265:756:        Crecursivedestroy (j);
5266:757:    Cfreesinglewidget (i);
5267:758:}
5268:759:
5269:760:void CFocusLast (void);
5270:761:
5271:762:/*returns 1 on error --- not found. Destroys a widget by name and all its
5272:763:   descendents */
5273:764:int Cundrawwidget (const char *identifier)
5274:765:{
5275:766:    int i = Ci (identifier);
5276:767:
5277:768:    if (i) {
5278:769:        Crecursivedestroy (i);
5279:770:        CFocusLast ();
5280:771:        return 0;
5281:772:    } else
5282:773:        return 1;
5283:774:}
5284:775:
5285:776:
5286:777:void Cundrawall ()
5287:778:{
5288:779:    int j;
5289:780:    while ((j = Cfindfirstchildof (CMain)))
5290:781:        Crecursivedestroy (j);
5291:782:    while ((j = Cfindfirstchildof (DefaultRootWindow (CDisplay))))
5292:783:        Crecursivedestroy (j);
5293:784:}
5294:785:
5295:786:void free_last_query_buttons (void);
5296:787:
5297:788:void CShutdown (void)
5298:789:{
5299:790:    Cundrawall ();
5300:791:    free (home_dir);
5301:792:    free (temp_dir);
5302:793:    home_dir = 0;
5303:794:    temp_dir = 0;
5304:795:    free_last_query_buttons ();
5305:796:    XFreeGC (CDisplay, CGC);
5306:797:    XUnloadFont (CDisplay, CFontStruct->fid);
5307:798:    XDestroyWindow (CDisplay, CMain);
5308:799:    XCloseDisplay (CDisplay);
5309:800:}
5310:801:
5311:802:void Cdrawstringxy (Window win, int x, int y, const char *text)
5312:803:{
5313:804:    XDrawString (CDisplay, win,
5314:805:                 CGC,
5315:806:                 FONT_OFFSET_X + x,
5316:807:                 FONT_OFFSET_Y + y, text, strlen (text));
5317:808:}
5318:809:
5319:810:void Cdrawstring (Window win, const char *text)
5320:811:{
5321:812:    Cdrawstringxy (win, 0, 0, text);
5322:813:}
5323:814:
5324:815:/* return 1 if focussed */
5325:816:int render_focus_ring (CWidget * wdt)
5326:817:{
5327:818:    unsigned int wd, hd, d;
5328:819:    int xd, yd;
5329:820:    Window p;
5330:821:    Window win = wdt->winid;
5331:822:
5332:823:    XGetGeometry (CDisplay, win, &p, &xd, &yd, &wd, &hd, &d, &d);
5333:824:
5334:825:    if (win == CGetFocus ()) {
5335:826:        if (wd == wdt->width) {
5336:827:            XMoveWindow (CDisplay, win, wdt->x - FOCUS_RING,
5337:828:                         wdt->y - FOCUS_RING);
5338:829:            XResizeWindow (CDisplay, win, wd + 2 * FOCUS_RING,
5339:830:                           hd + 2 * FOCUS_RING);
5340:831:        }
5341:832:        Crenderbevel (win, 0, 0, wdt->width + 2 * FOCUS_RING - 1,
5342:833:                      wdt->height + 2 * FOCUS_RING - 1, 1, 0);
5343:834:        Crenderbevel (win, 2, 2, wdt->width + 2 * FOCUS_RING - 3,
5344:835:                      wdt->height + 2 * FOCUS_RING - 3, 2, 1);
5345:836:        return 1;
5346:837:    } else {
5347:838:        if (wd != wdt->width) {
5348:839:            XMoveWindow (CDisplay, win, wdt->x, wdt->y);
5349:840:            XResizeWindow (CDisplay, win, wd - 2 * FOCUS_RING,
5350:841:                           hd - 2 * FOCUS_RING);
5351:842:        }
5352:843:    }
5353:844:    return 0;
5354:845:}
5355:846:
5356:847:void Crenderbutton (CWidget * wdt)
5357:848:{
5358:849:    int w = wdt->width, h = wdt->height;
5359:850:    int x = 0, y = 0;
5360:851:
5361:852:    Window win = wdt->winid;
5362:853:
5363:854:    if (render_focus_ring (wdt))
5364:855:        x = y = FOCUS_RING;
5365:856:
5366:857:    Csetcolor (C_FLAT);
5367:858:
5368:859:    switch (wdt->options) {
5369:860:    case CBUTTON_PRESSED:
5370:861:        Crect (win, x, y, w - 4, h - 4);
5371:862:        Csetcolor (C_BLACK);
5372:863:        Crenderbevel (win, x, y, x + w - 1, y + h - 1, 2, 1);
5373:864:        break;
5374:865:    case CBUTTON_HIGHLIGHT:
5375:866:        Crect (win, x + 1, y + 1, w - 2, h - 2);
5376:867:        Csetcolor (C_BLACK);
5377:868:        Crenderbevel (win, x, y, x + w - 1, y + h - 1, 1, 0);
5378:869:        break;
5379:870:    default:
5380:871:        Crect (win, x, y, w - 4, h - 4);
5381:872:        Csetcolor (C_BLACK);
5382:873:        Crenderbevel (win, x, y, x + w - 1, y + h - 1, 2, 0);
5383:874:    }
5384:875:    Cdrawstringxy (win, x + 2 + BUTTON_RELIEF, y + 2 + BUTTON_RELIEF,
5385:876:                   wdt->label);
5386:877:    if (wdt->hotkey) {
5387:878:        char *p;
5388:879:        int i;
5389:880:        for (i = 1; wdt->label[i]; i++)
5390:881:            if (wdt->label[i - 1] == ' ' && wdt->label[i] == wdt->hotkey) {
5391:882:                p = wdt->label + i;
5392:883:                goto done;
5393:884:            }
5394:885:        p = strchr (wdt->label, wdt->hotkey);
5395:886:      done:;
5396:887:        if (!p)
5397:888:            return;
5398:889:        x += XTextWidth (CFontStruct, wdt->label,
5399:890:                         (unsigned long) p - (unsigned long) wdt->label);
5400:891:        x += 2 + BUTTON_RELIEF +
5401:892:            CFontStruct->per_char[wdt->hotkey].lbearing - 1;
5402:893:        y += TEXT_BASE_LINE + CFontStruct->per_char[wdt->hotkey].descent;
5403:894:        y += 2 + BUTTON_RELIEF + 1;
5404:895:        Csetcolor (C_BLACK);
5405:896:        Cline (win, x, y, x + CFontStruct->per_char[wdt->hotkey].rbearing,
5406:897:               y);
5407:898:    }
5408:899:}
5409:900:
5410:901:void Crendertextinput (CWidget * wdt)
5411:902:{
5412:903:    int wc, isfocussed = 0;
5413:904:    int f;
5414:905:    int w = wdt->width, h = wdt->height;
5415:906:    Window win;
5416:907:
5417:908:    win = wdt->winid;
5418:909:    isfocussed = (win == CGetFocus ());
5419:910:
5420:911:    Csetcolor (C_WHITE);
5421:912:    Crect (win, 3, 3, w - 6, h - 6);
5422:913:
5423:914:    Csetcolor (C_BLACK);
5424:915:
5425:916:/*This is a little untidy, but it will account for uneven font widths
5426:917:   without having to think to hard */
5427:918:
5428:919:    do {
5429:920:        f = 0;
5430:921:/*wc is the position of the cursor from the left of the input window */
5431:922:        wc = CFontStruct->max_bounds.width / 2 + 1 +
5432:923:            XTextWidth (CFontStruct, wdt->text +
5433:924:                        wdt->firstcolumn, wdt->cursor - wdt->firstcolumn);
5434:925:
5435:926:        /*now lets make sure the cursor is well within the view */
5436:927:
5437:928:/*except for when the cursor is at the end of the line */
5438:929:        if (wdt->cursor == strlen (wdt->text)) {
5439:930:            if (wc > w - 3) {
5440:931:                wdt->firstcolumn++;
5441:932:                f = 1;
5442:933:            }
5443:934:        } else if (wc > max (w - 20, w * 3 / 4)) {
5444:935:            wdt->firstcolumn++;
5445:936:            f = 1;
5446:937:        }
5447:938:        if (wc < min (20, w / 4)) {
5448:939:            wdt->firstcolumn--;
5449:940:            f = 1;
5450:941:            /*Unless of course we are at the beginning of the string */
5451:942:            if (wdt->firstcolumn < 0) {
5452:943:                wdt->firstcolumn = 0;
5453:944:                f = 0;
5454:945:            }
5455:946:        }
5456:947:    } while (f);                /*recalculate if firstcolumn has changed */
5457:948:
5458:949:/*now draw the visible part of the string */
5459:950:    Cdrawstringxy (win, 3 + TEXT_INPUT_RELIEF, 3 + TEXT_INPUT_RELIEF,
5460:951:                   wdt->text + wdt->firstcolumn);
5461:952:
5462:953:    if (isfocussed) {
5463:954:        Crenderbevel (win, 0, 0, w - 1, h - 1, 3, 1); /*most outer border bevel */
5464:955:    } else {
5465:956:        Crenderbevel (win, 2, 2, w - 3, h - 3, 1, 1); /*border bevel */
5466:957:        Crenderbevel (win, 0, 0, w - 1, h - 1, 2, 0); /*most outer border bevel */
5467:958:    }
5468:959:
5469:960:    Csetcursor (win, wc, 5, w, h - 5, TEXT_INPUT_CURSOR, 0, 0, 0);
5470:961:}
5471:962:
5472:963:void Crenderbar (CWidget * wdt)
5473:964:{
5474:965:    int w = wdt->width, h = wdt->height;
5475:966:
5476:967:    Window win = wdt->winid;
5477:968:
5478:969:    Csetcolor (C_FLAT);
5479:970:    Cline (win, 1, 1, w - 2, 1);
5480:971:    Crenderbevel (win, 0, 0, w - 1, h - 1, 1, 1);
5481:972:}
5482:973:
5483:974:void Crerendertext (CWidget * wdt)
5484:975:{
5485:976:    static Window lastwin = 0;
5486:977:    static char lasttext[1024] = "";
5487:978:    Window win = wdt->winid;
5488:979:    char *q;
5489:980:    int h = wdt->height;
5490:981:    int w = wdt->width;
5491:982:    int i, l = 32000, n, x;
5492:983:
5493:984:    if (strchr (wdt->text, '\n')) {
5494:985:        Crendertext (wdt);
5495:986:        return;
5496:987:    }
5497:988:    q = wdt->text;
5498:989:
5499:990:    n = strlen (q);
5500:991:    x = TEXT_RELIEF + 1;        /* bevel is 1 */
5501:992:    if (lastwin == win) {
5502:993:        int last_width;
5503:994:        for (i = 0; i < n; i++)
5504:995:            if (lasttext[i] != q[i])
5505:996:                break;
5506:997:        q += i;
5507:998:        x += XTextWidth (CFontStruct, wdt->text, i);
5508:999:        n = strlen (q);
5509:1000:        l = x + XTextWidth (CFontStruct, q, n);
5510:1001:        last_width =
5511:1002:            XTextWidth (CFontStruct, lasttext,
5512:1003:                        strlen (lasttext)) + TEXT_RELIEF + 1;
5513:1004:        if (l < last_width && l < w - 1) {
5514:1005:            Csetcolor (C_FLAT);
5515:1006:            Crect (win, l, 1, w - 1 - l, h - 2);
5516:1007:        }
5517:1008:    }
5518:1009:    Csetcolor (C_BLACK);
5519:1010:    Csetbackcolor (C_FLAT);
5520:1011:
5521:1012:    XDrawImageString (CDisplay, win, CGC, FONT_OFFSET_X + x,
5522:1013:                      FONT_OFFSET_Y + TEXT_RELIEF + 1, q, n);
5523:1014:
5524:1015:    if (l > w - 1)
5525:1016:        Crenderbevel (win, 0, 0, w - 1, h - 1, 1, 1);
5526:1017:    lastwin = win;
5527:1018:    strcpy (lasttext, wdt->text);
5528:1019:}
5529:1020:
5530:1021:void Crendertext (CWidget * wdt)
5531:1022:{
5532:1023:    Window win = wdt->winid;
5533:1024:    char *p, *q = catstrs (wdt->text, "\n", NULL);
5534:1025:    int h = wdt->height, w = wdt->width;
5535:1026:
5536:1027:    Csetcolor (C_FLAT);
5537:1028:    Crect (win, 1, 1, w - 2, h - 2);
5538:1029:    Csetcolor (C_BLACK);
5539:1030:
5540:1031:    h = 1;                      /* bevel */
5541:1032:    while ((p = strchr (q, '\n'))) {
5542:1033:        XDrawString (CDisplay, win,
5543:1034:                     CGC,
5544:1035:                     FONT_OFFSET_X + TEXT_RELIEF + 1,
5545:1036:                     FONT_OFFSET_Y + TEXT_RELIEF + h,
5546:1037:                     q, (long) p - (long) q);
5547:1038:        h += TEXT_PIX_PER_LINE;
5548:1039:        q = p + 1;
5549:1040:    }
5550:1041:
5551:1042:    h = wdt->height;
5552:1043:    Crenderbevel (win, 0, 0, w - 1, h - 1, 1, 1);
5553:1044:}
5554:1045:
5555:1046:void Crenderwindow (CWidget * wdt)
5556:1047:{
5557:1048:    int w = wdt->width, h = wdt->height;
5558:1049:
5559:1050:    Window win = wdt->winid;
5560:1051:
5561:1052:    if (wdt->position & CRESIZABLE) {
5562:1053:        Csetcolor (Cwidgetcolor (13));
5563:1054:        Cline (win, w - 4, h - 38, w - 38, h - 4);
5564:1055:        Cline (win, w - 4, h - 27, w - 27, h - 4);
5565:1056:        Cline (win, w - 4, h - 16, w - 16, h - 4);
5566:1057:        Cline (win, w - 4, h - 39, w - 39, h - 4);
5567:1058:        Cline (win, w - 4, h - 28, w - 28, h - 4);
5568:1059:        Cline (win, w - 4, h - 17, w - 17, h - 4);
5569:1060:
5570:1061:        Csetcolor (Cwidgetcolor (3));
5571:1062:        Cline (win, w - 4, h - 34, w - 34, h - 4);
5572:1063:        Cline (win, w - 4, h - 23, w - 23, h - 4);
5573:1064:        Cline (win, w - 4, h - 12, w - 12, h - 4);
5574:1065:        Cline (win, w - 4, h - 35, w - 35, h - 4);
5575:1066:        Cline (win, w - 4, h - 24, w - 24, h - 4);
5576:1067:        Cline (win, w - 4, h - 13, w - 13, h - 4);
5577:1068:    }
5578:1069:    Crenderbevel (win, 0, 0, w - 1, h - 1, 2, 0);
5579:1070:    if (DefaultRootWindow (CDisplay) != wdt->parentid)
5580:1071:        if (win == CGetFocus ())
5581:1072:            Crenderbevel (win, 4, 4, w - 5, h - 5, 3, 1);
5582:1073:}
5583:1074:
5584:1075:void Crenderprogress (CWidget * wdt)
5585:1076:{
5586:1077:    int w = wdt->width, h = wdt->height;
5587:1078:    int p = wdt->cursor;
5588:1079:
5589:1080:    Window win = wdt->winid;
5590:1081:
5591:1082:    if (p > 65535)
5592:1083:        p = 65535;
5593:1084:    if (p < 0)
5594:1085:        p = 0;
5595:1086:    Csetcolor (C_FLAT);
5596:1087:    Crect (win, 4 + p * (w - 5) / 65535, 2, (65535 - p) * (w - 5) / 65535,
5597:1088:           h - 4);
5598:1089:    Csetcolor (Ccolor (3));
5599:1090:    Crect (win, 4, 4, p * (w - 9) / 65535, h - 8);
5600:1091:    Crenderbevel (win, 2, 2, 4 + p * (w - 9) / 65535, h - 3, 2, 0);
5601:1092:    Crenderbevel (win, 0, 0, w - 1, h - 1, 2, 1);
5602:1093:}
5603:1094:
5604:1095:
5605:1096:void Crendersunken (CWidget * wdt)
5606:1097:{
5607:1098:    int w = wdt->width, h = wdt->height;
5608:1099:    Window win = wdt->winid;
5609:1100:    Crenderbevel (win, 0, 0, w - 1, h - 1, 2, 1);
5610:1101:}
5611:1102:
5612:1103:
5613:1104:void Crendervertscrollbar (Window win, int x, int y, int w, int h, int pos,
5614:1105:                           int prop, int flags)
5615:1106:{
5616:1107:    int l = h - 10 * w / 3 - 5;
5617:1108:
5618:1109:    Crenderbevel (win, 0, 0, w - 1, h - 1, 2, 1);
5619:1110:    Csetcolor (C_FLAT);
5620:1111:    Crect (win, 2, w + 2 * w / 3 + 2, w - 4, (l - 5) * pos / 65535);
5621:1112:    Crect (win, 2, w + 2 * w / 3 + 3 + l * (prop + pos) / 65535, w - 4,
5622:1113:           h - 1 - w - 2 * w / 3 - (w + 2 * w / 3 + 4 +
5623:1114:                                    l * (prop + pos) / 65535));
5624:1115:
5625:1116:    if (flags & 32) {
5626:1117:        Crenderbevel (win, 2, 2, w - 3, w + 1, 2 - ((flags & 15) == 1), 2);
5627:1118:        Crenderbevel (win, 2, w + 2, w - 3, w + 2 * w / 3 + 1,
5628:1119:                      2 - ((flags & 15) == 2), 2);
5629:1120:        Crenderbevel (win, 2, h - 2 - w, w - 3, h - 3,
5630:1121:                      2 - ((flags & 15) == 4), 2);
5631:1122:        Crenderbevel (win, 2, h - 2 - w - 2 * w / 3, w - 3, h - 3 - w,
5632:1123:                      2 - ((flags & 15) == 5), 2);
5633:1124:        Crenderbevel (win, 2, w + 2 * w / 3 + 2 + (l - 5) * pos / 65535,
5634:1125:                      w - 3,
5635:1126:                      w + 2 * w / 3 + 7 + (l - 5) * (prop + pos) / 65535,
5636:1127:                      2 - ((flags & 15) == 3), 2);
5637:1128:    } else {
5638:1129:        Crenderbevel (win, 2, 2, w - 3, w + 1, 2, 2 | ((flags & 15) == 1));
5639:1130:        Crenderbevel (win, 2, w + 2, w - 3, w + 2 * w / 3 + 1, 2,
5640:1131:                      2 | ((flags & 15) == 2));
5641:1132:        Crenderbevel (win, 2, h - 2 - w, w - 3, h - 3, 2,
5642:1133:                      2 | ((flags & 15) == 4));
5643:1134:        Crenderbevel (win, 2, h - 2 - w - 2 * w / 3, w - 3, h - 3 - w, 2,
5644:1135:                      2 | ((flags & 15) == 5));
5645:1136:        Crenderbevel (win, 2, w + 2 * w / 3 + 2 + (l - 5) * pos / 65535,
5646:1137:                      w - 3,
5647:1138:                      w + 2 * w / 3 + 7 + (l - 5) * (prop + pos) / 65535,
5648:1139:                      2, 2 | ((flags & 15) == 3));
5649:1140:    }
5650:1141:}
5651:1142:
5652:1143:void Crenderscrollbar (CWidget * wdt)
5653:1144:{
5654:1145:    int flags = wdt->options;
5655:1146:    if (wdt->kind == CVERTSCROLL_WIDGET)
5656:1147:        Crendervertscrollbar (wdt->winid,
5657:1148:                              wdt->x, wdt->y,
5658:1149:                              wdt->width, wdt->height,
5659:1150:                              wdt->firstline, wdt->numlines, flags);
5660:1151:}
5661:1152:
5662:1153:void Crenderbevel (Window win, int x1, int y1, int x2, int y2, int thick,
5663:1154:                   int sunken)
5664:1155:{
5665:1156:    long cn, cs;
5666:1157:    int i;
5667:1158:
5668:1159:    if ((sunken & 2)) {
5669:1160:        Csetcolor (C_FLAT);
5670:1161:        Crect (win, x1 + thick, y1 + thick, x2 - x1 - 2 * thick + 1,
5671:1162:               y2 - y1 - 2 * thick + 1);
5672:1163:    }
5673:1164:    sunken &= 1;
5674:1165:
5675:1166:    cn = sunken ? Cwidgetcolor (4) : Cwidgetcolor (11);
5676:1167:    cs = sunken ? Cwidgetcolor (11) : Cwidgetcolor (4);
5677:1168:
5678:1169:    for (i = 0; i < thick; i++) {
5679:1170:        if (sunken || i != thick - 1) {
5680:1171:            Csetcolor (cn);
5681:1172:            Cline (win, x1 + i, y1 + i, x1 + i, y2 - 1 - i);
5682:1173:            Cline (win, x1 + i, y1 + i, x2 - 1 - i, y1 + i);
5683:1174:        }
5684:1175:        if (!sunken || i != 0) {
5685:1176:            Csetcolor (cs);
5686:1177:            Cline (win, x2 - i, y2 - i, x1 + i, y2 - i);
5687:1178:            Cline (win, x2 - i, y1 + i, x2 - i, y2 - i - 1);
5688:1179:        }
5689:1180:        if (sunken) {
5690:1181:            Csetcolor (Cwidgetcolor (15));
5691:1182:            XDrawPoint (CDisplay, win, CGC, x2 - i, y2 - i);
5692:1183:        } else {
5693:1184:            Csetcolor (C_WHITE);
5694:1185:            XDrawPoint (CDisplay, win, CGC, x1 + i, y1 + i);
5695:1186:        }
5696:1187:    }
5697:1188:    Csetcolor (Cwidgetcolor (13));
5698:1189:/* the edge of the bevel doth shine more brightly: */
5699:1190:    if (sunken) {
5700:1191:        Cline (win, x2 - 1, y2, x1, y2);
5701:1192:        Cline (win, x2, y1, x2, y2 - 1);
5702:1193:    } else {
5703:1194:        i--;
5704:1195:        Cline (win, x1 + i, y1 + i + 1, x1 + i, y2 - 1 - i);
5705:1196:        Cline (win, x1 + i + 1, y1 + i, x2 - 1 - i, y1 + i);
5706:1197:    }
5707:1198:    Csetcolor (C_BLACK);
5708:1199:}
5709:1200:
5710:1201:void Cexposepic (CWidget * w);
5711:1202:
5712:1203:void Csetwidgetposition (const char *ident, int x, int y)
5713:1204:{
5714:1205:    CWidget *w = Cwidget (ident);
5715:1206:
5716:1207:    if (w->winid) {             /*some widgets have no window of there own */
5717:1208:        w->x = x;
5718:1209:        w->y = y;
5719:1210:        XMoveWindow (CDisplay, w->winid, x, y);
5720:1211:    } else {
5721:1212:#ifdef HAVE_PICTURE
5722:1213:        Cexposepic (w);
5723:1214:        w->x = x;
5724:1215:        w->y = y;
5725:1216:        Cexposepic (w);
5726:1217:#endif
5727:1218:    }
5728:1219:}
5729:1220:
5730:1221:void Csetwidgetsize (const char *ident, int w, int h)
5731:1222:{
5732:1223:    CWidget *wt = Cwidget (ident);
5733:1224:    if (!wt)
5734:1225:        return;
5735:1226:
5736:1227:    if (wt->winid)
5737:1228:        XResizeWindow (CDisplay, wt->winid, w, h);
5738:1229:
5739:1230:    if (wt->kind == CWINDOW_WIDGET) {
5740:1231:        CWidget *wdt;
5741:1232:        XEvent e;
5742:1233:        int i;
5743:1234:        memset (&e, 0, sizeof (XEvent));
5744:1235:        e.type = ResizeNotify;
5745:1236:        e.xconfigure.x = w - wt->width;
5746:1237:        e.xconfigure.y = h - wt->height;
5747:1238:        e.xconfigure.width = w;
5748:1239:        e.xconfigure.height = h;
5749:1240:        e.xconfigure.display = CDisplay;
5750:1241:        i = Cfindfirstchildof (wt->winid);
5751:1242:        while (i) {
5752:1243:            wdt = CW (i);
5753:1244:            e.xany.window = wdt->winid;
5754:1245:            CSendEvent (&e);
5755:1246:            i = Cfindnextchildof (wdt->parentid, wdt->winid);
5756:1247:        }
5757:1248:    }
5758:1249:    wt->width = w;
5759:1250:    wt->height = h;
5760:1251:}
5761:1252:
5762:1253:void Csetsizehintpos (const char *ident)
5763:1254:{
5764:1255:    int x, y;
5765:1256:    Cgethintlimits (&x, &y);
5766:1257:    Csetwidgetsize (ident, x + 2, y + 2);
5767:1258:}
5768:1259:
5769:1260:static inline int inbounds (x, y, x1, y1, x2, y2)
5770:1261:{
5771:1262:    if (x >= x1 && x <= x2 && y >= y1 && y <= y2)
5772:1263:        return 1;
5773:1264:    else
5774:1265:        return 0;
5775:1266:}
5776:1267:
5777:1268:/*
5778:1269:   Which scrollbar button was pressed?
5779:1270: */
5780:1271:int Cscrollwhereis (int bx, int by, CWidget * wdt)
5781:1272:{
5782:1273:    int w = wdt->width;
5783:1274:    int h = wdt->height;
5784:1275:    int pos = wdt->firstline;
5785:1276:    int prop = wdt->numlines;
5786:1277:    int l = h - 10 * w / 3 - 5;
5787:1278:
5788:1279:    if (inbounds (bx, by, 2, 2, w - 3, w + 1))
5789:1280:        return 1;
5790:1281:    if (inbounds (bx, by, 2, w + 2, w - 3, w + 2 * w / 3 + 1))
5791:1282:        return 2;
5792:1283:    if (inbounds (bx, by, 2, h - 2 - w, w - 3, h - 3))
5793:1284:        return 4;
5794:1285:    if (inbounds (bx, by, 2, h - 2 - w - 2 * w / 3, w - 3, h - 3 - w))
5795:1286:        return 5;
5796:1287:    if (inbounds
5797:1288:        (bx, by, 2, w + 2 * w / 3 + 2 + (l - 5) * pos / 65535, w - 3,
5798:1289:         w + 2 * w / 3 + 7 + (l - 5) * (prop + pos) / 65535))
5799:1290:        return 3;
5800:1291:    return 0;
5801:1292:}
5802:1:/* coolwidget.h - main header file
5803:2:   Copyright (C) 1996, 1997 Paul Sheer
5804:3:
5805:4:   This program is free software; you can redistribute it and/or modify
5806:5:   it under the terms of the GNU General Public License as published by
5807:6:   the Free Software Foundation; either version 2 of the License, or
5808:7:   (at your option) any later version.
5809:8:
5810:9:   This program is distributed in the hope that it will be useful,
5811:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
5812:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
5813:12:   GNU General Public License for more details.
5814:13:
5815:14:   You should have received a copy of the GNU General Public License
5816:15:   along with this program; if not, write to the Free Software
5817:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
5818:17: */
5819:18:
5820:19:#ifndef COOL_WIDGET_H
5821:20:#define COOL_WIDGET_H
5822:21:
5823:22:#include <config.h>
5824:23:#include <stdio.h>
5825:24:#include <my_string.h>
5826:25:#include <stdlib.h>
5827:26:#include <stdarg.h>
5828:27:
5829:28:#include <X11/Xlib.h>
5830:29:#include <X11/Xutil.h>
5831:30:#include <X11/Xresource.h>
5832:31:#include "global.h"
5833:32:#include "vgagl.h"
5834:33:#include "lkeysym.h"
5835:34:
5836:35:#include "stringtools.h"
5837:36:#include "app_glob.c"
5838:37:#include "drawings.h"
5839:38:#include "3dkit.h"
5840:39:
5841:40:#ifdef HAVE_MAD
5842:41:#include "mad.h"
5843:42:#endif
5844:43:
5845:44:typedef struct initialisation {
5846:45:    int x, y, width, height;
5847:46:    int lines, columns, width_plus, height_plus;
5848:47:    char *name;
5849:48:    char *display, *geometry, *font, *bg;
5850:49:    char *fg_red, *fg_green, *fg_blue; /* string doubles */
5851:50:#define CINIT_OPTION_USE_GREY 1
5852:51:#define CINIT_OPTION_VERBOSE 2
5853:52:    unsigned long options;
5854:53:} CInitData;
5855:54:
5856:55:
5857:56:#define CEdit WEdit
5858:57:
5859:58:extern int errno;
5860:59:
5861:60:/* edit this */
5862:61:/* #define quad_t unsigned long */
5863:62:#define quad_t unsigned int
5864:63:#define word unsigned short
5865:64:#define byte unsigned char
5866:65:
5867:66:#define CMAGIC_BEGIN 0x9e065f4d
5868:67:#define CMAGIC_END 0xd4f560e9
5869:68:
5870:69:#define TEXT_SETCOL 1
5871:70:#define TEXT_SETLINE 2
5872:71:#define TEXT_SETPOS 3
5873:72:#define TEXT_SET_CURSOR_LINE 4
5874:73:
5875:74:#define FOCUS_RING 6
5876:75:
5877:76:/* These are all the widget kinds (the kind member of the widget structure) */
5878:77:enum { CNOT_A_WIDGET, CBUTTON_WIDGET, CWINDOW_WIDGET, CBAR_WIDGET,
5879:78:        CSUNKEN_WIDGET,
5880:79:    CVERTSCROLL_WIDGET, CHORSCROLL_WIDGET, CTEXTINPUT_WIDGET,
5881:80:        CTEXTBOX_WIDGET,
5882:81:    CTEXT_WIDGET, CBWIMAGE_WIDGET, CSPREAD_WIDGET, CPROGRESS_WIDGET,
5883:82:    CBITMAP_WIDGET, CBITMAPBUTTON_WIDGET, CSWITCH_WIDGET,
5884:83:        C8BITIMAGE_WIDGET,
5885:84:    CTHREED_WIDGET, CPICTURE_WIDGET, CEDITOR_WIDGET, CMENU_WIDGET,
5886:85:        CMENU_BUTTON_WIDGET,
5887:86:    CALARM_WIDGET
5888:87:};
5889:88:
5890:89:/*
5891:90:   Here are some addition events that you may recieve or send using
5892:91:   CNextEvent instead of XNextEvent. (LASTEvent = 35)
5893:92: */
5894:93:/* this comes every 1/7 of a second */
5895:94:#define AlarmEvent (LASTEvent + 1000)
5896:95:/* This you won't recieve ---  it is used for joining small expose regions together */
5897:96:#define InternalExpose (LASTEvent + 1001)
5898:97:/* This send this event to the editor to force the editor widget to execute a command */
5899:98:#define EditorCommand (LASTEvent + 1002)
5900:99:/* send to widgets when a window resizes */
5901:100:#define ResizeNotify (LASTEvent + 1003)
5902:101:/* comes every 1/100 of a second (see initapp.c for correct amount) */
5903:102:#define TickEvent (LASTEvent + 1004)
5904:103:                                          /* used for generating repeats on keys *//* NOT USED */
5905:104:#define InternalKeyPress (LASTEvent + 1005)
5906:105:/* used for sending internal FocusOut events */
5907:106:#define InternalFocusOut (LASTEvent + 1006)
5908:107:
5909:108:/* Library is limited to this number of widgets at once */
5910:109:#define MAX_NUMBER_OF_WIDGETS 1024
5911:110:
5912:111:/* one of the (long int) "CoolBlue" colors (0-15) that make up the windows, buttons etc */
5913:112:#define Cwidgetcolor(i) Cpixel[(i)]
5914:113:/* one of a 3x3x3 (RxGxB) color palette. eg R=2, G=1, B=0 is Ccolor(19). */
5915:114:#define Ccolor(i) Cpixel[(i) + 16]
5916:115:/* 0-64 grey levels (not supprted unless specified in config.h) */
5917:116:#define Cgrey(i) Cpixel[(i) + 43]
5918:117:
5919:118:/* draw a line in the window d */
5920:119:#define Cline(d, x, y, w, h)  XDrawLine(CDisplay, d, CGC, x, y, w, h)
5921:120:/* rectangle */
5922:121:#define Crect(d, x, y, w, h)  XFillRectangle(CDisplay, d, CGC, x, y, w, h)
5923:122:/* set the foreground color */
5924:123:#define Csetcolor(c) XSetForeground(CDisplay, CGC, (c))
5925:124:/* set the background color */
5926:125:#define Csetbackcolor(c) XSetBackground(CDisplay, CGC, (c))
5927:126:/* width of a string in pixels in the basic font */
5928:127:#define Cstringwidth(s) XTextWidth (CFontStruct, s, strlen(s))
5929:128:
5930:129:#define CSCREEN_ASPECT 1.333
5931:130:
5932:131:/* some standard colors */
5933:132:/* the color of the "flat" of a window */
5934:133:#define C_FLAT Cwidgetcolor(9)
5935:134:#define C_WHITE Ccolor(26)
5936:135:#define C_BLACK Ccolor(0)
5937:136:
5938:137:/* SelectInput for various types of widgets */
5939:138:#define INPUT_EXPOSE (KeyPressMask | ExposureMask | StructureNotifyMask | VisibilityChangeMask)
5940:139:#define INPUT_KEY (ExposureMask | ButtonPressMask | ButtonReleaseMask | \
5941:140:                        KeyPressMask | ButtonMotionMask | FocusChangeMask | StructureNotifyMask | PropertyChangeMask | EnterWindowMask)
5942:141:#define INPUT_MOTION (KeyPressMask | KeyReleaseMask | ExposureMask | ButtonPressMask | \
5943:142:                        ButtonReleaseMask | PointerMotionMask | ButtonMotionMask | EnterWindowMask)
5944:143:#define INPUT_BUTTON (INPUT_KEY | EnterWindowMask | LeaveWindowMask)
5945:144:
5946:145:/* internal */
5947:146:#define MAPPED 1
5948:147:#define FOCUS_WHEN_MAPPED 2
5949:148:
5950:149:/* menu callback function */
5951:150:typedef void (*callfn) ();
5952:151:
5953:152:struct menu_item {
5954:153:    char *text;
5955:154:    KeySym hot_key;
5956:155:    callfn call_back;
5957:156:};
5958:157:
5959:158:
5960:159:#define ClassOfVisual(v) ((v)->class)
5961:160:
5962:161:/* font dimensions */
5963:162:#define TEXT_BASE_LINE (CFontStruct->per_char['H'].ascent + CFontStruct->descent)
5964:163:#define TEXT_PIX_PER_LINE (TEXT_BASE_LINE + CFontStruct->descent)
5965:164:
5966:165:#define TEXT_M_WIDTH CMean_font_width
5967:166:
5968:167:/* spacing between widgets in pixels */
5969:168:#define WIDGET_SPACING 6
5970:169:
5971:170:/* spacing between the bevel and the text of the text widget */
5972:171:#define TEXT_RELIEF 3
5973:172:#define TEXT_INPUT_RELIEF 1
5974:173:#define BUTTON_RELIEF 2
5975:174:
5976:175:/* auto widget sizing (use instaed of width or height to work out the width
5977:176:    of widgets that have text in them) */
5978:177:#define AUTO_WIDTH                -32000
5979:178:#define AUTO_HEIGHT                -32001
5980:179:#define AUTO_SIZE                AUTO_WIDTH, AUTO_HEIGHT
5981:180:
5982:181:/* font offsets for drawing */
5983:182:#define FONT_OFFSET_X (0)
5984:183:#define IN_FONT_OFFSET_Y (0)
5985:184:
5986:185:/* if this gets changed, the cursor rendering (upside down "L") in editdraw and
5987:186:    cooledit.c must be adjusted so that the cursor is erased properly */
5988:187:#define FONT_OFFSET_Y (CFontStruct->per_char['H'].ascent + CFontStruct->descent + IN_FONT_OFFSET_Y)
5989:188:
5990:189:/*
5991:190:   A reduced event. This structure is returned by CNextEvent, and
5992:191:   contains most of the things you may need. Anything more is contained
5993:192:   in XEvent.
5994:193:*/
5995:194:typedef struct {
5996:195:/* widget's identification string */
5997:196:    char *ident;
5998:197:    int i;
5999:198:
6000:199:/* data */
6001:200:    int x;
6002:201:    int y;
6003:202:    int xt;
6004:203:    int yt;
6005:204:
6006:205:    Window window;
6007:206:
6008:207:/* enumerated above */
6009:208:    int kind;
6010:209:    int type;
6011:210:
6012:211:/* if a key was pressed, this is the KeySym */
6013:212:    int key;
6014:213:    int xlat;
6015:214:    Time time;
6016:215:    unsigned int button;
6017:216:
6018:217:/* 1 for a double click */
6019:218:    int double_click;
6020:219:    unsigned int state;
6021:220:
6022:221:/* if text was returned by the event */
6023:222:    char *text;
6024:223:
6025:224:/* if the event was already handled by a callback routine */
6026:225:    char handled;
6027:226:
6028:227:/* if the event coused an editor command */
6029:228:    long command;               /* editor commands */
6030:229:} CEvent;
6031:230:
6032:231:
6033:232:/* This is the structure of a widget: */
6034:233:struct cool_widget {
6035:234:    char ident[33];             /*unique identifying string given by user */
6036:235:/* for debugging */
6037:236:    quad_t magic_begin;
6038:237:
6039:238:/* essentials */
6040:239:    Window winid;               /*X integer window id of widget */
6041:240:    Window parentid;            /*parent window of window */
6042:241:    int (*eh) (struct cool_widget *, XEvent *, CEvent *); /* internal event handler */
6043:242:    int (*callback) (struct cool_widget *, XEvent *, CEvent *); /* user event handler */
6044:243:    void (*destroy) (struct cool_widget *); /*only a few widgets need special distruction */
6045:244:
6046:245:/* basics */
6047:246:    int width, height;          /*of window --- just to save looking it up */
6048:247:    int x, y;                   /*position in parent --- top left corner */
6049:248:    int kind;                   /*one of C??????_WIDGET above */
6050:249:    char disabled;              /*displayed, but not functioning */
6051:250:    char takes_focus;           /*can this widget take input focus? */
6052:251:    char mapped;
6053:252:
6054:253:/* data */
6055:254:    char *label;                /*text that gets drawn into button */
6056:255:    char *graphic;              /*Possibly a bitmap to go onto the button */
6057:256:    int *tab;                   /*columns for spreadsheat widget */
6058:257:    char *text;                 /*text goes into textbox textinput and text widgets */
6059:258:    char *headings;             /*headings of spreadsheet columns */
6060:259:    GraphicsContext *gl_graphicscontext; /*for svgalib image widgets */
6061:260:    XImage *ximage;             /*for X images picture widgets */
6062:261:    Pixmap pixmap;              /*for pixmaps */
6063:262:    CPicture *pic;              /*for lines, circles, rects and arcs. */
6064:263:    TD_Solid *solid;
6065:264:    struct editor_widget *editor;
6066:265:    struct menu_item *menu;
6067:266:
6068:267:/* Positions. What they are used for depends on the kind of widget. See coolwidget.c for an explanation */
6069:268:    long cursor;
6070:269:    long column;
6071:270:    long numlines;
6072:271:    long firstline;
6073:272:    long current;
6074:273:    long firstcolumn;
6075:274:    long textlength;
6076:275:    long mark1, mark2;
6077:276:    long search_start;
6078:277:    int search_len;
6079:278:    Window menu_focus_return;
6080:279:
6081:280:/* settings */
6082:281:    long options;
6083:282:#define CBUTTON_HIGHLIGHT 1
6084:283:#define CBUTTON_PRESSED 2
6085:284:#define MAN_PAGE 4
6086:285:#define TEXT_WRAP 8
6087:286:#define TEXT_NO_KEYS 16
6088:287:#define TEXT_BOX_NO_CURSOR 32
6089:288:#define TEXT_FILES 64
6090:289:#define BAR_WINDOW_WIDTH 128
6091:290:#define TEXT_CENTRED 256
6092:291:    char position;              /*one of three: */
6093:292:#define CALWAYS_ON_TOP                        1      /*always raised */
6094:293:#define CALWAYS_ON_BOTTOM                2    /*always lowered */
6095:294:#define CFIXED_POSITION                        4     /*cannot be moved */
6096:295:#define CRESIZABLE                        8          /*can be resized */
6097:296:
6098:297:    struct cool_widget *scrollbar; /*links to other widgets */
6099:298:    struct cool_widget *textbox;
6100:299:    struct cool_widget *textinput;
6101:300:    struct cool_widget *droppedmenu;
6102:301:    char keypressed;
6103:302:    char hotkey;
6104:303:    unsigned long fg;           /*colors */
6105:304:    unsigned long bg;
6106:305:
6107:306:/* user structure. you can put addition data that you might need in here */
6108:307:    void *user;
6109:308:
6110:309:/* for debugging */
6111:310:    quad_t magic_end;
6112:311:};
6113:312:
6114:313:typedef struct cool_widget CWidget;
6115:314:
6116:315:/* you may want to use these */
6117:316:#define CTextOf(w) ((w)->text)
6118:317:#define CLabelOf(w) ((w)->label)
6119:318:#define CUserOf(w) ((w)->user)
6120:319:#define CHeightOf(w) ((w)->height)
6121:320:#define CWidthOf(w) ((w)->width)
6122:321:#define CXof(w) ((w)->x)
6123:322:#define CYof(w) ((w)->y)
6124:323:#define CWindowOf(w) ((w)->winid)
6125:324:#define CParentOf(w) ((w)->parentid)
6126:325:#define CIdentOf(w) ((w)->ident)
6127:326:
6128:327:/* internal */
6129:328:typedef struct disabled_state {
6130:329:    quad_t state[(MAX_NUMBER_OF_WIDGETS + 31) / 32];
6131:330:    quad_t mask[(MAX_NUMBER_OF_WIDGETS + 31) / 32];
6132:331:} CState;
6133:332:
6134:333:/*
6135:334:   The only global variables for the widgets. This is the actual array
6136:335:   of pointers that holds the malloced widget structures
6137:336: */
6138:337:
6139:338:#ifdef COOL_WIDGET_C
6140:339:int CLastwidget;                /* gives length of widget list */
6141:340:CWidget *widget[MAX_NUMBER_OF_WIDGETS]; /* first widget is at 1 */
6142:341:#else
6143:342:extern int CLastwidget;
6144:343:extern CWidget *widget[MAX_NUMBER_OF_WIDGETS];
6145:344:#endif
6146:345:
6147:346:/* CW(i) used to return a pointer to the widget i */
6148:347:#define CW(i) widget[i]
6149:348:
6150:349:#define Cgettext(i) CW(Ci(i))->text
6151:350:
6152:351:/* returns a pointer (of type CWidget) to the widget called ident */
6153:352:CWidget *Cwidget (const char *ident);
6154:353:
6155:354:/*Ci'ndex, returns the index of this widget */
6156:355:int Ci (const char *ident);
6157:356:
6158:357:
6159:358:/* Initialise. Opens connection to the X display, processing -display -font, and -geom args
6160:359:   sets up GC's, visual's and so on */
6161:360:void Cinit (CInitData * config);
6162:361:
6163:362:/* Call when app is done. This undraws all widgets, free's all data
6164:363:   and closes the connection to the X display */
6165:364:void CShutdown (void);
6166:365:
6167:366:/* Prints an error to stderr, or to a window if one can be created, then exits */
6168:367:void Cerror (const char *fmt, ...);
6169:368:
6170:369:/* Normal malloc with check for 0 return */
6171:370:void *Cmalloc (size_t size);
6172:371:void *CDebugMalloc (size_t x, int line, const char *file);
6173:372:
6174:373:/* Draw a panel onto which widgets will be drawn */
6175:374:Window Cdrawwindow (const char *identifier, Window parent, int x, int y,
6176:375:                    int width, int height, const char *label);
6177:376:
6178:377:/* Draw a panel with a heading and a seperator line. The position below the
6179:378:seperator line is recorded in h, start drawing in the window from there. */
6180:379:Window Cdrawheadedwindow (const char *identifier, Window parent, int x,
6181:380:                          int y, int width, int height, const char *label);
6182:381:
6183:382:/* Draw a button */
6184:383:CWidget *Cdrawbutton (const char *identifier, Window parent, int x, int y,
6185:384:                      int width, int height, const char *label);
6186:385:
6187:386:/* Draw a button with a bitmap on it, (see dialog.c for example) */
6188:387:CWidget *Cdrawbitmapbutton (const char *identifier, Window parent, int x,
6189:388:                            int y, int width, int height, unsigned long fg,
6190:389:                            unsigned long bg, const unsigned char data[]);
6191:390:
6192:391:/* Draws a toggle switch, pass on as the default setting */
6193:392:CWidget *Cdrawswitch (const char *identifier, Window parent, int x, int y,
6194:393:                      unsigned long fg, unsigned long bg, int on);
6195:394:
6196:395:/* Draw a text input widget */
6197:396:CWidget *Cdrawtextinput (const char *identifier, Window parent, int x,
6198:397:                         int y, int width, int height, int maxlen,
6199:398:                         const char *string);
6200:399:
6201:400:/* Draws a scrollable textbox, with its scrollbar. text is newline seperate */
6202:401:CWidget *Cdrawtextbox (const char *identifier, Window parent, int x, int y,
6203:402:                       int width, int height, int line, int column,
6204:403:                       const char *text, long options);
6205:404:CWidget *Cdrawmanpage (const char *identifier, Window parent, int x, int y,
6206:405:                       int width, int height, int line, int column,
6207:406:                       const char *text);
6208:407:/* Change the text of the textbox. If preserve is 1, then the position in the text is not altered */
6209:408:CWidget *Credrawtextbox (const char *identifier, const char *text,
6210:409:                         int preserve);
6211:410:
6212:411:/* Draws a thin horizontal raised ridge */
6213:412:CWidget *Cdrawbar (Window parent, int x, int y, int w, int options);
6214:413:
6215:414:/* Vertical scroll bar */
6216:415:CWidget *Cdrawvertscrollbar (const char *identifier, Window parent, int x,
6217:416:                             int y, int length, int width, int pos,
6218:417:                             int prop);
6219:418:
6220:419:/* Draws one or more lines of text (seperated by newlines) in a sunken panel. Use like printf() */
6221:420:CWidget *Cdrawtext (const char *identifier, Window parent, int x, int y,
6222:421:                    const char *fmt, ...);
6223:422:/* Will replace the text of an existing text widget. Unlike other widgets, multiple text widgets can have the same ident */
6224:423:CWidget *Credrawtext (const char *identifier, const char *fmt, ...);
6225:424:
6226:425:/* Draws a file browser and returns a filename, file is the default file name */
6227:426:char *Cgetfile (Window parent, int x, int y,
6228:427:                const char *dir, const char *file, const char *label);
6229:428:char *Cgetdirectory (Window parent, int x, int y,
6230:429:                     const char *dir, const char *file, const char *label);
6231:430:char *Cgetsavefile (Window parent, int x, int y,
6232:431:                    const char *dir, const char *file, const char *label);
6233:432:char *Cgetloadfile (Window parent, int x, int y,
6234:433:                    const char *dir, const char *file, const char *label);
6235:434:
6236:435:/* Draws a directory browser and returns immediately */
6237:436:void Cdrawbrowser (const char *ident, Window parent, int x, int y,
6238:437:                   const char *dir, const char *file, const char *label);
6239:438:
6240:439:
6241:440:/* Draws a simple spreadsheat widget (not supprted) */
6242:441:CWidget *Cdrawspreadsheet (const char *ident, Window parent, int x, int y,
6243:442:                           int w, int h, const char *spreadtext,
6244:443:                           const char *heading, int *columns);
6245:444:
6246:445:/* Draws a full blown text editor, scrollbar and status line */
6247:446:CWidget *Cdraweditor (const char *identifier, Window parent, int x, int y,
6248:447:                      int width, int height, const char *text,
6249:448:                      const char *filename,
6250:449:                      const char *starting_directory);
6251:450:
6252:451:/* Draws a menu button that may be pulled down if clicked on */
6253:452:CWidget *Cdrawmenubutton (const char *ident, Window parent,
6254:453:                          Window focus_return, int x, int y, int width,
6255:454:                          int height, int num_items, const char *label,
6256:455:/* this is a menu item: */
6257:456:                          const char *text, int hot_key, callfn call_back,
6258:457:                          ...);
6259:458:
6260:459:/* Draws menu buttons for the editor. focus_return is where focus goes to if you escape from a menu */
6261:460:void CDrawEditMenuButtons (const char *ident, Window parent,
6262:461:                           Window focus_return, int x, int y);
6263:462:void Caddmenuitem (const char *ident, const char *text, int hot_key,
6264:463:                   callfn call_back);
6265:464:void Cremovemenuitem (const char *ident, const char *text); /**** UNTESTED ****/
6266:465:
6267:466:/* Draws a bitmap inside a sunken window */
6268:467:CWidget *Cdrawbitmap (const char *identifier, Window parent, int x, int y,
6269:468:                      int width, int height, unsigned long fg,
6270:469:                      unsigned long bg, const unsigned char *data);
6271:470:
6272:471:/* Draws a black and white picture 1 byte per pixel contiguous data */
6273:472:CWidget *Cdrawbwimage (const char *identifier, Window parent, int x, int y,
6274:473:                       int width, int height, unsigned char *data);
6275:474:
6276:475:/* A window with inward bevels */
6277:476:CWidget *Cdrawsunkenpanel (const char *identifier, Window parent, int x,
6278:477:                           int y, int width, int height,
6279:478:                           const char *label);
6280:479:
6281:480:/* Draw a progress bar */
6282:481:CWidget *Cdrawprogress (const char *identifier, Window parent, int x,
6283:482:                        int y, int width, int height, int p);
6284:483:
6285:484:/* Draws a picture, containing nothing. Allows lines, rectangles etc to
6286:485:be drawn into the picture */
6287:486:CWidget *Cdrawpicture (const char *identifier, Window parent, int x, int y,
6288:487:                       int max_num_elements);
6289:488:
6290:489:
6291:490:/* Destroy a widget. This will destroy all descendent widgets recursively */
6292:491:int Cundrawwidget (const char *identifier);
6293:492:
6294:493:/* Returns the widget's window */
6295:494:Window Cgetwidgetwinfromident (const char *identifier);
6296:495:
6297:496:/* Used internally, or for creating you own widgets, see coolwidget.c */
6298:497:CWidget *Csetupwidget (const char *identifier, Window parent, int x, int y,
6299:498:                       int width, int height, int kindofwidget,
6300:499:                       unsigned long input, unsigned long bgcolor,
6301:500:                       int takes_focus);
6302:501:
6303:502:/* For resizing and reposition a widget */
6304:503:void Csetwidgetsize (const char *ident, int w, int h);
6305:504:void Csetwidgetposition (const char *ident, int x, int y);
6306:505:
6307:506:/* Forces the a widget to be entirely redrawn */
6308:507:void Cexpose (const char *ident);
6309:508:
6310:509:/* Sends an expose event to a window */
6311:510:void Cexposewindowarea (Window win, int count, int x, int y, int w, int h);
6312:511:
6313:512:/* Sends an event to the coolwidget queue. Use instead of XSendEvent */
6314:513:int CSendEvent (XEvent * e);
6315:514:
6316:515:
6317:516:/* add a callback to a widget. Will be called if anything relevent happens
6318:517:to the widget. callback must return 1 if they handles a key press */
6319:518:void Caddcallback (const char *ident,
6320:519:                   int (*callback) (CWidget *, XEvent *, CEvent *));
6321:520:
6322:521:/* send the text box a command (such as XK_Left or XK_Down to scroll) */
6323:522:int Ctextboxcursormove (CWidget * w, KeySym key);
6324:523:
6325:524:/* forces all windows set to CALWAYS_NO_TOP (see above) to be raised */
6326:525:void Craisewindows (void);
6327:526:/* same for ALWAYS_ON_BOTTOM, call these after raising or lowering
6328:527:   a window, to keep the "underneath" windows where they should be
6329:528:   (eg the coolwidget logo in the top left of the screen */
6330:529:void Clowerwindows (void);
6331:530:
6332:531:/* Various rendering routines called internally */
6333:532:void Crenderbevel (Window win, int x1, int y1, int x2, int y2, int thick,
6334:533:                   int sunken);
6335:534:long Crendertextbox (CWidget * w, int redrawall);
6336:535:void Crenderbitmapbutton (CWidget * w, int state);
6337:536:void Crenderbwimage (CWidget * w, int x, int y, int rendw, int rendh);
6338:537:int render_focus_ring (CWidget * wdt);
6339:538:
6340:539:/* used internally to process filebrowser events */
6341:540:char *Chandlebrowser (const char *identifier, CEvent * cwevent,
6342:541:                      int options);
6343:542:
6344:543:/* internal */
6345:544:void Credrawspreadinput (CWidget * w, int dump);
6346:545:
6347:546:/*
6348:547:   Processes all events remaining in the queue. If any event matches
6349:548:   cwevent.ident then it copies it into xevent and cwevent.
6350:549:   It does NOT wait if there are no events in the queue.
6351:550: */
6352:551:int Ccheckifevent (XEvent * xevent, CEvent * cwevent);
6353:552:
6354:553:/*
6355:554:   The hinge of this whole library. This handles widget events and calls
6356:555:   the callback routines. It must go in the main loop of a program.
6357:556:*/
6358:557:void CNextEvent (XEvent * xevent, CEvent * cwevent);
6359:558:
6360:559:/* Process all events in the event queue before returning. Call this periodically
6361:560:during functions that take a long time (several seconds) to keep the display clean */
6362:561:void Cclearevents ();
6363:562:
6364:563:/* returns 1 if there is a mouse event on the queue, but does nothing */
6365:564:int CMousePending (const char *ident);
6366:565:
6367:566:/* Any events left? */
6368:567:int CPending ();
6369:568:
6370:569:/* Any events left on coolwidgets own event queue? */
6371:570:int CQueueSize ();
6372:571:
6373:572:/* Do not use the libc sleep command. This sleeps for t seconds,
6374:573:   resolution is 1/50 of a second */
6375:574:void CSleep (double t);
6376:575:
6377:576:/* Do not use the libc system command */
6378:577:int Csystem (const char *string);
6379:578:
6380:579:/* Destroy all widgets */
6381:580:void Cundrawall ();
6382:581:
6383:582:/* All widgets may be either enabled or disabled, meaning they either
6384:583:   recieve input from the mouse and keyboard, or not. This backs up the
6385:584:   state of all widgets into the structure CState. See dialog.c for an
6386:585:   example */
6387:586:void CBackupState (CState * s);
6388:587:/* This restore the state from the structure */
6389:588:void CRestoreState (CState * s);
6390:589:
6391:590:/* Disable a widget. ident may be a regular expression. */
6392:591:void CDisable (const char *ident);
6393:592:/* Enable */
6394:593:void CEnable (const char *ident);
6395:594:
6396:595:/* set the focus to a widget */
6397:596:void CFocus (CWidget * w);
6398:597:
6399:598:/* set the focus to a window */
6400:599:void CFocusWindow (Window win);
6401:600:
6402:601:/* get the current focus */
6403:602:Window CGetFocus (void);
6404:603:
6405:604:/* pull up or down a menu */
6406:605:void CPullDown (CWidget * button);
6407:606:void CPullUp (CWidget * button);
6408:607:
6409:608:/* set the editor that editmenu will send commands to */
6410:609:void CSetEditMenu (const char *ident);
6411:610:void CEditMenuCommand (int i);
6412:611:CWidget *CGetEditMenu (void);
6413:612:void CEditMenuKey (KeySym i, int state);
6414:613:
6415:614:/* internal */
6416:615:int CSendExpose (Window win, int x, int y, int w, int h);
6417:616:
6418:617:/* Set the position of the text in the text-box, see coolwidget.c */
6419:618:long Csettextboxpos (CWidget * wdt, int which, long p);
6420:619:
6421:620:/************* the rest is not properly documented **************/
6422:621:
6423:622:int Ccheck ();
6424:623:
6425:624:int Cistimerevent (XEvent * xevent);
6426:625:
6427:626:void Cresolvebutton (XEvent * xevent, CEvent * cwevent);
6428:627:
6429:628:
6430:629:void Ctextsize (int *w, int *h, const char *str);
6431:630:
6432:631:
6433:632:#ifdef DRAWINGS_C
6434:633:CWidget *CWdrawtarget;
6435:634:#else
6436:635:extern CWidget *CWdrawtarget;
6437:636:#endif
6438:637:
6439:638:void cw_destroypicture (CWidget * w);
6440:639:
6441:640:
6442:641:Window Cdrawfilebrowser (const char *identifier, Window parent, int x,
6443:642:                         int y, const char *dir, const char *file,
6444:643:                         const char *label);
6445:644:
6446:645:
6447:646:/* internal */
6448:647:void Ctoggle_cursor ();
6449:648:
6450:649:
6451:650:
6452:651:
6453:652:int regexp_match (char *pattern, char *string, int match_type);
6454:653:
6455:654:
6456:655:CWidget *CFindFirstDescendent (Window win);
6457:656:int Cfindnextchildof (Window win, Window child);
6458:657:int Cfindpreviouschildof (Window win, Window child);
6459:658:int Cfindfirstchildof (Window win);
6460:659:int Cfindlastchildof (Window win);
6461:660:int CWidgetOf (Window win);
6462:661:
6463:662:/* there are two cursor types */
6464:663:#define TEXT_INPUT_CURSOR 1
6465:664:#define EDITOR_CURSOR 2
6466:665:
6467:666:/* set the cursor position (internal) */
6468:667:void Csetcursor (Window win, int x, int y, int w, int h, int type, int chr,
6469:668:                 unsigned long fg, unsigned long bg);
6470:669:
6471:670:/* translates a key press to a keysym */
6472:671:KeySym CKeySym (XEvent * e);
6473:672:/* some by converts to a short with upper bits representing the state */
6474:673:short CKeySymMod (XEvent * e);
6475:674:
6476:675:/* gets a widgets position relative to some ancestor widget */
6477:676:void CGetWindowPosition (Window win, Window ancestor, int *x_return,
6478:677:                         int *y_return);
6479:678:
6480:679:CWidget *CNextFocus (CWidget * w);
6481:680:CWidget *CPreviousFocus (CWidget * w);
6482:681:CWidget *CChildFocus (CWidget * w);
6483:682:
6484:683:void Cresethintpos (int x, int y);
6485:684:void Csethintpos (int x, int y);
6486:685:void Cgethintpos (int *x, int *y);
6487:686:void Cgethintlimits (int *max_x, int *max_y);
6488:687:
6489:688:void CEnableAlarm ();
6490:689:void CDisableAlarm ();
6491:690:
6492:691:int CWindowPending (Window w);
6493:692:
6494:693:double my_log (double x);
6495:694:double my_sqrt (double x);
6496:695:double my_pow (double x, double y);
6497:696:
6498:697:#ifdef HAVE_MAD
6499:698:#define Cmalloc(x) malloc(x)
6500:699:#endif
6501:700:
6502:701:#ifndef HAVE_MAD
6503:702:#define Cmalloc(x) CDebugMalloc(x, __LINE__, __FILE__)
6504:703:#endif
6505:704:
6506:705:/* #define FOCUS_DEBUG */
6507:706:
6508:707:#ifdef FOCUS_DEBUG
6509:708:#        define CFocus(x) CFocusDebug(x,__LINE__,__FILE__)
6510:709:#        define CFocusWindow(x) CFocusWindowDebug(x,__LINE__,__FILE__)
6511:710:#else
6512:711:#        define CFocus(x) CFocusNormal(x)
6513:712:#        define CFocusWindow(x) CFocusWindowNormal(x)
6514:713:#endif
6515:714:
6516:715:void CFocusDebug (CWidget * w, int line, char *file);
6517:716:void CFocusNormal (CWidget * w);
6518:717:void CFocusWindowDebug (Window w, int line, char *file);
6519:718:void CFocusWindowNormal (Window w);
6520:719:
6521:720:void CDndInit (void);
6522:721:void CDrag (Window from, int data_type, unsigned char *data, int length,
6523:722:            unsigned long pointer_state);
6524:723:int CGetDrop (XEvent * xe, unsigned char **data, unsigned long *size,
6525:724:              int *x, int *y);
6526:725:void CDropAcknowledge (XEvent * xe);
6527:726:int CIsDropAcknowledge (XEvent * xe, unsigned int *state);
6528:727:Window CQueryPointer (int *x, int *y, unsigned int *mask);
6529:728:char *CDndDirectory (void);
6530:729:void CSetDndDirectory (char *d);
6531:730:char *CDndFileList (char *t, int *l, int *num_files);
6532:731:
6533:732:void Csetsizehintpos (const char *ident);
6534:733:
6535:734:Window my_XmuClientWindow (Display * dpy, Window win);
6536:735:
6537:736:#define DndNotDnd        -1
6538:737:#define DndUnknown        0
6539:738:#define DndRawData        1
6540:739:#define DndFile                2
6541:740:#define        DndFiles        3
6542:741:#define        DndText                4
6543:742:#define DndDir                5
6544:743:#define DndLink                6
6545:744:#define DndExe                7
6546:745:#define DndURL          8
6547:746:#define DndMIME         9
6548:747:
6549:748:#define DndEND                10
6550:749:
6551:750:#include "dirtools.h"
6552:751:#include "edit.h"
6553:752:#include "editcmddef.h"
6554:753:#include "imagewidget.h"
6555:754:#include "dialog.h"
6556:755:
6557:756:#endif
6558:1:static char *copyright =
6559:2:    "                    GNU GENERAL PUBLIC LICENSE\n"
6560:3:    "                       Version 2, June 1991\n"
6561:4:    "\n"
6562:5:    " Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n"
6563:6:    "                          675 Mass Ave, Cambridge, MA 02139, USA\n"
6564:7:    " Everyone is permitted to copy and distribute verbatim copies\n"
6565:8:    " of this license document, but changing it is not allowed.\n"
6566:9:    "\n"
6567:10:    "                            Preamble\n"
6568:11:    "\n"
6569:12:    "  The licenses for most software are designed to take away your\n"
6570:13:    "freedom to share and change it.  By contrast, the GNU General Public\n"
6571:14:    "License is intended to guarantee your freedom to share and change free\n"
6572:15:    "software--to make sure the software is free for all its users.  This\n"
6573:16:    "General Public License applies to most of the Free Software\n"
6574:17:    "Foundation's software and to any other program whose authors commit to\n"
6575:18:    "using it.  (Some other Free Software Foundation software is covered by\n"
6576:19:    "the GNU Library General Public License instead.)  You can apply it to\n"
6577:20:    "your programs, too.\n"
6578:21:    "\n"
6579:22:    "  When we speak of free software, we are referring to freedom, not\n"
6580:23:    "price.  Our General Public Licenses are designed to make sure that you\n"
6581:24:    "have the freedom to distribute copies of free software (and charge for\n"
6582:25:    "this service if you wish), that you receive source code or can get it\n"
6583:26:    "if you want it, that you can change the software or use pieces of it\n"
6584:27:    "in new free programs; and that you know you can do these things.\n"
6585:28:    "\n"
6586:29:    "  To protect your rights, we need to make restrictions that forbid\n"
6587:30:    "anyone to deny you these rights or to ask you to surrender the rights.\n"
6588:31:    "These restrictions translate to certain responsibilities for you if you\n"
6589:32:    "distribute copies of the software, or if you modify it.\n"
6590:33:    "\n"
6591:34:    "  For example, if you distribute copies of such a program, whether\n"
6592:35:    "gratis or for a fee, you must give the recipients all the rights that\n"
6593:36:    "you have.  You must make sure that they, too, receive or can get the\n"
6594:37:    "source code.  And you must show them these terms so they know their\n"
6595:38:    "rights.\n"
6596:39:    "\n"
6597:40:    "  We protect your rights with two steps: (1) copyright the software, and\n"
6598:41:    "(2) offer you this license which gives you legal permission to copy,\n"
6599:42:    "distribute and/or modify the software.\n"
6600:43:    "\n"
6601:44:    "  Also, for each author's protection and ours, we want to make certain\n"
6602:45:    "that everyone understands that there is no warranty for this free\n"
6603:46:    "software.  If the software is modified by someone else and passed on, we\n"
6604:47:    "want its recipients to know that what they have is not the original, so\n"
6605:48:    "that any problems introduced by others will not reflect on the original\n"
6606:49:    "authors' reputations.\n"
6607:50:    "\n"
6608:51:    "  Finally, any free program is threatened constantly by software\n"
6609:52:    "patents.  We wish to avoid the danger that redistributors of a free\n"
6610:53:    "program will individually obtain patent licenses, in effect making the\n"
6611:54:    "program proprietary.  To prevent this, we have made it clear that any\n"
6612:55:    "patent must be licensed for everyone's free use or not licensed at all.\n"
6613:56:    "\n"
6614:57:    "  The precise terms and conditions for copying, distribution and\n"
6615:58:    "modification follow.\n"
6616:59:    "\n"
6617:60:    "                    GNU GENERAL PUBLIC LICENSE\n"
6618:61:    "   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n"
6619:62:    "\n"
6620:63:    "  0. This License applies to any program or other work which contains\n"
6621:64:    "a notice placed by the copyright holder saying it may be distributed\n"
6622:65:    "under the terms of this General Public License.  The \"Program\", below,\n"
6623:66:    "refers to any such program or work, and a \"work based on the Program\"\n"
6624:67:    "means either the Program or any derivative work under copyright law:\n"
6625:68:    "that is to say, a work containing the Program or a portion of it,\n"
6626:69:    "either verbatim or with modifications and/or translated into another\n"
6627:70:    "language.  (Hereinafter, translation is included without limitation in\n"
6628:71:    "the term \"modification\".)  Each licensee is addressed as \"you\".\n"
6629:72:    "\n"
6630:73:    "Activities other than copying, distribution and modification are not\n"
6631:74:    "covered by this License; they are outside its scope.  The act of\n"
6632:75:    "running the Program is not restricted, and the output from the Program\n"
6633:76:    "is covered only if its contents constitute a work based on the\n"
6634:77:    "Program (independent of having been made by running the Program).\n"
6635:78:    "Whether that is true depends on what the Program does.\n"
6636:79:    "\n"
6637:80:    "  1. You may copy and distribute verbatim copies of the Program's\n"
6638:81:    "source code as you receive it, in any medium, provided that you\n"
6639:82:    "conspicuously and appropriately publish on each copy an appropriate\n"
6640:83:    "copyright notice and disclaimer of warranty; keep intact all the\n"
6641:84:    "notices that refer to this License and to the absence of any warranty;\n"
6642:85:    "and give any other recipients of the Program a copy of this License\n"
6643:86:    "along with the Program.\n"
6644:87:    "\n"
6645:88:    "You may charge a fee for the physical act of transferring a copy, and\n"
6646:89:    "you may at your option offer warranty protection in exchange for a fee.\n"
6647:90:    "\n"
6648:91:    "  2. You may modify your copy or copies of the Program or any portion\n"
6649:92:    "of it, thus forming a work based on the Program, and copy and\n"
6650:93:    "distribute such modifications or work under the terms of Section 1\n"
6651:94:    "above, provided that you also meet all of these conditions:\n"
6652:95:    "\n"
6653:96:    "    a) You must cause the modified files to carry prominent notices\n"
6654:97:    "    stating that you changed the files and the date of any change.\n"
6655:98:    "\n"
6656:99:    "    b) You must cause any work that you distribute or publish, that in\n"
6657:100:    "    whole or in part contains or is derived from the Program or any\n"
6658:101:    "    part thereof, to be licensed as a whole at no charge to all third\n"
6659:102:    "    parties under the terms of this License.\n"
6660:103:    "\n"
6661:104:    "    c) If the modified program normally reads commands interactively\n"
6662:105:    "    when run, you must cause it, when started running for such\n"
6663:106:    "    interactive use in the most ordinary way, to print or display an\n"
6664:107:    "    announcement including an appropriate copyright notice and a\n"
6665:108:    "    notice that there is no warranty (or else, saying that you provide\n"
6666:109:    "    a warranty) and that users may redistribute the program under\n"
6667:110:    "    these conditions, and telling the user how to view a copy of this\n"
6668:111:    "    License.  (Exception: if the Program itself is interactive but\n"
6669:112:    "    does not normally print such an announcement, your work based on\n"
6670:113:    "    the Program is not required to print an announcement.)\n"
6671:114:    "\n"
6672:115:    "These requirements apply to the modified work as a whole.  If\n"
6673:116:    "identifiable sections of that work are not derived from the Program,\n"
6674:117:    "and can be reasonably considered independent and separate works in\n"
6675:118:    "themselves, then this License, and its terms, do not apply to those\n"
6676:119:    "sections when you distribute them as separate works.  But when you\n"
6677:120:    "distribute the same sections as part of a whole which is a work based\n"
6678:121:    "on the Program, the distribution of the whole must be on the terms of\n"
6679:122:    "this License, whose permissions for other licensees extend to the\n"
6680:123:    "entire whole, and thus to each and every part regardless of who wrote it.\n"
6681:124:    "\n"
6682:125:    "Thus, it is not the intent of this section to claim rights or contest\n"
6683:126:    "your rights to work written entirely by you; rather, the intent is to\n"
6684:127:    "exercise the right to control the distribution of derivative or\n"
6685:128:    "collective works based on the Program.\n"
6686:129:    "\n"
6687:130:    "In addition, mere aggregation of another work not based on the Program\n"
6688:131:    "with the Program (or with a work based on the Program) on a volume of\n"
6689:132:    "a storage or distribution medium does not bring the other work under\n"
6690:133:    "the scope of this License.\n"
6691:134:    "\n"
6692:135:    "  3. You may copy and distribute the Program (or a work based on it,\n"
6693:136:    "under Section 2) in object code or executable form under the terms of\n"
6694:137:    "Sections 1 and 2 above provided that you also do one of the following:\n"
6695:138:    "\n"
6696:139:    "    a) Accompany it with the complete corresponding machine-readable\n"
6697:140:    "    source code, which must be distributed under the terms of Sections\n"
6698:141:    "    1 and 2 above on a medium customarily used for software interchange; or,\n"
6699:142:    "\n"
6700:143:    "    b) Accompany it with a written offer, valid for at least three\n"
6701:144:    "    years, to give any third party, for a charge no more than your\n"
6702:145:    "    cost of physically performing source distribution, a complete\n"
6703:146:    "    machine-readable copy of the corresponding source code, to be\n"
6704:147:    "    distributed under the terms of Sections 1 and 2 above on a medium\n"
6705:148:    "    customarily used for software interchange; or,\n"
6706:149:    "\n"
6707:150:    "    c) Accompany it with the information you received as to the offer\n"
6708:151:    "    to distribute corresponding source code.  (This alternative is\n"
6709:152:    "    allowed only for noncommercial distribution and only if you\n"
6710:153:    "    received the program in object code or executable form with such\n"
6711:154:    "    an offer, in accord with Subsection b above.)\n"
6712:155:    "\n"
6713:156:    "The source code for a work means the preferred form of the work for\n"
6714:157:    "making modifications to it.  For an executable work, complete source\n"
6715:158:    "code means all the source code for all modules it contains, plus any\n"
6716:159:    "associated interface definition files, plus the scripts used to\n"
6717:160:    "control compilation and installation of the executable.  However, as a\n"
6718:161:    "special exception, the source code distributed need not include\n"
6719:162:    "anything that is normally distributed (in either source or binary\n"
6720:163:    "form) with the major components (compiler, kernel, and so on) of the\n"
6721:164:    "operating system on which the executable runs, unless that component\n"
6722:165:    "itself accompanies the executable.\n"
6723:166:    "\n"
6724:167:    "If distribution of executable or object code is made by offering\n"
6725:168:    "access to copy from a designated place, then offering equivalent\n"
6726:169:    "access to copy the source code from the same place counts as\n"
6727:170:    "distribution of the source code, even though third parties are not\n"
6728:171:    "compelled to copy the source along with the object code.\n"
6729:172:    "\n"
6730:173:    "  4. You may not copy, modify, sublicense, or distribute the Program\n"
6731:174:    "except as expressly provided under this License.  Any attempt\n"
6732:175:    "otherwise to copy, modify, sublicense or distribute the Program is\n"
6733:176:    "void, and will automatically terminate your rights under this License.\n"
6734:177:    "However, parties who have received copies, or rights, from you under\n"
6735:178:    "this License will not have their licenses terminated so long as such\n"
6736:179:    "parties remain in full compliance.\n"
6737:180:    "\n"
6738:181:    "  5. You are not required to accept this License, since you have not\n"
6739:182:    "signed it.  However, nothing else grants you permission to modify or\n"
6740:183:    "distribute the Program or its derivative works.  These actions are\n"
6741:184:    "prohibited by law if you do not accept this License.  Therefore, by\n"
6742:185:    "modifying or distributing the Program (or any work based on the\n"
6743:186:    "Program), you indicate your acceptance of this License to do so, and\n"
6744:187:    "all its terms and conditions for copying, distributing or modifying\n"
6745:188:    "the Program or works based on it.\n"
6746:189:    "\n"
6747:190:    "  6. Each time you redistribute the Program (or any work based on the\n"
6748:191:    "Program), the recipient automatically receives a license from the\n"
6749:192:    "original licensor to copy, distribute or modify the Program subject to\n"
6750:193:    "these terms and conditions.  You may not impose any further\n"
6751:194:    "restrictions on the recipients' exercise of the rights granted herein.\n"
6752:195:    "You are not responsible for enforcing compliance by third parties to\n"
6753:196:    "this License.\n"
6754:197:    "\n"
6755:198:    "  7. If, as a consequence of a court judgment or allegation of patent\n"
6756:199:    "infringement or for any other reason (not limited to patent issues),\n"
6757:200:    "conditions are imposed on you (whether by court order, agreement or\n"
6758:201:    "otherwise) that contradict the conditions of this License, they do not\n"
6759:202:    "excuse you from the conditions of this License.  If you cannot\n"
6760:203:    "distribute so as to satisfy simultaneously your obligations under this\n"
6761:204:    "License and any other pertinent obligations, then as a consequence you\n"
6762:205:    "may not distribute the Program at all.  For example, if a patent\n"
6763:206:    "license would not permit royalty-free redistribution of the Program by\n"
6764:207:    "all those who receive copies directly or indirectly through you, then\n"
6765:208:    "the only way you could satisfy both it and this License would be to\n"
6766:209:    "refrain entirely from distribution of the Program.\n"
6767:210:    "\n"
6768:211:    "If any portion of this section is held invalid or unenforceable under\n"
6769:212:    "any particular circumstance, the balance of the section is intended to\n"
6770:213:    "apply and the section as a whole is intended to apply in other\n"
6771:214:    "circumstances.\n"
6772:215:    "\n"
6773:216:    "It is not the purpose of this section to induce you to infringe any\n"
6774:217:    "patents or other property right claims or to contest validity of any\n"
6775:218:    "such claims; this section has the sole purpose of protecting the\n"
6776:219:    "integrity of the free software distribution system, which is\n"
6777:220:    "implemented by public license practices.  Many people have made\n"
6778:221:    "generous contributions to the wide range of software distributed\n"
6779:222:    "through that system in reliance on consistent application of that\n"
6780:223:    "system; it is up to the author/donor to decide if he or she is willing\n"
6781:224:    "to distribute software through any other system and a licensee cannot\n"
6782:225:    "impose that choice.\n"
6783:226:    "\n"
6784:227:    "This section is intended to make thoroughly clear what is believed to\n"
6785:228:    "be a consequence of the rest of this License.\n"
6786:229:    "\n"
6787:230:    "  8. If the distribution and/or use of the Program is restricted in\n"
6788:231:    "certain countries either by patents or by copyrighted interfaces, the\n"
6789:232:    "original copyright holder who places the Program under this License\n"
6790:233:    "may add an explicit geographical distribution limitation excluding\n"
6791:234:    "those countries, so that distribution is permitted only in or among\n"
6792:235:    "countries not thus excluded.  In such case, this License incorporates\n"
6793:236:    "the limitation as if written in the body of this License.\n"
6794:237:    "\n"
6795:238:    "  9. The Free Software Foundation may publish revised and/or new versions\n"
6796:239:    "of the General Public License from time to time.  Such new versions will\n"
6797:240:    "be similar in spirit to the present version, but may differ in detail to\n"
6798:241:    "address new problems or concerns.\n"
6799:242:    "\n"
6800:243:    "Each version is given a distinguishing version number.  If the Program\n"
6801:244:    "specifies a version number of this License which applies to it and \"any\n"
6802:245:    "later version\", you have the option of following the terms and conditions\n"
6803:246:    "either of that version or of any later version published by the Free\n"
6804:247:    "Software Foundation.  If the Program does not specify a version number of\n"
6805:248:    "this License, you may choose any version ever published by the Free Software\n"
6806:249:    "Foundation.\n"
6807:250:    "\n"
6808:251:    "  10. If you wish to incorporate parts of the Program into other free\n"
6809:252:    "programs whose distribution conditions are different, write to the author\n"
6810:253:    "to ask for permission.  For software which is copyrighted by the Free\n"
6811:254:    "Software Foundation, write to the Free Software Foundation; we sometimes\n"
6812:255:    "make exceptions for this.  Our decision will be guided by the two goals\n"
6813:256:    "of preserving the free status of all derivatives of our free software and\n"
6814:257:    "of promoting the sharing and reuse of software generally.\n"
6815:258:    "\n"
6816:259:    "                            NO WARRANTY\n"
6817:260:    "\n"
6818:261:    "  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\n"
6819:262:    "FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\n"
6820:263:    "OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\n"
6821:264:    "PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\n"
6822:265:    "OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n"
6823:266:    "MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\n"
6824:267:    "TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\n"
6825:268:    "PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\n"
6826:269:    "REPAIR OR CORRECTION.\n"
6827:270:    "\n"
6828:271:    "  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\n"
6829:272:    "WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\n"
6830:273:    "REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\n"
6831:274:    "INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\n"
6832:275:    "OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\n"
6833:276:    "TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\n"
6834:277:    "YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\n"
6835:278:    "PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\n"
6836:279:    "POSSIBILITY OF SUCH DAMAGES.\n"
6837:280:    "\n"
6838:281:    "                     END OF TERMS AND CONDITIONS\n"
6839:282:    "\n"
6840:283:    "            How to Apply These Terms to Your New Programs\n"
6841:284:    "\n"
6842:285:    "  If you develop a new program, and you want it to be of the greatest\n"
6843:286:    "possible use to the public, the best way to achieve this is to make it\n"
6844:287:    "free software which everyone can redistribute and change under these terms.\n"
6845:288:    "\n"
6846:289:    "  To do so, attach the following notices to the program.  It is safest\n"
6847:290:    "to attach them to the start of each source file to most effectively\n"
6848:291:    "convey the exclusion of warranty; and each file should have at least\n"
6849:292:    "the \"copyright\" line and a pointer to where the full notice is found.\n"
6850:293:    "\n"
6851:294:    "    <one line to give the program's name and a brief idea of what it does.>\n"
6852:295:    "    Copyright (C) 19yy  <name of author>\n"
6853:296:    "\n"
6854:297:    "    This program is free software; you can redistribute it and/or modify\n"
6855:298:    "    it under the terms of the GNU General Public License as published by\n"
6856:299:    "    the Free Software Foundation; either version 2 of the License, or\n"
6857:300:    "    (at your option) any later version.\n"
6858:301:    "\n"
6859:302:    "    This program is distributed in the hope that it will be useful,\n"
6860:303:    "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
6861:304:    "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
6862:305:    "    GNU General Public License for more details.\n"
6863:306:    "\n"
6864:307:    "    You should have received a copy of the GNU General Public License\n"
6865:308:    "    along with this program; if not, write to the Free Software\n"
6866:309:    "    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n"
6867:310:    "\n"
6868:311:    "Also add information on how to contact you by electronic and paper mail.\n"
6869:312:    "\n"
6870:313:    "If the program is interactive, make it output a short notice like this\n"
6871:314:    "when it starts in an interactive mode:\n"
6872:315:    "\n"
6873:316:    "    Gnomovision version 69, Copyright (C) 19yy name of author\n"
6874:317:    "    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n"
6875:318:    "    This is free software, and you are welcome to redistribute it\n"
6876:319:    "    under certain conditions; type `show c' for details.\n"
6877:320:    "\n"
6878:321:    "The hypothetical commands `show w' and `show c' should show the appropriate\n"
6879:322:    "parts of the General Public License.  Of course, the commands you use may\n"
6880:323:    "be called something other than `show w' and `show c'; they could even be\n"
6881:324:    "mouse-clicks or menu items--whatever suits your program.\n"
6882:325:    "\n"
6883:326:    "You should also get your employer (if you work as a programmer) or your\n"
6884:327:    "school, if any, to sign a \"copyright disclaimer\" for the program, if\n"
6885:328:    "necessary.  Here is a sample; alter the names:\n"
6886:329:    "\n"
6887:330:    "  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n"
6888:331:    "  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n"
6889:332:    "\n"
6890:333:    "  <signature of Ty Coon>, 1 April 1989\n"
6891:334:    "  Ty Coon, President of Vice\n"
6892:335:    "\n"
6893:336:    "This General Public License does not permit incorporating your program into\n"
6894:337:    "proprietary programs.  If your program is a subroutine library, you may\n"
6895:338:    "consider it more useful to permit linking proprietary applications with the\n"
6896:339:    "library.  If this is what you want to do, use the GNU Library General\n"
6897:340:    "Public License instead of this License.";
6898:1:/* dialog.c - draws various useful dialog boxes
6899:2:   Copyright (C) 1996 Paul Sheer
6900:3:
6901:4:   This program is free software; you can redistribute it and/or modify
6902:5:   it under the terms of the GNU General Public License as published by
6903:6:   the Free Software Foundation; either version 2 of the License, or
6904:7:   (at your option) any later version.
6905:8:
6906:9:   This program is distributed in the hope that it will be useful,
6907:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
6908:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
6909:12:   GNU General Public License for more details.
6910:13:
6911:14:   You should have received a copy of the GNU General Public License
6912:15:   along with this program; if not, write to the Free Software
6913:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
6914:17: */
6915:18:
6916:19:#include <config.h>
6917:20:#include <stdio.h>
6918:21:#include <my_string.h>
6919:22:#include <stdlib.h>
6920:23:#include <stdarg.h>
6921:24:#ifdef HAVE_UNISTD_H
6922:25:#include <unistd.h>
6923:26:#endif
6924:27:#include <sys/errno.h>
6925:28:
6926:29:#include <X11/Xlib.h>
6927:30:#include <X11/Xutil.h>
6928:31:#include <X11/Xresource.h>
6929:32:#include "lkeysym.h"
6930:33:
6931:34:#include "stringtools.h"
6932:35:#include "app_glob.c"
6933:36:#include "dirtools.h"
6934:37:
6935:38:#include "coolwidget.h"
6936:39:#include "coollocal.h"
6937:40:#include "loadfile.h"
6938:41:
6939:42:#include "mad.h"
6940:43:#include "dialog.h"
6941:44:#include "edit.h"
6942:45:#include "editcmddef.h"
6943:46:
6944:47:#define MID_X 20
6945:48:#define MID_Y 20
6946:49:
6947:50:
6948:51:/* Yuriy Elkin: (from mc/src/util.c) */
6949:52:char *get_sys_error (const char *s)
6950:53:{
6951:54:    char *error_msg;
6952:55:    if (errno) {
6953:56:#ifdef HAVE_STRERROR
6954:57:        error_msg = strerror (errno);
6955:58:#else
6956:59:        extern int sys_nerr;
6957:60:        extern char *sys_errlist[];
6958:61:        if ((0 <= errno) && (errno < sys_nerr))
6959:62:            error_msg = sys_errlist[errno];
6960:63:        else
6961:64:            error_msg = "strange errno";
6962:65:#endif
6963:66:        return catstrs (s, "\n [", error_msg, "] ", 0);
6964:67:        errno = 0;
6965:68:    } else {
6966:69:        return (char *) s;
6967:70:    }
6968:71:}
6969:72:
6970:73:void Cerrordialog (Window in, int x, int y, const char *heading,
6971:74:                   const char *fmt, ...)
6972:75:{
6973:76:    va_list pa;
6974:77:    char *str;
6975:78:    Window win;
6976:79:    CEvent cwevent;
6977:80:    CState s;
6978:81:
6979:82:    va_start (pa, fmt);
6980:83:    str = vsprintf_alloc (fmt, pa);
6981:84:    va_end (pa);
6982:85:
6983:86:    if (!in) {
6984:87:        in = CMain;
6985:88:        x = MID_X;
6986:89:        y = MID_Y;
6987:90:    }
6988:91:    CBackupState (&s);
6989:92:    CDisable ("*");
6990:93:    win = Cdrawheadedwindow ("_error", in, x, y, 10, 10, heading);
6991:94:    Cgethintpos (&x, &y);
6992:95:    Cdrawtext ("", win, x, y, str);
6993:96:    free (str);
6994:97:    Cgethintpos (0, &y);
6995:98:    (Cdrawbitmapbutton
6996:99:     ("_clickhere", win, -50, y, 40, 40, Ccolor (22), C_FLAT,
6997:100:      exclam_bits))->options = TEXT_CENTRED;
6998:101:    Cwidget ("_error")->position = CFIXED_POSITION | CALWAYS_ON_TOP;
6999:102:    Csetsizehintpos ("_error");
7000:103:    CFocus (Cwidget ("_clickhere"));
7001:104:    do {
7002:105:        CNextEvent (NULL, &cwevent);
7003:106:    } while (strcmp (cwevent.ident, "_clickhere")
7004:107:             && cwevent.key != XK_Escape);
7005:108:    Cundrawwidget ("_error");
7006:109:    CRestoreState (&s);
7007:110:}
7008:111:
7009:112:void Cmessagedialog (Window in, int x, int y, const char *heading,
7010:113:                     const char *fmt, ...)
7011:114:{
7012:115:    va_list pa;
7013:116:    char *str;
7014:117:    Window win;
7015:118:    CEvent cwevent;
7016:119:    CState s;
7017:120:
7018:121:    va_start (pa, fmt);
7019:122:    str = vsprintf_alloc (fmt, pa);
7020:123:    va_end (pa);
7021:124:
7022:125:    if (!in)
7023:126:        in = CMain;
7024:127:
7025:128:    CBackupState (&s);
7026:129:    CDisable ("*");
7027:130:    win = Cdrawheadedwindow ("_error", in, x, y, 10, 10, heading);
7028:131:    Cgethintpos (&x, &y);
7029:132:    Cdrawtext ("", win, x, y, str);
7030:133:    free (str);
7031:134:    Cgethintpos (0, &y);
7032:135:    (Cdrawbitmapbutton
7033:136:     ("_clickhere", win, -50, y, 40, 40, Ccolor (6), C_FLAT,
7034:137:      tick_bits))->options = TEXT_CENTRED;
7035:138:    Cwidget ("_error")->position = CFIXED_POSITION | CALWAYS_ON_TOP;
7036:139:    Csetsizehintpos ("_error");
7037:140:    CFocus (Cwidget ("_clickhere"));
7038:141:    do {
7039:142:        CNextEvent (NULL, &cwevent);
7040:143:    } while (strcmp (cwevent.ident, "_clickhere")
7041:144:             && cwevent.key != XK_Escape);
7042:145:    Cundrawwidget ("_error");
7043:146:    CRestoreState (&s);
7044:147:}
7045:148:
7046:149:/* draws a scrollable text box with a button to clear. Can be used to give long help messages */
7047:150:void Ctextboxmessagedialog (Window in, int x, int y, int columns,
7048:151:                            int lines, const char *heading,
7049:152:                            const char *text, int line)
7050:153:{
7051:154:    Window win;
7052:155:    CEvent cwevent;
7053:156:    CState s;
7054:157:    int width, height;
7055:158:
7056:159:    width = columns * TEXT_M_WIDTH + 1 + 6;
7057:160:    height = lines * TEXT_PIX_PER_LINE + 1 + 6;
7058:161:
7059:162:    if (!in) {
7060:163:        in = CMain;
7061:164:        x = 20;
7062:165:        y = 20;
7063:166:    }
7064:167:    CBackupState (&s);
7065:168:    CDisable ("*");
7066:169:    win = Cdrawheadedwindow ("_error", in, x, y, 10, 10, heading);
7067:170:    Cgethintpos (&x, &y);
7068:171:    Cdrawtextbox ("_textmessbox", win, x, y, width, height, line, 0, text,
7069:172:                  0);
7070:173:    Cgethintpos (0, &y);
7071:174:    (Cdrawbitmapbutton
7072:175:     ("_clickhere", win, -50, y, 40, 40, Ccolor (6), C_FLAT,
7073:176:      tick_bits))->options = TEXT_CENTRED;
7074:177:    Cwidget ("_error")->position = CFIXED_POSITION | CALWAYS_ON_TOP;
7075:178:    Csetsizehintpos ("_error");
7076:179:    CFocus (Cwidget ("_clickhere"));
7077:180:    do {
7078:181:        CNextEvent (NULL, &cwevent);
7079:182:    } while (strcmp (cwevent.ident, "_clickhere")
7080:183:             && cwevent.key != XK_Escape);
7081:184:    Cundrawwidget ("_error");
7082:185:    CRestoreState (&s);
7083:186:}
7084:187:
7085:188:void Cfatalerrordialog (int x, int y, const char *fmt, ...)
7086:189:{
7087:190:    va_list pa;
7088:191:    char *str;
7089:192:    Window win;
7090:193:    CEvent cwevent;
7091:194:    CState s;
7092:195:
7093:196:    va_start (pa, fmt);
7094:197:    str = vsprintf_alloc (fmt, pa);
7095:198:    va_end (pa);
7096:199:
7097:200:    fprintf (stderr, "%s\n", str);
7098:201:
7099:202:    if (CDisplay) {
7100:203:        CBackupState (&s);
7101:204:        CDisable ("*");
7102:205:        win = Cdrawheadedwindow ("fatalerror", CMain, x, y,
7103:206:                                 10, 10, " Fatal Error ");
7104:207:        Cgethintpos (&x, &y);
7105:208:        Cdrawtext ("", win, x, y, str);
7106:209:        Cgethintpos (0, &y);
7107:210:        (Cdrawbitmapbutton
7108:211:         ("clickhere", win, -50, y, 40, 40, Ccolor (19), C_FLAT,
7109:212:          cross_bits))->options = TEXT_CENTRED;
7110:213:        Cwidget ("fatalerror")->position =
7111:214:            CFIXED_POSITION | CALWAYS_ON_TOP;
7112:215:        Csetsizehintpos ("fatalerror");
7113:216:        CFocus (Cwidget ("clickhere"));
7114:217:        do {
7115:218:            CNextEvent (NULL, &cwevent);
7116:219:        } while (strcmp (cwevent.ident, "clickhere"));
7117:220:    }
7118:221:    abort ();
7119:222:}
7120:223:
7121:224:
7122:225:
7123:226:/* returns a raw XK_key sym. See 'Note well' below. */
7124:227:short Crawkeyquery (Window in, int x, int y, const char *heading,
7125:228:                    const char *fmt, ...)
7126:229:{
7127:230:    va_list pa;
7128:231:    char *str;
7129:232:    int p = 0;
7130:233:    Window win;
7131:234:    CEvent cwevent;
7132:235:    XEvent xevent;
7133:236:    CState s;
7134:237:
7135:238:    va_start (pa, fmt);
7136:239:    str = vsprintf_alloc (fmt, pa);
7137:240:    va_end (pa);
7138:241:
7139:242:    if (!in) {
7140:243:        in = CMain;
7141:244:        x = MID_X;
7142:245:        y = MID_Y;
7143:246:    }
7144:247:    CBackupState (&s);
7145:248:    CDisable ("*");
7146:249:    win = Cdrawheadedwindow ("_inputdialog", in, x, y, 10, 10, heading);
7147:250:    Cgethintpos (&x, &y);
7148:251:    Cdrawtext ("", win, x, y, str);
7149:252:    Cgethintpos (&x, 0);
7150:253:    free (str);
7151:254:    Cdrawtextinput ("_inputdialog.input", win, x, y, (TEXT_M_WIDTH) * 3,
7152:255:                    AUTO_HEIGHT, 256, "");
7153:256:    Cgethintpos (0, &y);
7154:257:    (Cdrawbitmapbutton
7155:258:     ("_inputdialog.crosshere", win, -50, y, 40, 40, Ccolor (18), C_FLAT,
7156:259:      cross_bits))->options = TEXT_CENTRED;
7157:260:    Csetsizehintpos ("_inputdialog");
7158:261:    CFocus (Cwidget ("_inputdialog.input"));
7159:262:    Cwidget ("_inputdialog")->position = CALWAYS_ON_TOP;
7160:263:/* handler : */
7161:264:    do {
7162:265:        CNextEvent (&xevent, &cwevent);
7163:266:        if (cwevent.key == XK_Escape
7164:267:            || !strcmp (cwevent.ident, "_inputdialog.crosshere"))
7165:268:            break;
7166:269:        if (xevent.type == KeyPress)
7167:270:            p = CKeySymMod (&xevent);
7168:271:    } while (!p);
7169:272:
7170:273:    Cundrawwidget ("_inputdialog");
7171:274:    CRestoreState (&s);
7172:275:    return p;
7173:276:}
7174:277:
7175:278:/*
7176:279:   def is the default string in the textinput widget.
7177:280:   Result must be free'd. Returns 0 on cancel.
7178:281: */
7179:282:char *Cinputdialog (Window in, int x, int y, int min_width,
7180:283:                    const char *def, const char *heading, const char *fmt,
7181:284:                    ...)
7182:285:{
7183:286:    va_list pa;
7184:287:    char *str, *p = 0;
7185:288:    int w, h;
7186:289:    Window win;
7187:290:    CEvent cwevent;
7188:291:    CState s;
7189:292:
7190:293:    va_start (pa, fmt);
7191:294:    str = vsprintf_alloc (fmt, pa);
7192:295:    va_end (pa);
7193:296:
7194:297:    if (!in) {
7195:298:        in = CMain;
7196:299:        x = MID_X;
7197:300:        y = MID_Y;
7198:301:    }
7199:302:    Ctextsize (&w, &h, str);
7200:303:    w = max (max (w, min_width), 130);
7201:304:    CBackupState (&s);
7202:305:    CDisable ("*");
7203:306:    win = Cdrawheadedwindow ("_inputdialog", in, x, y, 10, 10, heading);
7204:307:    Cgethintpos (&x, &y);
7205:308:    Cdrawtext ("", win, x, y, str);
7206:309:    Cgethintpos (0, &y);
7207:310:    free (str);
7208:311:    Cdrawtextinput ("_inputdialog.input", win, x, y, w, AUTO_HEIGHT, 256,
7209:312:                    def);
7210:313:    Cgethintpos (0, &y);
7211:314:    Cdrawbitmapbutton ("_inputdialog.clickhere", win, (w + 16) / 4 - 22, y,
7212:315:                       40, 40, Ccolor (6), C_FLAT, tick_bits);
7213:316:    Cdrawbitmapbutton ("_inputdialog.crosshere", win,
7214:317:                       3 * (w + 16) / 4 - 22, y, 40, 40, Ccolor (18),
7215:318:                       C_FLAT, cross_bits);
7216:319:    Csetsizehintpos ("_inputdialog");
7217:320:    CFocus (Cwidget ("_inputdialog.input"));
7218:321:    Cwidget ("_inputdialog")->position = CALWAYS_ON_TOP;
7219:322:/* handler : */
7220:323:    do {
7221:324:        CNextEvent (NULL, &cwevent);
7222:325:        if (cwevent.key == XK_Escape
7223:326:            || !strcmp (cwevent.ident, "_inputdialog.crosshere"))
7224:327:            goto fin;
7225:328:        if (cwevent.key == XK_Return)
7226:329:            break;
7227:330:    } while (strcmp (cwevent.ident, "_inputdialog.clickhere"));
7228:331:    p = strdup (Cwidget ("_inputdialog.input")->text);
7229:332:
7230:333:  fin:
7231:334:    Cundrawwidget ("_inputdialog");
7232:335:    CRestoreState (&s);
7233:336:    return p;
7234:337:}
7235:338:
7236:339:static char *id[32] =
7237:340:    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
7238:341:0, 0, 0, 0, 0, 0, 0, 0, 0 };
7239:342:
7240:343:void free_last_query_buttons (void)
7241:344:{
7242:345:    int i;
7243:346:    for (i = 0; i < 32; i++)
7244:347:        if (id[i]) {
7245:348:            free (id[i]);
7246:349:            id[i] = 0;
7247:350:        }
7248:351:}
7249:352:
7250:353:int Cquerydialog (Window in, int x, int y, const char *heading,
7251:354:                  const char *first, ...)
7252:355:{
7253:356:    va_list pa;
7254:357:    int i, buttons = 0;
7255:358:    Window win;
7256:359:    CEvent cwevent;
7257:360:    CState s;
7258:361:    char *b[32];
7259:362:
7260:363:    free_last_query_buttons ();
7261:364:    va_start (pa, first);
7262:365:    while ((b[buttons] = va_arg (pa, char *)))
7263:366:         buttons++;
7264:367:    va_end (pa);
7265:368:    if (!buttons)
7266:369:        return -1;
7267:370:
7268:371:    if (!in) {
7269:372:        in = CMain;
7270:373:        x = MID_X;
7271:374:        y = MID_Y;
7272:375:    }
7273:376:    CBackupState (&s);
7274:377:    CDisable ("*");
7275:378:    win = Cdrawheadedwindow ("_querydialog", in, x, y, 10, 10, heading);
7276:379:    Cgethintpos (&x, &y);
7277:380:    (Cdrawtext ("_querydialog.text", win, x, y, first))->options =
7278:381:        TEXT_CENTRED;
7279:382:    Cgethintpos (0, &y);
7280:383:
7281:384:    for (i = 0; i < buttons; i++) {
7282:385:        Cdrawbutton (id[i] = sprintf_alloc ("_query.%.20s", b[i]),
7283:386:                     win, x, y, AUTO_WIDTH, AUTO_HEIGHT, b[i]);
7284:387:        Cgethintpos (&x, 0);
7285:388:    }
7286:389:
7287:390:    Csetsizehintpos ("_querydialog");
7288:391:    CFocus (Cwidget (catstrs ("_query.", b[0], 0)));
7289:392:    Cwidget ("_querydialog")->position = CALWAYS_ON_TOP;
7290:393:    for (;;) {
7291:394:        CNextEvent (NULL, &cwevent);
7292:395:        for (i = 0; i < buttons; i++) {
7293:396:            if (!strcmp (cwevent.ident, id[i])) {
7294:397:                Cundrawwidget ("_querydialog");
7295:398:                CRestoreState (&s);
7296:399:                return i;
7297:400:            }
7298:401:        }
7299:402:    }
7300:403:    CRestoreState (&s);
7301:404:}
7302:1:#ifndef DIALOGUE_H
7303:2:#define DIALOGUE_H
7304:3:
7305:4:#include <X11/Xlib.h>
7306:5:
7307:6:void Cfatalerrordialog (int x, int y, const char *fmt, ...);
7308:7:char *Cinputdialog (Window in, int x, int y, int min_width,
7309:8:                    const char *def, const char *heading, const char *fmt,
7310:9:                    ...);
7311:10:int Cquerydialog (Window in, int x, int y, const char *heading,
7312:11:                  const char *first, ...);
7313:12:void Cerrordialog (Window in, int x, int y, const char *heading,
7314:13:                   const char *fmt, ...);
7315:14:void Cmessagedialog (Window in, int x, int y, const char *heading,
7316:15:                     const char *fmt, ...);
7317:16:void Ctextboxmessagedialog (Window in, int x, int y, int width, int height,
7318:17:                            const char *heading, const char *text,
7319:18:                            int line);
7320:19:char *get_sys_error (const char *s);
7321:20:short Crawkeyquery (Window in, int x, int y, const char *heading,
7322:21:                    const char *fmt, ...);
7323:22:CWidget *Cmanpagedialog (Window in, int x, int y, int width, int height,
7324:23:                         const char *manpage);
7325:24:
7326:25:#endif
7327:1:/*
7328:2:   Copyright (C) 1996 Paul Sheer
7329:3:
7330:4:   This program is free software; you can redistribute it and/or modify
7331:5:   it under the terms of the GNU General Public License as published by
7332:6:   the Free Software Foundation; either version 2 of the License, or
7333:7:   (at your option) any later version.
7334:8:
7335:9:   This program is distributed in the hope that it will be useful,
7336:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
7337:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
7338:12:   GNU General Public License for more details.
7339:13:
7340:14:   You should have received a copy of the GNU General Public License
7341:15:   along with this program; if not, write to the Free Software
7342:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
7343:17: */
7344:18:
7345:19:#define MAX_LS_SIZE 65536
7346:20:
7347:21:#include <config.h>
7348:22:#include <stdio.h>
7349:23:#include <stdlib.h>
7350:24:#include <my_string.h>
7351:25:#include "stringtools.h"
7352:26:#include "dirtools.h"
7353:27:#include <sys/types.h>
7354:28:
7355:29:#if HAVE_DIRENT_H
7356:30:#include <dirent.h>
7357:31:#define NAMLEN(dirent) strlen((dirent)->d_name)
7358:32:#else
7359:33:#define dirent direct
7360:34:#define NAMLEN(dirent) (dirent)->d_namlen
7361:35:#if HAVE_SYS_NDIR_H
7362:36:#include <sys/ndir.h>
7363:37:#endif
7364:38:#if HAVE_SYS_DIR_H
7365:39:#include <sys/dir.h>
7366:40:#endif
7367:41:#if HAVE_NDIR_H
7368:42:#include <ndir.h>
7369:43:#endif
7370:44:#endif
7371:45:
7372:46:#include <my_string.h>
7373:47:#include <sys/stat.h>
7374:48:
7375:49:#ifdef HAVE_UNISTD_H
7376:50:#include <unistd.h>
7377:51:#endif
7378:52:
7379:53:#include "mad.h"
7380:54:
7381:55:/*should use realloc with error check ***** */
7382:56:/*Returns a \n seperated list of directories or files in the directory *directory.
7383:57:   The files are sorted alphabetacally */
7384:58:/*The list is malloc'ed and must be free'd */
7385:59:/*if f is '/' then only directories are returned. If f is '*' all files
7386:60:   are returned. If f is 'f', only files are returned */
7387:61:char *getfilelist (const char *directory, char f)
7388:62:{
7389:63:    struct dirent *directentry;
7390:64:    struct stat stats;
7391:65:    DIR *dir;
7392:66:    char *list = malloc (MAX_LS_SIZE); /* <--- this is just asking for shit */
7393:67:    int l, listsize = 0;
7394:68:    int numentries = 0;
7395:69:    int p, i, q;
7396:70:    char *firststr, *secondstr;
7397:71:    char path_fname[MAX_PATH_LEN];
7398:72:
7399:73:    if (!list)
7400:74:        return strdup ("Error: getfilelist, error allocating memory.\n");
7401:75:    *list = 0;
7402:76:
7403:77:/*
7404:78:    if (chdir (directory))
7405:79:        return strdup ("Error: No such directory.\n");
7406:80:*/
7407:81:    if ((dir = opendir (directory)) == NULL)
7408:82:        return strdup ("Error: Cannot open directory.\n");
7409:83:
7410:84:    while ((directentry = readdir (dir))) {
7411:85:        strcpy (path_fname, directory);
7412:86:        strcat (path_fname, "/");
7413:87:        strcat (path_fname, directentry->d_name);
7414:88:        if (!stat (path_fname, &stats)) {
7415:89:            if (S_ISDIR (stats.st_mode)) {
7416:90:                if (f == '/' || f == '*') {
7417:91:                    l = NAMLEN (directentry);
7418:92:                    strcpy (list + listsize, "/");
7419:93:                    strcpy (list + listsize + 1, directentry->d_name);
7420:94:                    strcpy (list + listsize + l + 1, "\n");
7421:95:                    listsize += l + 2;
7422:96:                    numentries++;
7423:97:                }
7424:98:            } else {
7425:99:                if (f == 'f' || f == '*') {
7426:100:                    l = NAMLEN (directentry);
7427:101:                    strcpy (list + listsize, directentry->d_name);
7428:102:                    strcpy (list + listsize + l, "\n");
7429:103:                    listsize += l + 1;
7430:104:                    numentries++;
7431:105:                }
7432:106:            }
7433:107:        }
7434:108:    }
7435:109:
7436:110:/*
7437:111:   now do a bubble sort on the list.
7438:112:   (a directory list isn't long enough to warrant
7439:113:   a quick sort) and the qsort command won't work on unevenly sized entries.
7440:114: */
7441:115:    f = 1;
7442:116:    if (numentries) {
7443:117:        while (f) {
7444:118:            numentries--;
7445:119:            p = 0;
7446:120:            f = 0;
7447:121:            for (i = 0; i < numentries; i++) {
7448:122:                q = strmovelines (list, p, 1, 32000);
7449:123:                if (strcmp
7450:124:                    (firststr = strline (list, p), secondstr =
7451:125:                     strline (list, q)) > 0) {
7452:126:                    strcpy (list + p, secondstr);
7453:127:                    p += strlen (secondstr);
7454:128:                    *(list + p++) = '\n';
7455:129:                    memcpy (list + p, firststr, strlen (firststr));
7456:130:                    f = 1;
7457:131:                } else
7458:132:                    p = q;
7459:133:            }
7460:134:        }
7461:135:
7462:136:        list[listsize - 1] = 0; /* remove the last \n */
7463:137:    }
7464:138:    closedir (dir);
7465:139:    return list;
7466:140:}
7467:1:#ifndef DIR_TOOLS_H
7468:2:#define DIR_TOOLS_H
7469:3:
7470:4:/*Returns a \n seperated list of directories or files from the directory *directory.
7471:5:   The files are sorted alphabetacally */
7472:6:/*The list is malloc'ed and must be free'd */
7473:7:/*if f is '/' then only directories are returned. If f is '*' all files
7474:8:   are returned. If f is 'f', only files are returned */
7475:9:char *getfilelist (const char *directory, char f);
7476:10:
7477:11:#endif
7478:1:/*
7479:2:   Copyright (C) 1996 Paul Sheer
7480:3:
7481:4:   This program is free software; you can redistribute it and/or modify
7482:5:   it under the terms of the GNU General Public License as published by
7483:6:   the Free Software Foundation; either version 2 of the License, or
7484:7:   (at your option) any later version.
7485:8:
7486:9:   This program is distributed in the hope that it will be useful,
7487:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
7488:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
7489:12:   GNU General Public License for more details.
7490:13:
7491:14:   You should have received a copy of the GNU General Public License
7492:15:   along with this program; if not, write to the Free Software
7493:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
7494:17: */
7495:18:
7496:19:#include <config.h>
7497:20:#include <stdio.h>
7498:21:#include <my_string.h>
7499:22:#include <stdlib.h>
7500:23:#include <stdarg.h>
7501:24:
7502:25:#include <X11/Xlib.h>
7503:26:#include <X11/Xutil.h>
7504:27:#include <X11/Xresource.h>
7505:28:#include "lkeysym.h"
7506:29:
7507:30:#include "stringtools.h"
7508:31:#include "app_glob.c"
7509:32:#include "dirtools.h"
7510:33:
7511:34:#include "coolwidget.h"
7512:35:#include "coollocal.h"
7513:36:#include "dialog.h"
7514:37:#include "regex.h"
7515:38:
7516:39:#include "mad.h"
7517:40:
7518:41:
7519:42:/* 1 if string matches
7520:43:   0 if string doesn't match
7521:44:   -1 if error in pattern */
7522:45:
7523:46:static char *old_pattern = 0;
7524:47:
7525:48:int regexp_match (char *pattern, char *string, int match_type)
7526:49:{
7527:50:    static regex_t r;
7528:51:    static int old_type;
7529:52:    int rval;
7530:53:
7531:54:    if (!old_pattern || strcmp (old_pattern, pattern)
7532:55:        || old_type != match_type) {
7533:56:        if (old_pattern) {
7534:57:            regfree (&r);
7535:58:            free (old_pattern);
7536:59:            old_pattern = 0;
7537:60:        }
7538:61:        pattern = convert_pattern (pattern, match_type, 0);
7539:62:        if (regcomp (&r, pattern, REG_EXTENDED | REG_NOSUB))
7540:63:            return -1;
7541:64:        old_pattern = strdup (pattern);
7542:65:        old_type = match_type;
7543:66:    }
7544:67:    rval = !regexec (&r, string, 0, NULL, 0);
7545:68:    return rval;
7546:69:}
7547:70:
7548:71:int easy_patterns = 1;
7549:72:
7550:73:static char *maybe_start_group (char *d, int do_group, int *was_wildcard)
7551:74:{
7552:75:    if (!do_group)
7553:76:        return d;
7554:77:    if (*was_wildcard)
7555:78:        return d;
7556:79:    *was_wildcard = 1;
7557:80:    *d++ = '\\';
7558:81:    *d++ = '(';
7559:82:    return d;
7560:83:}
7561:84:
7562:85:static char *maybe_end_group (char *d, int do_group, int *was_wildcard)
7563:86:{
7564:87:    if (!do_group)
7565:88:        return d;
7566:89:    if (!*was_wildcard)
7567:90:        return d;
7568:91:    *was_wildcard = 0;
7569:92:    *d++ = '\\';
7570:93:    *d++ = ')';
7571:94:    return d;
7572:95:}
7573:96:
7574:97:/* If shell patterns are on converts a shell pattern to a regular
7575:98:   expression. Called by regexp_match and mask_rename. */
7576:99:/* Shouldn't we support [a-fw] type wildcards as well ?? */
7577:100:char *convert_pattern (char *pattern, int match_type, int do_group)
7578:101:{
7579:102:    char *s, *d;
7580:103:    static char new_pattern[100];
7581:104:    int was_wildcard = 0;
7582:105:
7583:106:    if (easy_patterns) {
7584:107:        d = new_pattern;
7585:108:        if (match_type == match_file)
7586:109:            *d++ = '^';
7587:110:        for (s = pattern; *s; s++, d++) {
7588:111:            switch (*s) {
7589:112:            case '*':
7590:113:                d = maybe_start_group (d, do_group, &was_wildcard);
7591:114:                *d++ = '.';
7592:115:                *d = '*';
7593:116:                break;
7594:117:
7595:118:            case '?':
7596:119:                d = maybe_start_group (d, do_group, &was_wildcard);
7597:120:                *d = '.';
7598:121:                break;
7599:122:
7600:123:            case '.':
7601:124:                d = maybe_end_group (d, do_group, &was_wildcard);
7602:125:                *d++ = '\\';
7603:126:                *d = '.';
7604:127:                break;
7605:128:
7606:129:            default:
7607:130:                d = maybe_end_group (d, do_group, &was_wildcard);
7608:131:                *d = *s;
7609:132:                break;
7610:133:            }
7611:134:        }
7612:135:        d = maybe_end_group (d, do_group, &was_wildcard);
7613:136:        if (match_type == match_file)
7614:137:            *d++ = '$';
7615:138:        *d = 0;
7616:139:        return new_pattern;
7617:140:    } else
7618:141:        return pattern;
7619:142:}
7620:143:
7621:144:
7622:145:
7623:146:void CSetDisable (const char *ident, int disable)
7624:147:{
7625:148:    int i = CLastwidget + 1;
7626:149:    while (--i)
7627:150:        if (CW (i))
7628:151:            switch (regexp_match
7629:152:                    ((char *) ident, CW (i)->ident, match_file)) {
7630:153:            case 1:
7631:154:                CW (i)->disabled = disable;
7632:155:                break;
7633:156:            case -1:
7634:157:                Cfatalerrordialog (20, 20,
7635:158:                                   " Invalid regular expression in call to CDisable() ");
7636:159:                break;
7637:160:            }
7638:161:}
7639:162:
7640:163:void CDisable (const char *ident)
7641:164:{
7642:165:    if (!ident) {
7643:166:        if (old_pattern) {
7644:167:            free (old_pattern);
7645:168:            old_pattern = 0;
7646:169:        }
7647:170:    } else
7648:171:        CSetDisable (ident, 1);
7649:172:}
7650:173:
7651:174:void CEnable (const char *ident)
7652:175:{
7653:176:    CSetDisable (ident, 0);
7654:177:}
7655:178:
7656:179:/* These are to save or restore the present state of the widgets enablement. */
7657:180:/* You may create or destroy widget between save and restores, but
7658:181:do not destroy _and_ create, because these won't remember properly which
7659:182:are have gone and which are new. */
7660:183:
7661:184:void CBackupState (CState * s)
7662:185:{
7663:186:    int i = CLastwidget + 1;
7664:187:    memset (s, 0, sizeof (CState));
7665:188:    while (--i) {
7666:189:        if (CW (i)) {
7667:190:            s->mask[i / 32] |= (0x1L << (i % 32));
7668:191:            if (CW (i)->disabled != 0)
7669:192:                s->state[i / 32] |= (0x1L << (i % 32));
7670:193:        }
7671:194:    }
7672:195:}
7673:196:
7674:197:void CRestoreState (CState * s)
7675:198:{
7676:199:    int i = CLastwidget + 1;
7677:200:    while (--i)
7678:201:        if (CW (i))
7679:202:            if (((quad_t) s->mask[i / 32] & (0x1L << (i % 32))))
7680:203:                CW (i)->disabled =
7681:204:                    ((s->state[i / 32] & (0x1L << (i % 32))) != 0);
7682:205:}
7683:1:/* dnd.c - drag and drop support
7684:2:
7685:3:   Copyright (C) 1996 the Free Software Foundation
7686:4:
7687:5:   Authors: 1996 Paul Sheer
7688:6:
7689:7:   This program is free software; you can redistribute it and/or modify
7690:8:   it under the terms of the GNU General Public License as published by
7691:9:   the Free Software Foundation; either version 2 of the License, or
7692:10:   (at your option) any later version.
7693:11:
7694:12:   This program is distributed in the hope that it will be useful,
7695:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
7696:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
7697:15:   GNU General Public License for more details.
7698:16:
7699:17:   You should have received a copy of the GNU General Public License
7700:18:   along with this program; if not, write to the Free Software
7701:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
7702:20: */
7703:21:
7704:22:/* 
7705:23:   The cursor bitmaps and the cursor initialisation routines are from
7706:24:   the DND package which can be found with the OffiX package at
7707:25:   sunsite.unc.edu. These are Copyright (C) 1996 Csar Crusius.
7708:26:   I also took a look at his code to get a better idea how get my Dnd
7709:27:   working the same, and small parts of the code are modifications
7710:28:   from there.
7711:29: */
7712:30:
7713:31:#include <config.h>
7714:32:#include <my_string.h>
7715:33:#include <stdlib.h>
7716:34:#include <stdio.h>
7717:35:
7718:36:#include <X11/Xlib.h>
7719:37:#include <X11/Xutil.h>
7720:38:#include <X11/Xresource.h>
7721:39:#include <X11/Xatom.h>
7722:40:#include <X11/cursorfont.h>
7723:41:
7724:42:#include "cursor/file.xbm"
7725:43:#include "cursor/file_mask.xbm"
7726:44:#include "cursor/files.xbm"
7727:45:#include "cursor/files_mask.xbm"
7728:46:#include "cursor/dir.xbm"
7729:47:#include "cursor/dir_mask.xbm"
7730:48:#include "cursor/text.xbm"
7731:49:#include "cursor/text_mask.xbm"
7732:50:#include "cursor/grey.xbm"
7733:51:#include "cursor/grey_mask.xbm"
7734:52:#include "cursor/link.xbm"
7735:53:#include "cursor/link_mask.xbm"
7736:54:#include "cursor/app.xbm"
7737:55:#include "cursor/app_mask.xbm"
7738:56:#include "cursor/url.xbm"
7739:57:#include "cursor/url_mask.xbm"
7740:58:#include "cursor/mime.xbm"
7741:59:#include "cursor/mime_mask.xbm"
7742:60:
7743:61:#include "app_glob.c"
7744:62:#include "coolwidget.h"
7745:63:#include "mad.h"
7746:64:
7747:65:/* #define DND_DEBUG */
7748:66:
7749:67:Atom DndProtocol, DndSelection, DndAcknowledge;
7750:68:
7751:69:typedef struct {
7752:70:    int Width, Height;
7753:71:    char *ImageData, *MaskData;
7754:72:    int HotSpotX, HotSpotY;
7755:73:    Pixmap ImagePixmap, MaskPixmap;
7756:74:    Cursor CursorID;
7757:75:} CursorData;
7758:76:
7759:77:static CursorData DndCursor[DndEND] = {
7760:78:    {0, 0, NULL, NULL, 0, 0, 0},
7761:79:    {grey_width, grey_height, grey_bits, grey_mask_bits,
7762:80:     grey_x_hot, grey_y_hot},
7763:81:    {file_width, file_height, file_bits, file_mask_bits,
7764:82:     file_x_hot, file_y_hot},
7765:83:    {files_width, files_height, files_bits, files_mask_bits,
7766:84:     files_x_hot, files_y_hot},
7767:85:    {text_width, text_height, text_bits, text_mask_bits,
7768:86:     text_x_hot, text_y_hot},
7769:87:    {dir_width, dir_height, dir_bits, dir_mask_bits,
7770:88:     dir_x_hot, dir_y_hot},
7771:89:    {link_width, link_height, link_bits, link_mask_bits,
7772:90:     link_x_hot, link_y_hot},
7773:91:    {app_width, app_height, app_bits, app_mask_bits,
7774:92:     app_x_hot, app_y_hot},
7775:93:    {url_width, url_height, url_bits, url_mask_bits,
7776:94:     url_x_hot, url_y_hot},
7777:95:    {mime_width, mime_height, mime_bits, mime_mask_bits,
7778:96:     mime_x_hot, mime_y_hot}
7779:97:};
7780:98:
7781:99:static char dnd_directory[MAX_PATH_LEN] = "";
7782:100:
7783:101:/* return the prepending directory (see CDndFileList() below) */
7784:102:char *CDndDirectory (void)
7785:103:{
7786:104:    return dnd_directory;
7787:105:}
7788:106:
7789:107:char *striptrailing (char *s, int c)
7790:108:{
7791:109:    int i;
7792:110:    i = strlen (s) - 1;
7793:111:
7794:112:    while (i >= 0) {
7795:113:        if (s[i] == c) {
7796:114:            s[i--] = 0;
7797:115:            continue;
7798:116:        }
7799:117:        break;
7800:118:    }
7801:119:    return s;
7802:120:}
7803:121:
7804:122:/*
7805:123:   Sets the directory, must be a null terminated complete path.
7806:124:   Strips trailing slashes.
7807:125: */
7808:126:void CSetDndDirectory (char *d)
7809:127:{
7810:128:    if (!d)
7811:129:        return;
7812:130:    strcpy (dnd_directory, d);
7813:131:    striptrailing (dnd_directory, '/');
7814:132:    if (*dnd_directory)
7815:133:        return;
7816:134:    *dnd_directory = '/';
7817:135:}
7818:136:
7819:137:/*
7820:138:   Takes a newline seperated list of files,
7821:139:   returns a null seperated list of complete path names
7822:140:   by prepending dnd_directory to each file name.
7823:141:   returns 0 if no files in list.
7824:142:   result must always be free'd.
7825:143:   returns l as the total length of data.
7826:144:   returns num_files as the number of files in the list.
7827:145:   Alters t
7828:146: */
7829:147:char *CDndFileList (char *t, int *l, int *num_files)
7830:148:{
7831:149:    char *p, *q, *r, *result;
7832:150:    int i;
7833:151:    int path_len, len;
7834:152:
7835:153:/* strip leading newlines */
7836:154:    while (*t == '\n')
7837:155:        t++;
7838:156:
7839:157:/* strip trailing newlines */
7840:158:    striptrailing (t, '\n');
7841:159:
7842:160:    if (!*t)
7843:161:        return 0;
7844:162:
7845:163:/* count files */
7846:164:    for (i = 1, p = t; *p; p++)
7847:165:        if (*p == '\n')
7848:166:            i++;
7849:167:
7850:168:    *num_files = i;
7851:169:
7852:170:    len = (unsigned long) p - (unsigned long) t;
7853:171:    path_len = strlen (dnd_directory);
7854:172:    result = Cmalloc ((path_len + 2) * i + len + 2);
7855:173:
7856:174:    r = result;
7857:175:    p = t;
7858:176:    for (;;) {
7859:177:        q = strchr (p, '\n');
7860:178:        if (!q)
7861:179:            q = t + len;
7862:180:        *q = 0;
7863:181:        strcpy (r, dnd_directory);
7864:182:        r += path_len;
7865:183:        *r++ = '/';
7866:184:        strcpy (r, p);
7867:185:        r += (unsigned long) q - (unsigned long) p;
7868:186:        *r++ = 0;
7869:187:        if ((unsigned long) q == (unsigned long) t + len)
7870:188:            break;
7871:189:        p = ++q;
7872:190:    }
7873:191:    *r = 0;
7874:192:    *l = (unsigned long) r - (unsigned long) result;
7875:193:    return result;
7876:194:}
7877:195:
7878:196:
7879:197:/* Dnd initialisation */
7880:198:void CDndInit (void)
7881:199:{
7882:200:    int screen, i;
7883:201:    Colormap colormap;
7884:202:    Window root;
7885:203:    XColor Black, White;
7886:204:
7887:205:    DndAcknowledge = XInternAtom (CDisplay, "_DND_ACKNOWLEDGE", False);
7888:206:    DndProtocol = XInternAtom (CDisplay, "_DND_PROTOCOL", False);
7889:207:    DndSelection = XInternAtom (CDisplay, "_DND_SELECTION", False);
7890:208:
7891:209:    screen = DefaultScreen (CDisplay);
7892:210:    colormap = DefaultColormap (CDisplay, screen);
7893:211:    root = DefaultRootWindow (CDisplay);
7894:212:
7895:213:    Black.pixel = BlackPixel (CDisplay, screen);
7896:214:    White.pixel = WhitePixel (CDisplay, screen);
7897:215:    XQueryColor (CDisplay, colormap, &Black);
7898:216:    XQueryColor (CDisplay, colormap, &White);
7899:217:
7900:218:    for (i = 1; i != DndEND; i++) {
7901:219:        DndCursor[i].ImagePixmap =
7902:220:            XCreateBitmapFromData (CDisplay, root,
7903:221:                                   DndCursor[i].ImageData,
7904:222:                                   DndCursor[i].Width,
7905:223:                                   DndCursor[i].Height);
7906:224:        DndCursor[i].MaskPixmap =
7907:225:            XCreateBitmapFromData (CDisplay, root,
7908:226:                                   DndCursor[i].MaskData,
7909:227:                                   DndCursor[i].Width,
7910:228:                                   DndCursor[i].Height);
7911:229:        DndCursor[i].CursorID =
7912:230:            XCreatePixmapCursor (CDisplay, DndCursor[i].ImagePixmap,
7913:231:                                 DndCursor[i].MaskPixmap,
7914:232:                                 &Black, &White,
7915:233:                                 DndCursor[i].HotSpotX,
7916:234:                                 DndCursor[i].HotSpotY);
7917:235:    }
7918:236:    DndCursor[0].CursorID =
7919:237:        XCreateFontCursor (CDisplay, XC_question_arrow);
7920:238:}
7921:239:
7922:240:/*
7923:241:   This does a drag.
7924:242:   This is copied somewhat from the dnd Xt code by Csar Crusius 
7925:243:   so it should behave almost exactly the way his does.
7926:244:   From is the sending window. data_type is a dnd type in coolwidget.h,
7927:245:   data is the actual data, and length is its length.
7928:246:   pointer state is the state of the pointer.
7929:247:   I set the pointer state to that *during* the drag, not before.
7930:248:   See eh_editor in editwidget.c for details.
7931:249: */
7932:250:void CDrag (Window from, int data_type, unsigned char *data, int length,
7933:251:            unsigned long pointer_state)
7934:252:{
7935:253:    XEvent e;
7936:254:    long x, y;
7937:255:    Window root;
7938:256:    Window target, dispatch;
7939:257:
7940:258:#ifdef DND_DEBUG
7941:259:    printf ("Drag start\n");
7942:260:#endif
7943:261:
7944:262:    root = DefaultRootWindow (CDisplay);
7945:263:
7946:264:    XChangeProperty (CDisplay, root, DndSelection, XA_STRING, 8,
7947:265:                     PropModeReplace, data, length);
7948:266:
7949:267:    XGrabPointer (CDisplay, root, False,
7950:268:                  ButtonMotionMask | ButtonPressMask | ButtonReleaseMask,
7951:269:                  GrabModeSync, GrabModeAsync, root,
7952:270:                  DndCursor[data_type].CursorID, CurrentTime);
7953:271:
7954:272:    do {
7955:273:        XAllowEvents (CDisplay, SyncPointer, CurrentTime);
7956:274:        XNextEvent (CDisplay, &e);
7957:275:    } while (e.type != ButtonRelease);
7958:276:
7959:277:    XUngrabPointer (CDisplay, CurrentTime);
7960:278:
7961:279:    if (!e.xbutton.subwindow) {
7962:280:#ifdef DND_DEBUG
7963:281:        printf ("Pointer on root window, Drag end\n");
7964:282:#endif
7965:283:        return;
7966:284:    }
7967:285:    target = my_XmuClientWindow (CDisplay, e.xbutton.subwindow);
7968:286:    if (target == e.xbutton.subwindow)
7969:287:        dispatch = target;
7970:288:    else
7971:289:        dispatch = PointerWindow;
7972:290:
7973:291:    x = e.xbutton.x_root;
7974:292:    y = e.xbutton.y_root;
7975:293:
7976:294:    e.xclient.type = ClientMessage;
7977:295:    e.xclient.display = CDisplay;
7978:296:    e.xclient.message_type = DndProtocol;
7979:297:    e.xclient.format = 32;
7980:298:    e.xclient.window = target;
7981:299:    e.xclient.data.l[0] = data_type;
7982:300:    e.xclient.data.l[1] = pointer_state;
7983:301:    e.xclient.data.l[2] = from;
7984:302:    e.xclient.data.l[3] = x + y * 65536L;
7985:303:    e.xclient.data.l[4] = 1;
7986:304:
7987:305:    /* Send the drop message */
7988:306:    XSendEvent (CDisplay, dispatch, True, NoEventMask, &e);
7989:307:
7990:308:#ifdef DND_DEBUG
7991:309:    printf ("Drop send to window %ld from %ld, Drag end\n", target, from);
7992:310:#endif
7993:311:}
7994:312:
7995:313:
7996:314:/*
7997:315:   Returns data_type on success, DndNotDnd if not a Dnd drop.
7998:316:   Unneeded values can be passed as null.
7999:317: */
8000:318:int CGetDrop (XEvent * xe, unsigned char **data, unsigned long *size,
8001:319:              int *x, int *y)
8002:320:{
8003:321:    Atom ActualType;
8004:322:    int format;
8005:323:    unsigned long dsize;
8006:324:    unsigned char *ddata;
8007:325:    unsigned long remaining;
8008:326:
8009:327:    if (!data)
8010:328:        data = &ddata;
8011:329:    if (!size)
8012:330:        size = &dsize;
8013:331:
8014:332:    if (xe->type != ClientMessage) {
8015:333:#ifdef DND_DEBUG
8016:334:        printf ("None ClientMessage event to window %ld\n",
8017:335:                xe->xany.window);
8018:336:#endif
8019:337:        return DndNotDnd;
8020:338:    }
8021:339:#ifdef DND_DEBUG
8022:340:    printf ("ClientMessage event to window %ld\n", xe->xany.window);
8023:341:#endif
8024:342:    if (xe->xclient.message_type != DndProtocol
8025:343:        || xe->xclient.data.l[4] != 1)
8026:344:        return DndNotDnd;
8027:345:
8028:346:#ifdef DND_DEBUG
8029:347:    printf ("Drop recieved at window %ld from window %ld\n",
8030:348:            xe->xclient.window, xe->xclient.data.l[2]);
8031:349:#endif
8032:350:
8033:351:    XGetWindowProperty (CDisplay, DefaultRootWindow (CDisplay),
8034:352:                        DndSelection, 0L, 1000000L, False, AnyPropertyType,
8035:353:                        &ActualType, &format, size, &remaining, data);
8036:354:
8037:355:    if (x)
8038:356:        *x = xe->xclient.data.l[3] & 0xFFFF;
8039:357:    if (y)
8040:358:        *y = xe->xclient.data.l[3] >> 16;
8041:359:
8042:360:    return xe->xclient.data.l[0];
8043:361:}
8044:362:
8045:363:/* 
8046:364:   Sends an acknowledge event that the drop was recieved. This is my
8047:365:   extension to the protocol, but cooledit doesn't depend on
8048:366:   an acknowledge event being recieved, so everything will
8049:367:   work as usual when communicating with apps that don't 
8050:368:   support this. xe is the drop event that you recived and
8051:369:   is not be modified.
8052:370: */
8053:371:void CDropAcknowledge (XEvent * xe)
8054:372:{
8055:373:    XEvent e;
8056:374:    e.xclient.type = ClientMessage;
8057:375:    e.xclient.display = CDisplay;
8058:376:    e.xclient.message_type = DndAcknowledge;
8059:377:    e.xclient.format = 32;
8060:378:    e.xclient.window = xe->xclient.data.l[2]; /* to window that send the drop */
8061:379:    e.xclient.data.l[0] = xe->xclient.data.l[0]; /* data type */
8062:380:    e.xclient.data.l[1] = xe->xclient.data.l[1]; /* pointer state of the pointer when the drop was send */
8063:381:    e.xclient.data.l[2] = xe->xclient.window; /* from this window */
8064:382:    e.xclient.data.l[3] = 0;    /* not used */
8065:383:    e.xclient.data.l[4] = 1;    /* same dnd version, since this extension can be 
8066:384:                                   ignored, there is no need to have a new version */
8067:385:
8068:386:    XSendEvent (CDisplay, e.xclient.window, True, NoEventMask, &e);
8069:387:
8070:388:#ifdef DND_DEBUG
8071:389:    printf ("acknowledge send to window %ld from %ld, return\n",
8072:390:            xe->xclient.data.l[2], xe->xclient.window);
8073:391:#endif
8074:392:}
8075:393:
8076:394:/*
8077:395:   Checks if xe is an acknowledge event.
8078:396:   Returns data_type if so and the state that the pointer was in
8079:397:   when the drag was initiated.
8080:398:   Returns DndNotDnd if not an acknowledge event.
8081:399: */
8082:400:int CIsDropAcknowledge (XEvent * xe, unsigned int *state)
8083:401:{
8084:402:    if (xe->type != ClientMessage)
8085:403:        return DndNotDnd;
8086:404:    if (xe->xclient.message_type != DndAcknowledge
8087:405:        || xe->xclient.data.l[4] != 1)
8088:406:        return DndNotDnd;
8089:407:    if (state)
8090:408:        *state = xe->xclient.data.l[1];
8091:409:    return xe->xclient.data.l[0];
8092:410:}
8093:1:/*
8094:2:   Copyright (C) 1996 Paul Sheer
8095:3:
8096:4:   This program is free software; you can redistribute it and/or modify
8097:5:   it under the terms of the GNU General Public License as published by
8098:6:   the Free Software Foundation; either version 2 of the License, or
8099:7:   (at your option) any later version.
8100:8:
8101:9:   This program is distributed in the hope that it will be useful,
8102:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
8103:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
8104:12:   GNU General Public License for more details.
8105:13:
8106:14:   You should have received a copy of the GNU General Public License
8107:15:   along with this program; if not, write to the Free Software
8108:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
8109:17: */
8110:18:
8111:19:
8112:20:#define DRAWINGS_C
8113:21:
8114:22:#include <config.h>
8115:23:#include <stdio.h>
8116:24:#include <my_string.h>
8117:25:#include <stdlib.h>
8118:26:
8119:27:#include <X11/Xlib.h>
8120:28:#include <X11/Xutil.h>
8121:29:#include <X11/Xresource.h>
8122:30:#include "lkeysym.h"
8123:31:
8124:32:#include "stringtools.h"
8125:33:#include "app_glob.c"
8126:34:
8127:35:#include "coolwidget.h"
8128:36:#include "coollocal.h"
8129:37:
8130:38:#include "mad.h"
8131:39:
8132:40:#include "drawings.h"
8133:41:
8134:42:/*
8135:43:    the bounds are the maximum extents of the elements.
8136:44:    only events withing the bounds are evaluated.
8137:45:*/
8138:46:void extendbounds (CWidget * wdt, int x1, int y1, int x2, int y2)
8139:47:{
8140:48:    int xb = max (x1, x2);
8141:49:    int xa = min (x1, x2);
8142:50:    int yb = max (y1, y2);
8143:51:    int ya = min (y1, y2);
8144:52:
8145:53:    if (wdt->pic->x1 > xa)
8146:54:        wdt->pic->x1 = xa;
8147:55:    if (wdt->pic->x2 < xb)
8148:56:        wdt->pic->x2 = xb;
8149:57:
8150:58:    if (wdt->pic->y1 > ya)
8151:59:        wdt->pic->y1 = ya;
8152:60:    if (wdt->pic->y2 < yb)
8153:61:        wdt->pic->y2 = yb;
8154:62:}
8155:63:
8156:64:/* returns 1 on error */
8157:65:int Csetdrawingtarget (const char *picture_ident)
8158:66:{
8159:67:    return (!(CWdrawtarget = Cwidget (picture_ident)));
8160:68:}
8161:69:
8162:70:
8163:71:void Cexposepic (CWidget * wdt)
8164:72:{
8165:73:    Cexposewindowarea (wdt->parentid, 0, wdt->pic->x1 + wdt->x,
8166:74:                       wdt->pic->y1 + wdt->y,
8167:75:                       wdt->pic->x2 - wdt->pic->x1 + 1,
8168:76:                       wdt->pic->y2 - wdt->pic->y1 + 1);
8169:77:}
8170:78:
8171:79:
8172:80:void cw_destroypicture (CWidget * wdt)
8173:81:{
8174:82:    if (wdt->pic->pp) {
8175:83:        free (wdt->pic->pp);
8176:84:        wdt->pic->pp = 0;
8177:85:    }
8178:86:    if (wdt->pic) {
8179:87:        free (wdt->pic);
8180:88:        wdt->pic->pp = 0;
8181:89:    }
8182:90:}
8183:91:
8184:92:
8185:93:void cw_reboundpic (CWidget * wdt)
8186:94:{
8187:95:    int j;
8188:96:    wdt->pic->x1 = 30000;
8189:97:    wdt->pic->x2 = -30000;
8190:98:    wdt->pic->y1 = 30000;
8191:99:    wdt->pic->y2 = -30000;
8192:100:
8193:101:    if (wdt->pic->numelements) {
8194:102:        for (j = 0; j < wdt->pic->numelements; j++) {
8195:103:            CPicturePrimative *pp = &(wdt->pic->pp[j]);
8196:104:            switch (pp->type) {
8197:105:            case CRECTANGLE:
8198:106:            case CFILLED_RECTANGLE:
8199:107:                extendbounds (wdt, pp->x, pp->y, pp->x + pp->a,
8200:108:                              pp->y + pp->b);
8201:109:                break;
8202:110:            case CLINE:
8203:111:                extendbounds (wdt, pp->x, pp->y, pp->a, pp->b);
8204:112:                break;
8205:113:            }
8206:114:        }
8207:115:    }
8208:116:}
8209:117:
8210:118:
8211:119:CWidget *Cdrawpicture (const char *identifier, Window parent, int x, int y,
8212:120:                       int max_num_elements)
8213:121:{
8214:122:    CWidget **w;
8215:123:
8216:124:    if (Cwidget (identifier))
8217:125:        Cerror
8218:126:            ("Trying to create a picture with the same identifier as an existing widget.\n");
8219:127:
8220:128:    w = Cfindemptywidgetentry (); /*find first unused list entry in list of widgets */
8221:129:    *w = Callocatewidget (0, identifier, parent, x, y,
8222:130:                          0, 0, CPICTURE_WIDGET);
8223:131:    (*w)->pic = Cmalloc (sizeof (CPicture));
8224:132:    memset ((*w)->pic, 0, sizeof (CPicture));
8225:133:    (*w)->pic->pp =
8226:134:        Cmalloc (sizeof (CPicturePrimative) * max_num_elements);
8227:135:    cw_reboundpic (*w);
8228:136:
8229:137:    (*w)->eh = Cdefaulthandler (CPICTURE_WIDGET);
8230:138:    (*w)->destroy = cw_destroypicture;
8231:139:    Csetdrawingtarget (identifier);
8232:140:    return (*w);
8233:141:}
8234:142:
8235:143:void Cclearpic (void)
8236:144:{
8237:145:    CWidget *wdt = CWdrawtarget;
8238:146:    wdt->pic->numelements = 0;
8239:147:
8240:148:    Cexposepic (wdt);
8241:149:    cw_reboundpic (wdt);
8242:150:}
8243:151:
8244:152:int Cdrawline (float x1, float y1, float x2, float y2, unsigned long c)
8245:153:{
8246:154:    CWidget *wdt = CWdrawtarget;
8247:155:    int last = wdt->pic->numelements;
8248:156:
8249:157:    wdt->pic->pp[last].x = x1;
8250:158:    wdt->pic->pp[last].y = y1;
8251:159:    wdt->pic->pp[last].a = x2;
8252:160:    wdt->pic->pp[last].b = y2;
8253:161:    wdt->pic->pp[last].color = c;
8254:162:    wdt->pic->pp[last].type = CLINE;
8255:163:    wdt->pic->numelements++;
8256:164:
8257:165:    extendbounds (wdt, x1, y1, x2, y2);
8258:166:
8259:167:    Cexposepic (wdt);
8260:168:
8261:169:    return last;
8262:170:}
8263:171:
8264:172:int Cdrawpicrectangle (float x, float y, float w, float h, unsigned long c)
8265:173:{
8266:174:    CWidget *wdt = CWdrawtarget;
8267:175:    int last = wdt->pic->numelements;
8268:176:
8269:177:    wdt->pic->pp[last].x = x;
8270:178:    wdt->pic->pp[last].y = y;
8271:179:    wdt->pic->pp[last].a = w;
8272:180:    wdt->pic->pp[last].b = h;
8273:181:    wdt->pic->pp[last].color = c;
8274:182:    wdt->pic->pp[last].type = CRECTANGLE;
8275:183:    wdt->pic->numelements++;
8276:184:
8277:185:    extendbounds (wdt, x, y, x + w, y + h);
8278:186:
8279:187:    Cexposepic (wdt);
8280:188:
8281:189:    return last;
8282:190:}
8283:191:
8284:192:
8285:193:void Cremovepp (int j)
8286:194:{
8287:195:    if (CWdrawtarget->pic->numelements <= j || j < 0)
8288:196:        return;
8289:197:
8290:198:    if (CWdrawtarget->pic->numelements - 1 == j)
8291:199:        CWdrawtarget->pic->numelements--;
8292:200:    else
8293:201:        CWdrawtarget->pic->pp[j].type = 0;
8294:202:
8295:203:    Cexposepic (CWdrawtarget);
8296:204:    cw_reboundpic (CWdrawtarget);
8297:205:}
8298:206:
8299:207:
8300:208:void Cscalepicture (float s)
8301:209:{
8302:210:    CWidget *wdt = CWdrawtarget;
8303:211:    int j = 0;
8304:212:
8305:213:    if (s == 1)
8306:214:        return;
8307:215:
8308:216:    if (s < 1)
8309:217:        Cexposepic (wdt);
8310:218:    for (; j < wdt->pic->numelements; j++) {
8311:219:        CPicturePrimative *pp = &(wdt->pic->pp[j]);
8312:220:        pp->x *= s;
8313:221:        pp->y *= s;
8314:222:        pp->a *= s;
8315:223:        pp->b *= s;
8316:224:    }
8317:225:    wdt->pic->x1 *= s;
8318:226:    wdt->pic->x2 *= s;
8319:227:    wdt->pic->y1 *= s;
8320:228:    wdt->pic->y2 *= s;
8321:229:    cw_reboundpic (wdt);
8322:230:
8323:231:    if (s > 1)
8324:232:        Cexposepic (wdt);
8325:233:}
8326:234:
8327:235:
8328:236:#define is_between(a,b,c) \
8329:237:                    ((a) >= (b) && (a) <= (c))
8330:238:
8331:239:int eh_picture (CWidget * wdt, XEvent * xevent, CEvent * cwevent)
8332:240:{
8333:241:    int last = wdt->pic->numelements;
8334:242:    CPicturePrimative *pp = wdt->pic->pp;
8335:243:    Window win = wdt->parentid;
8336:244:    int x = wdt->x;
8337:245:    int y = wdt->y;
8338:246:
8339:247:    switch (xevent->type) {
8340:248:    case Expose:
8341:249:        if (last) {
8342:250:/* check if the expose covers the region of the picture */
8343:251:            int w =
8344:252:                max (max
8345:253:                     (xevent->xexpose.x,
8346:254:                      xevent->xexpose.x + xevent->xexpose.width),
8347:255:                     wdt->pic->x2 + x)
8348:256:                -
8349:257:                min (min
8350:258:                     (xevent->xexpose.x,
8351:259:                      xevent->xexpose.x + xevent->xexpose.width),
8352:260:                     wdt->pic->x1 + x);
8353:261:
8354:262:            int h =
8355:263:                max (max
8356:264:                     (xevent->xexpose.y,
8357:265:                      xevent->xexpose.y + xevent->xexpose.height),
8358:266:                     wdt->pic->y2 + y)
8359:267:                -
8360:268:                min (min
8361:269:                     (xevent->xexpose.y,
8362:270:                      xevent->xexpose.y + xevent->xexpose.height),
8363:271:                     wdt->pic->y1 + y);
8364:272:
8365:273:            if (h <
8366:274:                wdt->pic->y2 - wdt->pic->y1 + abs (xevent->xexpose.height)
8367:275:                && w <
8368:276:                wdt->pic->x2 - wdt->pic->x1 +
8369:277:                abs (xevent->xexpose.width)) {
8370:278:                int j = 0;
8371:279:                for (; j < last; j++)
8372:280:                    switch (pp[j].type) {
8373:281:                    case CLINE:
8374:282:                        Csetcolor (pp[j].color);
8375:283:                        Cline (win, pp[j].x + x, pp[j].y + y, pp[j].a + x,
8376:284:                               pp[j].b + y);
8377:285:                        break;
8378:286:                    case CFILLED_RECTANGLE:
8379:287:                        Csetcolor (pp[j].color);
8380:288:                        Crect (win, pp[j].x + x, pp[j].y + y, pp[j].a,
8381:289:                               pp[j].b);
8382:290:                        break;
8383:291:                    case CRECTANGLE:
8384:292:                        Csetcolor (pp[j].color);
8385:293:                        Cline (win, pp[j].x + x, pp[j].y + y,
8386:294:                               pp[j].x + x + pp[j].a, pp[j].y + y);
8387:295:                        Cline (win, pp[j].x + x, pp[j].y + y, pp[j].x + x,
8388:296:                               pp[j].y + y + pp[j].b);
8389:297:                        Cline (win, pp[j].x + x + pp[j].a,
8390:298:                               pp[j].y + y + pp[j].b,
8391:299:                               pp[j].x + x + pp[j].a, pp[j].y + y);
8392:300:                        Cline (win, pp[j].x + x + pp[j].a,
8393:301:                               pp[j].y + y + pp[j].b, pp[j].x + x,
8394:302:                               pp[j].y + y + pp[j].b);
8395:303:                        break;
8396:304:                    }
8397:305:            }
8398:306:        }
8399:307:        break;
8400:308:    case ButtonPress:
8401:309:        break;
8402:310:    }
8403:311:    return 0;
8404:312:}
8405:1:#ifndef DRAWINGS_H
8406:2:#define DRAWINGS_H
8407:3:
8408:4:/* types */
8409:5:#define CLINE 1
8410:6:#define CELLIPSE 2
8411:7:#define CCIRCLE 3
8412:8:#define CARC 4
8413:9:#define CRECTANGLE 5
8414:10:#define CFILLED_ELLIPSE 6
8415:11:#define CFILLED_CIRCLE 7
8416:12:#define CFILLED_ARC 8
8417:13:#define CFILLED_RECTANGLE 9
8418:14:
8419:15:typedef struct {
8420:16:    float x, y;                 /*point position (must be floats for scaling) */
8421:17:    float a, b;                 /*width and height for arcs, ellipses
8422:18:                                   and rectangle. Second point for lines */
8423:19:    char type;                  /*type */
8424:20:    short angle1, angle2;
8425:21:    unsigned long color;
8426:22:} CPicturePrimative;
8427:23:
8428:24:typedef struct {
8429:25:    int numelements;
8430:26:    float x1, y1;               /*maximum bounds of elements */
8431:27:    float x2, y2;
8432:28:    CPicturePrimative *pp;
8433:29:} CPicture;
8434:30:
8435:31:
8436:32:/* sets the widget into which subsequent drawing operations execute.
8437:33:returns 1 on error */
8438:34:int Csetdrawingtarget (const char *picture_ident);
8439:35:
8440:36:/* returns a pp index to be used for removepp */
8441:37:
8442:38:int Cdrawline (float x1, float y1, float x2, float y2, unsigned long c);
8443:39:
8444:40:int Cdrawpicrectangle (float x, float y, float w, float h,
8445:41:                       unsigned long c);
8446:42:
8447:43:void Cremovepp (int j);
8448:44:
8449:45:int Cdrawpoint (int x1, int y1, unsigned long c);
8450:46:
8451:47:int Cdrawarc (int x, int y, int width, int height, int angle1, int angle2,
8452:48:              unsigned long c);
8453:49:
8454:50:int Cdrawcurvedline (int x1, int y1, int x2, int y2, int radius,
8455:51:                     unsigned long c);
8456:52:
8457:53:int Cdrawfilledarc (int x, int y, int width, int height,
8458:54:                    int angle1, int angle2, int pie, unsigned long c);
8459:55:
8460:56:void Cscalepicture (float s);
8461:57:
8462:58:void Cclearpic (void);
8463:59:
8464:60:#endif
8465:1:/* editor low level data handling and cursor fundamentals.
8466:2:
8467:3:   Copyright (C) 1996 the Free Software Foundation
8468:4:   
8469:5:   Authors: 1996 Paul Sheer
8470:6:
8471:7:   This program is free software; you can redistribute it and/or modify
8472:8:   it under the terms of the GNU General Public License as published by
8473:9:   the Free Software Foundation; either version 2 of the License, or
8474:10:   (at your option) any later version.
8475:11:   
8476:12:   This program is distributed in the hope that it will be useful,
8477:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
8478:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
8479:15:   GNU General Public License for more details.
8480:16:
8481:17:   You should have received a copy of the GNU General Public License
8482:18:   along with this program; if not, write to the Free Software
8483:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
8484:20:
8485:21:#define _EDIT_C THIS_IS
8486:22:
8487:23:#include <config.h>
8488:24:#include "edit.h"
8489:25:
8490:26:/*
8491:27:   what editor are we going to emulate? one of EDIT_KEY_EMULATION_NORMAL
8492:28:   or EDIT_KEY_EMULATION_EMACS
8493:29: */
8494:30:int edit_key_emulation = EDIT_KEY_EMULATION_NORMAL;
8495:31:
8496:32:
8497:33:/* here's a quick sketch of the layout: (don't run this through indent.)
8498:34:
8499:35:(b1 is buffers1 and b2 is buffers2)
8500:36:
8501:37:                                      |
8502:38:\0\0\0\0\0m e _ f i l e . \nf i n . \n|T h i s _ i s _ s o\0\0\0\0\0\0\0\0\0
8503:39:______________________________________|______________________________________
8504:40:                                      |
8505:41:...  |  b2[2]   |  b2[1]   |  b2[0]   |  b1[0]   |  b1[1]   |  b1[2]   | ...
8506:42:     |->        |->        |->        |->        |->        |->        |
8507:43:                                      |
8508:44:          _<------------------------->|<----------------->_
8509:45:                  WEdit->curs2        |   WEdit->curs1
8510:46:          ^                           |                   ^
8511:47:          |                          ^|^                  |
8512:48:        cursor                       |||                cursor
8513:49:                                     |||
8514:50:                             file end|||file beginning
8515:51:                                      |
8516:52:                                      |
8517:53:
8518:54:          _
8519:55:This_is_some_file
8520:56:fin.
8521:57:
8522:58:
8523:59:*/
8524:60:
8525:61:
8526:62:
8527:63:int word_wrap_line_length = 20;
8528:64:
8529:65:
8530:66:
8531:67:
8532:68:/*
8533:69:   returns a byte from any location in the file.
8534:70:   Returns '\n' if out of bounds.
8535:71: */
8536:72:int edit_get_byte (WEdit * edit, long byte_index)
8537:73:{
8538:74:    unsigned long p;
8539:75:    if (byte_index >= (edit->curs1 + edit->curs2) || byte_index < 0)
8540:76:        return '\n';
8541:77:
8542:78:    if (byte_index >= edit->curs1) {
8543:79:        p = edit->curs1 + edit->curs2 - byte_index - 1;
8544:80:        return edit->buffers2[p >> S_EDIT_BUF_SIZE][EDIT_BUF_SIZE -
8545:81:                                                    (p & M_EDIT_BUF_SIZE) -
8546:82:                                                    1];
8547:83:    } else {
8548:84:        return edit->
8549:85:            buffers1[byte_index >> S_EDIT_BUF_SIZE][byte_index &
8550:86:                                                    M_EDIT_BUF_SIZE];
8551:87:    }
8552:88:}
8553:89:
8554:90:/* Initialisation routines */
8555:91:
8556:92:/* returns 1 on error */
8557:93:/* loads file OR text into buffers. Only one must be none-NULL. */
8558:94:/* cursor set to start of file */
8559:95:int init_dynamic_edit_buffers (WEdit * edit, const char *filename,
8560:96:                               const char *text)
8561:97:{
8562:98:    long buf;
8563:99:    int i = 0, j;
8564:100:    int file = 0;
8565:101:    int buf2;
8566:102:
8567:103:    for (j = 0; j <= MAXBUFF; j++) {
8568:104:        edit->buffers1[j] = NULL;
8569:105:        edit->buffers2[j] = NULL;
8570:106:    }
8571:107:
8572:108:    if (filename)
8573:109:        if ((file = open ((char *) filename, O_RDONLY)) == -1) {
8574:110:            Cerrordialogue (edit->widget->winid, 20, 20, " Error ",
8575:111:                            get_sys_error
8576:112:                            (" Fail trying to open edit file for reading. "));
8577:113:            return 1;
8578:114:        }
8579:115:    edit->curs2 = edit->last_byte;
8580:116:
8581:117:    buf2 = edit->curs2 >> S_EDIT_BUF_SIZE;
8582:118:
8583:119:    edit->buffers2[buf2] = Cmalloc (EDIT_BUF_SIZE);
8584:120:
8585:121:    if (filename)
8586:122:        read (file,
8587:123:              (char *) edit->buffers2[buf2] + EDIT_BUF_SIZE -
8588:124:              (edit->curs2 & M_EDIT_BUF_SIZE),
8589:125:              (edit->curs2 & M_EDIT_BUF_SIZE));
8590:126:    else
8591:127:        memcpy (edit->buffers2[buf2] + EDIT_BUF_SIZE -
8592:128:                (edit->curs2 & M_EDIT_BUF_SIZE),
8593:129:                text + (i++) * EDIT_BUF_SIZE,
8594:130:                (edit->curs2 & M_EDIT_BUF_SIZE));
8595:131:
8596:132:    for (buf = buf2 - 1; buf >= 0; buf--) {
8597:133:        edit->buffers2[buf] = Cmalloc (EDIT_BUF_SIZE);
8598:134:        if (filename)
8599:135:            read (file, (char *) edit->buffers2[buf], EDIT_BUF_SIZE);
8600:136:        else
8601:137:            memcpy (edit->buffers2[buf], text + (i++) * EDIT_BUF_SIZE,
8602:138:                    EDIT_BUF_SIZE);
8603:139:    }
8604:140:
8605:141:    edit->curs1 = 0;
8606:142:    if (filename)
8607:143:        close (file);
8608:144:
8609:145:    return 0;
8610:146:}
8611:147:
8612:148:/* returns 1 on error */
8613:149:int load_edit_file (WEdit * edit, const char *filename, const char *text)
8614:150:{
8615:151:    struct stat s;
8616:152:    int file;
8617:153:
8618:154:    if (text) {
8619:155:        edit->last_byte = strlen (text);
8620:156:        filename = NULL;
8621:157:    } else {
8622:158:        if ((file = open ((char *) filename, O_RDONLY)) < 0) {
8623:159:            Cerrordialogue (edit->widget->winid, 20, 20, " Error ",
8624:160:                            get_sys_error
8625:161:                            (" Fail trying to open edit file for reading. "));
8626:162:            return 1;
8627:163:        }
8628:164:        if (stat ((char *) filename, &s) < 0) {
8629:165:            close (file);
8630:166:            Cerrordialogue (edit->widget->winid, 20, 20, " Error ",
8631:167:                            get_sys_error
8632:168:                            (" Cannot get info on this file. "));
8633:169:            return 1;
8634:170:        }
8635:171:        if (S_ISDIR (s.st_mode) || S_ISSOCK (s.st_mode)
8636:172:            || S_ISFIFO (s.st_mode)) {
8637:173:            close (file);
8638:174:            Cerrordialogue (edit->widget->winid, 20, 20, " Error ",
8639:175:                            " This is not a text file ");
8640:176:            return 1;
8641:177:        }
8642:178:        if (s.st_size >= SIZE_LIMIT) {
8643:179:            close (file);
8644:180:            Cerrordialogue (edit->widget->winid, 20, 20, " Error ",
8645:181:                            " File is to large. Increase edit.h:MAXBUF and recompile ");
8646:182:            return 1;
8647:183:        }
8648:184:        close (file);
8649:185:        edit->last_byte = s.st_size;
8650:186:    }
8651:187:
8652:188:    return init_dynamic_edit_buffers (edit, filename, text);
8653:189:}
8654:190:
8655:191:
8656:192:/* fills in the edit struct. returns 0 on fail. Pass e as NULL for this function to do an malloc for you */
8657:193:WEdit *edit_init (WEdit * e, int lines, int columns, const char *filename,
8658:194:                  const char *text, const char *dir)
8659:195:{
8660:196:    char *f;
8661:197:    if (!e)
8662:198:        e = malloc (sizeof (WEdit));
8663:199:    if (!e) {
8664:200:        Cerrordialogue (e->widget->winid, 20, 20, " Error ",
8665:201:                        " Error allocating memory. ");
8666:202:        return 0;
8667:203:    }
8668:204:    memset (&(e->from_here), 0,
8669:205:            (unsigned long) &(e->to_here) -
8670:206:            (unsigned long) &(e->from_here));
8671:207:    e->num_widget_lines = lines;
8672:208:    e->num_widget_columns = columns;
8673:209:    if (!dir)
8674:210:        dir = "";
8675:211:    f = (char *) filename;
8676:212:    if (filename)
8677:213:        f = catstrs (dir, filename, 0);
8678:214:    if (load_edit_file (e, f, text)) {
8679:215:/* load_edit_file already gives an error message */
8680:216:        free (e);
8681:217:        return 0;
8682:218:    }
8683:219:    e->force |= REDRAW_PAGE;
8684:220:    if (filename) {
8685:221:        filename = catstrs (dir, filename, 0);
8686:222:        split_filename (e, (char *) filename);
8687:223:    } else {
8688:224:        e->filename = strdup ("");
8689:225:        e->dir = strdup (dir);
8690:226:    }
8691:227:    e->undo_stack = malloc ((STACK_SIZE + 10) * sizeof (long));
8692:228:    if (!e->undo_stack) {
8693:229:        Cerrordialogue (e->widget->winid, 20, 20, " Error ",
8694:230:                        " Error allocating memory. ");
8695:231:        free (e);
8696:232:        return 0;
8697:233:    }
8698:234:    e->total_lines = edit_count_lines (e, 0, e->last_byte);
8699:235:    return e;
8700:236:}
8701:237:
8702:238:
8703:239:/* clear the edit struct, freeing everything in it. returns 1 on success */
8704:240:int edit_clean (WEdit * edit)
8705:241:{
8706:242:    if (edit) {
8707:243:        int j = 0;
8708:244:        for (; j <= MAXBUFF; j++) {
8709:245:            if (edit->buffers1[j] != NULL)
8710:246:                free (edit->buffers1[j]);
8711:247:            if (edit->buffers2[j] != NULL)
8712:248:                free (edit->buffers2[j]);
8713:249:        }
8714:250:
8715:251:        if (edit->undo_stack)
8716:252:            free (edit->undo_stack);
8717:253:        if (edit->filename)
8718:254:            free (edit->filename);
8719:255:        if (edit->dir)
8720:256:            free (edit->dir);
8721:257:/* we don't want to clear the widget */
8722:258:        memset (&(edit->from_here), 0,
8723:259:                (unsigned long) &(edit->to_here) -
8724:260:                (unsigned long) &(edit->from_here));
8725:261:        return 1;
8726:262:    }
8727:263:    return 0;
8728:264:}
8729:265:
8730:266:
8731:267:/* returns 1 on success */
8732:268:int edit_renew (WEdit * edit)
8733:269:{
8734:270:    int lines = edit->num_widget_lines;
8735:271:    int columns = edit->num_widget_columns;
8736:272:    char *dir;
8737:273:
8738:274:    if (edit->dir)
8739:275:        dir = strdup (edit->dir);
8740:276:    else
8741:277:        dir = 0;
8742:278:
8743:279:    edit_clean (edit);
8744:280:    if (!edit_init (edit, lines, columns, 0, "", dir))
8745:281:        return 0;
8746:282:    return 1;
8747:283:}
8748:284:
8749:285:/* returns 1 on success */
8750:286:int edit_reload (WEdit * edit, const char *filename, const char *text,
8751:287:                 const char *dir)
8752:288:{
8753:289:    int lines = edit->num_widget_lines;
8754:290:    int columns = edit->num_widget_columns;
8755:291:    edit_clean (edit);
8756:292:    if (!edit_init (edit, lines, columns, filename, text, dir)) {
8757:293:        return 0;
8758:294:    }
8759:295:    return 1;
8760:296:}
8761:297:
8762:298:
8763:299:/*
8764:300:   Recording stack for undo:
8765:301:   The following is an implementation of a compressed stack. Identical
8766:302:   pushes are recorded by a negative prefix indicating the number of times the
8767:303:   same char was pushed. This saves space for repeated curs-left or curs-right
8768:304:   delete etc.
8769:305:
8770:306:   eg:
8771:307:
8772:308:  pushed:       stored:
8773:309:
8774:310:   a
8775:311:   b             a
8776:312:   b            -3
8777:313:   b             b
8778:314:   c  -->       -4
8779:315:   c             c
8780:316:   c             d
8781:317:   c
8782:318:   d
8783:319:
8784:320:   If the stack long int is 0-255 it represents a normal insert (from a backspace),
8785:321:   256-512 is an insert ahead (from a delete), If it is betwen 600 and 700 it is one
8786:322:   of the cursor functions #define'd in edit.h. 1000 through 700'000'000 is to
8787:323:   set edit->mark1 position. 700'000'000 through 1400'000'000 is to set edit->mark2
8788:324:   position.
8789:325:
8790:326:   The only way the curser moves or the buffer is changed is through the routines:
8791:327:   insert, backspace, insert_ahead, delete, and cursor_move.
8792:328:   These record the reverse undo movements onto the stack each time they are
8793:329:   called.
8794:330:
8795:331:   Each key press results in a set of actions (insert; delete ...). So each time
8796:332:   a key is pressed the current position of start_display is pushed as
8797:333:   KEY_PRESS + start_display. Then for undoing, we pop until we get to a number
8798:334:   over KEY_PRESS. We then assign this number less KEY_PRESS to start_display. So undo
8799:335:   tracks scrolling and key actions exactly. (KEY_PRESS is about (2^31) * (2/3) = 1400'000'000)
8800:336:
8801:337:*/
8802:338:
8803:339:static int push_action_disabled = 0;
8804:340:
8805:341:void push_action (WEdit * edit, long c, ...)
8806:342:{
8807:343:    unsigned long sp = edit->stack_pointer;
8808:344:    unsigned long spm1 = (edit->stack_pointer - 1) & M_STACK_SIZE;
8809:345:    if (push_action_disabled)
8810:346:        return;
8811:347:    if (c == CURS_LEFT_LOTS || c == CURS_RIGHT_LOTS) {
8812:348:        va_list ap;
8813:349:        edit->undo_stack[sp] =
8814:350:            c == CURS_LEFT_LOTS ? CURS_LEFT : CURS_RIGHT;
8815:351:        edit->stack_pointer = (edit->stack_pointer + 1) & M_STACK_SIZE;
8816:352:        va_start (ap, c);
8817:353:        c = -(va_arg (ap, int));
8818:354:        va_end (ap);
8819:355:    } else if (spm1 != edit->stack_bottom
8820:356:               && ((sp - 2) & M_STACK_SIZE) != edit->stack_bottom) {
8821:357:        int d;
8822:358:        if (edit->undo_stack[spm1] < 0) {
8823:359:            d = edit->undo_stack[(sp - 2) & M_STACK_SIZE];
8824:360:            if (d == c) {
8825:361:                if (edit->undo_stack[spm1] > -1000000000) {
8826:362:                    if (c < KEY_PRESS) /* --> no need to push multiple do-nothings */
8827:363:                        edit->undo_stack[spm1]--;
8828:364:                    return;
8829:365:                }
8830:366:            }
8831:367:/* #define NO_STACK_CURSMOVE_ANIHILATION */
8832:368:#ifndef NO_STACK_CURSMOVE_ANIHILATION
8833:369:            else if ((c == CURS_LEFT && d == CURS_RIGHT)
8834:370:                     || (c == CURS_RIGHT && d == CURS_LEFT)) { /* a left then a right anihilate each other */
8835:371:                if (edit->undo_stack[spm1] == -2)
8836:372:                    edit->stack_pointer = spm1;
8837:373:                else
8838:374:                    edit->undo_stack[spm1]++;
8839:375:                return;
8840:376:            }
8841:377:#endif
8842:378:        } else {
8843:379:            d = edit->undo_stack[spm1];
8844:380:            if (d == c) {
8845:381:                if (c >= KEY_PRESS)
8846:382:                    return;     /* --> no need to push multiple do-nothings */
8847:383:                edit->undo_stack[sp] = -2;
8848:384:                goto check_bottom;
8849:385:            }
8850:386:#ifndef NO_STACK_CURSMOVE_ANIHILATION
8851:387:            else if ((c == CURS_LEFT && d == CURS_RIGHT)
8852:388:                     || (c == CURS_RIGHT && d == CURS_LEFT)) { /* a left then a right anihilate each other */
8853:389:                edit->stack_pointer = spm1;
8854:390:                return;
8855:391:            }
8856:392:#endif
8857:393:        }
8858:394:    }
8859:395:    edit->undo_stack[sp] = c;
8860:396:  check_bottom:
8861:397:
8862:398:    edit->stack_pointer = (edit->stack_pointer + 1) & M_STACK_SIZE;
8863:399:
8864:400:/*if the sp wraps round and catches the stack_bottom then erase the first set of actions on the stack to make space - by moving stack_bottom forward one "key press" */
8865:401:    c = (edit->stack_pointer + 2) & M_STACK_SIZE;
8866:402:    if (c == edit->stack_bottom
8867:403:        || ((c + 1) & M_STACK_SIZE) == edit->stack_bottom)
8868:404:        do {
8869:405:            edit->stack_bottom = (edit->stack_bottom + 1) & M_STACK_SIZE;
8870:406:        } while (edit->undo_stack[edit->stack_bottom] < KEY_PRESS
8871:407:                 && edit->stack_bottom != edit->stack_pointer);
8872:408:
8873:409:/*If a single key produced enough pushes to wrap all the way round then we would notice that the [stack_bottom] does not contain KEY_PRESS. The stack is then initialised: */
8874:410:    if (edit->stack_pointer != edit->stack_bottom
8875:411:        && edit->undo_stack[edit->stack_bottom] < KEY_PRESS)
8876:412:        edit->stack_bottom = edit->stack_pointer = 0;
8877:413:}
8878:414:
8879:415:/*
8880:416:   TODO: if the user undos until the stack bottom, and the stack has not wrapped,
8881:417:   then the file should be as it was when he loaded up. Then set edit->modified to 0.
8882:418: */
8883:419:long pop_action (WEdit * edit)
8884:420:{
8885:421:    long c;
8886:422:    unsigned long sp = edit->stack_pointer;
8887:423:    if (sp == edit->stack_bottom) {
8888:424:        return STACK_BOTTOM;
8889:425:    }
8890:426:    sp = (sp - 1) & M_STACK_SIZE;
8891:427:    if ((c = edit->undo_stack[sp]) >= 0) {
8892:428:/*        edit->undo_stack[sp] = '@'; */
8893:429:        edit->stack_pointer = (edit->stack_pointer - 1) & M_STACK_SIZE;
8894:430:        return c;
8895:431:    }
8896:432:    if (sp == edit->stack_bottom) {
8897:433:        return STACK_BOTTOM;
8898:434:    }
8899:435:    c = edit->undo_stack[(sp - 1) & M_STACK_SIZE];
8900:436:    if (edit->undo_stack[sp] == -2) {
8901:437:/*      edit->undo_stack[sp] = '@'; */
8902:438:        edit->stack_pointer = sp;
8903:439:    } else
8904:440:        edit->undo_stack[sp]++;
8905:441:
8906:442:    return c;
8907:443:}
8908:444:
8909:445:
8910:446:/* is called whenever a modification is made by one of the four routines below */
8911:447:static inline void edit_modification (WEdit * edit)
8912:448:{
8913:449:    edit->modified = 1;
8914:450:}
8915:451:
8916:452:
8917:453:/*
8918:454:   Basic low level single character buffer alterations and movements at the cursor.
8919:455:   Returns char passed over, inserted or removed.
8920:456: */
8921:457:
8922:458:void edit_insert (WEdit * edit, int c)
8923:459:{
8924:460:/* check if file has grown to large */
8925:461:    if (edit->last_byte >= SIZE_LIMIT)
8926:462:        return;
8927:463:
8928:464:/* first we must update the position of the display window */
8929:465:    if (edit->curs1 < edit->start_display) {
8930:466:        edit->start_display++;
8931:467:        if (c == '\n')
8932:468:            edit->start_line++;
8933:469:    }
8934:470:/* now we must update some info on the file and check if a redraw is required */
8935:471:    if (c == '\n') {
8936:472:        edit->curs_line++;
8937:473:        edit->total_lines++;
8938:474:        edit->force |= REDRAW_LINE_ABOVE | REDRAW_AFTER_CURSOR;
8939:475:    }
8940:476:/* tell that we've modified the file */
8941:477:    edit_modification (edit);
8942:478:
8943:479:/* save the reverse command onto the undo stack */
8944:480:    push_action (edit, BACKSPACE);
8945:481:
8946:482:/* update markers */
8947:483:    edit->mark1 += (edit->mark1 > edit->curs1);
8948:484:    edit->mark2 += (edit->mark2 > edit->curs1);
8949:485:
8950:486:/* add a new buffer if we've reached the end of the last one */
8951:487:    if (!(edit->curs1 & M_EDIT_BUF_SIZE))
8952:488:        edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE] =
8953:489:            malloc (EDIT_BUF_SIZE);
8954:490:
8955:491:/* perfprm the insertion */
8956:492:    edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE][edit->
8957:493:                                                   curs1 & M_EDIT_BUF_SIZE]
8958:494:        = (unsigned char) c;
8959:495:
8960:496:/* update file length */
8961:497:    edit->last_byte++;
8962:498:
8963:499:/* update cursor position */
8964:500:    edit->curs1++;
8965:501:}
8966:502:
8967:503:
8968:504:/* same as edit_insert and move left */
8969:505:void edit_insert_ahead (WEdit * edit, int c)
8970:506:{
8971:507:    if (edit->last_byte >= SIZE_LIMIT)
8972:508:        return;
8973:509:    if (edit->curs1 < edit->start_display) {
8974:510:        edit->start_display++;
8975:511:        if (c == '\n')
8976:512:            edit->start_line++;
8977:513:    }
8978:514:    if (c == '\n') {
8979:515:        edit->total_lines++;
8980:516:        edit->force |= REDRAW_AFTER_CURSOR;
8981:517:    }
8982:518:    edit_modification (edit);
8983:519:    push_action (edit, DELETE);
8984:520:
8985:521:    edit->mark1 += (edit->mark1 >= edit->curs1);
8986:522:    edit->mark2 += (edit->mark2 >= edit->curs1);
8987:523:
8988:524:    if (!((edit->curs2 + 1) & M_EDIT_BUF_SIZE))
8989:525:        edit->buffers2[(edit->curs2 + 1) >> S_EDIT_BUF_SIZE] =
8990:526:            malloc (EDIT_BUF_SIZE);
8991:527:    edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE][EDIT_BUF_SIZE -
8992:528:                                                   (edit->
8993:529:                                                    curs2 &
8994:530:                                                    M_EDIT_BUF_SIZE) - 1] =
8995:531:        c;
8996:532:
8997:533:    edit->last_byte++;
8998:534:    edit->curs2++;
8999:535:}
9000:536:
9001:537:
9002:538:int edit_delete (WEdit * edit)
9003:539:{
9004:540:    int p;
9005:541:    if (!edit->curs2)
9006:542:        return 0;
9007:543:
9008:544:    edit->mark1 -= (edit->mark1 > edit->curs1);
9009:545:    edit->mark2 -= (edit->mark2 > edit->curs1);
9010:546:
9011:547:    p = edit->
9012:548:        buffers2[(edit->curs2 - 1) >> S_EDIT_BUF_SIZE][EDIT_BUF_SIZE -
9013:549:                                                       ((edit->curs2 -
9014:550:                                                         1) &
9015:551:                                                        M_EDIT_BUF_SIZE) -
9016:552:                                                       1];
9017:553:
9018:554:    if (!(edit->curs2 & M_EDIT_BUF_SIZE)) {
9019:555:        free (edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE]);
9020:556:        edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE] = NULL;
9021:557:    }
9022:558:    edit->last_byte--;
9023:559:    edit->curs2--;
9024:560:
9025:561:    if (p == '\n') {
9026:562:        edit->total_lines--;
9027:563:        edit->force |= REDRAW_AFTER_CURSOR;
9028:564:    }
9029:565:    push_action (edit, p + 256);
9030:566:    if (edit->curs1 < edit->start_display) {
9031:567:        edit->start_display--;
9032:568:        if (p == '\n')
9033:569:            edit->start_line--;
9034:570:    }
9035:571:    edit_modification (edit);
9036:572:
9037:573:    return p;
9038:574:}
9039:575:
9040:576:
9041:577:int edit_backspace (WEdit * edit)
9042:578:{
9043:579:    int p;
9044:580:    if (!edit->curs1)
9045:581:        return 0;
9046:582:
9047:583:    edit->mark1 -= (edit->mark1 >= edit->curs1);
9048:584:    edit->mark2 -= (edit->mark2 >= edit->curs1);
9049:585:
9050:586:    p = *(edit->buffers1[(edit->curs1 - 1) >> S_EDIT_BUF_SIZE] +
9051:587:          ((edit->curs1 - 1) & M_EDIT_BUF_SIZE));
9052:588:    if (!((edit->curs1 - 1) & M_EDIT_BUF_SIZE)) {
9053:589:        free (edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE]);
9054:590:        edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE] = NULL;
9055:591:    }
9056:592:    edit->last_byte--;
9057:593:    edit->curs1--;
9058:594:
9059:595:    if (p == '\n') {
9060:596:        edit->curs_line--;
9061:597:        edit->total_lines--;
9062:598:        edit->force |= REDRAW_AFTER_CURSOR;
9063:599:    }
9064:600:    push_action (edit, p);
9065:601:
9066:602:    if (edit->curs1 < edit->start_display) {
9067:603:        edit->start_display--;
9068:604:        if (p == '\n')
9069:605:            edit->start_line--;
9070:606:    }
9071:607:    edit_modification (edit);
9072:608:
9073:609:    return p;
9074:610:}
9075:611:
9076:612:#ifdef FAST_MOVE_CURSOR
9077:613:
9078:614:#define memqcpy(edit,d,s,i)                                                \
9079:615:        {                                                                \
9080:616:            unsigned long next;                                                \
9081:617:            char *dest = d;                                                \
9082:618:            char *src = s;                                                \
9083:619:            int n = i;                                                        \
9084:620:            while ((next =                                                \
9085:621:                    (unsigned long) memccpy (dest, src, '\n', n))) {        \
9086:622:                edit->curs_line--;                                        \
9087:623:                next -= (unsigned long) dest;                                \
9088:624:                n -= next;                                                \
9089:625:                src += next;                                                \
9090:626:                dest += next;                                                \
9091:627:            }                                                                \
9092:628:        }
9093:629:
9094:630:int edit_move_backward_lots (WEdit * edit, long increment)
9095:631:{
9096:632:    int r, s, t;
9097:633:    char *p;
9098:634:
9099:635:    if (increment > edit->curs1)
9100:636:        increment = edit->curs1;
9101:637:    if (increment <= 0)
9102:638:        return -1;
9103:639:    push_action (edit, CURS_RIGHT_LOTS, increment);
9104:640:
9105:641:    t = r = EDIT_BUF_SIZE - (edit->curs2 & M_EDIT_BUF_SIZE);
9106:642:    if (r > increment)
9107:643:        r = increment;
9108:644:    s = edit->curs1 & M_EDIT_BUF_SIZE;
9109:645:
9110:646:    p = 0;
9111:647:    if (s > r) {
9112:648:        memqcpy (edit,
9113:649:                 edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE] + t - r,
9114:650:                 edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE] + s - r,
9115:651:                 r);
9116:652:    } else {
9117:653:        if (s) {
9118:654:            memqcpy (edit,
9119:655:                     edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE] + t -
9120:656:                     s, edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE], s);
9121:657:            p = edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE];
9122:658:            edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE] = 0;
9123:659:        }
9124:660:        memqcpy (edit,
9125:661:                 edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE] + t - r,
9126:662:                 edit->buffers1[(edit->curs1 >> S_EDIT_BUF_SIZE) - 1] +
9127:663:                 EDIT_BUF_SIZE - (r - s), r - s);
9128:664:    }
9129:665:    increment -= r;
9130:666:    edit->curs1 -= r;
9131:667:    edit->curs2 += r;
9132:668:    if (!(edit->curs2 & M_EDIT_BUF_SIZE)) {
9133:669:        if (p)
9134:670:            edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE] = p;
9135:671:        else
9136:672:            edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE] =
9137:673:                malloc (EDIT_BUF_SIZE);
9138:674:    } else {
9139:675:        if (p)
9140:676:            free (p);
9141:677:    }
9142:678:
9143:679:    s = edit->curs1 & M_EDIT_BUF_SIZE;
9144:680:    while (increment) {
9145:681:        p = 0;
9146:682:        r = EDIT_BUF_SIZE;
9147:683:        if (r > increment)
9148:684:            r = increment;
9149:685:        t = s;
9150:686:        if (r < t)
9151:687:            t = r;
9152:688:        memqcpy (edit,
9153:689:                 edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE] +
9154:690:                 EDIT_BUF_SIZE - t,
9155:691:                 edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE] + s - t,
9156:692:                 t);
9157:693:        if (r >= s) {
9158:694:            if (t) {
9159:695:                p = edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE];
9160:696:                edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE] = 0;
9161:697:            }
9162:698:            memqcpy (edit,
9163:699:                     edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE] +
9164:700:                     EDIT_BUF_SIZE - r,
9165:701:                     edit->buffers1[(edit->curs1 >> S_EDIT_BUF_SIZE) - 1] +
9166:702:                     EDIT_BUF_SIZE - (r - s), r - s);
9167:703:        }
9168:704:        increment -= r;
9169:705:        edit->curs1 -= r;
9170:706:        edit->curs2 += r;
9171:707:        if (!(edit->curs2 & M_EDIT_BUF_SIZE)) {
9172:708:            if (p)
9173:709:                edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE] = p;
9174:710:            else
9175:711:                edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE] =
9176:712:                    malloc (EDIT_BUF_SIZE);
9177:713:        } else {
9178:714:            if (p)
9179:715:                free (p);
9180:716:        }
9181:717:    }
9182:718:    return edit_get_byte (edit, edit->curs1);
9183:719:}
9184:720:
9185:721:#endif                          /* ! FAST_MOVE_CURSOR */
9186:722:
9187:723:/* moves the curser right or left: increment positive or negative respectively */
9188:724:int edit_cursor_move (WEdit * edit, long increment)
9189:725:{
9190:726:/* this is the same as a combination of two of the above routines, with only one push onto the undo stack */
9191:727:    int c;
9192:728:
9193:729:#ifdef FAST_MOVE_CURSOR
9194:730:    if (increment < -256) {
9195:731:        edit->force |= REDRAW_PAGE;
9196:732:        return edit_move_backward_lots (edit, -increment);
9197:733:    }
9198:734:#endif                          /* ! FAST_MOVE_CURSOR */
9199:735:
9200:736:    if (increment < 0) {
9201:737:        for (; increment < 0; increment++) {
9202:738:            if (!edit->curs1)
9203:739:                return -1;
9204:740:
9205:741:            push_action (edit, CURS_RIGHT);
9206:742:
9207:743:            c = edit_get_byte (edit, edit->curs1 - 1);
9208:744:            if (!((edit->curs2 + 1) & M_EDIT_BUF_SIZE))
9209:745:                edit->buffers2[(edit->curs2 + 1) >> S_EDIT_BUF_SIZE] =
9210:746:                    malloc (EDIT_BUF_SIZE);
9211:747:            edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE][EDIT_BUF_SIZE -
9212:748:                                                           (edit->
9213:749:                                                            curs2 &
9214:750:                                                            M_EDIT_BUF_SIZE)
9215:751:                                                           - 1] = c;
9216:752:            edit->curs2++;
9217:753:            c = edit->
9218:754:                buffers1[(edit->curs1 -
9219:755:                          1) >> S_EDIT_BUF_SIZE][(edit->curs1 -
9220:756:                                                  1) & M_EDIT_BUF_SIZE];
9221:757:            if (!((edit->curs1 - 1) & M_EDIT_BUF_SIZE)) {
9222:758:                free (edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE]);
9223:759:                edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE] = NULL;
9224:760:            }
9225:761:            edit->curs1--;
9226:762:            if (c == '\n') {
9227:763:                edit->curs_line--;
9228:764:                edit->force |= REDRAW_LINE_BELOW;
9229:765:            }
9230:766:        }
9231:767:
9232:768:        return c;
9233:769:    } else if (increment > 0) {
9234:770:        for (; increment > 0; increment--) {
9235:771:            if (!edit->curs2)
9236:772:                return -2;
9237:773:
9238:774:            push_action (edit, CURS_LEFT);
9239:775:
9240:776:            c = edit_get_byte (edit, edit->curs1);
9241:777:            if (!(edit->curs1 & M_EDIT_BUF_SIZE))
9242:778:                edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE] =
9243:779:                    malloc (EDIT_BUF_SIZE);
9244:780:            edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE][edit->
9245:781:                                                           curs1 &
9246:782:                                                           M_EDIT_BUF_SIZE]
9247:783:                = c;
9248:784:            edit->curs1++;
9249:785:            c = edit->
9250:786:                buffers2[(edit->curs2 -
9251:787:                          1) >> S_EDIT_BUF_SIZE][EDIT_BUF_SIZE -
9252:788:                                                 ((edit->curs2 -
9253:789:                                                   1) & M_EDIT_BUF_SIZE) -
9254:790:                                                 1];
9255:791:            if (!(edit->curs2 & M_EDIT_BUF_SIZE)) {
9256:792:                free (edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE]);
9257:793:                edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE] = 0;
9258:794:            }
9259:795:            edit->curs2--;
9260:796:            if (c == '\n') {
9261:797:                edit->curs_line++;
9262:798:                edit->force |= REDRAW_LINE_ABOVE;
9263:799:            }
9264:800:        }
9265:801:        return c;
9266:802:    } else
9267:803:        return -3;
9268:804:}
9269:805:
9270:806:/* These functions return positions relative to lines */
9271:807:
9272:808:/* returns index of last char on line + 1 */
9273:809:long edit_eol (WEdit * edit, long current)
9274:810:{
9275:811:    if (current < edit->last_byte) {
9276:812:        for (;; current++)
9277:813:            if (current == edit->last_byte
9278:814:                || edit_get_byte (edit, current) == '\n')
9279:815:                break;
9280:816:    } else
9281:817:        return edit->last_byte;
9282:818:    return current;
9283:819:}
9284:820:
9285:821:/* returns index of first char on line */
9286:822:long edit_bol (WEdit * edit, long current)
9287:823:{
9288:824:    if (current > 0) {
9289:825:        for (;; current--)
9290:826:            if (current == 0 || edit_get_byte (edit, current - 1) == '\n')
9291:827:                break;
9292:828:    } else
9293:829:        return 0;
9294:830:    return current;
9295:831:}
9296:832:
9297:833:
9298:834:int edit_count_lines (WEdit * edit, long current, int upto)
9299:835:{
9300:836:    int lines = 0;
9301:837:    if (upto > edit->last_byte)
9302:838:        upto = edit->last_byte;
9303:839:    if (current < 0)
9304:840:        current = 0;
9305:841:    while (current < upto)
9306:842:        if (edit_get_byte (edit, current++) == '\n')
9307:843:            lines++;
9308:844:    return lines;
9309:845:}
9310:846:
9311:847:
9312:848:/* If lines is zero this returns the count of lines from current to upto. */
9313:849:/* If upto is zero returns index of lines forward current. */
9314:850:long edit_move_forward (WEdit * edit, long current, int lines, long upto)
9315:851:{
9316:852:    if (upto) {
9317:853:        return edit_count_lines (edit, current, upto);
9318:854:    } else {
9319:855:        int next;
9320:856:        if (lines < 0)
9321:857:            lines = 0;
9322:858:        while (lines--) {
9323:859:            next = edit_eol (edit, current) + 1;
9324:860:            if (next > edit->last_byte)
9325:861:                break;
9326:862:            else
9327:863:                current = next;
9328:864:        }
9329:865:        return current;
9330:866:    }
9331:867:}
9332:868:
9333:869:
9334:870:/* Returns offset of 'lines' lines up from current */
9335:871:long edit_move_backward (WEdit * edit, long current, int lines)
9336:872:{
9337:873:    if (lines < 0)
9338:874:        lines = 0;
9339:875:    current = edit_bol (edit, current);
9340:876:    while ((lines--) && current != 0)
9341:877:        current = edit_bol (edit, current - 1);
9342:878:    return current;
9343:879:}
9344:880:
9345:881:/* If cols is zero this returns the count of columns from current to upto. */
9346:882:/* If upto is zero returns index of cols across from current. */
9347:883:float edit_move_forward3 (WEdit * edit, long current, int cols, long upto)
9348:884:{
9349:885:    long p, q;
9350:886:    int col = 0;
9351:887:
9352:888:    if (upto) {
9353:889:        q = upto;
9354:890:        cols = -10;
9355:891:    } else
9356:892:        q = edit->last_byte + 2;
9357:893:
9358:894:    for (col = 0, p = current; p < q; p++) {
9359:895:        int c;
9360:896:        if (cols != -10) {
9361:897:            if (col == cols)
9362:898:                return p;
9363:899:            if (col > cols)
9364:900:                return p - 1;
9365:901:        }
9366:902:        c = edit_get_byte (edit, p);
9367:903:
9368:904:#ifdef MIDNIGHT
9369:905:        if (c == '\r')
9370:906:            continue;
9371:907:        else
9372:908:#endif
9373:909:        if (c == '\t')
9374:910:            col += TAB_SIZE - col % TAB_SIZE;
9375:911:        else
9376:912:            col++;
9377:913:        /*if(edit->nroff ... */
9378:914:        if (c == '\n') {
9379:915:            if (upto)
9380:916:                return col;
9381:917:            else
9382:918:                return p;
9383:919:        }
9384:920:    }
9385:921:    return (float) col;
9386:922:}
9387:923:
9388:924:
9389:925:/* returns the current column position of the cursor */
9390:926:int edit_get_col (WEdit * edit)
9391:927:{
9392:928:    return edit_move_forward3 (edit, edit_bol (edit, edit->curs1), 0,
9393:929:                               edit->curs1);
9394:930:}
9395:931:
9396:932:
9397:933:/* Scrolling functions */
9398:934:
9399:935:void update_curs_row (WEdit * edit)
9400:936:{
9401:937:    edit->curs_row = edit->curs_line - edit->start_line;
9402:938:}
9403:939:
9404:940:void update_curs_col (WEdit * edit)
9405:941:{
9406:942:    edit->curs_col =
9407:943:        edit_move_forward3 (edit, edit_bol (edit, edit->curs1), 0,
9408:944:                            edit->curs1);
9409:945:}
9410:946:
9411:947:/*moves the display start position up by i lines */
9412:948:void edit_scroll_upward (WEdit * edit, unsigned long i)
9413:949:{
9414:950:    int lines_above = edit->start_line;
9415:951:    if (i > lines_above)
9416:952:        i = lines_above;
9417:953:    if (i) {
9418:954:        edit->start_line -= i;
9419:955:        edit->start_display =
9420:956:            edit_move_backward (edit, edit->start_display, i);
9421:957:        edit->force |= REDRAW_PAGE;
9422:958:        edit->force &= (0xff - REDRAW_CHAR_ONLY);
9423:959:    }
9424:960:    update_curs_row (edit);
9425:961:}
9426:962:
9427:963:
9428:964:/* returns 1 if could scroll, 0 otherwise */
9429:965:void edit_scroll_downward (WEdit * edit, int i)
9430:966:{
9431:967:    int lines_below;
9432:968:    lines_below =
9433:969:        edit->total_lines - edit->start_line - (edit->num_widget_lines -
9434:970:                                                1);
9435:971:    if (lines_below > 0) {
9436:972:        if (i > lines_below)
9437:973:            i = lines_below;
9438:974:        edit->start_line += i;
9439:975:        edit->start_display =
9440:976:            edit_move_forward (edit, edit->start_display, i, 0);
9441:977:        edit->force |= REDRAW_PAGE;
9442:978:        edit->force &= (0xff - REDRAW_CHAR_ONLY);
9443:979:    }
9444:980:    update_curs_row (edit);
9445:981:}
9446:982:
9447:983:
9448:984:void edit_scroll_right (WEdit * edit, int i)
9449:985:{
9450:986:    edit->force |= REDRAW_PAGE;
9451:987:    edit->force &= (0xff - REDRAW_CHAR_ONLY);
9452:988:    edit->start_col -= i;
9453:989:}
9454:990:
9455:991:
9456:992:void edit_scroll_left (WEdit * edit, int i)
9457:993:{
9458:994:    if (edit->start_col) {
9459:995:        edit->start_col += i;
9460:996:        if (edit->start_col > 0)
9461:997:            edit->start_col = 0;
9462:998:        edit->force |= REDRAW_PAGE;
9463:999:        edit->force &= (0xff - REDRAW_CHAR_ONLY);
9464:1000:    }
9465:1001:}
9466:1002:
9467:1003:/* high level cursor movement commands */
9468:1004:
9469:1005:static int is_in_indent (WEdit * edit)
9470:1006:{
9471:1007:    long p = edit_bol (edit, edit->curs1);
9472:1008:    while (p < edit->curs1)
9473:1009:        if (!strchr (" \t", edit_get_byte (edit, p++)))
9474:1010:            return 0;
9475:1011:    return 1;
9476:1012:}
9477:1013:
9478:1014:static void edit_move_to_prev_col (WEdit * edit, long p)
9479:1015:{
9480:1016:    edit_cursor_move (edit,
9481:1017:                      (int) edit_move_forward3 (edit, p, edit->prev_col,
9482:1018:                                                0) - edit->curs1);
9483:1019:
9484:1020:    if (is_in_indent (edit) && option_fake_half_tabs) {
9485:1021:        update_curs_col (edit);
9486:1022:        if (edit->curs_col % HALF_TAB_SIZE) {
9487:1023:            edit->curs_col -= (edit->curs_col % HALF_TAB_SIZE);
9488:1024:            p = edit_bol (edit, edit->curs1);
9489:1025:            edit_cursor_move (edit,
9490:1026:                              (int) edit_move_forward3 (edit, p,
9491:1027:                                                        edit->curs_col,
9492:1028:                                                        0) - edit->curs1);
9493:1029:        }
9494:1030:    }
9495:1031:}
9496:1032:
9497:1033:
9498:1034:/* move i lines */
9499:1035:static void edit_move_up (WEdit * edit, unsigned long i, int scroll)
9500:1036:{
9501:1037:    long p, l = edit->curs_line;
9502:1038:
9503:1039:    if (i > l)
9504:1040:        i = l;
9505:1041:    if (i) {
9506:1042:        if (i > 1)
9507:1043:            edit->force |= REDRAW_PAGE;
9508:1044:        if (scroll)
9509:1045:            edit_scroll_upward (edit, i);
9510:1046:
9511:1047:        p = edit_bol (edit, edit->curs1);
9512:1048:        edit_cursor_move (edit,
9513:1049:                          (p =
9514:1050:                           edit_move_backward (edit, p, i)) - edit->curs1);
9515:1051:        edit_move_to_prev_col (edit, p);
9516:1052:
9517:1053:        edit->search_start = edit->curs1;
9518:1054:        edit->found_len = 0;
9519:1055:    }
9520:1056:}
9521:1057:
9522:1058:/* move i lines */
9523:1059:static void edit_move_down (WEdit * edit, int i, int scroll)
9524:1060:{
9525:1061:    long p, l = edit->total_lines - edit->curs_line;
9526:1062:
9527:1063:    if (i > l)
9528:1064:        i = l;
9529:1065:    if (i) {
9530:1066:        if (i > 1)
9531:1067:            edit->force |= REDRAW_PAGE;
9532:1068:        if (scroll)
9533:1069:            edit_scroll_downward (edit, i);
9534:1070:        p = edit_bol (edit, edit->curs1);
9535:1071:        edit_cursor_move (edit,
9536:1072:                          (p =
9537:1073:                           edit_move_forward (edit, p, i,
9538:1074:                                              0)) - edit->curs1);
9539:1075:        edit_move_to_prev_col (edit, p);
9540:1076:
9541:1077:        edit->search_start = edit->curs1;
9542:1078:        edit->found_len = 0;
9543:1079:    }
9544:1080:}
9545:1081:
9546:1082:static void edit_begin_page (WEdit * edit)
9547:1083:{
9548:1084:    update_curs_row (edit);
9549:1085:    edit_move_up (edit, edit->curs_row, 0);
9550:1086:}
9551:1087:
9552:1088:static void edit_end_page (WEdit * edit)
9553:1089:{
9554:1090:    update_curs_row (edit);
9555:1091:    edit_move_down (edit, edit->num_widget_lines - edit->curs_row - 1, 0);
9556:1092:}
9557:1093:
9558:1094:
9559:1095:/* goto beginning of text */
9560:1096:static void edit_move_to_top (WEdit * edit)
9561:1097:{
9562:1098:    if (edit->curs_line) {
9563:1099:        edit_cursor_move (edit, -edit->curs1);
9564:1100:        edit_move_to_prev_col (edit, 0);
9565:1101:        edit->force |= REDRAW_PAGE;
9566:1102:        edit->search_start = 0;
9567:1103:        update_curs_row (edit);
9568:1104:    }
9569:1105:}
9570:1106:
9571:1107:
9572:1108:/* goto end of text */
9573:1109:static void edit_move_to_bottom (WEdit * edit)
9574:1110:{
9575:1111:    if (edit->curs_line < edit->total_lines) {
9576:1112:        edit_cursor_move (edit, edit->curs2);
9577:1113:        edit->start_display = edit->last_byte;
9578:1114:        edit->start_line = edit->total_lines;
9579:1115:        update_curs_row (edit);
9580:1116:        edit_scroll_upward (edit, edit->num_widget_lines - 1);
9581:1117:        edit->force |= REDRAW_PAGE;
9582:1118:    }
9583:1119:}
9584:1120:
9585:1121:/* goto beginning of line */
9586:1122:static void edit_cursor_to_bol (WEdit * edit)
9587:1123:{
9588:1124:    edit_cursor_move (edit, edit_bol (edit, edit->curs1) - edit->curs1);
9589:1125:    edit->search_start = edit->curs1;
9590:1126:    edit->prev_col = edit_get_col (edit);
9591:1127:}
9592:1128:
9593:1129:/* goto end of line */
9594:1130:static void edit_cursor_to_eol (WEdit * edit)
9595:1131:{
9596:1132:    edit_cursor_move (edit, edit_eol (edit, edit->curs1) - edit->curs1);
9597:1133:    edit->search_start = edit->curs1;
9598:1134:    edit->prev_col = edit_get_col (edit);
9599:1135:}
9600:1136:
9601:1137:/* move cursor to line 'line' */
9602:1138:void edit_move_to_line (WEdit * e, long line)
9603:1139:{
9604:1140:    if (line < e->curs_line)
9605:1141:        edit_move_up (e, e->curs_line - line, 0);
9606:1142:    else
9607:1143:        edit_move_down (e, line - e->curs_line, 0);
9608:1144:    edit_scroll_screen_over_cursor (e);
9609:1145:}
9610:1146:
9611:1147:/* scroll window so that first visible line is 'line' */
9612:1148:void edit_move_display (WEdit * e, long line)
9613:1149:{
9614:1150:    if (line < e->start_line)
9615:1151:        edit_scroll_upward (e, e->start_line - line);
9616:1152:    else
9617:1153:        edit_scroll_downward (e, line - e->start_line);
9618:1154:}
9619:1155:
9620:1156:/* save markers onto undo stack */
9621:1157:void edit_push_markers (WEdit * edit)
9622:1158:{
9623:1159:    push_action (edit, MARK_1 + edit->mark1);
9624:1160:    push_action (edit, MARK_2 + edit->mark2);
9625:1161:}
9626:1162:
9627:1163:void edit_set_markers (WEdit * edit, long m1, long m2)
9628:1164:{
9629:1165:    edit->mark1 = m1;
9630:1166:    edit->mark2 = m2;
9631:1167:}
9632:1168:
9633:1169:
9634:1170:/* highlight marker toggle */
9635:1171:void edit_mark_cmd (WEdit * edit, int unmark)
9636:1172:{
9637:1173:    edit_push_markers (edit);
9638:1174:    if (unmark) {
9639:1175:        edit_set_markers (edit, 0, 0);
9640:1176:        edit->force |= REDRAW_PAGE;
9641:1177:    } else {
9642:1178:        if (edit->mark2 >= 0) {
9643:1179:            edit_set_markers (edit, edit->curs1, -1);
9644:1180:            edit->force |= REDRAW_PAGE;
9645:1181:        } else
9646:1182:            edit_set_markers (edit, edit->mark1, edit->curs1);
9647:1183:    }
9648:1184:}
9649:1185:
9650:1186:int my_type_of (int c)
9651:1187:{
9652:1188:    if (c < ' ' && c > 0)
9653:1189:        return 1;
9654:1190:    if (strchr ("+_-.", c))
9655:1191:        if (strchr (option_whole_chars_move, c))
9656:1192:            return 3;
9657:1193:    if (!strcasechr (option_whole_chars_move, c))
9658:1194:        return 2;
9659:1195:    if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z')
9660:1196:        || (c >= 'A' && c <= 'Z') || c >= 160)
9661:1197:        return 3;
9662:1198:    return c;
9663:1199:}
9664:1200:
9665:1201:void edit_left_word_move (WEdit * edit)
9666:1202:{
9667:1203:    do {
9668:1204:        edit_cursor_move (edit, -1);
9669:1205:        if (!edit->curs1)
9670:1206:            break;
9671:1207:    } while (my_type_of (edit_get_byte (edit, edit->curs1))
9672:1208:             == my_type_of (edit_get_byte (edit, edit->curs1 - 1)));
9673:1209:}
9674:1210:
9675:1211:static void edit_left_word_move_cmd (WEdit * edit)
9676:1212:{
9677:1213:    edit_left_word_move (edit);
9678:1214:    if (strchr (option_whole_chars_move, ' '))
9679:1215:        if (strchr ("\t ", edit_get_byte (edit, edit->curs1)))
9680:1216:            edit_left_word_move (edit);
9681:1217:    edit->force |= REDRAW_PAGE;
9682:1218:}
9683:1219:
9684:1220:void edit_right_word_move (WEdit * edit)
9685:1221:{
9686:1222:    do {
9687:1223:        edit_cursor_move (edit, 1);
9688:1224:        if (edit->curs1 >= edit->last_byte)
9689:1225:            break;
9690:1226:    } while (my_type_of (edit_get_byte (edit, edit->curs1 - 1))
9691:1227:             == my_type_of (edit_get_byte (edit, edit->curs1)));
9692:1228:}
9693:1229:
9694:1230:static void edit_right_word_move_cmd (WEdit * edit)
9695:1231:{
9696:1232:    edit_right_word_move (edit);
9697:1233:    if (strchr (option_whole_chars_move, ' '))
9698:1234:        if (strchr ("\t ", edit_get_byte (edit, edit->curs1)))
9699:1235:            edit_right_word_move (edit);
9700:1236:    edit->force |= REDRAW_PAGE;
9701:1237:}
9702:1238:
9703:1239:
9704:1240:static void edit_right_delete_word (WEdit * edit)
9705:1241:{
9706:1242:    int c;
9707:1243:    do {
9708:1244:        c = edit_delete (edit);
9709:1245:    } while (my_type_of (c) ==
9710:1246:             my_type_of (edit_get_byte (edit, edit->curs1)));
9711:1247:}
9712:1248:
9713:1249:static void edit_left_delete_word (WEdit * edit)
9714:1250:{
9715:1251:    int c;
9716:1252:    do {
9717:1253:        c = edit_backspace (edit);
9718:1254:    } while (my_type_of (c) ==
9719:1255:             my_type_of (edit_get_byte (edit, edit->curs1 - 1)));
9720:1256:}
9721:1257:
9722:1258:
9723:1259:/*
9724:1260:   the start column position is not recorded, and hence does not
9725:1261:   undo as it happed. But who would notice.
9726:1262: */
9727:1263:void edit_do_undo (WEdit * edit)
9728:1264:{
9729:1265:    long ac;
9730:1266:    long count = 0;
9731:1267:
9732:1268:    push_action_disabled = 1;   /* don't record undo's onto undo stack! */
9733:1269:
9734:1270:    while ((ac = pop_action (edit)) < KEY_PRESS) {
9735:1271:        switch (ac) {
9736:1272:        case STACK_BOTTOM:
9737:1273:            goto done_undo;
9738:1274:        case CURS_RIGHT:
9739:1275:            edit_cursor_move (edit, 1);
9740:1276:            break;
9741:1277:        case CURS_LEFT:
9742:1278:            edit_cursor_move (edit, -1);
9743:1279:            break;
9744:1280:        case BACKSPACE:
9745:1281:            edit_backspace (edit);
9746:1282:            break;
9747:1283:        case DELETE:
9748:1284:            edit_delete (edit);
9749:1285:            break;
9750:1286:        }
9751:1287:        if (ac >= 256 && ac < 512)
9752:1288:            edit_insert_ahead (edit, ac - 256);
9753:1289:        if (ac >= 0 && ac < 256)
9754:1290:            edit_insert (edit, ac);
9755:1291:
9756:1292:        if (ac >= MARK_1 - 2 && ac < MARK_2 - 2) {
9757:1293:            edit->mark1 = ac - MARK_1;
9758:1294:        } else if (ac >= MARK_2 - 2 && ac < KEY_PRESS) {
9759:1295:            edit->mark2 = ac - MARK_2;
9760:1296:        }
9761:1297:        if (count++)
9762:1298:            edit->force |= REDRAW_PAGE; /* more than one pop usually means something big */
9763:1299:    }
9764:1300:
9765:1301:    if (edit->start_display > ac - KEY_PRESS) {
9766:1302:        edit->start_line -=
9767:1303:            edit_count_lines (edit, ac - KEY_PRESS, edit->start_display);
9768:1304:        edit->force |= REDRAW_PAGE;
9769:1305:    } else if (edit->start_display < ac - KEY_PRESS) {
9770:1306:        edit->start_line +=
9771:1307:            edit_count_lines (edit, edit->start_display, ac - KEY_PRESS);
9772:1308:        edit->force |= REDRAW_PAGE;
9773:1309:    }
9774:1310:    edit->start_display = ac - KEY_PRESS; /* see push and pop above */
9775:1311:    update_curs_row (edit);
9776:1312:
9777:1313:  done_undo:;
9778:1314:    push_action_disabled = 0;
9779:1315:}
9780:1316:
9781:1317:static void edit_delete_to_line_end (WEdit * edit)
9782:1318:{
9783:1319:    int c;
9784:1320:    do {
9785:1321:        c = edit_delete (edit);
9786:1322:    } while (c != '\n' && c);
9787:1323:    edit_insert_ahead (edit, '\n');
9788:1324:}
9789:1325:
9790:1326:static void edit_delete_line (WEdit * edit)
9791:1327:{
9792:1328:    int c;
9793:1329:    do {
9794:1330:        c = edit_delete (edit);
9795:1331:    } while (c != '\n' && c);
9796:1332:    do {
9797:1333:        c = edit_backspace (edit);
9798:1334:    } while (c != '\n' && c);
9799:1335:    if (c)
9800:1336:        edit_insert (edit, '\n');
9801:1337:}
9802:1338:
9803:1339:static void insert_spaces_tab (WEdit * edit)
9804:1340:{
9805:1341:    int i = option_tab_spacing;
9806:1342:    while (i--)
9807:1343:        edit_insert (edit, ' ');
9808:1344:}
9809:1345:
9810:1346:static int is_aligned_on_a_tab (WEdit * edit)
9811:1347:{
9812:1348:    update_curs_col (edit);
9813:1349:    if ((edit->curs_col % TAB_SIZE)
9814:1350:        && edit->curs_col % TAB_SIZE != HALF_TAB_SIZE)
9815:1351:        return 0;               /* not alligned on a tab */
9816:1352:    return 1;
9817:1353:}
9818:1354:
9819:1355:static int right_of_four_spaces (WEdit * edit)
9820:1356:{
9821:1357:    int i, ch = 0;
9822:1358:    for (i = 1; i <= HALF_TAB_SIZE; i++)
9823:1359:        ch |= edit_get_byte (edit, edit->curs1 - i);
9824:1360:    if (ch == ' ')
9825:1361:        return is_aligned_on_a_tab (edit);
9826:1362:    return 0;
9827:1363:}
9828:1364:
9829:1365:static int left_of_four_spaces (WEdit * edit)
9830:1366:{
9831:1367:    int i, ch = 0;
9832:1368:    for (i = 0; i < HALF_TAB_SIZE; i++)
9833:1369:        ch |= edit_get_byte (edit, edit->curs1 + i);
9834:1370:    if (ch == ' ')
9835:1371:        return is_aligned_on_a_tab (edit);
9836:1372:    return 0;
9837:1373:}
9838:1374:
9839:1375:static void edit_auto_indent (WEdit * edit, int always)
9840:1376:{
9841:1377:    long p, q;
9842:1378:    int indent;
9843:1379:
9844:1380:    p = edit->curs1;
9845:1381:    while (strchr ("\t\n\r ", edit_get_byte (edit, p - 1)) && p > 0) /* move back/up to a line with text */
9846:1382:        p--;
9847:1383:
9848:1384:    p = q = edit_bol (edit, p);
9849:1385:
9850:1386:    while (strchr ("\t ", edit_get_byte (edit, q)) && q < edit->last_byte - 1) /* move to the end of the leading whitespace of the line */
9851:1387:        q++;
9852:1388:
9853:1389:    indent = (int) edit_move_forward3 (edit, p, 0, q); /* count the number of columns of indentation */
9854:1390:
9855:1391:    /* insert that amount: */
9856:1392:    if (!option_fill_tabs_with_spaces) {
9857:1393:        while (indent >= TAB_SIZE) {
9858:1394:            edit_insert (edit, '\t');
9859:1395:            indent -= TAB_SIZE;
9860:1396:        }
9861:1397:    }
9862:1398:    while (indent--)
9863:1399:        edit_insert (edit, ' ');
9864:1400:}
9865:1401:
9866:1402:/* ***
9867:1403:   TODO: how would you like this to respond to tabs?
9868:1404:   The following works for me. Any suggesions.
9869:1405: */
9870:1406:static void edit_tab_cmd (WEdit * edit)
9871:1407:{
9872:1408:    int i;
9873:1409:
9874:1410:    if (option_fake_half_tabs) {
9875:1411:        if (is_in_indent (edit)) {
9876:1412:            /*insert a half tab (usually four spaces) unless there is a
9877:1413:               half tab already behind, then delete it and insert a 
9878:1414:               full tab. */
9879:1415:            if (right_of_four_spaces (edit)) {
9880:1416:                for (i = 1; i <= HALF_TAB_SIZE; i++)
9881:1417:                    edit_backspace (edit);
9882:1418:                if (option_fill_tabs_with_spaces) {
9883:1419:                    insert_spaces_tab (edit);
9884:1420:                } else {
9885:1421:                    edit_insert (edit, '\t');
9886:1422:                }
9887:1423:            } else {
9888:1424:                for (i = 1; i <= HALF_TAB_SIZE; i++)
9889:1425:                    edit_insert (edit, ' ');
9890:1426:            }
9891:1427:            return;
9892:1428:        }
9893:1429:    }
9894:1430:    if (option_fill_tabs_with_spaces) {
9895:1431:        insert_spaces_tab (edit);
9896:1432:    } else {
9897:1433:        edit_insert (edit, '\t');
9898:1434:    }
9899:1435:    return;
9900:1436:}
9901:1437:
9902:1438:
9903:1439:#include "editcmddef.h"
9904:1440:void edit_execute_macro (WEdit * edit, struct macro macro[], int n);
9905:1441:
9906:1442:/* either command or char_for_insertion must be passed as -1 */
9907:1443:int edit_execute_command (WEdit * edit, int command,
9908:1444:                          int char_for_insertion);
9909:1445:
9910:1446:int edit_translate_key (WEdit * edit, unsigned int x_keycode, long x_key,
9911:1447:                        int x_state, int *cmd, int *ch)
9912:1448:{
9913:1449:    int command = -1;
9914:1450:    int char_for_insertion = -1;
9915:1451:
9916:1452:#ifdef MIDNIGHT
9917:1453:#include "edit/edit_key_translator.c"
9918:1454:#else
9919:1455:#include "widget/edit_key_translator.c"
9920:1456:#endif
9921:1457:
9922:1458:    *cmd = command;
9923:1459:    *ch = char_for_insertion;
9924:1460:
9925:1461:    if ((command == -1 || command == 0) && char_for_insertion == -1) /* unchanged, key has no function here */
9926:1462:        return 0;
9927:1463:    return 1;
9928:1464:}
9929:1465:
9930:1466:void push_key_press (WEdit * edit)
9931:1467:{
9932:1468:    push_action (edit, KEY_PRESS + edit->start_display);
9933:1469:    if (edit->mark2 == -1)
9934:1470:        push_action (edit, MARK_1 + edit->mark1);
9935:1471:}
9936:1472:
9937:1473:
9938:1474:/* this executes a command as though the user initiated it through a key press. */
9939:1475:/* callback with WIDGET_KEY as a message calls this after translating the key
9940:1476:        press */
9941:1477:/* this can be used to pass any command to the editor. Same as sendevent with
9942:1478:        msg = WIDGET_COMMAND and par = command  except the screen wouldn't update */
9943:1479:/* one of command or char_for_insertion must be passed as -1 */
9944:1480:/* commands are executed, and char_for_insertion is inserted at the cursor */
9945:1481:/* returns 0 if the command is a macro that was not found, 1 otherwise */
9946:1482:int edit_execute_key_command (WEdit * edit, int command,
9947:1483:                              int char_for_insertion)
9948:1484:{
9949:1485:    int r;
9950:1486:    if (command == CK_Begin_Record_Macro) {
9951:1487:        edit->macro_i = 0;
9952:1488:        return command;
9953:1489:    }
9954:1490:
9955:1491:    if (command == CK_End_Record_Macro && edit->macro_i != -1) {
9956:1492:        edit->force |= REDRAW_COMPLETELY;
9957:1493:        edit_save_macro_cmd (edit, edit->macro, edit->macro_i);
9958:1494:        edit->macro_i = -1;
9959:1495:        return command;
9960:1496:    }
9961:1497:
9962:1498:    if (edit->macro_i >= 0 && edit->macro_i < MAX_MACRO_LENGTH - 1) {
9963:1499:        edit->macro[edit->macro_i].command = command;
9964:1500:        edit->macro[edit->macro_i++].ch = char_for_insertion;
9965:1501:    }
9966:1502:
9967:1503:/* record the beginning of a set of editing actions initiated by a key press */
9968:1504:    if (command != CK_Undo)
9969:1505:        push_key_press (edit);
9970:1506:
9971:1507:    r = edit_execute_command (edit, command, char_for_insertion);
9972:1508:
9973:1509:#if WORD_WRAP
9974:1510:    if (word_wrap_line_length)
9975:1511:        if (char_for_insertion > 0 || command == CK_Return
9976:1512:            || command == CK_Tab || command == CK_Delete
9977:1513:            || command == CK_BackSpace)
9978:1514:            edit_word_wrap (edit);
9979:1515:#endif
9980:1516:
9981:1517:    return r;
9982:1518:}
9983:1519:
9984:1520:
9985:1521:static const char *shell_cmd[] = SHELL_COMMANDS_i
9986:1522:/* 
9987:1523:   This executes a command at a lower level than macro recording.
9988:1524:   It also does not push a key_press onto the undo stack. This means
9989:1525:   that if it is called many times, a single undo command will undo
9990:1526:   all of them. It also does not check for the Undo command.
9991:1527:   Returns 0 if the command is a macro that was not found, 1
9992:1528:   otherwise.
9993:1529: */
9994:1530:    int edit_execute_command (WEdit * edit, int command,
9995:1531:                              int char_for_insertion) {
9996:1532:    int result = 1;
9997:1533:    if (edit->found_len)
9998:1534:/* the next key press will unhighlight the found string, so update whole page */
9999:1535:        edit->force |= REDRAW_PAGE;
10000:1536:
10001:1537:    if (command / 100 == 6) {   /* a highlight command like shift-arrow */
10002:1538:        if (!edit->highlight
10003:1539:            || (edit->mark2 != -1 && edit->mark1 != edit->mark2)) {
10004:1540:            edit_mark_cmd (edit, 1); /* clear */
10005:1541:            edit_mark_cmd (edit, 0); /* marking on */
10006:1542:        }
10007:1543:        edit->highlight = 1;
10008:1544:    } else {                    /* any other command */
10009:1545:        if (edit->highlight) {
10010:1546:            edit->highlight = 0;
10011:1547:            edit_mark_cmd (edit, 0); /* clear */
10012:1548:        }
10013:1549:        edit->highlight = 0;
10014:1550:    }
10015:1551:
10016:1552:/* first check for undo */
10017:1553:    if (command == CK_Undo) {
10018:1554:        edit_do_undo (edit);
10019:1555:        edit->found_len = 0;
10020:1556:        edit->prev_col = edit_get_col (edit);
10021:1557:        edit->search_start = edit->curs1;
10022:1558:        return 1;
10023:1559:    }
10024:1560:/* An ordinary key press */
10025:1561:    if (char_for_insertion >= 0) {
10026:1562:        if (edit->overwrite) {
10027:1563:            if (edit_get_byte (edit, edit->curs1) != '\n')
10028:1564:                edit_delete (edit);
10029:1565:        }
10030:1566:        edit_insert (edit, char_for_insertion);
10031:1567:        edit->found_len = 0;
10032:1568:        edit->prev_col = edit_get_col (edit);
10033:1569:        edit->search_start = edit->curs1;
10034:1570:        return 1;
10035:1571:    }
10036:1572:    switch (command) {
10037:1573:    case CK_Begin_Page:
10038:1574:    case CK_End_Page:
10039:1575:    case CK_Begin_Page_Highlight:
10040:1576:    case CK_End_Page_Highlight:
10041:1577:    case CK_Word_Left:
10042:1578:    case CK_Word_Right:
10043:1579:    case CK_Up:
10044:1580:    case CK_Down:
10045:1581:    case CK_Word_Left_Highlight:
10046:1582:    case CK_Word_Right_Highlight:
10047:1583:    case CK_Up_Highlight:
10048:1584:    case CK_Down_Highlight:
10049:1585:        if (edit->mark2 == -1)
10050:1586:            break;              /*marking is following the cursor: may need to highlight a whole line */
10051:1587:    case CK_Left:
10052:1588:    case CK_Right:
10053:1589:    case CK_Left_Highlight:
10054:1590:    case CK_Right_Highlight:
10055:1591:        edit->force |= REDRAW_CHAR_ONLY;
10056:1592:    }
10057:1593:
10058:1594:/* basic cursor key commands */
10059:1595:    switch (command) {
10060:1596:    case CK_BackSpace:
10061:1597:        if (option_backspace_through_tabs && is_in_indent (edit)) {
10062:1598:            while (edit_get_byte (edit, edit->curs1 - 1) != '\n'
10063:1599:                   && edit->curs1 > 0)
10064:1600:                edit_backspace (edit);
10065:1601:            break;
10066:1602:        } else {
10067:1603:            if (option_fake_half_tabs) {
10068:1604:                int i;
10069:1605:                if (is_in_indent (edit) && right_of_four_spaces (edit)) {
10070:1606:                    for (i = 0; i < HALF_TAB_SIZE; i++)
10071:1607:                        edit_backspace (edit);
10072:1608:                    break;
10073:1609:                }
10074:1610:            }
10075:1611:        }
10076:1612:        edit_backspace (edit);
10077:1613:        break;
10078:1614:    case CK_Delete:
10079:1615:        if (option_fake_half_tabs) {
10080:1616:            int i;
10081:1617:            if (is_in_indent (edit) && left_of_four_spaces (edit)) {
10082:1618:                for (i = 1; i <= HALF_TAB_SIZE; i++)
10083:1619:                    edit_delete (edit);
10084:1620:                break;
10085:1621:            }
10086:1622:        }
10087:1623:        edit_delete (edit);
10088:1624:        break;
10089:1625:    case CK_Delete_Word_Left:
10090:1626:        edit_left_delete_word (edit);
10091:1627:        break;
10092:1628:    case CK_Delete_Word_Right:
10093:1629:        edit_right_delete_word (edit);
10094:1630:        break;
10095:1631:    case CK_Delete_Line:
10096:1632:        edit_delete_line (edit);
10097:1633:        break;
10098:1634:    case CK_Delete_To_Line_End:
10099:1635:        edit_delete_to_line_end (edit);
10100:1636:        break;
10101:1637:    case CK_Return:
10102:1638:        edit_insert (edit, '\n');
10103:1639:        if (option_return_does_auto_indent)
10104:1640:            edit_auto_indent (edit, 0);
10105:1641:        break;
10106:1642:    case CK_Enter:
10107:1643:        edit_insert (edit, '\n');
10108:1644:        break;
10109:1645:
10110:1646:    case CK_Page_Up:
10111:1647:    case CK_Page_Up_Highlight:
10112:1648:        edit_move_up (edit, edit->num_widget_lines - 1, 1);
10113:1649:        break;
10114:1650:    case CK_Page_Down:
10115:1651:    case CK_Page_Down_Highlight:
10116:1652:        edit_move_down (edit, edit->num_widget_lines - 1, 1);
10117:1653:        break;
10118:1654:    case CK_Left:
10119:1655:    case CK_Left_Highlight:
10120:1656:        if (option_fake_half_tabs) {
10121:1657:            if (is_in_indent (edit) && right_of_four_spaces (edit)) {
10122:1658:                edit_cursor_move (edit, -HALF_TAB_SIZE);
10123:1659:                edit->force &= (0xFF - REDRAW_CHAR_ONLY);
10124:1660:                break;
10125:1661:            }
10126:1662:        }
10127:1663:        edit_cursor_move (edit, -1);
10128:1664:        break;
10129:1665:    case CK_Right:
10130:1666:    case CK_Right_Highlight:
10131:1667:        if (option_fake_half_tabs) {
10132:1668:            if (is_in_indent (edit) && left_of_four_spaces (edit)) {
10133:1669:                edit_cursor_move (edit, HALF_TAB_SIZE);
10134:1670:                edit->force &= (0xFF - REDRAW_CHAR_ONLY);
10135:1671:                break;
10136:1672:            }
10137:1673:        }
10138:1674:        edit_cursor_move (edit, 1);
10139:1675:        break;
10140:1676:    case CK_Begin_Page:
10141:1677:    case CK_Begin_Page_Highlight:
10142:1678:        edit_begin_page (edit);
10143:1679:        break;
10144:1680:    case CK_End_Page:
10145:1681:    case CK_End_Page_Highlight:
10146:1682:        edit_end_page (edit);
10147:1683:        break;
10148:1684:    case CK_Word_Left:
10149:1685:    case CK_Word_Left_Highlight:
10150:1686:        edit_left_word_move_cmd (edit);
10151:1687:        break;
10152:1688:    case CK_Word_Right:
10153:1689:    case CK_Word_Right_Highlight:
10154:1690:        edit_right_word_move_cmd (edit);
10155:1691:        break;
10156:1692:    case CK_Up:
10157:1693:    case CK_Up_Highlight:
10158:1694:        edit_move_up (edit, 1, 0);
10159:1695:        break;
10160:1696:    case CK_Down:
10161:1697:    case CK_Down_Highlight:
10162:1698:        edit_move_down (edit, 1, 0);
10163:1699:        break;
10164:1700:    case CK_Scroll_Up:
10165:1701:    case CK_Scroll_Up_Highlight:
10166:1702:        edit_move_up (edit, 1, 1);
10167:1703:        break;
10168:1704:    case CK_Scroll_Down:
10169:1705:    case CK_Scroll_Down_Highlight:
10170:1706:        edit_move_down (edit, 1, 1);
10171:1707:        break;
10172:1708:    case CK_Home:
10173:1709:    case CK_Home_Highlight:
10174:1710:        edit_cursor_to_bol (edit);
10175:1711:        break;
10176:1712:    case CK_End:
10177:1713:    case CK_End_Highlight:
10178:1714:        edit_cursor_to_eol (edit);
10179:1715:        break;
10180:1716:
10181:1717:    case CK_Tab:
10182:1718:        edit_tab_cmd (edit);
10183:1719:        break;
10184:1720:
10185:1721:    case CK_Toggle_Insert:
10186:1722:        edit->overwrite = (edit->overwrite == 0);
10187:1723:        break;
10188:1724:
10189:1725:    case CK_Mark:
10190:1726:        edit_mark_cmd (edit, 0);
10191:1727:        break;
10192:1728:    case CK_Unmark:
10193:1729:        edit_mark_cmd (edit, 1);
10194:1730:        break;
10195:1731:
10196:1732:    case CK_Beginning_Of_Text:
10197:1733:    case CK_Beginning_Of_Text_Highlight:
10198:1734:        edit_move_to_top (edit);
10199:1735:        break;
10200:1736:    case CK_End_Of_Text:
10201:1737:    case CK_End_Of_Text_Highlight:
10202:1738:        edit_move_to_bottom (edit);
10203:1739:        break;
10204:1740:
10205:1741:    case CK_Copy:
10206:1742:        edit_block_copy_cmd (edit);
10207:1743:        break;
10208:1744:    case CK_Remove:
10209:1745:        edit_block_delete_cmd (edit);
10210:1746:        break;
10211:1747:    case CK_Move:
10212:1748:        edit_block_move_cmd (edit);
10213:1749:        break;
10214:1750:
10215:1751:    case CK_XStore:
10216:1752:        edit_copy_to_X_buf_cmd (edit);
10217:1753:        break;
10218:1754:    case CK_XCut:
10219:1755:        edit_cut_to_X_buf_cmd (edit);
10220:1756:        break;
10221:1757:    case CK_XPaste:
10222:1758:        paste_from_X_buf_cmd (edit);
10223:1759:        break;
10224:1760:
10225:1761:    case CK_Save_As:
10226:1762:        edit_save_as_cmd (edit);
10227:1763:        break;
10228:1764:    case CK_Save:
10229:1765:        edit_save_confirm_cmd (edit);
10230:1766:        break;
10231:1767:    case CK_Load:
10232:1768:        edit_load_cmd (edit);
10233:1769:        break;
10234:1770:    case CK_Save_Block:
10235:1771:        edit_save_block_cmd (edit);
10236:1772:        break;
10237:1773:    case CK_Insert_File:
10238:1774:        edit_insert_file_cmd (edit);
10239:1775:        break;
10240:1776:
10241:1777:    case CK_Find:
10242:1778:        edit_search_cmd (edit, 0);
10243:1779:        break;
10244:1780:    case CK_Find_Again:
10245:1781:        edit_search_cmd (edit, 1);
10246:1782:        break;
10247:1783:    case CK_Replace:
10248:1784:        edit_replace_cmd (edit, 0);
10249:1785:        break;
10250:1786:    case CK_Replace_Again:
10251:1787:        edit_replace_cmd (edit, 1);
10252:1788:        break;
10253:1789:
10254:1790:    case CK_Exit:
10255:1791:        edit_quit_cmd (edit);
10256:1792:        break;
10257:1793:    case CK_New:
10258:1794:        edit_new_cmd (edit);
10259:1795:        break;
10260:1796:
10261:1797:    case CK_Help:
10262:1798:        edit_help_cmd (edit);
10263:1799:        break;
10264:1800:
10265:1801:    case CK_Refresh:
10266:1802:        edit_refresh_cmd (edit);
10267:1803:        break;
10268:1804:
10269:1805:    case CK_Date:{
10270:1806:            time_t t;
10271:1807:            time (&t);
10272:1808:            edit_printf (edit, ctime (&t));
10273:1809:            edit->force |= REDRAW_PAGE;
10274:1810:            break;
10275:1811:        }
10276:1812:    case CK_Goto:
10277:1813:        edit_goto_cmd (edit);
10278:1814:        break;
10279:1815:    case CK_Sort:
10280:1816:        edit_sort_cmd (edit);
10281:1817:        break;
10282:1818:    }
10283:1819:
10284:1820:
10285:1821:
10286:1822:/* CK_Pipe_Block */
10287:1823:    if ((command / 1000) == 1) { /* a shell command */
10288:1824:        edit_block_process_cmd (edit, shell_cmd[command - 1000], 1);
10289:1825:    }
10290:1826:    if (command > CK_Macro (0) && command <= CK_Last_Macro) { /* a macro command */
10291:1827:        int s[2];
10292:1828:        struct macro m[MAX_MACRO_LENGTH];
10293:1829:        int nm;
10294:1830:        s[0] = command - 2000;
10295:1831:        s[1] = 0;
10296:1832:        if ((result = edit_load_macro_cmd (edit, m, &nm, s)))
10297:1833:            edit_execute_macro (edit, m, nm);
10298:1834:    }
10299:1835:/* keys which must set the col position, and the search vars */
10300:1836:    switch (command) {
10301:1837:    case CK_Find:
10302:1838:    case CK_Find_Again:
10303:1839:    case CK_Replace:
10304:1840:    case CK_Replace_Again:
10305:1841:        edit->prev_col = edit_get_col (edit);
10306:1842:        return 1;
10307:1843:        break;
10308:1844:    case CK_Up:
10309:1845:    case CK_Down:
10310:1846:    case CK_Page_Up:
10311:1847:    case CK_Page_Down:
10312:1848:    case CK_Beginning_Of_Text:
10313:1849:    case CK_End_Of_Text:
10314:1850:        edit->search_start = edit->curs1;
10315:1851:        edit->found_len = 0;
10316:1852:        return 1;
10317:1853:        break;
10318:1854:    default:
10319:1855:        edit->found_len = 0;
10320:1856:        edit->prev_col = edit_get_col (edit);
10321:1857:        edit->search_start = edit->curs1;
10322:1858:    }
10323:1859:
10324:1860:    return result;
10325:1861:}
10326:1862:
10327:1863:
10328:1864:/* either command or char_for_insertion must be passed as -1 */
10329:1865:/* returns 0 if command is a macro that was not found, 1 otherwise */
10330:1866:int Cedit_execute_command (WEdit * edit, int command,
10331:1867:                           int char_for_insertion)
10332:1868:{
10333:1869:    int r;
10334:1870:    r = edit_execute_command (edit, command, char_for_insertion);
10335:1871:    Cedit_update_screen (edit);
10336:1872:    return r;
10337:1873:}
10338:1874:
10339:1875:void edit_execute_macro (WEdit * edit, struct macro macro[], int n)
10340:1876:{
10341:1877:    int i = 0;
10342:1878:    edit->force |= REDRAW_PAGE;
10343:1879:    for (; i < n; i++) {
10344:1880:        edit_execute_command (edit, macro[i].command, macro[i].ch);
10345:1881:    }
10346:1882:    Cedit_update_screen (edit);
10347:1883:}
10348:1:/* editor high level editing commands.
10349:2:
10350:3:   Copyright (C) 1996 the Free Software Foundation
10351:4:
10352:5:   Authors: 1996 Paul Sheer
10353:6:
10354:7:   This program is free software; you can redistribute it and/or modify
10355:8:   it under the terms of the GNU General Public License as published by
10356:9:   the Free Software Foundation; either version 2 of the License, or
10357:10:   (at your option) any later version.
10358:11:
10359:12:   This program is distributed in the hope that it will be useful,
10360:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
10361:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
10362:15:   GNU General Public License for more details.
10363:16:
10364:17:   You should have received a copy of the GNU General Public License
10365:18:   along with this program; if not, write to the Free Software
10366:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
10367:20:
10368:21:/* #define PIPE_BLOCKS_SO_READ_BYTE_BY_BYTE */
10369:22:
10370:23:#include <config.h>
10371:24:#include "edit.h"
10372:25:
10373:26:#ifndef MIDNIGHT
10374:27:#include "loadfile.h"
10375:28:#endif
10376:29:
10377:30:/* globals: */
10378:31:
10379:32:/* search and replace: */
10380:33:int replace_scanf = 0;
10381:34:int replace_regexp = 0;
10382:35:int replace_all = 0;
10383:36:int replace_prompt = 1;
10384:37:int replace_whole = 0;
10385:38:int replace_case = 0;
10386:39:
10387:40:/* queries on a save */
10388:41:#ifdef MIDNIGHT
10389:42:int edit_confirm_save = 1;
10390:43:#else
10391:44:int edit_confirm_save = 0;
10392:45:#endif
10393:46:
10394:47:#define NUM_REPL_ARGS 16
10395:48:#define MAX_REPL_LEN 1024
10396:49:
10397:50:#ifdef MIDNIGHT
10398:51:
10399:52:#define my_lower_case(x) ((x) < 'a' ? (x) - 'A' + 'a' : (x))
10400:53:
10401:54:char *strcasechr (const char *s, int c)
10402:55:{
10403:56:    for (; my_lower_case (*s) != my_lower_case ((char) c); ++s)
10404:57:        if (*s == '\0')
10405:58:            return 0;
10406:59:    return (char *) s;
10407:60:}
10408:61:
10409:62:
10410:63:#include "src/mad.h"
10411:64:
10412:65:#ifndef HAVE_MEMMOVE
10413:66:/* for Christophe */
10414:67:static void *memmove (void *dest, const void *src, size_t n)
10415:68:{
10416:69:    char *t, *s;
10417:70:
10418:71:    if (dest <= src) {
10419:72:        t = (char *) dest;
10420:73:        s = (char *) src;
10421:74:        while (n--)
10422:75:            *t++ = *s++;
10423:76:    } else {
10424:77:        t = (char *) dest + n;
10425:78:        s = (char *) src + n;
10426:79:        while (n--)
10427:80:            *--t = *--s;
10428:81:    }
10429:82:    return dest;
10430:83:}
10431:84:#endif
10432:85:
10433:86:char *itoa (int i)
10434:87:{
10435:88:    static char t[14];
10436:89:    char *s = t + 13;
10437:90:    int j = i;
10438:91:    *s-- = 0;
10439:92:    do {
10440:93:        *s-- = i % 10 + '0';
10441:94:    } while ((i = i / 10));
10442:95:    if (j < 0)
10443:96:        *s-- = '-';
10444:97:    return ++s;
10445:98:}
10446:99:
10447:100:/*
10448:101:   This joins strings end on end and allocates memory for the result.
10449:102:   The result is later automatically free'd and must not be free'd
10450:103:   by the caller.
10451:104: */
10452:105:char *catstrs (const char *first, ...)
10453:106:{
10454:107:    static char *stacked[16] =
10455:108:        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
10456:109:    static int i = 0;
10457:110:    va_list ap;
10458:111:    int len;
10459:112:    char *data;
10460:113:
10461:114:    if (!first)
10462:115:        return 0;
10463:116:
10464:117:    len = strlen (first);
10465:118:    va_start (ap, first);
10466:119:
10467:120:    while ((data = va_arg (ap, char *)) != 0)
10468:121:         len += strlen (data);
10469:122:
10470:123:    len++;
10471:124:
10472:125:    i = (i + 1) % 16;
10473:126:    if (stacked[i])
10474:127:        free (stacked[i]);
10475:128:
10476:129:    stacked[i] = malloc (len);
10477:130:    va_end (ap);
10478:131:    va_start (ap, first);
10479:132:    strcpy (stacked[i], first);
10480:133:    while ((data = va_arg (ap, char *)) != 0)
10481:134:         strcat (stacked[i], data);
10482:135:    va_end (ap);
10483:136:
10484:137:    return stacked[i];
10485:138:}
10486:139:#endif
10487:140:
10488:141:#ifdef MIDNIGHT
10489:142:
10490:143:void edit_help_cmd (WEdit * edit)
10491:144:{
10492:145:    interactive_display (LIBDIR "mc.hlp", "[Internal File Editor]");
10493:146:    edit->force |= REDRAW_COMPLETELY;
10494:147:}
10495:148:
10496:149:void edit_refresh_cmd (WEdit * edit)
10497:150:{
10498:151:    dlg_erase (edit->widget.parent);
10499:152:    edit->force |= REDRAW_COMPLETELY;
10500:153:}
10501:154:
10502:155:#else
10503:156:
10504:157:void edit_help_cmd (WEdit * edit)
10505:158:{
10506:159:}
10507:160:
10508:161:void edit_refresh_cmd (WEdit * edit)
10509:162:{
10510:163:}
10511:164:
10512:165:#endif
10513:166:
10514:167:
10515:168:/*TODO: Create backfile */
10516:169:
10517:170:/*Fast save file: Does NOT create a backup file. */
10518:171:/*returns 0 on error */
10519:172:int edit_save_file (WEdit * edit, const char *filename)
10520:173:{
10521:174:    long buf;
10522:175:    long filelen = 0;
10523:176:    int file;
10524:177:
10525:178:#ifdef MIDNIGHT
10526:179:    if ((file =
10527:180:         mc_open ((char *) filename, O_CREAT | O_WRONLY | O_TRUNC,
10528:181:                  S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
10529:182:        return 0;
10530:183:#else
10531:184:    if ((file = open ((char *) filename, O_WRONLY | O_TRUNC)) == -1)
10532:185:        if ((file =
10533:186:             creat ((char *) filename,
10534:187:                    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
10535:188:            return 0;
10536:189:#endif
10537:190:
10538:191:    buf = 0;
10539:192:    while (buf <= (edit->curs1 >> S_EDIT_BUF_SIZE) - 1) {
10540:193:        filelen +=
10541:194:            write (file, (char *) edit->buffers1[buf], EDIT_BUF_SIZE);
10542:195:        buf++;
10543:196:    }
10544:197:    filelen +=
10545:198:        write (file, (char *) edit->buffers1[buf],
10546:199:               edit->curs1 & M_EDIT_BUF_SIZE);
10547:200:
10548:201:    if (edit->curs2) {
10549:202:        edit->curs2--;
10550:203:        buf = (edit->curs2 >> S_EDIT_BUF_SIZE);
10551:204:        filelen +=
10552:205:            write (file,
10553:206:                   (char *) edit->buffers2[buf] + EDIT_BUF_SIZE -
10554:207:                   (edit->curs2 & M_EDIT_BUF_SIZE) - 1,
10555:208:                   1 + (edit->curs2 & M_EDIT_BUF_SIZE));
10556:209:        buf--;
10557:210:        while (buf >= 0) {
10558:211:            filelen +=
10559:212:                write (file, (char *) edit->buffers2[buf], EDIT_BUF_SIZE);
10560:213:            buf--;
10561:214:        }
10562:215:        edit->curs2++;
10563:216:    }
10564:217:    close (file);
10565:218:
10566:219:    if (filelen == edit->last_byte)
10567:220:        return 1;
10568:221:    else
10569:222:        return 0;
10570:223:}
10571:224:
10572:225:#ifdef MIDNIGHT
10573:226:
10574:227:void split_filename (WEdit * edit, char *f)
10575:228:{
10576:229:    if (edit->filename)
10577:230:        free (edit->filename);
10578:231:    edit->filename = strdup (f);
10579:232:    if (edit->dir)
10580:233:        free (edit->dir);
10581:234:    edit->dir = strdup ("");
10582:235:}
10583:236:
10584:237:#else
10585:238:
10586:239:void split_filename (WEdit * edit, char *longname)
10587:240:{
10588:241:    char *exp, *p;
10589:242:    exp = path_compress (0, longname);
10590:243:    p = strrchr (exp, '/');
10591:244:    if (edit->filename)
10592:245:        free (edit->filename);
10593:246:    if (edit->dir)
10594:247:        free (edit->dir);
10595:248:    if (p) {
10596:249:        edit->filename = strdup (++p);
10597:250:        *p = 0;
10598:251:        edit->dir = strdup (exp);
10599:252:    } else {
10600:253:        edit->filename = strdup (exp);
10601:254:        edit->dir = strdup ("/");
10602:255:    }
10603:256:}
10604:257:
10605:258:#endif
10606:259:
10607:260:/*  here we want to warn the user of overwriting an existing file, but only if they
10608:261:   have made a change to the filename */
10609:262:/* returns 1 on success */
10610:263:int edit_save_as_cmd (WEdit * edit)
10611:264:{
10612:265:    char *exp =
10613:266:        Cgetsavefile (edit->widget->winid, 40, 40, edit->dir,
10614:267:                      edit->filename, " Save As ");
10615:268:    push_action (edit, KEY_PRESS + edit->start_display);
10616:269:    edit->force |= REDRAW_COMPLETELY;
10617:270:
10618:271:    if (exp) {
10619:272:        if (!*exp) {
10620:273:            free (exp);
10621:274:            return 0;
10622:275:        } else {
10623:276:            if (strcmp (catstrs (edit->dir, edit->filename, 0), exp)) {
10624:277:                int file;
10625:278:                if ((file = open ((char *) exp, O_RDONLY)) != -1) { /* the file exists */
10626:279:                    close (file);
10627:280:#ifdef MIDNIGHT
10628:281:                    if (query_dialog
10629:282:                        (" Warning ",
10630:283:                         " A file already exists with this name. ", 0, 2,
10631:284:                         " Overwrite ", " Cancel "))
10632:285:#else
10633:286:                    if (Cquerydialogue
10634:287:                        (edit->widget->winid, 20, 20, " Warning ",
10635:288:                         " A file already exists with this name. ",
10636:289:                         " Overwrite ", " Cancel ", NULL))
10637:290:#endif
10638:291:                        return 0;
10639:292:                }
10640:293:            }
10641:294:            if (edit_save_file (edit, exp)) {
10642:295:                split_filename (edit, exp);
10643:296:                free (exp);
10644:297:                edit->modified = 0;
10645:298:                return 1;
10646:299:            } else {
10647:300:                free (exp);
10648:301:                Cerrordialogue (edit->widget->winid, 20, 20, " Save as ",
10649:302:                                get_sys_error
10650:303:                                (" Error trying to save file. "));
10651:304:                return 0;
10652:305:            }
10653:306:        }
10654:307:    } else
10655:308:        return 0;
10656:309:}
10657:310:
10658:311:
10659:312:
10660:313:#ifdef MIDNIGHT
10661:314:int raw_callback (struct Dlg_head *h, int key, int Msg)
10662:315:{
10663:316:    switch (Msg) {
10664:317:    case DLG_DRAW:
10665:318:        attrset (REVERSE_COLOR);
10666:319:        dlg_erase (h);
10667:320:        draw_box (h, 1, 1, h->lines - 2, h->cols - 2);
10668:321:
10669:322:        attrset (COLOR_HOT_NORMAL);
10670:323:        dlg_move (h, 1, 2);
10671:324:        printw (h->title);
10672:325:        break;
10673:326:
10674:327:    case DLG_KEY:
10675:328:        h->running = 0;
10676:329:        h->ret_value = key;
10677:330:        return 1;
10678:331:    }
10679:332:    return 0;
10680:333:}
10681:334:
10682:335:/* gets a raw key from the keyboard. Passing cancel = 1 draws
10683:336:   a cancel button thus allowing c-c etc.. Alternatively, cancel = 0 
10684:337:   will return the next key pressed */
10685:338:int edit_raw_key_query (char *heading, char *query, int cancel)
10686:339:{
10687:340:    int w = strlen (query) + 7;
10688:341:    struct Dlg_head *raw_dlg = create_dlg (0, 0, 7, w, dialog_colors,
10689:342:                                           raw_callback, "[Raw Key Query]",
10690:343:                                           "raw_key_input",
10691:344:                                           DLG_CENTER | DLG_TRYUP);
10692:345:    x_set_dialog_title (raw_dlg, heading);
10693:346:    raw_dlg->raw = 1;           /* to return even a tab key */
10694:347:    if (cancel)
10695:348:        add_widget (raw_dlg,
10696:349:                    button_new (4, w / 2 - 5, B_CANCEL, "[ Cancel ]", 'c',
10697:350:                                2, 0, 0, 0));
10698:351:    add_widget (raw_dlg, label_new (3 - cancel, 2, query, 0));
10699:352:    add_widget (raw_dlg,
10700:353:                input_new (3 - cancel, w - 5, INPUT_COLOR, 2, "", 0));
10701:354:    run_dlg (raw_dlg);
10702:355:    w = raw_dlg->ret_value;
10703:356:    destroy_dlg (raw_dlg);
10704:357:    if (cancel)
10705:358:        if (w == XCTRL ('g') || w == XCTRL ('c') || w == ESC_CHAR
10706:359:            || w == B_CANCEL)
10707:360:            return 0;
10708:361:/* hence ctrl-a (=B_CANCEL), ctrl-g, ctrl-c, and Esc are cannot returned */
10709:362:    return w;
10710:363:}
10711:364:
10712:365:#else
10713:366:
10714:367:int edit_raw_key_query (char *heading, char *query, int cancel)
10715:368:{
10716:369:    return Crawkeyquery (0, 0, 0, heading, query);
10717:370:}
10718:371:
10719:372:#endif
10720:373:
10721:374:/* creates a macro file if it doesn't exist */
10722:375:static FILE *edit_open_macro_file (const char *r)
10723:376:{
10724:377:    char *filename;
10725:378:    int file;
10726:379:    filename = catstrs (home_dir, MACRO_FILE, 0);
10727:380:#ifdef MIDNIGHT
10728:381:    if ((file =
10729:382:         mc_open (filename, O_CREAT | O_RDWR,
10730:383:                  S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
10731:384:        return 0;
10732:385:#else
10733:386:    if ((file = open (filename, O_RDWR)) == -1)
10734:387:        if ((file =
10735:388:             creat ((char *) filename,
10736:389:                    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
10737:390:            return 0;
10738:391:#endif
10739:392:    close (file);
10740:393:    return fopen (filename, r);
10741:394:}
10742:395:
10743:396:/* returns 0 on error */
10744:397:int edit_save_macro_cmd (WEdit * edit, struct macro macro[], int n)
10745:398:{
10746:399:    int i;
10747:400:    FILE *f;
10748:401:    int s;
10749:402:
10750:403:    edit->force |= REDRAW_COMPLETELY;
10751:404:    push_action (edit, KEY_PRESS + edit->start_display);
10752:405:    s = edit_raw_key_query (" Macro ", " Press the macro's new hotkey: ",
10753:406:                            1);
10754:407:    if (s) {
10755:408:        f = edit_open_macro_file ("a+");
10756:409:        if (f) {
10757:410:            fprintf (f, "key '%d %d': ", s, /* s[1] */ (int) 0); /* later we might want key combinations, but not yet */
10758:411:            for (i = 0; i < n; i++)
10759:412:                fprintf (f, "%hd %hd, ", macro[i].command, macro[i].ch);
10760:413:            fprintf (f, ";\n");
10761:414:            fclose (f);
10762:415:            return 1;
10763:416:        } else
10764:417:            Cerrordialogue (edit->widget->winid, 20, 20, " Save macro ",
10765:418:                            get_sys_error
10766:419:                            (" Error trying to open macro file. "));
10767:420:    }
10768:421:    return 0;
10769:422:}
10770:423:
10771:424:
10772:425:
10773:426:
10774:427:/* return 0 on error */
10775:428:int edit_load_macro_cmd (WEdit * edit, struct macro macro[], int *n,
10776:429:                         int *k)
10777:430:{
10778:431:    FILE *f;
10779:432:    int s[4];
10780:433:
10781:434:    if ((f = edit_open_macro_file ("r"))) {
10782:435:        do {
10783:436:            *n = fscanf (f, "key '%d %d': ", &(s[0]), &(s[1]));
10784:437:            if (!(*n) || *n == EOF) {
10785:438:                fclose (f);
10786:439:                return 0;
10787:440:            }
10788:441:            *n = 0;
10789:442:            while (fscanf
10790:443:                   (f, "%hd %hd, ", &macro[*n].command, &macro[*n].ch))
10791:444:                (*n)++;
10792:445:            fscanf (f, ";\n");
10793:446:        } while (s[0] != k[0] || s[1] != k[1]);
10794:447:        fclose (f);
10795:448:        return 1;
10796:449:    } else
10797:450:        Cerrordialogue (edit->widget->winid, 20, 20, " Load macro ",
10798:451:                        get_sys_error
10799:452:                        (" Error trying to open macro file. "));
10800:453:    return 0;
10801:454:}
10802:455:
10803:456:
10804:457:/* returns 1 on success */
10805:458:int edit_save_confirm_cmd (WEdit * edit)
10806:459:{
10807:460:    char *f;
10808:461:
10809:462:#ifdef MIDNIGHT
10810:463:    if (edit_confirm_save) {
10811:464:        f = catstrs (" Confirm save file: ", edit->filename, " ? ", 0);
10812:465:        if (query_dialog (" Save file ", f, 0, 2, " Save ", " Cancel "))
10813:466:#else
10814:467:    if (edit_confirm_save) {
10815:468:        f = catstrs (" Confirm save file: ", edit->dir, edit->filename,
10816:469:                     " ? ", 0);
10817:470:        if (Cquerydialogue
10818:471:            (edit->widget->winid, 20, 20, " Save file ", f, " Save ",
10819:472:             " Cancel ", NULL))
10820:473:#endif
10821:474:            return 0;
10822:475:    }
10823:476:    return edit_save_cmd (edit);
10824:477:}
10825:478:
10826:479:
10827:480:/* returns 1 on success */
10828:481:int edit_save_cmd (WEdit * edit)
10829:482:{
10830:483:    edit->force |= REDRAW_COMPLETELY;
10831:484:    if (!edit_save_file (edit, catstrs (edit->dir, edit->filename, 0)))
10832:485:        return edit_save_as_cmd (edit);
10833:486:    edit->modified = 0;
10834:487:    return 1;
10835:488:}
10836:489:
10837:490:
10838:491:/* returns 1 on success */
10839:492:int edit_new_cmd (WEdit * edit)
10840:493:{
10841:494:    edit->force |= REDRAW_COMPLETELY;
10842:495:    if (edit->modified)
10843:496:#ifdef MIDNIGHT
10844:497:        if (query_dialog
10845:498:            (" Warning ", " Continue discards unsaved changes. ", 0, 2,
10846:499:             " Continue ", " Cancel "))
10847:500:#else
10848:501:        if (Cquerydialogue
10849:502:            (edit->widget->winid, 20, 20, " Warning ",
10850:503:             " Current text was modified without a file save. \n Continue discards these changes. ",
10851:504:             " Continue ", " Cancel ", NULL))
10852:505:#endif
10853:506:            return 0;
10854:507:    edit->modified = 0;
10855:508:    return edit_renew (edit);   /* if this gives an error, something has really screwed up */
10856:509:}
10857:510:
10858:511:int edit_load_cmd (WEdit * edit)
10859:512:{
10860:513:    char *exp;
10861:514:    int mod = 0;
10862:515:    edit->force |= REDRAW_COMPLETELY;
10863:516:    if (edit->modified) {
10864:517:        mod = 1;
10865:518:#ifdef MIDNIGHT
10866:519:        if (query_dialog
10867:520:            (" Warning ", " Continue discards unsaved changes. ", 0, 2,
10868:521:             " Continue ", " Cancel "))
10869:522:#else
10870:523:        if (Cquerydialogue
10871:524:            (edit->widget->winid, 20, 20, "Warning",
10872:525:             " Current text was modified without a file save. \n Continue discards these changes. ",
10873:526:             " Continue ", " Cancel ", NULL))
10874:527:#endif
10875:528:            return 0;
10876:529:    }
10877:530:    edit->modified = 0;
10878:531:
10879:532:    exp =
10880:533:        Cgetloadfile (edit->widget->winid, 40, 40, edit->dir,
10881:534:                      edit->filename, " Load ");
10882:535:
10883:536:    if (exp) {
10884:537:        if (!*exp) {
10885:538:            free (exp);
10886:539:        } else {
10887:540:            int file;
10888:541:            if ((file = open ((char *) exp, O_RDONLY)) != -1) {
10889:542:                close (file);
10890:543:                edit_reload (edit, exp, 0, "");
10891:544:                split_filename (edit, exp);
10892:545:                free (exp);
10893:546:                edit->modified = 0;
10894:547:                edit->force |= REDRAW_COMPLETELY;
10895:548:                return 1;
10896:549:            } else {
10897:550:                free (exp);
10898:551:                Cerrordialogue (edit->widget->winid, 20, 20, " Load ",
10899:552:                                get_sys_error
10900:553:                                (" Error trying to open file for reading. "));
10901:554:            }
10902:555:        }
10903:556:    }
10904:557:    edit->modified = mod;       /* on fail, restore the modidifed state */
10905:558:    return 0;
10906:559:}
10907:560:
10908:561:/*
10909:562:   if mark2 is -1 then marking is from mark1 to the cursor.
10910:563:   Otherwise its between the markers. This handles this.
10911:564:   Returns 1 if no text is marked.
10912:565: */
10913:566:int eval_marks (WEdit * edit, long *start_mark, long *end_mark)
10914:567:{
10915:568:    if (edit->mark1 != edit->mark2) {
10916:569:        if (edit->mark2 >= 0) {
10917:570:            *start_mark = min (edit->mark1, edit->mark2);
10918:571:            *end_mark = max (edit->mark1, edit->mark2);
10919:572:        } else {
10920:573:            *start_mark = min (edit->mark1, edit->curs1);
10921:574:            *end_mark = max (edit->mark1, edit->curs1);
10922:575:        }
10923:576:        return 0;
10924:577:    } else {
10925:578:        *start_mark = *end_mark = 0;
10926:579:        return 1;
10927:580:    }
10928:581:}
10929:582:
10930:583:/*Block copy, move and delete commands */
10931:584:
10932:585:void edit_block_copy_cmd (WEdit * edit)
10933:586:{
10934:587:    long start_mark, end_mark, current = edit->curs1;
10935:588:    long count;
10936:589:    char *copy_buf;
10937:590:
10938:591:    if (eval_marks (edit, &start_mark, &end_mark))
10939:592:        return;
10940:593:
10941:594:
10942:595:    copy_buf = malloc (end_mark - start_mark);
10943:596:
10944:597:/* all that gets pushed are deletes hence little space is used on the stack */
10945:598:
10946:599:    edit_push_markers (edit);
10947:600:
10948:601:    count = start_mark;
10949:602:    while (count < end_mark) {
10950:603:        copy_buf[end_mark - count - 1] = edit_get_byte (edit, count);
10951:604:        count++;
10952:605:    }
10953:606:    while (count-- > start_mark) {
10954:607:        edit_insert_ahead (edit, copy_buf[end_mark - count - 1]);
10955:608:    }
10956:609:    free (copy_buf);
10957:610:    edit_scroll_screen_over_cursor (edit);
10958:611:
10959:612:    if (start_mark < current && end_mark > current)
10960:613:        edit_set_markers (edit, start_mark,
10961:614:                          end_mark + end_mark - start_mark);
10962:615:
10963:616:    edit->force |= REDRAW_PAGE;
10964:617:}
10965:618:
10966:619:
10967:620:void edit_block_move_cmd (WEdit * edit)
10968:621:{
10969:622:    long count;
10970:623:    long current;
10971:624:    char *copy_buf;
10972:625:    long start_mark, end_mark;
10973:626:
10974:627:    if (eval_marks (edit, &start_mark, &end_mark))
10975:628:        return;
10976:629:
10977:630:    if (start_mark <= edit->curs1 && end_mark >= edit->curs1)
10978:631:        return;
10979:632:
10980:633:    if ((end_mark - start_mark) > MAX_STACK)
10981:634:#ifdef MIDNIGHT
10982:635:        if (query_dialog
10983:636:            (" Warning ",
10984:637:             " Block is large, you may not be able to undo this action. ",
10985:638:             0, 2, " Continue ", " Cancel "))
10986:639:#else
10987:640:        if (Cquerydialogue
10988:641:            (edit->widget->winid, 20, 20, " Warning ",
10989:642:             " Block is large, you may not be able to undo this action. ",
10990:643:             " Continue ", " Cancel ", NULL))
10991:644:#endif
10992:645:            return;
10993:646:
10994:647:    copy_buf = malloc (end_mark - start_mark);
10995:648:
10996:649:    edit_push_markers (edit);
10997:650:
10998:651:    current = edit->curs1;
10999:652:    edit_cursor_move (edit, start_mark - edit->curs1);
11000:653:    edit_scroll_screen_over_cursor (edit);
11001:654:
11002:655:    count = start_mark;
11003:656:    while (count < end_mark) {
11004:657:        copy_buf[end_mark - count - 1] = edit_delete (edit);
11005:658:        count++;
11006:659:    }
11007:660:    edit_scroll_screen_over_cursor (edit);
11008:661:
11009:662:    if (edit_cursor_move (edit, current - edit->curs1 -
11010:663:                          (((current - edit->curs1) >
11011:664:                            0) ? end_mark - start_mark : 0)));
11012:665:    edit_scroll_screen_over_cursor (edit);
11013:666:
11014:667:    while (count-- > start_mark) {
11015:668:        edit_insert_ahead (edit, copy_buf[end_mark - count - 1]);
11016:669:        edit_set_markers (edit, edit->curs1,
11017:670:                          edit->curs1 + end_mark - start_mark);
11018:671:    }
11019:672:    edit_scroll_screen_over_cursor (edit);
11020:673:
11021:674:    free (copy_buf);
11022:675:    edit->force |= REDRAW_PAGE;
11023:676:}
11024:677:
11025:678:
11026:679:/* returns 1 if canceelled by user */
11027:680:int edit_block_delete_cmd (WEdit * edit)
11028:681:{
11029:682:    long count;
11030:683:    long start_mark, end_mark;
11031:684:
11032:685:    if (eval_marks (edit, &start_mark, &end_mark)) {
11033:686:        start_mark = edit_bol (edit, edit->curs1);
11034:687:        end_mark = edit_eol (edit, edit->curs1) + 1;
11035:688:    }
11036:689:    if ((end_mark - start_mark) > MAX_STACK)
11037:690:#ifdef MIDNIGHT
11038:691:        if (query_dialog
11039:692:            (" Warning ",
11040:693:             " Block is large, you may not be able to undo this action. ",
11041:694:             0, 2, " Continue ", " Cancel "))
11042:695:#else
11043:696:        if (Cquerydialogue
11044:697:            (edit->widget->winid, 20, 20, " Warning ",
11045:698:             " Block is large, you may not be able to undo this action. ",
11046:699:             " Continue ", " Cancel ", NULL))
11047:700:#endif
11048:701:            return 1;
11049:702:
11050:703:    edit_push_markers (edit);
11051:704:
11052:705:    edit_cursor_move (edit, start_mark - edit->curs1);
11053:706:    edit_scroll_screen_over_cursor (edit);
11054:707:
11055:708:    count = start_mark;
11056:709:    while (count < end_mark) {
11057:710:        edit_delete (edit);
11058:711:        count++;
11059:712:    }
11060:713:
11061:714:    edit_set_markers (edit, 0, 0);
11062:715:    edit->force |= REDRAW_PAGE;
11063:716:
11064:717:    return 0;
11065:718:}
11066:719:
11067:720:
11068:721:#ifdef MIDNIGHT
11069:722:
11070:723:#define INPUT_INDEX 8
11071:724:#define SEARCH_DLG_HEIGHT 9
11072:725:#define REPLACE_DLG_HEIGHT 14
11073:726:#define B_REPLACE_ALL B_USER+1
11074:727:#define B_SKIP_REPLACE B_USER+2
11075:728:
11076:729:int edit_replace_prompt (WEdit * edit, char *replace_text, int xpos,
11077:730:                         int ypos)
11078:731:{
11079:732:    if (replace_prompt) {
11080:733:        QuickWidget quick_widgets[] = {
11081:734:            {quick_button, 8, 11, 3, 6, "[ Cancel ]", 'c', 2, B_CANCEL, 0,
11082:735:             0, XV_WLAY_DONTCARE, NULL}
11083:736:            ,
11084:737:            {quick_button, 5, 11, 3, 6, "[ Replace all ]", 'a', 10,
11085:738:             B_REPLACE_ALL, 0,
11086:739:             0, XV_WLAY_DONTCARE, NULL}
11087:740:            ,
11088:741:            {quick_button, 3, 11, 3, 6, "[ Skip ]", 's', 2, B_SKIP_REPLACE,
11089:742:             0,
11090:743:             0, XV_WLAY_DONTCARE, NULL}
11091:744:            ,
11092:745:            {quick_button, 1, 11, 3, 6, "[ Replace ]", 'r', 2, B_ENTER, 0,
11093:746:             0, XV_WLAY_DONTCARE, NULL}
11094:747:            ,
11095:748:            {quick_label, 2, 50, 2, 6, 0,
11096:749:             0, 0, 0, 0, 0, XV_WLAY_DONTCARE, 0}
11097:750:            ,
11098:751:            {0}
11099:752:        };
11100:753:
11101:754:        quick_widgets[4].text =
11102:755:            catstrs (" Replace with: ", replace_text, 0);
11103:756:
11104:757:        {
11105:758:            QuickDialog Quick_input = { 66, 6, 0, 0, " Replace ",
11106:759:                "[Input Line Keys]", "quick_input", 0 /*quick_widgets */
11107:760:            };
11108:761:
11109:762:            Quick_input.widgets = quick_widgets;
11110:763:
11111:764:            Quick_input.xpos = xpos;
11112:765:            Quick_input.ypos = ypos;
11113:766:            return quick_dialog (&Quick_input);
11114:767:        }
11115:768:    } else
11116:769:        return 0;
11117:770:}
11118:771:
11119:772:
11120:773:
11121:774:void edit_replace_dialog (WEdit * edit, char **search_text,
11122:775:                          char **replace_text, char **arg_order)
11123:776:{
11124:777:    int treplace_scanf = replace_scanf;
11125:778:    int treplace_regexp = replace_regexp;
11126:779:    int treplace_all = replace_all;
11127:780:    int treplace_prompt = replace_prompt;
11128:781:    int treplace_whole = replace_whole;
11129:782:    int treplace_case = replace_case;
11130:783:
11131:784:    char *tsearch_text;
11132:785:    char *treplace_text;
11133:786:    char *targ_order;
11134:787:    QuickWidget quick_widgets[] = {
11135:788:        {quick_button, 6, 10, 11, REPLACE_DLG_HEIGHT, "[ Cancel ]", 'c', 2,
11136:789:         B_CANCEL, 0,
11137:790:         0, XV_WLAY_DONTCARE, NULL},
11138:791:        {quick_button, 2, 10, 11, REPLACE_DLG_HEIGHT, "[ Ok ]", 'o', 2,
11139:792:         B_ENTER, 0,
11140:793:         0, XV_WLAY_DONTCARE, NULL},
11141:794:        {quick_checkbox, 25, 50, 10, REPLACE_DLG_HEIGHT,
11142:795:         "Scanf expression", 'n', 8, 0,
11143:796:         0, 0, XV_WLAY_DONTCARE, NULL},
11144:797:        {quick_checkbox, 25, 50, 9, REPLACE_DLG_HEIGHT, "Replace all", 'a',
11145:798:         8, 0,
11146:799:         0, 0, XV_WLAY_DONTCARE, NULL},
11147:800:        {quick_checkbox, 25, 50, 8, REPLACE_DLG_HEIGHT,
11148:801:         "Prompt on replace", 'p', 0, 0,
11149:802:         0, 0, XV_WLAY_DONTCARE, NULL},
11150:803:        {quick_checkbox, 4, 50, 10, REPLACE_DLG_HEIGHT, "Regular exprssn",
11151:804:         'r', 0, 0,
11152:805:         0, 0, XV_WLAY_DONTCARE, NULL},
11153:806:        {quick_checkbox, 4, 50, 9, REPLACE_DLG_HEIGHT, "Whole words only",
11154:807:         'w', 0, 0,
11155:808:         0, 0, XV_WLAY_DONTCARE, NULL},
11156:809:        {quick_checkbox, 4, 50, 8, REPLACE_DLG_HEIGHT, "Case sensitive",
11157:810:         's', 5, 0,
11158:811:         0, 0, XV_WLAY_DONTCARE, NULL},
11159:812:        {quick_input, 3, 50, 7, REPLACE_DLG_HEIGHT, 0, 0, 44, 0, 0,
11160:813:         0, XV_WLAY_BELOWCLOSE, 0},
11161:814:        {quick_label, 2, 50, 6, REPLACE_DLG_HEIGHT,
11162:815:         " Enter replacement argument order eg. 3,2,1,4 ", 0, 0, 0, 0,
11163:816:         0, XV_WLAY_DONTCARE, 0},
11164:817:        {quick_input, 3, 50, 5, REPLACE_DLG_HEIGHT, 0, 0, 44, 0, 0,
11165:818:         0, XV_WLAY_BELOWCLOSE, 0},
11166:819:        {quick_label, 2, 50, 4, REPLACE_DLG_HEIGHT,
11167:820:         " Enter replacement string", 0, 0, 0, 0,
11168:821:         0, XV_WLAY_DONTCARE, 0},
11169:822:        {quick_input, 3, 50, 3, REPLACE_DLG_HEIGHT, 0, 0, 44, 0, 0,
11170:823:         0, XV_WLAY_BELOWCLOSE, 0},
11171:824:        {quick_label, 2, 50, 2, REPLACE_DLG_HEIGHT, " Enter search string",
11172:825:         0, 0, 0, 0,
11173:826:         0, XV_WLAY_DONTCARE, 0},
11174:827:        {0}
11175:828:    };
11176:829:
11177:830:    quick_widgets[2].result = &treplace_scanf;
11178:831:    quick_widgets[3].result = &treplace_all;
11179:832:    quick_widgets[4].result = &treplace_prompt;
11180:833:    quick_widgets[5].result = &treplace_regexp;
11181:834:    quick_widgets[6].result = &treplace_whole;
11182:835:    quick_widgets[7].result = &treplace_case;
11183:836:    quick_widgets[8].str_result = &targ_order;
11184:837:    quick_widgets[8].text = *arg_order;
11185:838:    quick_widgets[10].str_result = &treplace_text;
11186:839:    quick_widgets[10].text = *replace_text;
11187:840:    quick_widgets[12].str_result = &tsearch_text;
11188:841:    quick_widgets[12].text = *search_text;
11189:842:    {
11190:843:        QuickDialog Quick_input =
11191:844:            { 50, REPLACE_DLG_HEIGHT, -1, 0, " Replace ",
11192:845:            "[Input Line Keys]", "quick_input", 0 /*quick_widgets */
11193:846:        };
11194:847:
11195:848:        Quick_input.widgets = quick_widgets;
11196:849:
11197:850:        if (quick_dialog (&Quick_input) != B_CANCEL) {
11198:851:            *arg_order = *(quick_widgets[INPUT_INDEX].str_result);
11199:852:            *replace_text = *(quick_widgets[INPUT_INDEX + 2].str_result);
11200:853:            *search_text = *(quick_widgets[INPUT_INDEX + 4].str_result);
11201:854:            replace_scanf = treplace_scanf;
11202:855:            replace_regexp = treplace_regexp;
11203:856:            replace_all = treplace_all;
11204:857:            replace_prompt = treplace_prompt;
11205:858:            replace_whole = treplace_whole;
11206:859:            replace_case = treplace_case;
11207:860:            return;
11208:861:        } else {
11209:862:            *arg_order = NULL;
11210:863:            *replace_text = NULL;
11211:864:            *search_text = NULL;
11212:865:            return;
11213:866:        }
11214:867:    }
11215:868:}
11216:869:
11217:870:
11218:871:void edit_search_dialog (WEdit * edit, char **search_text)
11219:872:{
11220:873:    int treplace_scanf = replace_scanf;
11221:874:    int treplace_regexp = replace_regexp;
11222:875:    int treplace_whole = replace_whole;
11223:876:    int treplace_case = replace_case;
11224:877:
11225:878:    char *tsearch_text;
11226:879:    QuickWidget quick_widgets[] = {
11227:880:        {quick_button, 6, 10, 6, SEARCH_DLG_HEIGHT, "[ Cancel ]", 'c', 2,
11228:881:         B_CANCEL, 0,
11229:882:         0, XV_WLAY_DONTCARE, NULL},
11230:883:        {quick_button, 2, 10, 6, SEARCH_DLG_HEIGHT, "[ Ok ]", 'o', 2,
11231:884:         B_ENTER, 0,
11232:885:         0, XV_WLAY_DONTCARE, NULL},
11233:886:        {quick_checkbox, 25, 50, 5, SEARCH_DLG_HEIGHT, "Scanf expression",
11234:887:         'n', 8, 0,
11235:888:         0, 0, XV_WLAY_DONTCARE, NULL},
11236:889:        {quick_checkbox, 25, 50, 4, SEARCH_DLG_HEIGHT, "Regular exprssn",
11237:890:         'r', 0, 0,
11238:891:         0, 0, XV_WLAY_DONTCARE, NULL},
11239:892:        {quick_checkbox, 4, 50, 5, SEARCH_DLG_HEIGHT, "Whole words only",
11240:893:         'w', 0, 0,
11241:894:         0, 0, XV_WLAY_DONTCARE, NULL},
11242:895:        {quick_checkbox, 4, 50, 4, SEARCH_DLG_HEIGHT, "Case sensitive",
11243:896:         's', 5, 0,
11244:897:         0, 0, XV_WLAY_DONTCARE, NULL},
11245:898:        {quick_input, 3, 50, 3, SEARCH_DLG_HEIGHT, 0, 0, 44, 0, 0,
11246:899:         0, XV_WLAY_BELOWCLOSE, 0},
11247:900:        {quick_label, 2, 50, 2, SEARCH_DLG_HEIGHT, " Enter search string",
11248:901:         0, 0, 0, 0,
11249:902:         0, XV_WLAY_DONTCARE, 0},
11250:903:        {0}
11251:904:    };
11252:905:
11253:906:    quick_widgets[2].result = &treplace_scanf;
11254:907:    quick_widgets[3].result = &treplace_regexp;
11255:908:    quick_widgets[4].result = &treplace_whole;
11256:909:    quick_widgets[5].result = &treplace_case;
11257:910:    quick_widgets[6].str_result = &tsearch_text;
11258:911:    quick_widgets[6].text = *search_text;
11259:912:
11260:913:    {
11261:914:        QuickDialog Quick_input =
11262:915:            { 50, SEARCH_DLG_HEIGHT, -1, 0, " Search ",
11263:916:            "[Input Line Keys]", "quick_input", 0 /*quick_widgets */
11264:917:        };
11265:918:
11266:919:        Quick_input.widgets = quick_widgets;
11267:920:
11268:921:        if (quick_dialog (&Quick_input) != B_CANCEL) {
11269:922:            *search_text = *(quick_widgets[6].str_result);
11270:923:            replace_scanf = treplace_scanf;
11271:924:            replace_regexp = treplace_regexp;
11272:925:            replace_whole = treplace_whole;
11273:926:            replace_case = treplace_case;
11274:927:            return;
11275:928:        } else {
11276:929:            *search_text = NULL;
11277:930:            return;
11278:931:        }
11279:932:    }
11280:933:}
11281:934:
11282:935:
11283:936:#else
11284:937:
11285:938:#define B_ENTER 0
11286:939:#define B_SKIP_REPLACE 1
11287:940:#define B_REPLACE_ALL 2
11288:941:#define B_CANCEL 3
11289:942:
11290:943:#define R_W 450
11291:944:
11292:945:extern CWidget *wedit;
11293:946:
11294:947:void edit_search_replace_dialog (Window parent, int x, int y,
11295:948:                                 char **search_text, char **replace_text,
11296:949:                                 char **arg_order, char *heading,
11297:950:                                 int option)
11298:951:{
11299:952:    Window win;
11300:953:    XEvent xev;
11301:954:    CEvent cev;
11302:955:    int h, height = 300;
11303:956:    CState s;
11304:957:    int xh, yh, yh2, yh3, xs, ys, o;
11305:958:    CWidget *m;
11306:959:
11307:960:    if (replace_text == 0)      /* must be a search dialog */
11308:961:        height -= 110;
11309:962:
11310:963:    CBackupState (&s);
11311:964:    CDisable ("*");
11312:965:
11313:966:    win =
11314:967:        Cdrawheadedwindow ("replace", parent, x, y, R_W, height, heading);
11315:968:    Cgethintpos (&xh, &h);
11316:969:
11317:970:    Cwidget ("replace")->position = CALWAYS_ON_TOP;
11318:971:    o = (Cdrawtext ("replace.t1", win, xh, h, " Enter search text : "))->
11319:972:        height;
11320:973:
11321:974:    o = (32 - o) / 2;
11322:975:    Cgethintpos (0, &yh);
11323:976:    Cdrawtextinput ("replace.sinp", win, xh, yh, 10, AUTO_HEIGHT, 256,
11324:977:                    *search_text);
11325:978:
11326:979:    if (replace_text) {
11327:980:        Cgethintpos (0, &yh);
11328:981:        Cdrawtext ("replace.t2", win, xh, yh, " Enter replace text : ");
11329:982:        Cgethintpos (0, &yh);
11330:983:        Cdrawtextinput ("replace.rinp", win, xh, yh, 10, AUTO_HEIGHT, 256,
11331:984:                        *replace_text);
11332:985:        Cgethintpos (0, &yh);
11333:986:        Cdrawtext ("replace.t3", win, xh, yh, " Enter argument order : ");
11334:987:        Cgethintpos (0, &yh);
11335:988:        Cdrawtextinput ("replace.ainp", win, xh, yh, 10, AUTO_HEIGHT, 256,
11336:989:                        *arg_order);
11337:990:    }
11338:991:    Cgethintpos (0, &yh);
11339:992:    yh3 = yh;
11340:993:    Cdrawswitch ("replace.ww", win, xh, yh, C_BLACK, C_FLAT,
11341:994:                 replace_whole);
11342:995:    Cgethintpos (0, &yh2);
11343:996:    Cdrawtext ("replace.t4", win, 32 + WIDGET_SPACING + xh, yh + o,
11344:997:               " Whole words only ");
11345:998:    Cdrawswitch ("replace.case", win, xh, yh2, C_BLACK, C_FLAT,
11346:999:                 replace_case);
11347:1000:    Cgethintpos (0, &yh);
11348:1001:    Cdrawtext ("replace.t5", win, 32 + WIDGET_SPACING + xh, yh2 + o,
11349:1002:               " Case sensitive ");
11350:1003:    Cdrawswitch ("replace.reg", win, xh, yh, C_BLACK, C_FLAT,
11351:1004:                 replace_regexp);
11352:1005:    Cdrawtext ("replace.t6", win, 32 + WIDGET_SPACING + xh, yh + o,
11353:1006:               " Regular expression ");
11354:1007:    Cgethintpos (&xh, 0);
11355:1008:    xs = xh;
11356:1009:    ys = yh;
11357:1010:
11358:1011:    if (replace_text) {
11359:1012:        Cdrawswitch ("replace.pr", win, xh, yh3, C_BLACK, C_FLAT,
11360:1013:                     replace_prompt);
11361:1014:        Cgethintpos (0, &yh);
11362:1015:        Cdrawtext ("replace.t7", win, xh + 32 + WIDGET_SPACING, yh3 + o,
11363:1016:                   " Prompt on replace ");
11364:1017:        Cdrawswitch ("replace.all", win, xh, yh, C_BLACK, C_FLAT,
11365:1018:                     replace_all);
11366:1019:        Cdrawtext ("replace.t8", win, xh + 32 + WIDGET_SPACING, yh + o,
11367:1020:                   " Replace all ");
11368:1021:    }
11369:1022:    Cdrawswitch ("replace.scanf", win, xs, ys, C_BLACK, C_FLAT,
11370:1023:                 replace_scanf);
11371:1024:    Cdrawtext ("replace.t9", win, xs + 32 + WIDGET_SPACING, ys + o,
11372:1025:               " Scanf expression ");
11373:1026:
11374:1027:    Csetsizehintpos ("replace");
11375:1028:    m = Cwidget ("replace");
11376:1029:    Cdrawbitmapbutton ("replace.ok", win,
11377:1030:                       m->width - WIDGET_SPACING - 48 - 2, h, 40, 40,
11378:1031:                       Ccolor (6), C_FLAT, tick_bits);
11379:1032:    Cdrawbitmapbutton ("replace.cancel", win,
11380:1033:                       m->width - WIDGET_SPACING - 48 - 2,
11381:1034:                       h + WIDGET_SPACING + 48, 40, 40, Ccolor (18),
11382:1035:                       C_FLAT, cross_bits);
11383:1036:    Csetwidgetsize ("replace.sinp", m->width - WIDGET_SPACING * 3 - 4 - 48,
11384:1037:                    (Cwidget ("replace.sinp"))->height);
11385:1038:    if (replace_text) {
11386:1039:        Csetwidgetsize ("replace.rinp",
11387:1040:                        m->width - WIDGET_SPACING * 3 - 4 - 48,
11388:1041:                        (Cwidget ("replace.rinp"))->height);
11389:1042:        Csetwidgetsize ("replace.ainp",
11390:1043:                        m->width - WIDGET_SPACING * 3 - 4 - 48,
11391:1044:                        (Cwidget ("replace.ainp"))->height);
11392:1045:    }
11393:1046:
11394:1047:    CFocus (Cwidget ("replace.sinp"));
11395:1048:
11396:1049:    for (;;) {
11397:1050:        CNextEvent (&xev, &cev);
11398:1051:        if (!strcmp (cev.ident, "replace.cancel")
11399:1052:            || (CKeySym (&xev) == XK_Escape && xev.type == KeyPress)) {
11400:1053:            *search_text = 0;
11401:1054:            break;
11402:1055:        }
11403:1056:        if (!strcmp (cev.ident, "replace.ok")
11404:1057:            || (CKeySym (&xev) == XK_Return && xev.type == KeyPress)) {
11405:1058:            if (replace_text) {
11406:1059:                replace_all = Cwidget ("replace.all")->keypressed;
11407:1060:                replace_prompt = Cwidget ("replace.pr")->keypressed;
11408:1061:                *replace_text = strdup (Cwidget ("replace.rinp")->text);
11409:1062:                *arg_order = strdup (Cwidget ("replace.ainp")->text);
11410:1063:            }
11411:1064:            *search_text = strdup (Cwidget ("replace.sinp")->text);
11412:1065:            replace_whole = Cwidget ("replace.ww")->keypressed;
11413:1066:            replace_case = Cwidget ("replace.case")->keypressed;
11414:1067:            replace_scanf = Cwidget ("replace.scanf")->keypressed;
11415:1068:            replace_regexp = Cwidget ("replace.reg")->keypressed;
11416:1069:            break;
11417:1070:        }
11418:1071:    }
11419:1072:    Cundrawwidget ("replace");
11420:1073:    CRestoreState (&s);
11421:1074:}
11422:1075:
11423:1076:
11424:1077:
11425:1078:void edit_search_dialog (WEdit * edit, char **search_text)
11426:1079:{
11427:1080:    edit_search_replace_dialog (CMain, 20, 20, search_text, 0, 0,
11428:1081:                                " Search ", 0);
11429:1082:}
11430:1083:
11431:1084:void edit_replace_dialog (WEdit * edit, char **search_text,
11432:1085:                          char **replace_text, char **arg_order)
11433:1086:{
11434:1087:    edit_search_replace_dialog (CMain, 20, 20, search_text, replace_text,
11435:1088:                                arg_order, " Replace ", 0);
11436:1089:}
11437:1090:
11438:1091:int edit_replace_prompt (WEdit * edit, char *replace_text, int xpos,
11439:1092:                         int ypos)
11440:1093:{
11441:1094:    if (replace_prompt) {
11442:1095:        int q;
11443:1096:        char *p, *r = 0;
11444:1097:        r = p = malloc (strlen (replace_text) + NUM_REPL_ARGS * 2);
11445:1098:        strcpy (p, replace_text);
11446:1099:        while ((p = strchr (p, '%'))) { /* convert "%" to "%%" so no convertion is attempted */
11447:1100:            memmove (p + 2, p + 1, strlen (p) + 1);
11448:1101:            *(++p) = '%';
11449:1102:            p++;
11450:1103:        }
11451:1104:        q = Cquerydialogue (CMain, 20, 20, " Replace ",
11452:1105:                            catstrs (" Replace with: ", r, 0), " Replace ",
11453:1106:                            " Skip ", " Replace all ", " Cancel ", NULL);
11454:1107:        if (r)
11455:1108:            free (r);
11456:1109:        switch (q) {
11457:1110:        case 0:
11458:1111:            return B_ENTER;
11459:1112:        case 1:
11460:1113:            return B_SKIP_REPLACE;
11461:1114:        case 2:
11462:1115:            return B_REPLACE_ALL;
11463:1116:        case 3:
11464:1117:            return B_CANCEL;
11465:1118:        }
11466:1119:    }
11467:1120:    return 0;
11468:1121:}
11469:1122:
11470:1123:
11471:1124:
11472:1125:#endif
11473:1126:
11474:1127:#define lcase(c) (((c)>='A'&&(c)<='Z')?(c)-'A'+'a':(c))
11475:1128:
11476:1129:
11477:1130:long sargs[NUM_REPL_ARGS][256 / sizeof (long)];
11478:1131:
11479:1132:#define SCANF_ARGS sargs[0], sargs[1], sargs[2], sargs[3], \
11480:1133:                     sargs[4], sargs[5], sargs[6], sargs[7], \
11481:1134:                     sargs[8], sargs[9], sargs[10], sargs[11], \
11482:1135:                     sargs[12], sargs[13], sargs[14], sargs[15]
11483:1136:
11484:1137:#define PRINTF_ARGS sargs[argord[0]], sargs[argord[1]], sargs[argord[2]], sargs[argord[3]], \
11485:1138:                     sargs[argord[4]], sargs[argord[5]], sargs[argord[6]], sargs[argord[7]], \
11486:1139:                     sargs[argord[8]], sargs[argord[9]], sargs[argord[10]], sargs[argord[11]], \
11487:1140:                     sargs[argord[12]], sargs[argord[13]], sargs[argord[14]], sargs[argord[15]]
11488:1141:
11489:1142:/* This function is a modification of mc-3.2.10/src/view.c:regexp_view_search() */
11490:1143:/* returns -3 on error in pattern, -1 on not found, found_len = 0 if either */
11491:1144:int string_regexp_search (char *pattern, char *string, int len,
11492:1145:                          int match_type, int *found_len)
11493:1146:{
11494:1147:    static regex_t r;
11495:1148:    static char *old_pattern = NULL;
11496:1149:    static int old_type;
11497:1150:    int startpos;
11498:1151:
11499:1152:    if (!old_pattern || strcmp (old_pattern, pattern)
11500:1153:        || old_type != match_type) {
11501:1154:        if (old_pattern) {
11502:1155:            regfree (&r);
11503:1156:            free (old_pattern);
11504:1157:        }
11505:1158:        if (regcomp (&r, pattern, REG_EXTENDED | REG_NOSUB)) {
11506:1159:            *found_len = 0;
11507:1160:            return -3;
11508:1161:        }
11509:1162:        old_pattern = strdup (pattern);
11510:1163:        old_type = match_type;
11511:1164:    }
11512:1165:    startpos = re_search (&r, string, len, 0, len, NULL);
11513:1166:    if (startpos < 0) {
11514:1167:        *found_len = 0;
11515:1168:        return -1;
11516:1169:    }
11517:1170:    *found_len = re_match (&r, string, len, startpos, NULL);
11518:1171:    return startpos;
11519:1172:}
11520:1173:
11521:1174:
11522:1175:
11523:1176:long edit_find_string (long start, char *exp, int *len, long last_byte,
11524:1177:                       int (*get_byte) (void *, long), void *data)
11525:1178:{
11526:1179:    long p, q;
11527:1180:    long l = strlen (exp), f = 0;
11528:1181:    int n = 0;
11529:1182:
11530:1183:    *len = l;
11531:1184:
11532:1185:    for (p = 0; p < l; p++)     /* count conversions... */
11533:1186:        if (exp[p] == '%')
11534:1187:            if (exp[++p] != '%') /* ...except for "%%" */
11535:1188:                n++;
11536:1189:
11537:1190:    if ((n && replace_scanf) || replace_regexp) {
11538:1191:        int c;
11539:1192:        char *buf, *mbuf;
11540:1193:
11541:1194:        replace_scanf = (!replace_regexp); /* can't have both */
11542:1195:
11543:1196:        if (!replace_regexp)
11544:1197:            if (n > NUM_REPL_ARGS - 1)
11545:1198:                return -2;
11546:1199:        buf = malloc (MAX_REPL_LEN * 2 + 2);
11547:1200:        mbuf = buf;
11548:1201:        if (!replace_case)
11549:1202:            for (p = 0; exp[p] != 0; p++)
11550:1203:                exp[p] = lcase (exp[p]);
11551:1204:
11552:1205:        if (replace_case) {
11553:1206:            for (p = start; p < last_byte && p < start + MAX_REPL_LEN; p++)
11554:1207:                buf[p - start] = (*get_byte) (data, p);
11555:1208:        } else {
11556:1209:            for (p = start; p < last_byte && p < start + MAX_REPL_LEN; p++) {
11557:1210:                c = (*get_byte) (data, p);
11558:1211:                buf[p - start] = lcase (c);
11559:1212:            }
11560:1213:        }
11561:1214:
11562:1215:        buf[(q = p - start)] = 0;
11563:1216:
11564:1217:        if (!replace_regexp)
11565:1218:            exp = catstrs (exp, "%n", 0);
11566:1219:
11567:1220:        while (*buf) {
11568:1221:            if (replace_regexp) {
11569:1222:                if (buf == mbuf || buf == mbuf + MAX_REPL_LEN / 2) { /* search the window after it moves half its length */
11570:1223:                    int found_start =
11571:1224:                        string_regexp_search (exp, buf, q, match_normal,
11572:1225:                                              len);
11573:1226:                    if (found_start == -3)
11574:1227:                        return -3;
11575:1228:                    if (*len)
11576:1229:                        return found_start + start;
11577:1230:                }
11578:1231:            } else {
11579:1232:                if (n == sscanf (buf, exp, SCANF_ARGS)) {
11580:1233:                    *len = *((int *) sargs[n]);
11581:1234:                    return start;
11582:1235:                }
11583:1236:            }
11584:1237:            if (q + start < last_byte) {
11585:1238:                if (replace_case) {
11586:1239:                    buf[q] = (*get_byte) (data, q + start);
11587:1240:                } else {
11588:1241:                    c = (*get_byte) (data, q + start);
11589:1242:                    buf[q] = lcase (c);
11590:1243:                }
11591:1244:                q++;
11592:1245:            }
11593:1246:            buf[q] = 0;
11594:1247:            start++;
11595:1248:            buf++;              /* move the window along */
11596:1249:            if (buf == mbuf + MAX_REPL_LEN) { /* the window is about to go past the end of allocated memory, so... */
11597:1250:                memmove (mbuf, buf, strlen (buf) + 1); /* reset it */
11598:1251:                buf = mbuf;
11599:1252:            }
11600:1253:            q--;
11601:1254:        }
11602:1255:        free (mbuf);
11603:1256:    } else {
11604:1257:        if (replace_case) {
11605:1258:            for (p = start; p <= last_byte - l; p++) {
11606:1259:                if ((*get_byte) (data, p) == exp[0]) { /* check if first char matches */
11607:1260:                    for (f = 0, q = 0; q < l && f < 1; q++)
11608:1261:                        if ((*get_byte) (data, q + p) != exp[q])
11609:1262:                            f = 1;
11610:1263:                    if (f == 0)
11611:1264:                        return p;
11612:1265:                }
11613:1266:            }
11614:1267:        } else {
11615:1268:            for (p = 0; exp[p] != 0; p++)
11616:1269:                exp[p] = lcase (exp[p]);
11617:1270:
11618:1271:            for (p = start; p <= last_byte - l; p++) {
11619:1272:                if (lcase ((*get_byte) (data, p)) == exp[0]) {
11620:1273:                    for (f = 0, q = 0; q < l && f < 1; q++)
11621:1274:                        if (lcase ((*get_byte) (data, q + p)) != exp[q])
11622:1275:                            f = 1;
11623:1276:                    if (f == 0)
11624:1277:                        return p;
11625:1278:                }
11626:1279:            }
11627:1280:        }
11628:1281:    }
11629:1282:    return -2;
11630:1283:}
11631:1284:
11632:1285:
11633:1286:long edit_find (long search_start, char *exp, int *len, long last_byte,
11634:1287:                int (*get_byte) (void *, long), void *data)
11635:1288:{                               /*front end to find_string to check for
11636:1289:                                   whole words */
11637:1290:    long p;
11638:1291:    p = search_start;
11639:1292:
11640:1293:    while ((p =
11641:1294:            edit_find_string (p, exp, len, last_byte, get_byte,
11642:1295:                              data)) >= 0) {
11643:1296:        if (replace_whole) {
11644:1297:/*If the bordering chars are not in option_whole_chars_search then word is whole */
11645:1298:            if (!strcasechr
11646:1299:                (option_whole_chars_search, (*get_byte) (data, p - 1))
11647:1300:                && !strcasechr (option_whole_chars_search,
11648:1301:                                (*get_byte) (data, p + *len)))
11649:1302:                return p;
11650:1303:        } else
11651:1304:            return p;
11652:1305:        p++;                    /*not a whole word so continue search. */
11653:1306:    }
11654:1307:    return p;
11655:1308:}
11656:1309:
11657:1310:#define is_digit(x) ((x) >= '0' && (x) <= '9')
11658:1311:
11659:1312:#define snprintf(v) { \
11660:1313:                *p1++ = *p++; \
11661:1314:                *p1++ = '%'; \
11662:1315:                *p1++ = 'n'; \
11663:1316:                *p1 = '\0'; \
11664:1317:                sprintf(s,q1,v,&n); \
11665:1318:                s += n; \
11666:1319:            }
11667:1320:
11668:1321:/* this function uses the sprintf command to do a vprintf */
11669:1322:/* it takes pointers to arguments instead of the arguments themselves */
11670:1323:int sprintf_p (char *str, const char *fmt, ...)
11671:1324:{
11672:1325:    va_list ap;
11673:1326:    int n;
11674:1327:    char *q, *p, *s = str;
11675:1328:    char q1[32];
11676:1329:    char *p1;
11677:1330:
11678:1331:    va_start (ap, fmt);
11679:1332:    p = q = (char *) fmt;
11680:1333:
11681:1334:    while ((p = strchr (p, '%'))) {
11682:1335:        n = (int) ((unsigned long) p - (unsigned long) q);
11683:1336:        strncpy (s, q, n);      /* copy stuff between format specifiers */
11684:1337:        s += n;
11685:1338:        *s = 0;
11686:1339:        q = p;
11687:1340:        p1 = q1;
11688:1341:        *p1++ = *p++;
11689:1342:        if (*p == '%') {
11690:1343:            p++;
11691:1344:            *s++ = '%';
11692:1345:            q = p;
11693:1346:            continue;
11694:1347:        }
11695:1348:        if (*p == 'n') {
11696:1349:            p++;
11697:1350:/* do nothing */
11698:1351:            q = p;
11699:1352:            continue;
11700:1353:        }
11701:1354:        if (*p == '#')
11702:1355:            *p1++ = *p++;
11703:1356:        if (*p == '0')
11704:1357:            *p1++ = *p++;
11705:1358:        if (*p == '-')
11706:1359:            *p1++ = *p++;
11707:1360:        if (*p == '+')
11708:1361:            *p1++ = *p++;
11709:1362:        if (*p == '*') {
11710:1363:            p++;
11711:1364:            strcpy (p1, itoa (*va_arg (ap, int *))); /* replace field width with a number */
11712:1365:            p1 += strlen (p1);
11713:1366:        } else {
11714:1367:            while (is_digit (*p))
11715:1368:                *p1++ = *p++;
11716:1369:        }
11717:1370:        if (*p == '.')
11718:1371:            *p1++ = *p++;
11719:1372:        if (*p == '*') {
11720:1373:            p++;
11721:1374:            strcpy (p1, itoa (*va_arg (ap, int *))); /* replace precision with a number */
11722:1375:            p1 += strlen (p1);
11723:1376:        } else {
11724:1377:            while (is_digit (*p))
11725:1378:                *p1++ = *p++;
11726:1379:        }
11727:1380:/* flags done, now get argument */
11728:1381:        if (*p == 's') {
11729:1382:            snprintf (va_arg (ap, char *));
11730:1383:        } else if (*p == 'h') {
11731:1384:            if (strchr ("diouxX", *p))
11732:1385:                snprintf (*va_arg (ap, short *));
11733:1386:        } else if (*p == 'l') {
11734:1387:            *p1++ = *p++;
11735:1388:            if (strchr ("diouxX", *p))
11736:1389:                snprintf (*va_arg (ap, long *));
11737:1390:        } else if (strchr ("cdiouxX", *p)) {
11738:1391:            snprintf (*va_arg (ap, int *));
11739:1392:        } else if (*p == 'L') {
11740:1393:            *p1++ = *p++;
11741:1394:            if (strchr ("EefgG", *p))
11742:1395:                snprintf (*va_arg (ap, long double *));
11743:1396:        } else if (strchr ("EefgG", *p)) {
11744:1397:            snprintf (*va_arg (ap, double *));
11745:1398:        } else if (strchr ("DOU", *p)) {
11746:1399:            snprintf (*va_arg (ap, long *));
11747:1400:        } else if (*p == 'p') {
11748:1401:            snprintf (*va_arg (ap, void **));
11749:1402:        }
11750:1403:        q = p;
11751:1404:    }
11752:1405:    va_end (ap);
11753:1406:    sprintf (s, q);             /* print trailing leftover */
11754:1407:    return (unsigned long) s - (unsigned long) str + strlen (s);
11755:1408:}
11756:1409:
11757:1410:static void regexp_error (WEdit * edit)
11758:1411:{
11759:1412:    Cerrordialogue (edit->widget->winid, 20, 20, " Error ",
11760:1413:                    " Invalid regular expression ");
11761:1414:}
11762:1415:
11763:1416:void edit_replace_cmd (WEdit * edit, int again)
11764:1417:{
11765:1418:    static char *old1 = NULL;
11766:1419:    static char *old2 = NULL;
11767:1420:    static char *old3 = NULL;
11768:1421:    char *exp1 = "";
11769:1422:    char *exp2 = "";
11770:1423:    char *exp3 = "";
11771:1424:    int replace_yes;
11772:1425:    int replace_continue;
11773:1426:    int i = 0;
11774:1427:    long times_replaced = 0;
11775:1428:    char fin_string[32];
11776:1429:    int argord[NUM_REPL_ARGS];
11777:1430:
11778:1431:    edit->force |= REDRAW_COMPLETELY;
11779:1432:
11780:1433:    exp1 = old1 ? old1 : exp1;
11781:1434:    exp2 = old2 ? old2 : exp2;
11782:1435:    exp3 = old3 ? old3 : exp3;
11783:1436:
11784:1437:    if (again) {
11785:1438:        if (!old1 || !old2)
11786:1439:            return;
11787:1440:        exp1 = strdup (old1);
11788:1441:        exp2 = strdup (old2);
11789:1442:        exp3 = strdup (old3);
11790:1443:    } else {
11791:1444:        push_action (edit, KEY_PRESS + edit->start_display);
11792:1445:        edit_replace_dialog (edit, &exp1, &exp2, &exp3);
11793:1446:    }
11794:1447:
11795:1448:    if (!exp1 || !*exp1) {
11796:1449:        edit->force = REDRAW_COMPLETELY;
11797:1450:        if (exp1) {
11798:1451:            free (exp1);
11799:1452:            free (exp2);
11800:1453:            free (exp3);
11801:1454:        }
11802:1455:        return;
11803:1456:    }
11804:1457:    if (old1)
11805:1458:        free (old1);
11806:1459:    if (old2)
11807:1460:        free (old2);
11808:1461:    if (old3)
11809:1462:        free (old3);
11810:1463:    old1 = strdup (exp1);
11811:1464:    old2 = strdup (exp2);
11812:1465:    old3 = strdup (exp3);
11813:1466:
11814:1467:    {
11815:1468:        char *s;
11816:1469:        int ord, i;
11817:1470:        while ((s = strchr (exp3, ' ')))
11818:1471:            memmove (s, s + 1, strlen (s));
11819:1472:        s = exp3;
11820:1473:        for (i = 0; i < NUM_REPL_ARGS; i++) {
11821:1474:            if ((unsigned long) s != 1 && s < exp3 + strlen (exp3)) {
11822:1475:                if ((ord = atoi (s)))
11823:1476:                    argord[i] = ord - 1;
11824:1477:                else
11825:1478:                    argord[i] = i;
11826:1479:                s = strchr (s, ',') + 1;
11827:1480:            } else
11828:1481:                argord[i] = i;
11829:1482:        }
11830:1483:    }
11831:1484:
11832:1485:    replace_continue = replace_all;
11833:1486:
11834:1487:    do {
11835:1488:        int len = 0;
11836:1489:        long new_start;
11837:1490:        new_start =
11838:1491:            edit_find (edit->search_start, exp1, &len, edit->last_byte,
11839:1492:                       (int (*)(void *, long)) edit_get_byte,
11840:1493:                       (void *) edit);
11841:1494:/*
11842:1495:long edit_find (long search_start, char *exp, int *len, long last_byte, int (*get_byte) (void *, long index), void *data)
11843:1496:*/
11844:1497:        if (new_start == -3) {
11845:1498:            regexp_error (edit);
11846:1499:            break;
11847:1500:        }
11848:1501:        edit->search_start = new_start;
11849:1502:        /*returns negative on not found or error in pattern */
11850:1503:
11851:1504:        if (edit->search_start >= 0) {
11852:1505:            edit->found_start = edit->search_start;
11853:1506:            i = edit->found_len = len;
11854:1507:
11855:1508:            edit_cursor_move (edit, edit->search_start - edit->curs1);
11856:1509:            edit_scroll_screen_over_cursor (edit);
11857:1510:
11858:1511:            replace_yes = 1;
11859:1512:
11860:1513:            if (replace_prompt) {
11861:1514:                int l;
11862:1515:                l = edit->curs_row - edit->num_widget_lines / 3;
11863:1516:                if (l > 0)
11864:1517:                    edit_scroll_downward (edit, l);
11865:1518:                if (l < 0)
11866:1519:                    edit_scroll_upward (edit, -l);
11867:1520:
11868:1521:                edit_scroll_screen_over_cursor (edit);
11869:1522:                edit->force |= REDRAW_PAGE;
11870:1523:                edit_render_keypress (edit);
11871:1524:
11872:1525:                /*so that undo stops at each query */
11873:1526:                push_key_press (edit);
11874:1527:
11875:1528:                switch (edit_replace_prompt (edit, exp2, /*and prompt 2/3 down */
11876:1529:                                             edit->num_widget_columns / 2 -
11877:1530:                                             33,
11878:1531:                                             edit->num_widget_lines * 2 /
11879:1532:                                             3)) {
11880:1533:                case B_ENTER:
11881:1534:                    break;
11882:1535:                case B_SKIP_REPLACE:
11883:1536:                    replace_yes = 0;
11884:1537:                    break;
11885:1538:                case B_REPLACE_ALL:
11886:1539:                    replace_prompt = 0;
11887:1540:                    replace_continue = 1;
11888:1541:                    break;
11889:1542:                case B_CANCEL:
11890:1543:                    replace_yes = 0;
11891:1544:                    replace_continue = 0;
11892:1545:                    break;
11893:1546:                }
11894:1547:            }
11895:1548:            if (replace_yes) {  /* delete then insert new */
11896:1549:                if (replace_scanf) {
11897:1550:                    char repl_str[MAX_REPL_LEN + 2];
11898:1551:                    if (sprintf_p (repl_str, exp2, PRINTF_ARGS) >= 0) {
11899:1552:                        times_replaced++;
11900:1553:                        while (i--)
11901:1554:                            edit_delete (edit);
11902:1555:                        while (repl_str[++i])
11903:1556:                            edit_insert (edit, repl_str[i]);
11904:1557:                    } else {
11905:1558:                        Cerrordialogue (edit->widget->winid, 20, 20,
11906:1559:                                        " Replace ",
11907:1560:                                        " Error in replacement format string. ");
11908:1561:                        replace_continue = 0;
11909:1562:                    }
11910:1563:                } else {
11911:1564:                    times_replaced++;
11912:1565:                    while (i--)
11913:1566:                        edit_delete (edit);
11914:1567:                    while (exp2[++i])
11915:1568:                        edit_insert (edit, exp2[i]);
11916:1569:                }
11917:1570:                edit->found_len = i;
11918:1571:            }
11919:1572:            edit->search_start += i; /*so that we don't find the same string again */
11920:1573:            edit_scroll_screen_over_cursor (edit);
11921:1574:        } else {
11922:1575:            edit->search_start = edit->curs1; /* try and find from right here for next search */
11923:1576:            update_curs_col (edit);
11924:1577:
11925:1578:            edit->force |= REDRAW_PAGE;
11926:1579:            edit_render_keypress (edit);
11927:1580:            if (times_replaced) {
11928:1581:                sprintf (fin_string, " %ld replacements made. ",
11929:1582:                         times_replaced);
11930:1583:                Cmessagedialogue (edit->widget->winid, 20, 20, " Replace ",
11931:1584:                                  fin_string);
11932:1585:            } else
11933:1586:                Cmessagedialogue (edit->widget->winid, 20, 20, " Replace ",
11934:1587:                                  " Search string not found. ");
11935:1588:            replace_continue = 0;
11936:1589:        }
11937:1590:    } while (replace_continue);
11938:1591:
11939:1592:    free (exp1);
11940:1593:    free (exp2);
11941:1594:    free (exp3);
11942:1595:    edit->force = REDRAW_COMPLETELY;
11943:1596:    edit_scroll_screen_over_cursor (edit);
11944:1597:}
11945:1598:
11946:1599:
11947:1600:
11948:1601:
11949:1602:void edit_search_cmd (WEdit * edit, int again)
11950:1603:{
11951:1604:    static char *old = NULL;
11952:1605:    char *exp = "";
11953:1606:
11954:1607:    exp = old ? old : exp;
11955:1608:    if (again) {                /*ctrl-hotkey for search again. */
11956:1609:        if (!old)
11957:1610:            return;
11958:1611:        exp = strdup (old);
11959:1612:    } else {
11960:1613:        edit_search_dialog (edit, &exp);
11961:1614:        push_action (edit, KEY_PRESS + edit->start_display);
11962:1615:    }
11963:1616:
11964:1617:    if (exp) {
11965:1618:        if (*exp) {
11966:1619:            int len = 0;
11967:1620:            if (old)
11968:1621:                free (old);
11969:1622:            old = strdup (exp);
11970:1623:
11971:1624:            edit->search_start =
11972:1625:                edit_find (edit->search_start, exp, &len, edit->last_byte,
11973:1626:                           (int (*)(void *, long)) edit_get_byte,
11974:1627:                           (void *) edit);
11975:1628:
11976:1629:            if (edit->search_start >= 0) {
11977:1630:                edit->found_start = edit->search_start;
11978:1631:                edit->found_len = len;
11979:1632:
11980:1633:                edit_cursor_move (edit, edit->search_start - edit->curs1);
11981:1634:                edit_scroll_screen_over_cursor (edit);
11982:1635:
11983:1636:                edit->search_start++;
11984:1637:            } else if (edit->search_start == -3) {
11985:1638:                edit->search_start = edit->curs1;
11986:1639:                regexp_error (edit);
11987:1640:            } else {
11988:1641:                edit->search_start = edit->curs1;
11989:1642:                Cerrordialogue (edit->widget->winid, 20, 20, " Search ",
11990:1643:                                " Search search string not found. ");
11991:1644:            }
11992:1645:        }
11993:1646:        free (exp);
11994:1647:    }
11995:1648:    edit->force |= REDRAW_COMPLETELY;
11996:1649:    edit_scroll_screen_over_cursor (edit);
11997:1650:}
11998:1651:
11999:1652:
12000:1653:/* Real edit only */
12001:1654:void edit_quit_cmd (WEdit * edit)
12002:1655:{
12003:1656:    push_action (edit, KEY_PRESS + edit->start_display);
12004:1657:
12005:1658:    edit->force |= REDRAW_COMPLETELY;
12006:1659:    if (edit->modified) {
12007:1660:#ifdef MIDNIGHT
12008:1661:        switch (query_dialog
12009:1662:                (" Quit ", " File was modified, Save with exit? ", 0, 3,
12010:1663:                 " Cancel quit ", " Yes ", " No ")) {
12011:1664:#else
12012:1665:        switch (Cquerydialogue
12013:1666:                (edit->widget->winid, 20, 20, " Quit ",
12014:1667:                 " Current text was modified without a file save. \n Save with exit? ",
12015:1668:                 " Cancel quit ", " Yes ", " No ", NULL)) {
12016:1669:#endif
12017:1670:        case 1:
12018:1671:            edit_push_markers (edit);
12019:1672:            edit_set_markers (edit, 0, 0);
12020:1673:            if (!edit_save_cmd (edit))
12021:1674:                return;
12022:1675:        case 2:
12023:1676:#ifdef MIDNIGHT
12024:1677:            edit->widget.parent->running = 0;
12025:1678:#else
12026:1679:            edit->stopped = 1;
12027:1680:#endif
12028:1681:            return;
12029:1682:        case 0:
12030:1683:            return;
12031:1684:        }
12032:1685:    } else
12033:1686:#ifdef MIDNIGHT
12034:1687:        edit->widget.parent->running = 0;
12035:1688:#else
12036:1689:        edit->stopped = 1;
12037:1690:#endif
12038:1691:}
12039:1692:
12040:1693:#define TEMP_BUF_LEN 1024
12041:1694:
12042:1695:/* returns a null terminated length of text. Result must be free'd */
12043:1696:unsigned char *edit_get_block (WEdit * edit, long start, long finish)
12044:1697:{
12045:1698:    unsigned char *s, *r;
12046:1699:    r = s = malloc (finish - start + 1);
12047:1700:    while (start < finish)
12048:1701:        *s++ = edit_get_byte (edit, start++);
12049:1702:    *s = 0;
12050:1703:    return r;
12051:1704:}
12052:1705:
12053:1706:/* save block, returns 1 on success */
12054:1707:int edit_save_block (WEdit * edit, const char *filename, long start,
12055:1708:                     long finish)
12056:1709:{
12057:1710:    long i = start, end, filelen = finish - start;
12058:1711:    int file;
12059:1712:    unsigned char *buf;
12060:1713:
12061:1714:#ifdef MIDNIGHT
12062:1715:    if ((file =
12063:1716:         mc_open ((char *) filename, O_CREAT | O_WRONLY | O_TRUNC,
12064:1717:                  S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
12065:1718:        return 0;
12066:1719:#else
12067:1720:    if ((file = open ((char *) filename, O_WRONLY | O_TRUNC)) == -1)
12068:1721:        if ((file =
12069:1722:             creat ((char *) filename,
12070:1723:                    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
12071:1724:            return 0;
12072:1725:#endif
12073:1726:
12074:1727:    buf = malloc (TEMP_BUF_LEN);
12075:1728:    while (start != finish) {
12076:1729:        end = min (finish, start + TEMP_BUF_LEN);
12077:1730:        for (; i < end; i++)
12078:1731:            buf[i - start] = edit_get_byte (edit, i);
12079:1732:        filelen -= write (file, (char *) buf, end - start);
12080:1733:        start = end;
12081:1734:    }
12082:1735:    free (buf);
12083:1736:    close (file);
12084:1737:    if (filelen)
12085:1738:        return 0;
12086:1739:    return 1;
12087:1740:}
12088:1741:
12089:1742:#ifndef MIDNIGHT
12090:1743:
12091:1744:/* copies a block to the XWindows buffer */
12092:1745:static int edit_XStore_block (WEdit * edit, long start, long finish)
12093:1746:{
12094:1747:    unsigned long len = finish - start, i;
12095:1748:    char *buf;
12096:1749:
12097:1750:    buf = malloc (len);
12098:1751:    if (buf) {
12099:1752:        for (i = 0; i < len; i++, start++)
12100:1753:            buf[i] = edit_get_byte (edit, start);
12101:1754:        XStoreBytes (CDisplay, buf, (int) len); /* note that XStoreBytes takes an integer length */
12102:1755:        free (buf);
12103:1756:        return 0;
12104:1757:    } else
12105:1758:        return 1;
12106:1759:}
12107:1760:
12108:1761:int edit_copy_to_X_buf_cmd (WEdit * edit)
12109:1762:{
12110:1763:    long start_mark, end_mark;
12111:1764:    if (eval_marks (edit, &start_mark, &end_mark))
12112:1765:        return 0;
12113:1766:    if (edit_XStore_block (edit, start_mark, end_mark)) {
12114:1767:        Cerrordialogue (edit->widget->winid, 20, 20,
12115:1768:                        " Copy to X clipboard ",
12116:1769:                        " Block to big, cannot allocate memory. ");
12117:1770:        return 1;
12118:1771:    }
12119:1772:    edit_mark_cmd (edit, 1);
12120:1773:    return 0;
12121:1774:}
12122:1775:
12123:1776:int edit_cut_to_X_buf_cmd (WEdit * edit)
12124:1777:{
12125:1778:    long start_mark, end_mark;
12126:1779:    if (eval_marks (edit, &start_mark, &end_mark))
12127:1780:        return 0;
12128:1781:    if (edit_XStore_block (edit, start_mark, end_mark)) {
12129:1782:        Cerrordialogue (edit->widget->winid, 20, 20,
12130:1783:                        " Copy to X clipboard ",
12131:1784:                        " Block to big, cannot allocate memory. ");
12132:1785:        return 1;
12133:1786:    }
12134:1787:    edit_block_delete_cmd (edit);
12135:1788:    edit_mark_cmd (edit, 1);
12136:1789:    return 0;
12137:1790:}
12138:1791:
12139:1792:void paste_from_X_buf_cmd (WEdit * edit)
12140:1793:{
12141:1794:    char *s;
12142:1795:    int nbytes;
12143:1796:
12144:1797:    s = XFetchBytes (CDisplay, &nbytes);
12145:1798:    if (s && nbytes) {
12146:1799:        int i;
12147:1800:        for (i = nbytes - 1; i >= 0; i--) /* last byte first or else we'll write everything backwards */
12148:1801:            edit_insert_ahead (edit, s[i]);
12149:1802:        XFree (s);
12150:1803:    }
12151:1804:    edit->force |= REDRAW_PAGE;
12152:1805:}
12153:1806:
12154:1807:#else                           /* MIDNIGHT */
12155:1808:
12156:1809:/* copies a block to clipboard file */
12157:1810:static int edit_XStore_block (WEdit * edit, long start, long finish)
12158:1811:{
12159:1812:    return edit_save_block (edit, catstrs (home_dir, CLIP_FILE, 0), start,
12160:1813:                            finish);
12161:1814:}
12162:1815:
12163:1816:int edit_copy_to_X_buf_cmd (WEdit * edit)
12164:1817:{
12165:1818:    long start_mark, end_mark;
12166:1819:    if (eval_marks (edit, &start_mark, &end_mark))
12167:1820:        return 0;
12168:1821:    if (!edit_XStore_block (edit, start_mark, end_mark)) {
12169:1822:        Cerrordialogue (edit->widget->winid, 20, 20, " Copy to clipboard ",
12170:1823:                        get_sys_error (" Unable to save to file. "));
12171:1824:        return 1;
12172:1825:    }
12173:1826:    edit_mark_cmd (edit, 1);
12174:1827:    return 0;
12175:1828:}
12176:1829:
12177:1830:int edit_cut_to_X_buf_cmd (WEdit * edit)
12178:1831:{
12179:1832:    long start_mark, end_mark;
12180:1833:    if (eval_marks (edit, &start_mark, &end_mark))
12181:1834:        return 0;
12182:1835:    if (!edit_XStore_block (edit, start_mark, end_mark)) {
12183:1836:        Cerrordialogue (edit->widget->winid, 20, 20, " Cut to clipboard ",
12184:1837:                        " Unable to save to file. ");
12185:1838:        return 1;
12186:1839:    }
12187:1840:    edit_block_delete_cmd (edit);
12188:1841:    edit_mark_cmd (edit, 1);
12189:1842:    return 0;
12190:1843:}
12191:1844:
12192:1845:void paste_from_X_buf_cmd (WEdit * edit)
12193:1846:{
12194:1847:    edit_insert_file (edit, catstrs (home_dir, CLIP_FILE, 0));
12195:1848:}
12196:1849:
12197:1850:#endif                          /* MIDMIGHT */
12198:1851:
12199:1852:void edit_goto_cmd (WEdit * edit)
12200:1853:{
12201:1854:    char *f;
12202:1855:    static int l = 0;
12203:1856:#ifdef MIDNIGHT
12204:1857:    char s[12];
12205:1858:    sprintf (s, "%d", l);
12206:1859:    f = input_dialog (" Goto line ", " Enter line: ", l ? s : "");
12207:1860:#else
12208:1861:    f = Cinputdialog (edit->widget->winid, 20, 20, 150, l ? itoa (l) : "",
12209:1862:                      " Goto line ", " Enter line: ");
12210:1863:#endif
12211:1864:    if (f) {
12212:1865:        if (*f) {
12213:1866:            l = atoi (f);
12214:1867:            edit_move_display (edit, l - edit->num_widget_lines / 2 - 1);
12215:1868:            edit_move_to_line (edit, l - 1);
12216:1869:            edit->force |= REDRAW_COMPLETELY;
12217:1870:            free (f);
12218:1871:        }
12219:1872:    }
12220:1873:}
12221:1874:
12222:1875:/*returns 1 on success */
12223:1876:int edit_save_block_cmd (WEdit * edit)
12224:1877:{
12225:1878:    long start_mark, end_mark;
12226:1879:    char *exp;
12227:1880:    if (eval_marks (edit, &start_mark, &end_mark))
12228:1881:        return 1;
12229:1882:
12230:1883:    exp =
12231:1884:        Cgetsavefile (edit->widget->winid, 40, 40, edit->dir,
12232:1885:                      catstrs (home_dir, CLIP_FILE, 0), " Save Block ");
12233:1886:
12234:1887:    edit->force |= REDRAW_COMPLETELY;
12235:1888:    push_action (edit, KEY_PRESS + edit->start_display);
12236:1889:
12237:1890:    if (exp) {
12238:1891:        if (!*exp) {
12239:1892:            free (exp);
12240:1893:            return 0;
12241:1894:        } else {
12242:1895:            if (edit_save_block (edit, exp, start_mark, end_mark)) {
12243:1896:                free (exp);
12244:1897:                edit->force |= REDRAW_COMPLETELY;
12245:1898:                return 1;
12246:1899:            } else {
12247:1900:                free (exp);
12248:1901:                edit->force |= REDRAW_COMPLETELY;
12249:1902:                Cerrordialogue (edit->widget->winid, 20, 20,
12250:1903:                                " Save Block ",
12251:1904:                                get_sys_error
12252:1905:                                (" Error trying to save file. "));
12253:1906:                return 0;
12254:1907:            }
12255:1908:        }
12256:1909:    } else
12257:1910:        return 0;
12258:1911:}
12259:1912:
12260:1913:
12261:1914:/* inserts a file at the cursor, returns 1 on success */
12262:1915:int edit_insert_file (WEdit * edit, const char *filename)
12263:1916:{
12264:1917:    int i, file, blocklen;
12265:1918:    long current = edit->curs1;
12266:1919:    unsigned char *buf;
12267:1920:
12268:1921:    if ((file = open ((char *) filename, O_RDONLY)) == -1)
12269:1922:        return 0;
12270:1923:    buf = malloc (TEMP_BUF_LEN);
12271:1924:    while ((blocklen = read (file, (char *) buf, TEMP_BUF_LEN)) > 0) {
12272:1925:        for (i = 0; i < blocklen; i++)
12273:1926:            edit_insert (edit, buf[i]);
12274:1927:    }
12275:1928:    edit_cursor_move (edit, current - edit->curs1);
12276:1929:    free (buf);
12277:1930:    close (file);
12278:1931:    if (blocklen)
12279:1932:        return 0;
12280:1933:    return 1;
12281:1934:}
12282:1935:
12283:1936:
12284:1937:/* returns 1 on success */
12285:1938:int edit_insert_file_cmd (WEdit * edit)
12286:1939:{
12287:1940:    char *exp =
12288:1941:        Cgetloadfile (edit->widget->winid, 40, 40, edit->dir,
12289:1942:                      catstrs (home_dir, CLIP_FILE, 0), " Insert File ");
12290:1943:    edit->force |= REDRAW_COMPLETELY;
12291:1944:
12292:1945:    push_action (edit, KEY_PRESS + edit->start_display);
12293:1946:
12294:1947:    if (exp) {
12295:1948:        if (!*exp) {
12296:1949:            free (exp);
12297:1950:            return 0;
12298:1951:        } else {
12299:1952:            if (edit_insert_file (edit, exp)) {
12300:1953:                free (exp);
12301:1954:                return 1;
12302:1955:            } else {
12303:1956:                free (exp);
12304:1957:                Cerrordialogue (edit->widget->winid, 20, 20,
12305:1958:                                " Insert file ",
12306:1959:                                get_sys_error
12307:1960:                                (" Error trying to insert file. "));
12308:1961:                return 0;
12309:1962:            }
12310:1963:        }
12311:1964:    } else
12312:1965:        return 0;
12313:1966:}
12314:1967:
12315:1968:/* sorts a block, returns -1 on system fail, 1 on cancel and 0 on success */
12316:1969:int edit_sort_cmd (WEdit * edit)
12317:1970:{
12318:1971:    static char *old = 0;
12319:1972:    char *exp;
12320:1973:    long start_mark, end_mark;
12321:1974:    int e;
12322:1975:
12323:1976:    if (eval_marks (edit, &start_mark, &end_mark)) {
12324:1977:        Cerrordialogue (edit->widget->winid, 20, 20, " Process block ",
12325:1978:                        " You must first highlight a block of text. ");
12326:1979:        return 0;
12327:1980:    }
12328:1981:    edit_save_block (edit, catstrs (home_dir, BLOCK_FILE, 0), start_mark,
12329:1982:                     end_mark);
12330:1983:
12331:1984:    exp = old ? old : "";
12332:1985:
12333:1986:#ifdef MIDNIGHT
12334:1987:    exp =
12335:1988:        input_dialog (" Run Sort ",
12336:1989:                      " Enter sort options (see manpage) separated by whitespace: ",
12337:1990:                      "");
12338:1991:#else
12339:1992:    exp =
12340:1993:        Cinputdialog (0, 0, 0, 200, exp, " Run Sort ",
12341:1994:                      " Enter sort options (see manpage) separated by whitespace: ");
12342:1995:#endif
12343:1996:
12344:1997:    if (!exp)
12345:1998:        return 1;
12346:1999:    if (old)
12347:2000:        free (old);
12348:2001:    old = exp;
12349:2002:
12350:2003:#ifdef MIDNIGHT
12351:2004:    e = system (catstrs
12352:2005:                (" sort ", exp, " ", home_dir, BLOCK_FILE, " > ", home_dir,
12353:2006:                 TEMP_FILE, 0));
12354:2007:#else
12355:2008:    e = Csystem (catstrs
12356:2009:                 (" sort ", exp, " ", home_dir, BLOCK_FILE, " > ",
12357:2010:                  home_dir, TEMP_FILE, 0));
12358:2011:#endif
12359:2012:    if (e) {
12360:2013:        if (e == -1 || e == 127) {
12361:2014:            Cerrordialogue (edit->widget->winid, 20, 20, " Sort ",
12362:2015:                            get_sys_error
12363:2016:                            (" Error trying to execute sort command "));
12364:2017:        } else {
12365:2018:            char q[8];
12366:2019:            sprintf (q, "%d ", e);
12367:2020:            Cerrordialogue (edit->widget->winid, 20, 20, " Sort ",
12368:2021:                            catstrs (" Sort returned non-zero: ", q, 0));
12369:2022:        }
12370:2023:        return -1;
12371:2024:    }
12372:2025:
12373:2026:    edit->force |= REDRAW_COMPLETELY;
12374:2027:
12375:2028:    if (edit_block_delete_cmd (edit))
12376:2029:        return 1;
12377:2030:    edit_insert_file (edit, catstrs (home_dir, TEMP_FILE, 0));
12378:2031:    return 0;
12379:2032:}
12380:2033:
12381:2034:
12382:2035:/* if block is 1, a block must be highlighted and the shell command
12383:2036:   processes it. If block is 0 the shell command is a straight system
12384:2037:   command, that just produces some output which is to be inserted */
12385:2038:void edit_block_process_cmd (WEdit * edit, const char *shell_cmd,
12386:2039:                             int block)
12387:2040:{
12388:2041:    long start_mark, end_mark;
12389:2042:    struct stat s;
12390:2043:    char *f = NULL, *b = NULL;
12391:2044:
12392:2045:    if (block) {
12393:2046:        if (eval_marks (edit, &start_mark, &end_mark)) {
12394:2047:            Cerrordialogue (edit->widget->winid, 20, 20, " Process block ",
12395:2048:                            " You must first highlight a block of text. ");
12396:2049:            return;
12397:2050:        }
12398:2051:        edit_save_block (edit, b =
12399:2052:                         catstrs (home_dir, BLOCK_FILE, 0), start_mark,
12400:2053:                         end_mark);
12401:2054:#ifdef MIDNIGHT
12402:2055:        my_system (0, shell, catstrs (home_dir, shell_cmd, 0));
12403:2056:#else
12404:2057:        Csystem (catstrs ("/bin/sh ", home_dir, shell_cmd, 0));
12405:2058:#endif
12406:2059:    } else {
12407:2060:#ifdef MIDNIGHT
12408:2061:        my_system (0, shell, shell_cmd);
12409:2062:#else
12410:2063:        Csystem (catstrs ("/bin/sh ", home_dir, shell_cmd, 0));
12411:2064:#endif
12412:2065:    }
12413:2066:
12414:2067:    edit->force |= REDRAW_COMPLETELY;
12415:2068:
12416:2069:    f = catstrs (home_dir, ERROR_FILE, 0);
12417:2070:
12418:2071:    if (block) {
12419:2072:        if (stat (f, &s) == 0) {
12420:2073:            if (!s.st_size) {   /* no error messages */
12421:2074:                if (edit_block_delete_cmd (edit))
12422:2075:                    return;
12423:2076:                edit_insert_file (edit, b);
12424:2077:                return;
12425:2078:            } else {
12426:2079:#ifndef MIDNIGHT
12427:2080:                f = loadfile (f, 0);
12428:2081:                if (f) {        /* if the stat did not fail, niether should load file */
12429:2082:                    Ctextboxmessagedialog (CMain, 20, 20, 80, 25,
12430:2083:                                           catstrs (" Error messages of  ",
12431:2084:                                                    shell_cmd, " ", 0), f,
12432:2085:                                           0);
12433:2086:                    free (f);
12434:2087:                }
12435:2088:                return;
12436:2089:#else
12437:2090:                edit_insert_file (edit, f);
12438:2091:                return;
12439:2092:#endif
12440:2093:            }
12441:2094:        } else {
12442:2095:            Cerrordialogue (edit->widget->winid, 20, 20, " Process block ",
12443:2096:                            get_sys_error (" Error trying to stat file "));
12444:2097:            return;
12445:2098:        }
12446:2099:    }
12447:2100:}
12448:2101:
12449:2102:int edit_execute_command (WEdit * edit, int command,
12450:2103:                          int char_for_insertion);
12451:2104:
12452:2105:/* prints at the cursor */
12453:2106:/* returns the number of chars printed */
12454:2107:int edit_print_string (WEdit * e, const char *s)
12455:2108:{
12456:2109:    int i = 0;
12457:2110:    while (s[i])
12458:2111:        edit_execute_command (e, -1, s[i++]);
12459:2112:    e->force |= REDRAW_COMPLETELY;
12460:2113:    Cedit_update_screen (e);
12461:2114:    return i;
12462:2115:}
12463:2116:
12464:2117:int edit_printf (WEdit * e, const char *fmt, ...)
12465:2118:{
12466:2119:    int i;
12467:2120:    va_list pa;
12468:2121:    char s[1024];
12469:2122:    va_start (pa, fmt);
12470:2123:    sprintf (s, fmt, pa);
12471:2124:    i = edit_print_string (e, s);
12472:2125:    va_end (pa);
12473:2126:    return i;
12474:2127:}
12475:1:#ifndef __EDIT_CMD_DEF_H
12476:2:#define __EDIT_CMD_DEF_H
12477:3:
12478:4:/*  in the distant future, keyboards will be invented with a
12479:5:    seperate key for each one of these commands   *sigh*      */
12480:6:
12481:7:/* cursor movements */
12482:8:#define CK_No_Command                 -1
12483:9:#define CK_BackSpace                 1
12484:10:#define CK_Delete                 2
12485:11:#define CK_Return                 3
12486:12:#define CK_Page_Up                 4
12487:13:#define CK_Page_Down                 5
12488:14:#define CK_Left                 6
12489:15:#define CK_Right                 7
12490:16:#define CK_Word_Left                 8
12491:17:#define CK_Word_Right                 9
12492:18:#define CK_Up                         10
12493:19:#define CK_Down                 11
12494:20:#define CK_Home                        12
12495:21:#define CK_End                         13
12496:22:#define CK_Tab                         14
12497:23:#define CK_Undo                        15
12498:24:#define CK_Beginning_Of_Text    16
12499:25:#define CK_End_Of_Text                17
12500:26:#define CK_Scroll_Up                18
12501:27:#define CK_Scroll_Down                19
12502:28:#define CK_Enter                20
12503:29:#define CK_Begin_Page                21
12504:30:#define CK_End_Page                22
12505:31:#define CK_Delete_Word_Left        23
12506:32:#define CK_Delete_Word_Right        24
12507:33:
12508:34:
12509:35:/* file commands */
12510:36:#define CK_Save                 101
12511:37:#define CK_Load                 102
12512:38:#define CK_New                  103
12513:39:#define CK_Save_As                104
12514:40:
12515:41:/* block commands */
12516:42:#define CK_Mark                 201
12517:43:#define CK_Copy                 202
12518:44:#define CK_Move                 203
12519:45:#define CK_Remove                 204
12520:46:#define CK_Unmark                 206
12521:47:#define CK_Save_Block                207
12522:48:
12523:49:/* search and replace */
12524:50:#define CK_Find                        301
12525:51:#define CK_Find_Again                302
12526:52:#define CK_Replace                303
12527:53:#define CK_Replace_Again        304
12528:54:
12529:55:/* misc */
12530:56:#define CK_Insert_File                401
12531:57:#define CK_Exit                        402
12532:58:#define CK_Toggle_Insert        403
12533:59:#define CK_Help                        404
12534:60:#define CK_Date                        405
12535:61:#define CK_Refresh                406
12536:62:#define CK_Goto                        407
12537:63:#define CK_Delete_Line                408
12538:64:#define CK_Delete_To_Line_End        409
12539:65:#define CK_Run_Make                410
12540:66:#define CK_Man_Page                411
12541:67:#define CK_Sort                        412
12542:68:
12543:69:/* macro */
12544:70:#define CK_Begin_Record_Macro        501
12545:71:#define CK_End_Record_Macro        502
12546:72:
12547:73:/* highlight commands */
12548:74:#define CK_Page_Up_Highlight                 604
12549:75:#define CK_Page_Down_Highlight                 605
12550:76:#define CK_Left_Highlight                 606
12551:77:#define CK_Right_Highlight                 607
12552:78:#define CK_Word_Left_Highlight                 608
12553:79:#define CK_Word_Right_Highlight         609
12554:80:#define CK_Up_Highlight                 610
12555:81:#define CK_Down_Highlight                 611
12556:82:#define CK_Home_Highlight                612
12557:83:#define CK_End_Highlight                 613
12558:84:#define CK_Beginning_Of_Text_Highlight        614
12559:85:#define CK_End_Of_Text_Highlight        615
12560:86:#define CK_Begin_Page_Highlight                616
12561:87:#define CK_End_Page_Highlight                617
12562:88:#define CK_Scroll_Up_Highlight                618
12563:89:#define CK_Scroll_Down_Highlight        619
12564:90:
12565:91:/* X clipboard operations */
12566:92:
12567:93:#define CK_XStore                701
12568:94:#define CK_XCut                        702
12569:95:#define CK_XPaste                703
12570:96:
12571:97:
12572:98:/*
12573:99:   Process a block through a shell command: CK_Pipe_Block(i) executes shell_cmd[i].
12574:100:   shell_cmd[i] must process the file ~/cooledit.block and output ~/cooledit.block
12575:101:   which is then inserted into the text in place of the original block. shell_cmd[i] must
12576:102:   also produce a file homedir/cooledit.error . If this file is not empty an error will
12577:103:   have been assumed to have occured, and the block will not be replaced.
12578:104:   TODO: bring up a viewer to display the error message instead of inserting
12579:105:   it into the text, which is annoying.
12580:106: */
12581:107:#define CK_Pipe_Block(i)        (1000+(i))
12582:108:
12583:109:/* execute a macro */
12584:110:#define CK_Macro(i)                (2000+(i))
12585:111:#define CK_Last_Macro                CK_Macro(0x7FFF)
12586:112:
12587:113:#define SHELL_COMMANDS_i {"/cedit/edit.indent.rc", "/cedit/edit.spell.rc", "/cedit/edit.sort.rc", /* and so on */ 0};
12588:114:
12589:115:#endif
12590:1:/* editor text drawing.
12591:2:
12592:3:   Copyright (C) 1996 the Free Software Foundation
12593:4:
12594:5:   Authors: 1996 Paul Sheer
12595:6:
12596:7:   This program is free software; you can redistribute it and/or modify
12597:8:   it under the terms of the GNU General Public License as published by
12598:9:   the Free Software Foundation; either version 2 of the License, or
12599:10:   (at your option) any later version.
12600:11:
12601:12:   This program is distributed in the hope that it will be useful,
12602:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
12603:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
12604:15:   GNU General Public License for more details.
12605:16:
12606:17:   You should have received a copy of the GNU General Public License
12607:18:   along with this program; if not, write to the Free Software
12608:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
12609:20:
12610:21:#include <config.h>
12611:22:#include "edit.h"
12612:23:
12613:24:#define MAX_LINE_LEN 1024
12614:25:
12615:26:#ifndef MIDNIGHT
12616:27:#include "app_glob.c"
12617:28:#include "dirtools.h"
12618:29:#include "coollocal.h"
12619:30:#else
12620:31:#include "src/mad.h"
12621:32:#endif
12622:33:
12623:34:
12624:35:static void status_string (WEdit * edit, char *s, int w)
12625:36:{
12626:37:    int i;
12627:38:    char t[160];                /* 160 just to be sure */
12628:39:/* The field lengths just prevents the status line from shortening to much */
12629:40:    sprintf (t, "[%c%c%c%c] %2ld:%3ld+%2ld=%3ld/%3ld - *%-4ld/%4ldb=%3d",
12630:41:             edit->mark1 != edit->mark2 ? 'B' : '-',
12631:42:             edit->modified ? 'M' : '-', edit->macro_i < 0 ? '-' : 'R',
12632:43:             edit->overwrite == 0 ? '-' : 'O',
12633:44:             edit->curs_col, edit->start_line + 1, edit->curs_row,
12634:45:             edit->curs_line + 1, edit->total_lines + 1, edit->curs1,
12635:46:             edit->last_byte, edit->curs1 < edit->last_byte
12636:47:             ? edit_get_byte (edit, edit->curs1) : -1);
12637:48:    sprintf (s, "%.*s", w + 1, t);
12638:49:    i = strlen (s);
12639:50:    s[i] = ' ';
12640:51:    i = w;
12641:52:    do {
12642:53:        if (strchr (" +-*=/:b", s[i])) /* chop off the last word/number */
12643:54:            break;
12644:55:        s[i] = ' ';
12645:56:    } while (i--);
12646:57:    s[i] = ' ';
12647:58:    s[w] = 0;
12648:59:}
12649:60:
12650:61:
12651:62:#ifdef MIDNIGHT
12652:63:
12653:64:/* how to get as much onto the status line as is numerically possible :) */
12654:65:void edit_status (WEdit * edit)
12655:66:{
12656:67:    int w, i, t;
12657:68:    char *s;
12658:69:    w = edit->widget.cols - (edit->have_frame * 2);
12659:70:    s = malloc (w + 15);
12660:71:    if (w < 4)
12661:72:        w = 4;
12662:73:    memset (s, ' ', w);
12663:74:    attrset (SELECTED_COLOR);
12664:75:    if (w > 4) {
12665:76:        widget_move (edit, edit->have_frame, edit->have_frame);
12666:77:        i = w > 24 ? 18 : w - 6;
12667:78:        i = i < 13 ? 13 : i;
12668:79:        sprintf (s, "%s",
12669:80:                 name_trunc (edit->filename ? edit->filename : "", i));
12670:81:        i += strlen (s);
12671:82:        s[strlen (s)] = ' ';
12672:83:        t = w - 20;
12673:84:        if (t < 0)
12674:85:            t = 0;
12675:86:        status_string (edit, s + 20, t);
12676:87:    } else {
12677:88:        s[w] = 0;
12678:89:    }
12679:90:    printw ("%.*s", w, s);
12680:91:
12681:92:    attrset (NORMAL_COLOR);
12682:93:    free (s);
12683:94:}
12684:95:
12685:96:#else
12686:97:
12687:98:void edit_status (WEdit * edit)
12688:99:{
12689:100:    int w, i, t;
12690:101:    char *s;
12691:102:    w = edit->num_widget_columns - 1;
12692:103:    if (w < 0)
12693:104:        w = 0;
12694:105:/*    if (w > 70)
12695:106:   w = 70; */
12696:107:    s = malloc (3 * w / 2 + 80);
12697:108:    memset (s, ' ', w);
12698:109:    if (w > 1) {
12699:110:        i = w > 24 ? 18 : w - 6;
12700:111:        i = i < 13 ? 13 : i;
12701:112:        sprintf (s, "%s",
12702:113:                 name_trunc (edit->filename ? edit->filename : "", i));
12703:114:        i = strlen (s);
12704:115:        s[i] = ' ';
12705:116:        t = w - i - 2;
12706:117:        if (t < 0)
12707:118:            t = 0;
12708:119:        status_string (edit, s + i + 2, t);
12709:120:    }
12710:121:    s[w] = 0;
12711:122:    Credrawtext (catstrs (edit->widget->ident, ".text", 0), s);
12712:123:    free (s);
12713:124:}
12714:125:
12715:126:
12716:127:#endif
12717:128:
12718:129:
12719:130:/* boolean */
12720:131:int cursor_in_screen (WEdit * edit, long row)
12721:132:{
12722:133:    if (row < 0 || row >= edit->num_widget_lines)
12723:134:        return 0;
12724:135:    else
12725:136:        return 1;
12726:137:}
12727:138:
12728:139:/* returns rows from the first displayed line to the cursor */
12729:140:int cursor_from_display_top (WEdit * edit)
12730:141:{
12731:142:    if (edit->curs1 < edit->start_display)
12732:143:        return -edit_move_forward (edit, edit->curs1, 0,
12733:144:                                   edit->start_display);
12734:145:    else
12735:146:        return edit_move_forward (edit, edit->start_display, 0,
12736:147:                                  edit->curs1);
12737:148:}
12738:149:
12739:150:/* returns how far the cursor is out of the screen */
12740:151:int cursor_out_of_screen (WEdit * edit)
12741:152:{
12742:153:    int row = cursor_from_display_top (edit);
12743:154:    if (row >= edit->num_widget_lines)
12744:155:        return row - edit->num_widget_lines + 1;
12745:156:    if (row < 0)
12746:157:        return row;
12747:158:    return 0;
12748:159:}
12749:160:
12750:161:
12751:162:/* this scrolls the text so that cursor is on the screen */
12752:163:void edit_scroll_screen_over_cursor (WEdit * edit)
12753:164:{
12754:165:    int p = edit_get_col (edit);
12755:166:    int outby;
12756:167:    update_curs_row (edit);
12757:168:    outby =
12758:169:        p + edit->start_col - edit->num_widget_columns + 1 +
12759:170:        EDIT_RIGHT_EXTREME;
12760:171:    if (outby > 0)
12761:172:        edit_scroll_right (edit, outby);
12762:173:    outby = EDIT_LEFT_EXTREME - p - edit->start_col;
12763:174:    if (outby > 0)
12764:175:        edit_scroll_left (edit, outby);
12765:176:    p = edit->curs_row;
12766:177:    outby = p - edit->num_widget_lines + 1 + EDIT_BOTTOM_EXTREME;
12767:178:    if (outby > 0)
12768:179:        edit_scroll_downward (edit, outby);
12769:180:    outby = EDIT_TOP_EXTREME - p;
12770:181:    if (outby > 0)
12771:182:        edit_scroll_upward (edit, outby);
12772:183:    update_curs_row (edit);
12773:184:}
12774:185:
12775:186:
12776:187:
12777:188:#ifndef MIDNIGHT
12778:189:
12779:190:#define CACHE_WIDTH 256
12780:191:#define CACHE_HEIGHT 128
12781:192:
12782:193:int EditExposeRedraw = 0;
12783:194:
12784:195:/* background colors: marked is refers to mouse highlighting, highlighted refers to a found string. */
12785:196:unsigned long edit_abnormal_color, edit_marked_abnormal_color;
12786:197:unsigned long edit_highlighted_color, edit_marked_color;
12787:198:unsigned long edit_normal_background_color;
12788:199:
12789:200:/* foreground colors */
12790:201:unsigned long edit_normal_foreground_color, edit_bold_color;
12791:202:unsigned long edit_italic_color;
12792:203:
12793:204:/* cursor color */
12794:205:unsigned long edit_cursor_color;
12795:206:
12796:207:void edit_set_foreground_colors (unsigned long normal, unsigned long bold,
12797:208:                                 unsigned long italic)
12798:209:{
12799:210:    edit_normal_foreground_color = normal;
12800:211:    edit_bold_color = bold;
12801:212:    edit_italic_color = italic;
12802:213:}
12803:214:
12804:215:void edit_set_background_colors (unsigned long normal,
12805:216:                                 unsigned long abnormal,
12806:217:                                 unsigned long marked,
12807:218:                                 unsigned long marked_abnormal,
12808:219:                                 unsigned long highlighted)
12809:220:{
12810:221:    edit_abnormal_color = abnormal;
12811:222:    edit_marked_abnormal_color = marked_abnormal;
12812:223:    edit_marked_color = marked;
12813:224:    edit_highlighted_color = highlighted;
12814:225:    edit_normal_background_color = normal;
12815:226:}
12816:227:
12817:228:void edit_set_cursor_color (unsigned long c)
12818:229:{
12819:230:    edit_cursor_color = c;
12820:231:}
12821:232:
12822:233:void xprint_to_widget (Window win, long row, int start_col,
12823:234:                       float start_col_real, long end_col,
12824:235:                       unsigned short line[])
12825:236:{
12826:237:    static unsigned short cache[CACHE_WIDTH][CACHE_HEIGHT];
12827:238:    static Window last = 0;
12828:239:    int M_width = TEXT_M_WIDTH;
12829:240:    int M_height = TEXT_PIX_PER_LINE;
12830:241:    int x, y = row * M_height + EDIT_TEXT_VERTICAL_OFFSET;
12831:242:    unsigned short *p;
12832:243:    static char text[MAX_LINE_LEN];
12833:244:    unsigned int style;
12834:245:    int i = 0;
12835:246:    unsigned long bg, fg;
12836:247:    int cursor_found = 0;
12837:248:
12838:249:    if (row >= CACHE_HEIGHT || end_col >= CACHE_WIDTH) /* this will look ugly to users who want gian-normou-huge edit windows */
12839:250:        return;
12840:251:
12841:252:/* find the end of the line and, */
12842:253:    while (line[i++]);
12843:254:
12844:255:/* discard the part of the line we don't need to draw */
12845:256:    line += (start_col - (int) start_col_real);
12846:257:    i -= start_col - (int) start_col_real + 1;
12847:258:    if (i <= 0)
12848:259:        i = 0;
12849:260:
12850:261:/* if its not the same window, reset the screen rememberer */
12851:262:    if (last != win) {
12852:263:        last = win;
12853:264:        memset (cache, -1, CACHE_WIDTH * CACHE_HEIGHT * sizeof (short));
12854:265:    }
12855:266:/* fill from the end of the line with spaces up to the required width */
12856:267:    while (i <= end_col - start_col && i < CACHE_WIDTH)
12857:268:        line[i++] = ' ';
12858:269:    line[i] = 0;
12859:270:
12860:271:    if (!EditExposeRedraw) {    /* except for exposes (when we don't know what was erased) */
12861:272:/* discard part of the line that is the same on the screen, where the cache remembers it: */
12862:273:        for (i = 0, x = start_col; x <= end_col; x++, i++)
12863:274:            if (cache[x][row] != line[i]
12864:275:                || cache[x][row] & MOD_CURSOR * 256)
12865:276:                break;
12866:277:
12867:278:        for (x = end_col; x >= start_col && x >= i;
12868:279:             line[(x--) - start_col] = 0)
12869:280:            if (cache[x][row] != line[x - start_col]
12870:281:                || cache[x][row] & MOD_CURSOR * 256)
12871:282:                break;
12872:283:        start_col += i;
12873:284:        line += i;
12874:285:    }
12875:286:    x = start_col * M_width + EDIT_TEXT_HORIZONTAL_OFFSET; /* pixel pos of line start */
12876:287:    p = line;
12877:288:
12878:289:    while (*p) {
12879:290:        i = 0;
12880:291:        style = (*p) & 0xFF00;
12881:292:        if (style & (MOD_ABNORMAL * 256)) {
12882:293:            bg = edit_abnormal_color;
12883:294:            if (style & (MOD_MARKED * 256))
12884:295:                bg = edit_marked_abnormal_color;
12885:296:        } else if (style & (MOD_HIGHLIGHTED * 256))
12886:297:            bg = edit_highlighted_color;
12887:298:        else if (style & (MOD_MARKED * 256))
12888:299:            bg = edit_marked_color;
12889:300:        else
12890:301:            bg = edit_normal_background_color;
12891:302:        fg = edit_normal_foreground_color;
12892:303:        if (style & (MOD_BOLD * 256))
12893:304:            fg = edit_bold_color;
12894:305:        if (style & (MOD_ITALIC * 256))
12895:306:            fg = edit_italic_color;
12896:307:/* print all characters with the same style (i.e. same foreground and background color) at once: */
12897:308:        while (style == ((*p) & 0xFF00) && *p) {
12898:309:            text[i++] = (char) *p;
12899:310:            cache[start_col++][row] = *(p++);
12900:311:        }
12901:312:        Csetbackcolor (bg);
12902:313:        Csetcolor (fg);
12903:314:        XDrawImageString (CDisplay, win, CGC, x + FONT_OFFSET_X,
12904:315:                          y + FONT_OFFSET_Y, text, i);
12905:316:/* if we printed a cursor: */
12906:317:        if (style & (MOD_CURSOR * 256)) {
12907:318:            Csetcolor (edit_cursor_color);
12908:319:            Cline (win, x, y + CFontStruct->descent + IN_FONT_OFFSET_Y, x, y + M_height - 1 + IN_FONT_OFFSET_Y); /* non focussed cursor form */
12909:320:            Cline (win, x + 1, y + CFontStruct->descent + IN_FONT_OFFSET_Y,
12910:321:                   x + M_width - 1,
12911:322:                   y + CFontStruct->descent + IN_FONT_OFFSET_Y);
12912:323:            cursor_found = 1;
12913:324:            Csetcursor (win, x, y, M_width, M_height, EDITOR_CURSOR, *text, bg, fg); /* widget library's flashing cursor */
12914:325:        }
12915:326:        x += M_width * i;
12916:327:    }
12917:328:}
12918:329:
12919:330:
12920:331:#else
12921:332:
12922:333:#define BOLD_COLOR        MARKED_COLOR
12923:334:#define UNDERLINE_COLOR   VIEW_UNDERLINED_COLOR
12924:335:#define MARK_COLOR        SELECTED_COLOR
12925:336:#define DEF_COLOR         NORMAL_COLOR
12926:337:
12927:338:static void set_color (int font)
12928:339:{
12929:340:    attrset (font);
12930:341:}
12931:342:
12932:343:#define edit_move(x,y) widget_move(edit, y, x);
12933:344:
12934:345:static void print_to_widget (WEdit * edit, long row, int start_col,
12935:346:                             float start_col_real, long end_col,
12936:347:                             unsigned short line[])
12937:348:{
12938:349:    int x = (float) start_col_real + EDIT_TEXT_HORIZONTAL_OFFSET;
12939:350:    int x1 = start_col + EDIT_TEXT_HORIZONTAL_OFFSET;
12940:351:    int y = row + EDIT_TEXT_VERTICAL_OFFSET;
12941:352:
12942:353:    set_color (DEF_COLOR);
12943:354:    edit_move (x1, y);
12944:355:    hline (' ', end_col + 1 - EDIT_TEXT_HORIZONTAL_OFFSET - x1);
12945:356:
12946:357:    edit_move (x + FONT_OFFSET_X, y + FONT_OFFSET_Y);
12947:358:    {
12948:359:        unsigned short *p = line;
12949:360:        int textchar = ' ';
12950:361:        long style;
12951:362:
12952:363:        while (*p) {
12953:364:            style = (*p) >> 8;
12954:365:            textchar = (*p) & 255;
12955:366:            if (!style || style & MOD_ABNORMAL || style & MOD_CURSOR)
12956:367:                set_color (DEF_COLOR);
12957:368:            if (style & MOD_ABNORMAL)
12958:369:                textchar = '.';
12959:370:            if (style & MOD_HIGHLIGHTED) {
12960:371:                set_color (BOLD_COLOR);
12961:372:            } else if (style & MOD_MARKED) {
12962:373:                set_color (MARK_COLOR);
12963:374:            }
12964:375:            if (style & MOD_UNDERLINED) {
12965:376:                set_color (UNDERLINE_COLOR);
12966:377:            }
12967:378:            if (style & MOD_BOLD) {
12968:379:                set_color (BOLD_COLOR);
12969:380:            }
12970:381:            addch (textchar);
12971:382:            p++;
12972:383:        }
12973:384:    }
12974:385:}
12975:386:
12976:387:#endif
12977:388:
12978:389:
12979:390:
12980:391:#ifndef MIDNIGHT
12981:392:
12982:393:/* feel free to add your own translation table (XWindows version only) */
12983:394:static char basic_translation[256] =
12984:395:    { "0ABCDEFGHIJKL\005NOPQRSTUVWXYZ[\\]^_"
12985:396:" !\"#$%&'()*+,-./0123456789:;<=>?"
12986:397:"@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
12987:398:"`abcdefghijklmnopqrstuvwxyz{|}~ "
12988:399:"\024\024\024\024\024\024\024\024\024\024\024\024\024\024\024\024\024\024\024\024\024\024\024\024\024\024"
12989:400:"\023\023\023\023\023\023\023\023\023\023\023\023\023\023\023\023\023\023\023\023\023\023\023\023\023"
12990:401:"\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022\022"
12991:402:"\021\021\021\021\021\021\021\021\021\021\021\021\021\021\021\021\021\021\021\021\021\021\021\021\021"
12992:403:"\020\020\020\020\020\020\020\020\020\020\020\020\020\020\020\020\020\020\020\020\020\020\020\020\020\020"
12993:404:};
12994:405:
12995:406:char *translation_table = 0;
12996:407:
12997:408:#endif
12998:409:
12999:410:
13000:411:/* b pointer to begining of line */
13001:412:static void edit_draw_this_line (WEdit * edit, long b, long row,
13002:413:                                 long start_col, long end_col)
13003:414:{
13004:415:    static unsigned short line[MAX_LINE_LEN];
13005:416:    unsigned short *p = line;
13006:417:    long m1 = 0, m2 = 0, q;
13007:418:    int col, start_col_real;
13008:419:    unsigned int c;
13009:420:    int i;
13010:421:
13011:422:#ifndef MIDNIGHT
13012:423:    if (!translation_table)
13013:424:        translation_table = basic_translation;
13014:425:#endif
13015:426:
13016:427:    q = edit_move_forward3 (edit, b, start_col - edit->start_col, 0);
13017:428:    start_col_real = (col =
13018:429:                      (int) edit_move_forward3 (edit, b, 0,
13019:430:                                                q)) + edit->start_col;
13020:431:
13021:432:    if (col + 16 > -edit->start_col) {
13022:433:        eval_marks (edit, &m1, &m2);
13023:434:
13024:435:        if (row <= edit->total_lines - edit->start_line) {
13025:436:            while (col <= end_col - edit->start_col) {
13026:437:                *p = 0;
13027:438:                if (q == edit->curs1)
13028:439:                    *p |= MOD_CURSOR * 256;
13029:440:                if (q >= m1 && q < m2)
13030:441:                    *p |= MOD_MARKED * 256;
13031:442:                if (q >= edit->found_start
13032:443:                    && q < edit->found_start + edit->found_len)
13033:444:                    *p |= MOD_HIGHLIGHTED * 256;
13034:445:                switch (c = edit_get_byte (edit, q++)) {
13035:446:                case '\n':
13036:447:                    col = end_col - edit->start_col + 1; /* quit */
13037:448:                    *(p++) |= ' ';
13038:449:                    break;
13039:450:                case '\t':
13040:451:                    i = TAB_SIZE - ((int) col % TAB_SIZE);
13041:452:                    *p |= ' ';
13042:453:                    c = *(p++) & (0xFFFF - MOD_CURSOR * 256);
13043:454:                    col += i;
13044:455:                    while (--i)
13045:456:                        *(p++) = c;
13046:457:                    break;
13047:458:#ifdef MIDNIGHT
13048:459:                case '\r':
13049:460:                    break;
13050:461:#endif
13051:462:                default:
13052:463:#ifdef MIDNIGHT
13053:464:                    if (is_printable (c)) {
13054:465:                        *(p++) |= c;
13055:466:                    } else {
13056:467:                        *(p++) = '.';
13057:468:                        *p |= (256 * MOD_ABNORMAL);
13058:469:                    }
13059:470:#else
13060:471:                    if (option_international_characters) {
13061:472:                        if (c < ' ' || (c > '~' && c < 160))
13062:473:                            *p |= (256 * MOD_ABNORMAL);
13063:474:                        if (c < 160)
13064:475:                            *(p++) |= translation_table[c];
13065:476:                        else
13066:477:                            *(p++) |= c;
13067:478:                    } else {
13068:479:                        if (c < ' ' || c > '~')
13069:480:                            *p |= (256 * MOD_ABNORMAL);
13070:481:                        *(p++) |= translation_table[c];
13071:482:                    }
13072:483:#endif
13073:484:                    col++;
13074:485:                    break;
13075:486:                }
13076:487:            }
13077:488:        }
13078:489:    } else {
13079:490:        start_col_real = start_col = 0;
13080:491:    }
13081:492:    *p = 0;
13082:493:
13083:494:#ifdef MIDNIGHT
13084:495:    print_to_widget (edit, row, start_col, start_col_real, end_col, line);
13085:496:#else
13086:497:    xprint_to_widget (edit->widget->winid, row, start_col, start_col_real,
13087:498:                      end_col, line);
13088:499:#endif
13089:500:}
13090:501:
13091:502:#ifdef MIDNIGHT
13092:503:#define key_pending(x) (!is_idle())
13093:504:#else
13094:505:static int key_pending (WEdit * edit)
13095:506:{
13096:507:    int b = 0;
13097:508:    if (!(edit->force & REDRAW_COMPLETELY)) {
13098:509:        XEvent ev;
13099:510:        while (XCheckWindowEvent
13100:511:               (CDisplay, edit->widget->winid, KeyPressMask, &ev)) {
13101:512:            XSendEvent (CDisplay, edit->widget->winid, 0, KeyPressMask, &ev); /* don't discard the event, but resend it */
13102:513:            b = 1;
13103:514:        }
13104:515:    }
13105:516:    return b;
13106:517:}
13107:518:#endif
13108:519:
13109:520:/* b for pointer to begining of line */
13110:521:static void drawthischar (WEdit * edit, long curs, long row)
13111:522:{
13112:523:    int b = edit_bol (edit, curs);
13113:524:    long start_col =
13114:525:        edit_move_forward3 (edit, b, 0, curs) + edit->start_col;
13115:526:    edit_draw_this_line (edit, b, row, start_col, start_col);
13116:527:}
13117:528:
13118:529:
13119:530:/* cursor must be in screen for other than REDRAW_PAGE passed in force */
13120:531:void Crenderedittext (WEdit * edit, long start_row, long start_column,
13121:532:                      long end_row, long end_column)
13122:533:{
13123:534:    long row = 0, curs_row;
13124:535:    static int prev_curs_row = 0;
13125:536:    static long prev_start_display = 0;
13126:537:    static int prev_start_col = 0;
13127:538:    static long prev_curs = 0;
13128:539:
13129:540:#ifndef MIDNIGHT
13130:541:    static Window prev_win = 0;
13131:542:#endif
13132:543:
13133:544:    int force = edit->force;
13134:545:    long b;
13135:546:
13136:547:/*
13137:548:   if the position of the page has not moved then we can draw the cursor character only.
13138:549:   This will prevent line flicker when using arrow keys.
13139:550: */
13140:551:    if ((!(force & REDRAW_CHAR_ONLY)) || (force & REDRAW_PAGE)
13141:552:#ifndef MIDNIGHT
13142:553:        || prev_win != edit->widget->winid
13143:554:#endif
13144:555:        ) {
13145:556:        if (!(force & REDRAW_IN_BOUNDS)) { /* !REDRAW_IN_BOUNDS means to ignore bounds and redraw whole rows */
13146:557:            start_row = 0;
13147:558:            start_column = 0;
13148:559:            end_row = edit->num_widget_lines - 1;
13149:560:            end_column = edit->num_widget_columns - 1;
13150:561:        }
13151:562:        if (force & REDRAW_PAGE) {
13152:563:            row = start_row;
13153:564:            b = edit_move_forward (edit, edit->start_display, start_row,
13154:565:                                   0);
13155:566:            while (row <= end_row) {
13156:567:                if (key_pending (edit))
13157:568:                    return;
13158:569:                edit_draw_this_line (edit, b, row, start_column,
13159:570:                                     end_column);
13160:571:                b = edit_move_forward (edit, b, 1, 0);
13161:572:                row++;
13162:573:            }
13163:574:        } else {
13164:575:            curs_row = edit->curs_row;
13165:576:
13166:577:            if (force & REDRAW_BEFORE_CURSOR) {
13167:578:                if (start_row < curs_row) {
13168:579:                    long upto =
13169:580:                        curs_row - 1 <= end_row ? curs_row - 1 : end_row;
13170:581:                    row = start_row;
13171:582:                    b = edit->start_display;
13172:583:                    while (row <= upto) {
13173:584:                        if (key_pending (edit))
13174:585:                            return;
13175:586:                        edit_draw_this_line (edit, b, row, start_column,
13176:587:                                             end_column);
13177:588:                        b = edit_move_forward (edit, b, 1, 0);
13178:589:                    }
13179:590:                }
13180:591:            }
13181:592:            b = edit_bol (edit, edit->curs1);
13182:593:            if (curs_row >= start_row && curs_row <= end_row) {
13183:594:                if (key_pending (edit))
13184:595:                    return;
13185:596:                edit_draw_this_line (edit, b, curs_row, start_column,
13186:597:                                     end_column);
13187:598:            }
13188:599:            if (force & REDRAW_AFTER_CURSOR) {
13189:600:                if (end_row > curs_row) {
13190:601:                    row =
13191:602:                        curs_row + 1 <
13192:603:                        start_row ? start_row : curs_row + 1;
13193:604:                    b = edit_move_forward (edit, b, 1, 0);
13194:605:                    while (row <= end_row) {
13195:606:                        if (key_pending (edit))
13196:607:                            return;
13197:608:                        edit_draw_this_line (edit, b, row, start_column,
13198:609:                                             end_column);
13199:610:                        b = edit_move_forward (edit, b, 1, 0);
13200:611:                        row++;
13201:612:                    }
13202:613:                }
13203:614:            }
13204:615:            if (force & REDRAW_LINE_ABOVE && curs_row >= 1) {
13205:616:                row = curs_row - 1;
13206:617:                b = edit_move_backward (edit, edit_bol (edit, edit->curs1),
13207:618:                                        1);
13208:619:                if (row >= start_row && row <= end_row) {
13209:620:                    if (key_pending (edit))
13210:621:                        return;
13211:622:                    edit_draw_this_line (edit, b, row, start_column,
13212:623:                                         end_column);
13213:624:                }
13214:625:            }
13215:626:            if (force & REDRAW_LINE_BELOW
13216:627:                && row < edit->num_widget_lines - 1) {
13217:628:                row = curs_row + 1;
13218:629:                b = edit_bol (edit, edit->curs1);
13219:630:                b = edit_move_forward (edit, b, 1, 0);
13220:631:                if (row >= start_row && row <= end_row) {
13221:632:                    if (key_pending (edit))
13222:633:                        return;
13223:634:                    edit_draw_this_line (edit, b, row, start_column,
13224:635:                                         end_column);
13225:636:                }
13226:637:            }
13227:638:        }
13228:639:    } else {
13229:640:        drawthischar (edit, prev_curs, prev_curs_row);
13230:641:        drawthischar (edit, edit->curs1, edit->curs_row);
13231:642:    }
13232:643:
13233:644:    edit->force = 0;
13234:645:
13235:646:    prev_curs_row = edit->curs_row;
13236:647:    prev_curs = edit->curs1;
13237:648:    prev_start_display = edit->start_display;
13238:649:    prev_start_col = edit->start_col;
13239:650:#ifndef MIDNIGHT
13240:651:    prev_win = edit->widget->winid;
13241:652:#endif
13242:653:
13243:654:}
13244:655:
13245:656:
13246:657:
13247:658:#ifndef MIDNIGHT
13248:659:void Cedit_expose_to_area (XExposeEvent * xexpose, int *row1, int *col1,
13249:660:                           int *row2, int *col2)
13250:661:{
13251:662:    int M_width = TEXT_M_WIDTH;
13252:663:    int M_height = TEXT_PIX_PER_LINE;
13253:664:
13254:665:    *col1 = (xexpose->x - EDIT_TEXT_HORIZONTAL_OFFSET) / M_width;
13255:666:    *row1 = (xexpose->y - EDIT_TEXT_VERTICAL_OFFSET) / M_height;
13256:667:    *col2 =
13257:668:        (xexpose->x + xexpose->width -
13258:669:         EDIT_TEXT_HORIZONTAL_OFFSET) / M_width;
13259:670:    *row2 =
13260:671:        (xexpose->y + xexpose->height -
13261:672:         EDIT_TEXT_VERTICAL_OFFSET) / M_height;
13262:673:}
13263:674:
13264:675:void edit_render_tidbits (CWidget * widget)
13265:676:{
13266:677:    int isfocussed;
13267:678:    int w = widget->width, h = widget->height;
13268:679:    Window win;
13269:680:
13270:681:    win = widget->winid;
13271:682:    isfocussed = (win == CGetFocus ());
13272:683:
13273:684:    Csetcolor (C_FLAT);
13274:685:
13275:686:    if (isfocussed) {
13276:687:        Crenderbevel (win, 0, 0, w - 1, h - 1, 3, 1); /*most outer border bevel */
13277:688:    } else {
13278:689:        Crenderbevel (win, 2, 2, w - 3, h - 3, 1, 1); /*border bevel */
13279:690:        Crenderbevel (win, 0, 0, w - 1, h - 1, 2, 0); /*most outer border bevel */
13280:691:    }
13281:692:}
13282:693:
13283:694:#endif
13284:695:
13285:696:void edit_render (WEdit * edit, int page, int row_start, int col_start,
13286:697:                  int row_end, int col_end)
13287:698:{
13288:699:    if (page)                   /* if it was an expose event, 'page' would be set */
13289:700:        edit->force |= REDRAW_PAGE | REDRAW_IN_BOUNDS;
13290:701:
13291:702:#ifndef MIDNIGHT
13292:703:    edit_set_foreground_colors (Ccolor (option_editor_fg_normal),
13293:704:                                Ccolor (option_editor_fg_bold),
13294:705:                                Ccolor (option_editor_fg_italic)
13295:706:        );
13296:707:    edit_set_background_colors (Ccolor (option_editor_bg_normal),
13297:708:                                Ccolor (option_editor_bg_abnormal),
13298:709:                                Ccolor (option_editor_bg_marked),
13299:710:                                Ccolor (option_editor_bg_marked_abnormal),
13300:711:                                Ccolor (option_editor_bg_highlighted)
13301:712:        );
13302:713:    edit_set_cursor_color (Ccolor (option_editor_fg_cursor)
13303:714:        );
13304:715:
13305:716:    if (!EditExposeRedraw)
13306:717:        Csetcursor (0, 0, 0, 0, 0, 0, 0, 0, 0);
13307:718:#endif
13308:719:
13309:720:    Crenderedittext (edit, row_start, col_start, row_end, col_end);
13310:721:    if (edit->force)            /* edit->force != 0 means a key was pending and the redraw 
13311:722:                                   was halted, so next time we must redraw everything in case stuff
13312:723:                                   was left undrawn from a previous key press */
13313:724:        edit->force |= REDRAW_PAGE;
13314:725:#ifndef MIDNIGHT
13315:726:    edit_render_tidbits (edit->widget);
13316:727:#endif
13317:728:}
13318:729:
13319:730:#ifndef MIDNIGHT
13320:731:void edit_render_expose (WEdit * edit, XExposeEvent * xexpose)
13321:732:{
13322:733:    int row_start, col_start, row_end, col_end;
13323:734:    Cedit_expose_to_area (xexpose, &row_start, &col_start, &row_end,
13324:735:                          &col_end);
13325:736:    edit_render (edit, 1, row_start, col_start, row_end, col_end);
13326:737:}
13327:738:
13328:739:void edit_render_keypress (WEdit * edit)
13329:740:{
13330:741:    edit_render (edit, 0, 0, 0, 0, 0);
13331:742:}
13332:743:
13333:744:#else
13334:745:
13335:746:void edit_render_keypress (WEdit * edit)
13336:747:{
13337:748:    edit_render (edit, 0, 0, 0, 0, 0);
13338:749:}
13339:750:
13340:751:
13341:752:
13342:753:
13343:754:#endif
13344:1:#ifndef __EDIT_H
13345:2:#define __EDIT_H
13346:3:
13347:4:#ifdef MIDNIGHT
13348:5:
13349:6:#include <stdio.h>
13350:7:#include <sys/types.h>
13351:8:#ifdef HAVE_UNISTD_H
13352:9:#include <unistd.h>
13353:10:#endif
13354:11:#include <string.h>
13355:12:#include "src/tty.h"
13356:13:#include <sys/stat.h>
13357:14:
13358:15:#ifdef HAVE_FCNTL_H
13359:16:#include <fcntl.h>
13360:17:#endif
13361:18:
13362:19:#include <stdlib.h>
13363:20:#include <malloc.h>
13364:21:
13365:22:#else
13366:23:
13367:24:#include "global.h"
13368:25:#include <stdio.h>
13369:26:#include <sys/types.h>
13370:27:
13371:28:#ifdef HAVE_UNISTD_H
13372:29:#include <unistd.h>
13373:30:#endif
13374:31:
13375:32:#include <my_string.h>
13376:33:#include <sys/stat.h>
13377:34:
13378:35:#ifdef HAVE_FCNTL_H
13379:36:#include <fcntl.h>
13380:37:#endif
13381:38:
13382:39:#include <stdlib.h>
13383:40:#include <stdarg.h>
13384:41:
13385:42:#ifdef HAVE_SYS_TIME_H
13386:43:#include <sys/time.h>
13387:44:#endif
13388:45:
13389:46:#include "regex.h"
13390:47:
13391:48:#endif
13392:49:
13393:50:#ifndef MIDNIGHT
13394:51:
13395:52:#include <signal.h>
13396:53:#include <X11/Xlib.h>
13397:54:#include <X11/Xutil.h>
13398:55:#include <X11/Xresource.h>
13399:56:#include "lkeysym.h"
13400:57:#include "coolwidget.h"
13401:58:#include "app_glob.c"
13402:59:#include "coollocal.h"
13403:60:#include "dialog.h"
13404:61:#include "stringtools.h"
13405:62:#include "editoptions.h"
13406:63:
13407:64:#else
13408:65:
13409:66:#include "src/main.h"           /* for char *shell */
13410:67:#include "src/mad.h"
13411:68:#include "src/dlg.h"
13412:69:#include "src/widget.h"
13413:70:#include "src/color.h"
13414:71:#include "src/dialog.h"
13415:72:#include "src/mouse.h"
13416:73:#include "src/global.h"
13417:74:#include "src/help.h"
13418:75:#include "src/key.h"
13419:76:#include "src/wtools.h"         /* for QuickWidgets */
13420:77:#include "src/win.h"
13421:78:#include "vfs/vfs.h"
13422:79:#include "src/menu.h"
13423:80:#include "src/regex.h"
13424:81:#define WANT_WIDGETS
13425:82:
13426:83:#define WIDGET_COMMAND (WIDGET_USER + 10)
13427:84:#define N_menus 5
13428:85:
13429:86:#endif
13430:87:
13431:88:#define SEARCH_DIALOG_OPTION_NO_SCANF        1
13432:89:#define SEARCH_DIALOG_OPTION_NO_REGEX        2
13433:90:#define SEARCH_DIALOG_OPTION_NO_CASE        4
13434:91:
13435:92:#define CLIP_FILE "/cedit/cooledit.clip"
13436:93:#define MACRO_FILE "/cedit/cooledit.macros"
13437:94:#define BLOCK_FILE "/cedit/cooledit.block"
13438:95:#define ERROR_FILE "/cedit/cooledit.error"
13439:96:#define TEMP_FILE "/cedit/cooledit.temp"
13440:97:#define EDIT_DIR "/cedit"
13441:98:
13442:99:#define EDIT_KEY_EMULATION_NORMAL 0
13443:100:#define EDIT_KEY_EMULATION_EMACS  1
13444:101:
13445:102:#define REDRAW_LINE_ABOVE    (1 << 0)
13446:103:#define REDRAW_LINE_BELOW    (1 << 1)
13447:104:#define REDRAW_AFTER_CURSOR  (1 << 2)
13448:105:#define REDRAW_BEFORE_CURSOR (1 << 3)
13449:106:#define REDRAW_PAGE          (1 << 4)
13450:107:#define REDRAW_IN_BOUNDS     (1 << 5)
13451:108:#define REDRAW_CHAR_ONLY     (1 << 6)
13452:109:#define REDRAW_COMPLETELY    (1 << 7)
13453:110:
13454:111:#define MOD_ABNORMAL 1
13455:112:#define MOD_UNDERLINED 2
13456:113:#define MOD_BOLD 4
13457:114:#define MOD_HIGHLIGHTED 8
13458:115:#define MOD_MARKED 16
13459:116:#define MOD_ITALIC 32
13460:117:#define MOD_CURSOR 64
13461:118:
13462:119:#ifndef MIDNIGHT
13463:120:#define EDIT_TEXT_HORIZONTAL_OFFSET 4
13464:121:#define EDIT_TEXT_VERTICAL_OFFSET 3
13465:122:#else
13466:123:#define EDIT_TEXT_HORIZONTAL_OFFSET 0
13467:124:#define EDIT_TEXT_VERTICAL_OFFSET 1
13468:125:#define FONT_OFFSET_X 0
13469:126:#define FONT_OFFSET_Y 0
13470:127:
13471:128:#endif
13472:129:
13473:130:#define EDIT_RIGHT_EXTREME 0
13474:131:#define EDIT_LEFT_EXTREME 0
13475:132:#define EDIT_TOP_EXTREME 0
13476:133:#define EDIT_BOTTOM_EXTREME 0
13477:134:
13478:135:#define MAX_MACRO_LENGTH 256
13479:136:
13480:137:/*there are a maximum of ... */
13481:138:#define MAXBUFF 1024
13482:139:/*... edit buffers, each of which is ... */
13483:140:#define EDIT_BUF_SIZE 16384
13484:141:/* ...bytes in size. */
13485:142:
13486:143:/*x / EDIT_BUF_SIZE equals x >> ... */
13487:144:#define S_EDIT_BUF_SIZE 14
13488:145:
13489:146:/* x % EDIT_BUF_SIZE is equal to x && ... */
13490:147:#define M_EDIT_BUF_SIZE 16383
13491:148:
13492:149:#define SIZE_LIMIT (EDIT_BUF_SIZE * (MAXBUFF - 2))
13493:150:/* Note a 16k stack is 64k of data and enough to hold (usually) around 10
13494:151:   pages of undo info. */
13495:152:#define STACK_BITS 14
13496:153:#define MAX_STACK (1<<(STACK_BITS-1)) /* the most that one command can occupy without giving a warning */
13497:154:#define STACK_SIZE (1<<STACK_BITS)
13498:155:#define M_STACK_SIZE (STACK_SIZE-1)
13499:156:/*.. used same as M_EDIT_BUF_SIZE */
13500:157:
13501:158:/*some codes that may be pushed onto or returned from the undo stack: */
13502:159:#define CURS_LEFT 601
13503:160:#define CURS_RIGHT 602
13504:161:#define DELETE 603
13505:162:#define BACKSPACE 604
13506:163:#define STACK_BOTTOM 605
13507:164:#define CURS_LEFT_LOTS 606
13508:165:#define CURS_RIGHT_LOTS 607
13509:166:#define MARK_1 1000
13510:167:#define MARK_2 700000000
13511:168:#define KEY_PRESS 1400000000
13512:169:
13513:170:/*Tabs spaces: (sofar only HALF_TAB_SIZE is used: */
13514:171:#define TAB_SIZE                option_tab_spacing
13515:172:#define HALF_TAB_SIZE                ((int) option_tab_spacing / 2)
13516:173:
13517:174:struct macro {
13518:175:    short command;
13519:176:    short ch;
13520:177:};
13521:178:
13522:179:struct editor_widget {
13523:180:#ifdef MIDNIGHT
13524:181:    Widget widget;
13525:182:#else
13526:183:    struct cool_widget *widget;
13527:184:#endif
13528:185:#define from_here num_widget_lines
13529:186:    int num_widget_lines;
13530:187:    int num_widget_columns;
13531:188:
13532:189:#ifdef MIDNIGHT
13533:190:    int have_frame;
13534:191:#else
13535:192:    int stopped;
13536:193:#endif
13537:194:
13538:195:    char *filename;             /* Name of the file */
13539:196:    char *dir;                  /* current directory */
13540:197:
13541:198:/* dynamic buffers and curser position for editor: */
13542:199:    long curs1;                 /*position of the cursor from the beginning of the file. */
13543:200:    long curs2;                 /*position from the end of the file */
13544:201:    unsigned char *buffers1[MAXBUFF + 1]; /*all data up to curs1 */
13545:202:    unsigned char *buffers2[MAXBUFF + 1]; /*all data from end of file down to curs2 */
13546:203:
13547:204:/* search variables */
13548:205:    long search_start;          /* First character to start searching from */
13549:206:    int found_len;              /* Length of found string or 0 if none was found */
13550:207:    long found_start;           /* the found word from a search - start position */
13551:208:
13552:209:/* display information */
13553:210:    long last_byte;             /* Last byte of file */
13554:211:    long start_display;         /* First char displayed */
13555:212:    long start_col;             /* First displayed column, negative */
13556:213:    long curs_row;              /*row position of curser on the screen */
13557:214:    long curs_col;              /*column position on screen */
13558:215:    unsigned char force;        /* how much of the screen do we redraw? */
13559:216:    unsigned char overwrite;
13560:217:    unsigned char modified;     /*has the file been changed?: 1 if char inserted or
13561:218:                                   deleted at all since last load or save */
13562:219:    unsigned char highlight;
13563:220:    long prev_col;              /*recent column position of the curser - used when moving
13564:221:                                   up or down past lines that are shorter than the current line */
13565:222:    long curs_line;             /*line number of the cursor. */
13566:223:    long start_line;            /*line nummber of the top of the page */
13567:224:
13568:225:/* file info */
13569:226:    long total_lines;           /*total lines in the file */
13570:227:    long mark1;                 /*position of highlight start */
13571:228:    long mark2;                 /*position of highlight end */
13572:229:/* user options */
13573:230:    int wrap_len;
13574:231:
13575:232:/* undo stack and pointers */
13576:233:    unsigned long stack_pointer;
13577:234:    long *undo_stack;
13578:235:    unsigned long stack_bottom;
13579:236:    int (*user_defined_key) (unsigned int state, unsigned int keycode);
13580:237:
13581:238:    int to_here;                /* dummy marker */
13582:239:
13583:240:/* macro stuff */
13584:241:    int macro_i;                /* -1 if not recording index to macro[] otherwise */
13585:242:    struct macro macro[MAX_MACRO_LENGTH];
13586:243:};
13587:244:
13588:245:typedef struct editor_widget WEdit;
13589:246:
13590:247:#ifndef MIDNIGHT
13591:248:
13592:249:void edit_render_expose (WEdit * edit, XExposeEvent * xexpose);
13593:250:void edit_render_tidbits (struct cool_widget *widget);
13594:251:int eh_editor (CWidget * w, XEvent * xevent, CEvent * cwevent);
13595:252:void edit_draw_menus (Window parent, int x, int y);
13596:253:void edit_run_make (void);
13597:254:void edit_change_directory (void);
13598:255:void xprint_to_widget (Window win, long row, int start_col,
13599:256:                       float start_col_real, long end_col,
13600:257:                       unsigned short line[]);
13601:258:int edit_man_page_cmd (WEdit * edit);
13602:259:void edit_search_replace_dialog (Window parent, int x, int y,
13603:260:                                 char **search_text, char **replace_text,
13604:261:                                 char **arg_order, char *heading,
13605:262:                                 int option);
13606:263:void edit_search_dialog (WEdit * edit, char **search_text);
13607:264:long edit_find (long search_start, char *exp, int *len, long last_byte,
13608:265:                int (*get_byte) (void *, long index), void *data);
13609:266:void edit_set_foreground_colors (unsigned long normal, unsigned long bold,
13610:267:                                 unsigned long italic);
13611:268:void edit_set_background_colors (unsigned long normal,
13612:269:                                 unsigned long abnormal,
13613:270:                                 unsigned long marked,
13614:271:                                 unsigned long marked_abnormal,
13615:272:                                 unsigned long highlighted);
13616:273:void edit_set_cursor_color (unsigned long c);
13617:274:void draw_options_dialog (Window parent, int x, int y);
13618:275:
13619:276:#else
13620:277:
13621:278:int edit_drop_hotkey_menu (WEdit * e, int key);
13622:279:void edit_menu_cmd (WEdit * e);
13623:280:void edit_init_menu_emacs (void);
13624:281:void edit_init_menu_normal (void);
13625:282:void edit_done_menu (void);
13626:283:int edit_raw_key_query (char *heading, char *query, int cancel);
13627:284:
13628:285:#endif
13629:286:
13630:287:int edit_get_byte (WEdit * edit, long byte_index);
13631:288:int load_edit_file (WEdit * edit, const char *filename, const char *text);
13632:289:int edit_count_lines (WEdit * edit, long current, int upto);
13633:290:long edit_move_forward (WEdit * edit, long current, int lines, long upto);
13634:291:float edit_move_forward3 (WEdit * edit, long current, int cols, long upto);
13635:292:long edit_move_backward (WEdit * edit, long current, int lines);
13636:293:int edit_translate_key (WEdit * edit, unsigned int x_keycode, long x_key,
13637:294:                        int x_state, int *cmd, int *ch);
13638:295:void edit_scroll_screen_over_cursor (WEdit * edit);
13639:296:void edit_render_keypress (WEdit * edit);
13640:297:void edit_scroll_upward (WEdit * edit, unsigned long i);
13641:298:void edit_scroll_downward (WEdit * edit, int i);
13642:299:void edit_scroll_right (WEdit * edit, int i);
13643:300:void edit_scroll_left (WEdit * edit, int i);
13644:301:int edit_get_col (WEdit * edit);
13645:302:long edit_bol (WEdit * edit, long current);
13646:303:long edit_eol (WEdit * edit, long current);
13647:304:void update_curs_row (WEdit * edit);
13648:305:void update_curs_col (WEdit * edit);
13649:306:
13650:307:void edit_block_copy_cmd (WEdit * edit);
13651:308:void edit_block_move_cmd (WEdit * edit);
13652:309:int edit_block_delete_cmd (WEdit * edit);
13653:310:
13654:311:int edit_delete (WEdit * edit);
13655:312:void edit_insert (WEdit * edit, int c);
13656:313:int edit_cursor_move (WEdit * edit, long increment);
13657:314:void push_action (WEdit * edit, long c, ...);
13658:315:void push_key_press (WEdit * edit);
13659:316:void edit_insert_ahead (WEdit * edit, int c);
13660:317:int edit_save_file (WEdit * edit, const char *filename);
13661:318:int edit_save_cmd (WEdit * edit);
13662:319:int edit_save_confirm_cmd (WEdit * edit);
13663:320:int edit_save_as_cmd (WEdit * edit);
13664:321:WEdit *edit_init (WEdit * e, int lines, int columns, const char *filename,
13665:322:                  const char *text, const char *dir);
13666:323:int edit_clean (WEdit * edit);
13667:324:int edit_renew (WEdit * edit);
13668:325:int edit_new_cmd (WEdit * edit);
13669:326:int edit_reload (WEdit * edit, const char *filename, const char *text,
13670:327:                 const char *dir);
13671:328:int edit_load_cmd (WEdit * edit);
13672:329:void edit_mark_cmd (WEdit * edit, int unmark);
13673:330:void edit_set_markers (WEdit * edit, long m1, long m2);
13674:331:void edit_push_markers (WEdit * edit);
13675:332:void edit_quit_cmd (WEdit * edit);
13676:333:void edit_replace_cmd (WEdit * edit, int again);
13677:334:void edit_search_cmd (WEdit * edit, int again);
13678:335:int edit_save_block_cmd (WEdit * edit);
13679:336:int edit_insert_file_cmd (WEdit * edit);
13680:337:int edit_insert_file (WEdit * edit, const char *filename);
13681:338:void edit_block_process_cmd (WEdit * edit, const char *shell_cmd,
13682:339:                             int block);
13683:340:char *catstrs (const char *first, ...);
13684:341:void edit_refresh_cmd (WEdit * edit);
13685:342:void edit_date_cmd (WEdit * edit);
13686:343:void edit_goto_cmd (WEdit * edit);
13687:344:int eval_marks (WEdit * edit, long *start_mark, long *end_mark);
13688:345:void edit_status (WEdit * edit);
13689:346:int Cedit_execute_command (WEdit * edit, int command,
13690:347:                           int char_for_insertion);
13691:348:int edit_execute_key_command (WEdit * edit, int command,
13692:349:                              int char_for_insertion);
13693:350:void Cedit_update_screen (WEdit * edit);
13694:351:int edit_printf (WEdit * e, const char *fmt, ...);
13695:352:int edit_print_string (WEdit * e, const char *s);
13696:353:void edit_move_to_line (WEdit * e, long line);
13697:354:void edit_move_display (WEdit * e, long line);
13698:355:void edit_word_wrap (WEdit * edit);
13699:356:unsigned char *edit_get_block (WEdit * edit, long start, long finish);
13700:357:int edit_sort_cmd (WEdit * edit);
13701:358:void edit_help_cmd (WEdit * edit);
13702:359:void edit_left_word_move (WEdit * edit);
13703:360:void edit_right_word_move (WEdit * edit);
13704:361:
13705:362:int edit_save_macro_cmd (WEdit * edit, struct macro macro[], int n);
13706:363:int edit_load_macro_cmd (WEdit * edit, struct macro macro[], int *n,
13707:364:                         int *k);
13708:365:
13709:366:int edit_copy_to_X_buf_cmd (WEdit * edit);
13710:367:int edit_cut_to_X_buf_cmd (WEdit * edit);
13711:368:void paste_from_X_buf_cmd (WEdit * edit);
13712:369:
13713:370:void split_filename (WEdit * edit, char *name);
13714:371:
13715:372:#ifdef MIDNIGHT
13716:373:
13717:374:#define TEXT_PIX_PER_LINE 1
13718:375:#define TEXT_M_WIDTH 1
13719:376:
13720:377:#define get_sys_error(s) (s)
13721:378:#define open(f,p) mc_open(f,p)
13722:379:#define close(f) mc_close(f)
13723:380:#define read(f,b,c) mc_read(f,b,c)
13724:381:#define write(f,b,c) mc_write(f,b,c)
13725:382:#define stat(f,s) mc_stat(f,s)
13726:383:
13727:384:#define Cgetloadfile(w,x,y,d,f,h) input_dialog (h, " Enter file name: ", f)
13728:385:#define Cgetsavefile(w,x,y,d,f,h) input_dialog (h, " Enter file name: ", f)
13729:386:#define Cmalloc(x) malloc(x)
13730:387:
13731:388:#define set_error_msg(s) edit_init_error_msg = strdup(s)
13732:389:
13733:390:#ifdef _EDIT_C
13734:391:
13735:392:#define Cerrordialogue(w,x,y,h,s) set_error_msg(s)
13736:393:char *edit_init_error_msg = NULL;
13737:394:#else                           /* ! _EDIT_C */
13738:395:
13739:396:#define Cerrordialogue(w,x,y,h,s) query_dialog (h, s, 0, 1, " Cancel ")
13740:397:#define Cmessagedialogue(w,x,y,h,s) query_dialog (h, s, 0, 1, " Ok ")
13741:398:extern char *edit_init_error_msg;
13742:399:
13743:400:#endif                          /* ! _EDIT_C */
13744:401:
13745:402:#define get_error_msg(s) edit_init_error_msg
13746:403:
13747:404:#else                           /* ! MIDNIGHT */
13748:405:
13749:406:#define Cerrordialogue(w,x,y,h,s) Cerrordialog(w,x,y,h,s)
13750:407:#define Cmessagedialogue(w,x,y,h,s) Cmessagedialog(w,x,y,h,s)
13751:408:#define Cmessagedialogue(w,x,y,h,s) Cmessagedialog(w,x,y,h,s)
13752:409:#define Cquerydialogue Cquerydialog
13753:410:
13754:411:#endif                          /* ! MIDNIGHT */
13755:412:
13756:413:extern char *home_dir;
13757:414:
13758:415:#ifdef _EDIT_C
13759:416:
13760:417:int option_international_characters = 0;
13761:418:int option_tab_spacing = 8;
13762:419:int option_fill_tabs_with_spaces = 0;
13763:420:int option_return_does_auto_indent = 1;
13764:421:int option_backspace_through_tabs = 0;
13765:422:int option_fake_half_tabs = 1;
13766:423:
13767:424:int option_editor_fg_normal = 26;
13768:425:int option_editor_fg_bold = 8;
13769:426:int option_editor_fg_italic = 10;
13770:427:
13771:428:int option_editor_bg_normal = 1;
13772:429:int option_editor_bg_abnormal = 0;
13773:430:int option_editor_bg_marked = 2;
13774:431:int option_editor_bg_marked_abnormal = 9;
13775:432:int option_editor_bg_highlighted = 12;
13776:433:int option_editor_fg_cursor = 18;
13777:434:
13778:435:char *option_whole_chars_search = "0123456789abcdefghijklmnopqrstuvwxyz_";
13779:436:char *option_whole_chars_move =
13780:437:    "0123456789abcdefghijklmnopqrstuvwxyz_; ,[](){}";
13781:438:
13782:439:#else                           /* ! _EDIT_C */
13783:440:
13784:441:extern int option_international_characters;
13785:442:extern int option_tab_spacing;
13786:443:extern int option_fill_tabs_with_spaces;
13787:444:extern int option_return_does_auto_indent;
13788:445:extern int option_backspace_through_tabs;
13789:446:extern int option_fake_half_tabs;
13790:447:
13791:448:extern int option_editor_fg_normal;
13792:449:extern int option_editor_fg_bold;
13793:450:extern int option_editor_fg_italic;
13794:451:
13795:452:extern int option_editor_bg_normal;
13796:453:extern int option_editor_bg_abnormal;
13797:454:extern int option_editor_bg_marked;
13798:455:extern int option_editor_bg_marked_abnormal;
13799:456:extern int option_editor_bg_highlighted;
13800:457:extern int option_editor_fg_cursor;
13801:458:
13802:459:extern char *option_whole_chars_search;
13803:460:extern char *option_whole_chars_move;
13804:461:
13805:462:#endif                          /* ! _EDIT_C */
13806:463:
13807:464:#endif
13808:1:/*
13809:2:   This is #include'd into the function edit_handle_key in edit.c.
13810:3:
13811:4:   This sequence of code takes the integer 'x_state' and the long
13812:5:   integer 'x_key' and translates them into the integer 'command' or the
13813:6:   integer 'char_for_insertion'. 'x_key' holds one of the keys in the
13814:7:   system header file key_sym_def.h (/usr/include/X11/key_sym_def.h on
13815:8:   my Linux machine) and 'x_state' holds a bitwise inclusive OR of
13816:9:   Button1Mask, Button2Mask, ShiftMask, LockMask, ControlMask, Mod1Mask,
13817:10:   Mod2Mask, Mod3Mask, Mod4Mask, or Mod5Mask as explained in the
13818:11:   XKeyEvent man page. The integer 'command' is one of the editor
13819:12:   commands in the header file editcmddef.h
13820:13:
13821:14:   Normally you would only be interested in the ShiftMask and
13822:15:   ControlMask modifiers. The Mod1Mask modifier refers to the Alt key
13823:16:   on my system.
13824:17:
13825:18:   If the particular 'x_key' is an ordinary character (say XK_a) then
13826:19:   you must translate it into 'char_for_insertion', and leave 'command'
13827:20:   untouched.
13828:21:
13829:22:   So for example, to add the key binding Ctrl-@ for marking text,
13830:23:   the following piece of code can be used:
13831:24:
13832:25:   if ((x_state & ControlMask) && x_key == XK_2) {
13833:26:       command = CK_Mark;
13834:27:       goto fin:
13835:28:   }
13836:29:
13837:30:   For another example, suppose you want the exclamation mark key to
13838:31:   insert a '1' then,
13839:32:
13840:33:   if (x_key == XK_exclam) {
13841:34:       char_for_insertion = '1';
13842:35:       goto fin:
13843:36:   }
13844:37:
13845:38:   However you must not set both 'command' and 'char_for_insertion';
13846:39:   one or the other only.
13847:40:
13848:41:   Not every combination of key states and keys will work though,
13849:42:   and some experimentation may be necessary.
13850:43:
13851:44:   Almost any C code can go into this file. The code below is an
13852:45:   example that may by appended or modified by the user. For brevity,
13853:46:   it has a lookup table for basic key presses.
13854:47:
13855:48: */
13856:49:
13857:50:#include "editcmddef.h"
13858:51:
13859:52:static long key_map[128] =
13860:53:    { XK_BackSpace, CK_BackSpace, XK_Delete, CK_Delete, XK_Return,
13861:54:CK_Return, XK_Page_Up, CK_Page_Up,
13862:55:    XK_Page_Down, CK_Page_Down, XK_Left, CK_Left, XK_Right, CK_Right,
13863:56:        XK_Up, CK_Up, XK_Down, CK_Down,
13864:57:    XK_Home, CK_Home, XK_End, CK_End, XK_Tab, CK_Tab, XK_Undo, CK_Undo,
13865:58:        XK_Insert, CK_Toggle_Insert,
13866:59:    XK_F3, CK_Mark, XK_F5, CK_Copy, XK_F6, CK_Move, XK_F8, CK_Remove,
13867:60:        XK_F2, CK_Save, XK_F12, CK_Save_As,
13868:61:    XK_F10, CK_Exit, /* XK_Escape, CK_Exit, this may be a bit rash */
13869:62:        XK_F19, CK_Pipe_Block (0),
13870:63:    XK_F4, CK_Replace, XK_F17, CK_Find_Again, XK_F7, CK_Find, XK_F15,
13871:64:        CK_Insert_File, 0, 0
13872:65:};
13873:66:
13874:67:static long key_pad_map[10] =
13875:68:    { XK_Insert, XK_End, XK_Down, XK_Page_Down, XK_Left,
13876:69:    XK_Down, XK_Right, XK_Home, XK_Up, XK_Page_Up
13877:70:};
13878:71:
13879:72:
13880:73:#define DEFAULT_NUM_LOCK        1
13881:74:
13882:75:static int num_lock = DEFAULT_NUM_LOCK;
13883:76:static int raw = 0;
13884:77:int i = 0;
13885:78:int h;
13886:79:
13887:80:if (edit)
13888:81:    if (edit->user_defined_key)
13889:82:        if ((h = (*(edit->user_defined_key)) (x_state, x_keycode))) {
13890:83:            command = h;
13891:84:            goto fin;
13892:85:        }
13893:86:
13894:87:if (x_key <= 0 || x_key == XK_Control_L || x_key == XK_Control_R
13895:88:    || x_key == XK_Shift_L || x_key == XK_Shift_R || x_key == XK_Alt_L
13896:89:    || x_key == XK_Alt_R)
13897:90:    goto fin;
13898:91:
13899:92:if (raw) {
13900:93:    char_for_insertion = x_key - XK_space + ' ';
13901:94:    if (x_state & ControlMask)
13902:95:        char_for_insertion &= 31;
13903:96:    if (x_state & (Mod1Mask))
13904:97:        char_for_insertion |= 128;
13905:98:    raw = 0;
13906:99:    goto fin;
13907:100:}
13908:101:
13909:102:if ((x_state & Mod1Mask)) {
13910:103:    switch (x_key) {
13911:104:    case XK_Left:
13912:105:    case XK_KP_Left:
13913:106:        command = CK_Delete_Word_Left;
13914:107:        goto fin;
13915:108:    case XK_Right:
13916:109:    case XK_KP_Right:
13917:110:        command = CK_Delete_Word_Right;
13918:111:        goto fin;
13919:112:    case XK_l:
13920:113:    case XK_L:
13921:114:        command = CK_Goto;
13922:115:        goto fin;
13923:116:    case XK_F5:
13924:117:        command = CK_Sort;
13925:118:        goto fin;
13926:119:    case XK_F7:
13927:120:        command = CK_Run_Make;
13928:121:        goto fin;
13929:122:    }
13930:123:}
13931:124:
13932:125:if (!(x_state & Mod1Mask)) {
13933:126:
13934:127:    if ((x_key == XK_a || x_key == XK_A) && (x_state & ControlMask)) {
13935:128:        command =
13936:129:            CK_Macro (Crawkeyquery
13937:130:                      (0, 0, 0, " Execute Macro ",
13938:131:                       " Press macro hotkey: "));
13939:132:        if (command == CK_Macro (0))
13940:133:            command = -1;
13941:134:        goto fin;
13942:135:    }
13943:136:/* edit is a pointer to the widget */
13944:137:    if (edit)
13945:138:        if ((x_key == XK_r || x_key == XK_R) && (x_state & ControlMask)) {
13946:139:            command =
13947:140:                edit->macro_i <
13948:141:                0 ? CK_Begin_Record_Macro : CK_End_Record_Macro;
13949:142:            goto fin;
13950:143:        }
13951:144:    if (x_key == XK_Num_Lock) {
13952:145:        num_lock = 1 - num_lock;
13953:146:        goto fin;
13954:147:    }
13955:148:
13956:149:    switch (x_key) {
13957:150:    case XK_KP_Home:
13958:151:        x_key = XK_Home;
13959:152:        break;
13960:153:    case XK_KP_End:
13961:154:        x_key = XK_End;
13962:155:        break;
13963:156:    case XK_KP_Page_Up:
13964:157:        x_key = XK_Page_Up;
13965:158:        break;
13966:159:    case XK_KP_Page_Down:
13967:160:        x_key = XK_Page_Down;
13968:161:        break;
13969:162:    case XK_KP_Up:
13970:163:        x_key = XK_Up;
13971:164:        break;
13972:165:    case XK_KP_Down:
13973:166:        x_key = XK_Down;
13974:167:        break;
13975:168:    case XK_KP_Left:
13976:169:        x_key = XK_Left;
13977:170:        break;
13978:171:    case XK_KP_Right:
13979:172:        x_key = XK_Right;
13980:173:        break;
13981:174:    case XK_KP_Insert:
13982:175:        x_key = XK_Insert;
13983:176:        break;
13984:177:    case XK_KP_Delete:
13985:178:        x_key = XK_Delete;
13986:179:        break;
13987:180:    case XK_KP_Enter:
13988:181:        x_key = XK_Return;
13989:182:        break;
13990:183:    case XK_KP_Add:
13991:184:        x_key = XK_plus;
13992:185:        break;
13993:186:    case XK_KP_Subtract:
13994:187:        x_key = XK_minus;
13995:188:        break;
13996:189:    }
13997:190:
13998:191:/* first translate the key-pad */
13999:192:    if (num_lock) {
14000:193:        if (x_key >= XK_R1 && x_key <= XK_R9) {
14001:194:            x_key = key_pad_map[x_key - XK_R1 + 1];
14002:195:        } else if (x_key >= XK_KP_0 && x_key <= XK_KP_9) {
14003:196:            x_key = key_pad_map[x_key - XK_KP_0];
14004:197:        } else if (x_key == XK_KP_Decimal) {
14005:198:            x_key = XK_Delete;
14006:199:        }
14007:200:    } else {
14008:201:        if (x_key >= XK_KP_0 && x_key <= XK_KP_9) {
14009:202:            x_key += XK_0 - XK_KP_0;
14010:203:        }
14011:204:        if (x_key == XK_KP_Decimal) {
14012:205:            x_key = XK_period;
14013:206:        }
14014:207:    }
14015:208:
14016:209:    if ((x_state & ShiftMask) && (x_state & ControlMask)) {
14017:210:        switch (x_key) {
14018:211:        case XK_Page_Up:
14019:212:            command = CK_Beginning_Of_Text_Highlight;
14020:213:            goto fin;
14021:214:        case XK_Page_Down:
14022:215:            command = CK_End_Of_Text_Highlight;
14023:216:            goto fin;
14024:217:        case XK_Left:
14025:218:            command = CK_Word_Left_Highlight;
14026:219:            goto fin;
14027:220:        case XK_Right:
14028:221:            command = CK_Word_Right_Highlight;
14029:222:            goto fin;
14030:223:        case XK_Up:
14031:224:            command = CK_Scroll_Up_Highlight;
14032:225:            goto fin;
14033:226:        case XK_Down:
14034:227:            command = CK_Scroll_Down_Highlight;
14035:228:            goto fin;
14036:229:        case XK_Home:
14037:230:            command = CK_Begin_Page_Highlight;
14038:231:            goto fin;
14039:232:        case XK_End:
14040:233:            command = CK_End_Page_Highlight;
14041:234:            goto fin;
14042:235:        }
14043:236:    }
14044:237:    if ((x_state & ShiftMask) && !(x_state & ControlMask)) {
14045:238:        switch (x_key) {
14046:239:        case XK_Page_Up:
14047:240:            command = CK_Page_Up_Highlight;
14048:241:            goto fin;
14049:242:        case XK_Page_Down:
14050:243:            command = CK_Page_Down_Highlight;
14051:244:            goto fin;
14052:245:        case XK_Left:
14053:246:            command = CK_Left_Highlight;
14054:247:            goto fin;
14055:248:        case XK_Right:
14056:249:            command = CK_Right_Highlight;
14057:250:            goto fin;
14058:251:        case XK_Up:
14059:252:            command = CK_Up_Highlight;
14060:253:            goto fin;
14061:254:        case XK_Down:
14062:255:            command = CK_Down_Highlight;
14063:256:            goto fin;
14064:257:        case XK_Home:
14065:258:            command = CK_Home_Highlight;
14066:259:            goto fin;
14067:260:        case XK_End:
14068:261:            command = CK_End_Highlight;
14069:262:            goto fin;
14070:263:        case XK_Insert:
14071:264:            command = CK_XPaste;
14072:265:            goto fin;
14073:266:        case XK_Delete:
14074:267:            command = CK_XCut;
14075:268:            goto fin;
14076:269:        case XK_Return:
14077:270:            command = CK_Enter;
14078:271:            goto fin;
14079:272:/* this parallel F12, F19, F15, and F17 for some systems */
14080:273:        case XK_F2:
14081:274:            command = CK_Save_As;
14082:275:            goto fin;
14083:276:        case XK_F9:
14084:277:            command = CK_Pipe_Block (0);
14085:278:            goto fin;
14086:279:        case XK_F5:
14087:280:            command = CK_Insert_File;
14088:281:            goto fin;
14089:282:        case XK_F7:
14090:283:            command = CK_Find_Again;
14091:284:            goto fin;
14092:285:        }
14093:286:    }
14094:287:/* things that need a control key */
14095:288:    if (x_state & ControlMask) {
14096:289:        switch (x_key) {
14097:290:        case XK_F1:
14098:291:            command = CK_Man_Page;
14099:292:            goto fin;
14100:293:        case XK_U:
14101:294:        case XK_u:
14102:295:        case XK_BackSpace:
14103:296:            command = CK_Undo;
14104:297:            goto fin;
14105:298:        case XK_Page_Up:
14106:299:            command = CK_Beginning_Of_Text;
14107:300:            goto fin;
14108:301:        case XK_Page_Down:
14109:302:            command = CK_End_Of_Text;
14110:303:            goto fin;
14111:304:        case XK_Up:
14112:305:            command = CK_Scroll_Up;
14113:306:            goto fin;
14114:307:        case XK_Down:
14115:308:            command = CK_Scroll_Down;
14116:309:            goto fin;
14117:310:        case XK_Left:
14118:311:            command = CK_Word_Left;
14119:312:            goto fin;
14120:313:        case XK_Right:
14121:314:            command = CK_Word_Right;
14122:315:            goto fin;
14123:316:        case XK_Home:
14124:317:            command = CK_Begin_Page;
14125:318:            goto fin;
14126:319:        case XK_End:
14127:320:            command = CK_End_Page;
14128:321:            goto fin;
14129:322:        case XK_N:
14130:323:        case XK_n:
14131:324:            command = CK_New;
14132:325:            goto fin;
14133:326:        case XK_O:
14134:327:        case XK_o:
14135:328:            command = CK_Load;
14136:329:            goto fin;
14137:330:        case XK_P:
14138:331:        case XK_p:
14139:332:            command = CK_Pipe_Block (1);
14140:333:            goto fin;
14141:334:        case XK_D:
14142:335:        case XK_d:
14143:336:            command = CK_Date;
14144:337:            goto fin;
14145:338:        case XK_Q:
14146:339:        case XK_q:
14147:340:            raw = 1;
14148:341:            goto fin;
14149:342:        case XK_F:
14150:343:        case XK_f:
14151:344:            command = CK_Save_Block;
14152:345:            goto fin;
14153:346:        case XK_F5:
14154:347:        case XK_F15:
14155:348:            command = CK_Insert_File;
14156:349:            goto fin;
14157:350:        case XK_Insert:
14158:351:            command = CK_XStore;
14159:352:            goto fin;
14160:353:        case XK_y:
14161:354:        case XK_Y:
14162:355:            command = CK_Delete_Line;
14163:356:            goto fin;
14164:357:        case XK_Delete:
14165:358:            command = CK_Remove;
14166:359:            goto fin;
14167:360:        }
14168:361:    }
14169:362:/* an ordinary ascii character */
14170:363:    if (!(x_state & ControlMask)) {
14171:364:        if (x_key >= XK_space && x_key <= XK_asciitilde) {
14172:365:            char_for_insertion = x_key - XK_space + ' ';
14173:366:            goto fin;
14174:367:        }
14175:368:/* other commands */
14176:369:        i = 0;
14177:370:        while (key_map[i] != x_key && key_map[i])
14178:371:            i += 2;
14179:372:        command = key_map[i + 1];
14180:373:        if (command)
14181:374:            goto fin;
14182:375:    }
14183:376:}
14184:377:
14185:378:fin:
14186:1:/* editor menu definitions and initialisation
14187:2:
14188:3:   Copyright (C) 1996 the Free Software Foundation
14189:4:   
14190:5:   Authors: 1996 Paul Sheer
14191:6:
14192:7:   This program is free software; you can redistribute it and/or modify
14193:8:   it under the terms of the GNU General Public License as published by
14194:9:   the Free Software Foundation; either version 2 of the License, or
14195:10:   (at your option) any later version.
14196:11:   
14197:12:   This program is distributed in the hope that it will be useful,
14198:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
14199:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
14200:15:   GNU General Public License for more details.
14201:16:
14202:17:   You should have received a copy of the GNU General Public License
14203:18:   along with this program; if not, write to the Free Software
14204:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
14205:20:
14206:21:
14207:22:#include <config.h>
14208:23:#include "edit.h"
14209:24:
14210:25:#include "editcmddef.h"
14211:26:
14212:27:#ifdef MIDNIGHT
14213:28:#include "src/mad.h"
14214:29:
14215:30:extern int edit_key_emulation;
14216:31:extern WEdit *wedit;
14217:32:extern WButtonBar *edit_bar;
14218:33:extern Dlg_head *edit_dlg;
14219:34:extern WMenu *edit_menubar;
14220:35:
14221:36:#define Cmessagedialogue(w,x,y,h,s) query_dialog (h, s, 0, 1, " Ok ")
14222:37:#define CFocus(x)
14223:38:
14224:39:static void menu_cmd (int i)
14225:40:{
14226:41:    send_message (wedit->widget.parent, (Widget *) wedit, WIDGET_COMMAND,
14227:42:                  i);
14228:43:}
14229:44:
14230:45:static void menu_key (int i)
14231:46:{
14232:47:    send_message (wedit->widget.parent, (Widget *) wedit, WIDGET_KEY, i);
14233:48:}
14234:49:
14235:50:#else
14236:51:
14237:52:extern CWidget *wedit;
14238:53:
14239:54:void CSetEditMenu (const char *ident)
14240:55:{
14241:56:    wedit = Cwidget (ident);
14242:57:}
14243:58:
14244:59:CWidget *CGetEditMenu (void)
14245:60:{
14246:61:    return wedit;
14247:62:}
14248:63:
14249:64:static void menu_cmd (int i)
14250:65:{
14251:66:    XEvent e;
14252:67:    if (wedit) {
14253:68:        memset (&e, 0, sizeof (XEvent));
14254:69:        e.type = EditorCommand;
14255:70:        e.xkey.keycode = i;
14256:71:        e.xkey.window = wedit->winid;
14257:72:        CFocus (wedit);
14258:73:        CSendEvent (&e);
14259:74:    }
14260:75:}
14261:76:
14262:77:void CEditMenuCommand (int i)
14263:78:{
14264:79:    menu_cmd (i);
14265:80:}
14266:81:
14267:82:static void menu_key (KeySym i, int state)
14268:83:{
14269:84:    int cmd, ch;
14270:85:    if (edit_translate_key (wedit->editor, 0, i, state, &cmd, &ch)) {
14271:86:        if (cmd > 0)
14272:87:            menu_cmd (cmd);
14273:88:    }
14274:89:}
14275:90:
14276:91:void CEditMenuKey (KeySym i, int state)
14277:92:{
14278:93:    menu_key (i, state);
14279:94:}
14280:95:
14281:96:#endif
14282:97:
14283:98:#ifdef MIDNIGHT
14284:99:
14285:100:void edit_wrap_cmd ()
14286:101:{
14287:102:    Cmessagedialogue (CMain, 20, 20, " Word wrap ", " Not yet supported ");
14288:103:    return;                     /* TODO */
14289:104:}
14290:105:
14291:106:void edit_layout_cmd ()
14292:107:{
14293:108:    Cmessagedialogue (CMain, 20, 20, " Layout ", " Not yet supported ");
14294:109:    return;                     /* TODO */
14295:110:}
14296:111:
14297:112:void edit_about_cmd ()
14298:113:{
14299:114:    Cmessagedialogue (CMain, 20, 20, " About ",
14300:115:                      "\n"
14301:116:                      "                 Cooledit  v2.1\n"
14302:117:                      "\n"
14303:118:                      " Copyright (C) 1996 the Free Software Foundation\n"
14304:119:                      "\n"
14305:120:                      "       A user friendly text editor written\n"
14306:121:                      "           for the Midnight Commander.\n");
14307:122:}
14308:123:#endif
14309:124:
14310:125:void menu_load_cmd (void)
14311:126:{
14312:127:    menu_cmd (CK_Load);
14313:128:}
14314:129:void menu_new_cmd (void)
14315:130:{
14316:131:    menu_cmd (CK_New);
14317:132:}
14318:133:void menu_save_cmd (void)
14319:134:{
14320:135:    menu_cmd (CK_Save);
14321:136:}
14322:137:void menu_save_as_cmd (void)
14323:138:{
14324:139:    menu_cmd (CK_Save_As);
14325:140:}
14326:141:void menu_insert_file_cmd (void)
14327:142:{
14328:143:    menu_cmd (CK_Insert_File);
14329:144:}
14330:145:void menu_quit_cmd (void)
14331:146:{
14332:147:    menu_cmd (CK_Exit);
14333:148:}
14334:149:void menu_mark_cmd (void)
14335:150:{
14336:151:    menu_cmd (CK_Mark);
14337:152:}
14338:153:void menu_ins_cmd (void)
14339:154:{
14340:155:    menu_cmd (CK_Toggle_Insert);
14341:156:}
14342:157:void menu_copy_cmd (void)
14343:158:{
14344:159:    menu_cmd (CK_Copy);
14345:160:}
14346:161:void menu_move_cmd (void)
14347:162:{
14348:163:    menu_cmd (CK_Move);
14349:164:}
14350:165:void menu_delete_cmd (void)
14351:166:{
14352:167:    menu_cmd (CK_Remove);
14353:168:}
14354:169:void menu_cut_cmd (void)
14355:170:{
14356:171:    menu_cmd (CK_Save_Block);
14357:172:}
14358:173:void menu_search_cmd (void)
14359:174:{
14360:175:    menu_cmd (CK_Find);
14361:176:}
14362:177:void menu_search_again_cmd (void)
14363:178:{
14364:179:    menu_cmd (CK_Find_Again);
14365:180:}
14366:181:void menu_replace_cmd (void)
14367:182:{
14368:183:    menu_cmd (CK_Replace);
14369:184:}
14370:185:void menu_begin_record_cmd (void)
14371:186:{
14372:187:    menu_cmd (CK_Begin_Record_Macro);
14373:188:}
14374:189:void menu_end_record_cmd (void)
14375:190:{
14376:191:    menu_cmd (CK_End_Record_Macro);
14377:192:}
14378:193:
14379:194:#ifdef MIDNIGHT
14380:195:void menu_wrap_cmd (void)
14381:196:{
14382:197:    edit_wrap_cmd ();
14383:198:}
14384:199:void menu_layout_cmd (void)
14385:200:{
14386:201:    edit_layout_cmd ();
14387:202:}
14388:203:#endif
14389:204:
14390:205:
14391:206:#ifdef MIDNIGHT
14392:207:void menu_exec_macro_cmd (void)
14393:208:{
14394:209:    menu_key (XCTRL ('a'));
14395:210:}
14396:211:#else
14397:212:void menu_exec_macro_cmd (void)
14398:213:{
14399:214:    menu_key (XK_a, ControlMask);
14400:215:}
14401:216:#endif
14402:217:
14403:218:#ifdef MIDNIGHT
14404:219:void menu_c_form_cmd (void)
14405:220:{
14406:221:    menu_key (KEY_F (19));
14407:222:}
14408:223:#endif
14409:224:
14410:225:#ifdef MIDNIGHT
14411:226:void menu_ispell_cmd (void)
14412:227:{
14413:228:    menu_cmd (CK_Pipe_Block (1));
14414:229:}
14415:230:#endif
14416:231:
14417:232:void menu_sort_cmd (void)
14418:233:{
14419:234:    menu_cmd (CK_Sort);
14420:235:}
14421:236:
14422:237:void menu_date_cmd (void)
14423:238:{
14424:239:    menu_cmd (CK_Date);
14425:240:}
14426:241:void menu_undo_cmd (void)
14427:242:{
14428:243:    menu_cmd (CK_Undo);
14429:244:}
14430:245:void menu_beginning_cmd (void)
14431:246:{
14432:247:    menu_cmd (CK_Beginning_Of_Text);
14433:248:}
14434:249:void menu_end_cmd (void)
14435:250:{
14436:251:    menu_cmd (CK_End_Of_Text);
14437:252:}
14438:253:void menu_refresh_cmd (void)
14439:254:{
14440:255:    menu_cmd (CK_Refresh);
14441:256:}
14442:257:void menu_goto_line (void)
14443:258:{
14444:259:    menu_cmd (CK_Goto);
14445:260:}
14446:261:
14447:262:#ifdef MIDNIGHT
14448:263:void menu_lit_cmd (void)
14449:264:{
14450:265:    menu_key (XCTRL ('q'));
14451:266:}
14452:267:#else
14453:268:/* void menu_lit_cmd (void)                {  menu_key(XK_q, ControlMask); } */
14454:269:#endif
14455:270:
14456:271:#ifdef MIDNIGHT
14457:272:
14458:273:static menu_entry FileMenu[] = {
14459:274:    {' ', "Open/load...     C-o", 'O', menu_load_cmd},
14460:275:    {' ', "New              C-n", 'N', menu_new_cmd},
14461:276:    {' ', "", ' ', 0},
14462:277:    {' ', "Save              F2", 'S', menu_save_cmd},
14463:278:    {' ', "save As...       F12", 'A', menu_save_as_cmd},
14464:279:    {' ', "", ' ', 0},
14465:280:    {' ', "Insert file...   F15", 'I', menu_insert_file_cmd},
14466:281:    {' ', "", ' ', 0},
14467:282:    {' ', "aBout...            ", 'B', edit_about_cmd},
14468:283:    {' ', "", ' ', 0},
14469:284:    {' ', "Quit             F10", 'Q', menu_quit_cmd}
14470:285:};
14471:286:
14472:287:static menu_entry FileMenuEmacs[] = {
14473:288:    {' ', "Open/load...     C-o", 'O', menu_load_cmd},
14474:289:    {' ', "New            C-x k", 'N', menu_new_cmd},
14475:290:    {' ', "", ' ', 0},
14476:291:    {' ', "Save              F2", 'S', menu_save_cmd},
14477:292:    {' ', "save As...       F12", 'A', menu_save_as_cmd},
14478:293:    {' ', "", ' ', 0},
14479:294:    {' ', "Insert file...   F15", 'I', menu_insert_file_cmd},
14480:295:    {' ', "", ' ', 0},
14481:296:    {' ', "aBout...            ", 'B', edit_about_cmd},
14482:297:    {' ', "", ' ', 0},
14483:298:    {' ', "Quit             F10", 'Q', menu_quit_cmd}
14484:299:};
14485:300:
14486:301:static menu_entry EditMenu[] = {
14487:302:    {' ', "Toggle Mark       F3", 'T', menu_mark_cmd},
14488:303:    {' ', "", ' ', 0},
14489:304:    {' ', "toggle Ins/overw Ins", 'I', menu_ins_cmd},
14490:305:    {' ', "", ' ', 0},
14491:306:    {' ', "Copy              F5", 'C', menu_copy_cmd},
14492:307:    {' ', "Move              F6", 'M', menu_move_cmd},
14493:308:    {' ', "Delete            F8", 'D', menu_delete_cmd},
14494:309:    {' ', "", ' ', 0},
14495:310:    {' ', "cut to File...   C-f", 'F', menu_cut_cmd},
14496:311:    {' ', "", ' ', 0},
14497:312:    {' ', "Undo             C-u", 'U', menu_undo_cmd},
14498:313:    {' ', "", ' ', 0},
14499:314:    {' ', "Beginning     C-PgUp", 'B', menu_beginning_cmd},
14500:315:    {' ', "End           C-PgDn", 'E', menu_end_cmd}
14501:316:};
14502:317:
14503:318:static menu_entry EditMenuEmacs[] = {
14504:319:    {' ', "Toggle Mark       F3", 'T', menu_mark_cmd},
14505:320:    {' ', "", ' ', 0},
14506:321:    {' ', "toggle Ins/overw Ins", 'I', menu_ins_cmd},
14507:322:    {' ', "", ' ', 0},
14508:323:    {' ', "Copy              F5", 'C', menu_copy_cmd},
14509:324:    {' ', "Move              F6", 'M', menu_move_cmd},
14510:325:    {' ', "Delete            F8", 'D', menu_delete_cmd},
14511:326:    {' ', "", ' ', 0},
14512:327:    {' ', "cut to File...      ", 'F', menu_cut_cmd},
14513:328:    {' ', "", ' ', 0},
14514:329:    {' ', "Undo             C-u", 'U', menu_undo_cmd},
14515:330:    {' ', "", ' ', 0},
14516:331:    {' ', "Beginning     C-PgUp", 'B', menu_beginning_cmd},
14517:332:    {' ', "End           C-PgDn", 'E', menu_end_cmd}
14518:333:};
14519:334:
14520:335:static menu_entry SearReplMenu[] = {
14521:336:    {' ', "Search...         F7", 'S', menu_search_cmd},
14522:337:    {' ', "search Again     F17", 'A', menu_search_again_cmd},
14523:338:    {' ', "Replace...        F4", 'R', menu_replace_cmd}
14524:339:};
14525:340:
14526:341:static menu_entry SearReplMenuEmacs[] = {
14527:342:    {' ', "Search...         F7", 'S', menu_search_cmd},
14528:343:    {' ', "search Again     F17", 'A', menu_search_again_cmd},
14529:344:    {' ', "Replace...        F4", 'R', menu_replace_cmd}
14530:345:};
14531:346:
14532:347:static menu_entry CmdMenu[] = {
14533:348:    {' ', "Goto line...            M-l", 'G', menu_goto_line},
14534:349:    {' ', "", ' ', 0},
14535:350:    {' ', "insert Literal...       C-q", 'L', menu_lit_cmd},
14536:351:    {' ', "", ' ', 0},
14537:352:    {' ', "Refresh screen          C-l", 'R', menu_refresh_cmd},
14538:353:    {' ', "", ' ', 0},
14539:354:    {' ', "Start record macro      C-r", 'S', menu_begin_record_cmd},
14540:355:    {' ', "Finish record macro...  C-r", 'F', menu_end_record_cmd},
14541:356:    {' ', "Execute macro...   C-a, KEY", 'E', menu_exec_macro_cmd},
14542:357:    {' ', "", ' ', 0},
14543:358:    {' ', "insert Date/time        C-d", 'D', menu_date_cmd},
14544:359:    {' ', "", ' ', 0},
14545:360:    {' ', "'ispell' Spell Check    C-p", 'P', menu_ispell_cmd},
14546:361:    {' ', "Sort...                 M-s", 'O', menu_sort_cmd},
14547:362:    {' ', "'indent' C Formatter    F19", 'C', menu_c_form_cmd}
14548:363:};
14549:364:
14550:365:static menu_entry CmdMenuEmacs[] = {
14551:366:    {' ', "Goto line...            M-l", 'G', menu_goto_line},
14552:367:    {' ', "", ' ', 0},
14553:368:    {' ', "insert Literal...       C-q", 'L', menu_lit_cmd},
14554:369:    {' ', "", ' ', 0},
14555:370:    {' ', "Refresh screen          C-l", 'R', menu_refresh_cmd},
14556:371:    {' ', "", ' ', 0},
14557:372:    {' ', "Start record macro      C-r", 'S', menu_begin_record_cmd},
14558:373:    {' ', "Finish record macro...  C-r", 'F', menu_end_record_cmd},
14559:374:    {' ', "Execute macro... C-x e, KEY", 'E', menu_exec_macro_cmd},
14560:375:    {' ', "", ' ', 0},
14561:376:    {' ', "insert Date/time           ", 'D', menu_date_cmd},
14562:377:    {' ', "", ' ', 0},
14563:378:    {' ', "'ispell' Spell Check    C-p", 'P', menu_ispell_cmd},
14564:379:    {' ', "Sort...                 M-s", 'O', menu_sort_cmd},
14565:380:    {' ', "'indent' C Formatter    F19", 'C', menu_c_form_cmd}
14566:381:};
14567:382:
14568:383:static menu_entry OptMenu[] = {
14569:384:    {' ', "Word wrap...", 'W', menu_wrap_cmd},
14570:385:    {' ', "Layout...", 'L', menu_layout_cmd}
14571:386:};
14572:387:
14573:388:static menu_entry OptMenuEmacs[] = {
14574:389:    {' ', "Word wrap...", 'W', menu_wrap_cmd},
14575:390:    {' ', "Layout...", 'L', menu_layout_cmd}
14576:391:};
14577:392:
14578:393:
14579:394:#define menu_entries(x) sizeof(x)/sizeof(menu_entry)
14580:395:
14581:396:Menu EditMenuBar[N_menus];
14582:397:
14583:398:void edit_init_menu_normal (void)
14584:399:{
14585:400:    EditMenuBar[0] =
14586:401:        create_menu (" File ", FileMenu, menu_entries (FileMenu));
14587:402:    EditMenuBar[1] =
14588:403:        create_menu (" Edit ", EditMenu, menu_entries (EditMenu));
14589:404:    EditMenuBar[2] =
14590:405:        create_menu (" Sear/Repl ", SearReplMenu,
14591:406:                     menu_entries (SearReplMenu));
14592:407:    EditMenuBar[3] =
14593:408:        create_menu (" Command ", CmdMenu, menu_entries (CmdMenu));
14594:409:    EditMenuBar[4] =
14595:410:        create_menu (" Options ", OptMenu, menu_entries (OptMenu));
14596:411:}
14597:412:
14598:413:void edit_init_menu_emacs (void)
14599:414:{
14600:415:    EditMenuBar[0] =
14601:416:        create_menu (" File ", FileMenuEmacs,
14602:417:                     menu_entries (FileMenuEmacs));
14603:418:    EditMenuBar[1] =
14604:419:        create_menu (" Edit ", EditMenuEmacs,
14605:420:                     menu_entries (EditMenuEmacs));
14606:421:    EditMenuBar[2] =
14607:422:        create_menu (" Sear/Repl ", SearReplMenuEmacs,
14608:423:                     menu_entries (SearReplMenuEmacs));
14609:424:    EditMenuBar[3] =
14610:425:        create_menu (" Command ", CmdMenuEmacs,
14611:426:                     menu_entries (CmdMenuEmacs));
14612:427:    EditMenuBar[4] =
14613:428:        create_menu (" Options ", OptMenuEmacs,
14614:429:                     menu_entries (OptMenuEmacs));
14615:430:}
14616:431:
14617:432:void edit_done_menu (void)
14618:433:{
14619:434:    int i;
14620:435:    for (i = 0; i < N_menus; i++)
14621:436:        destroy_menu (EditMenuBar[i]);
14622:437:}
14623:438:
14624:439:
14625:440:void edit_drop_menu_cmd (WEdit * e, int which)
14626:441:{
14627:442:    if (edit_menubar->active)
14628:443:        return;
14629:444:    edit_menubar->active = 1;
14630:445:    edit_menubar->dropped = drop_menus;
14631:446:    edit_menubar->previous_selection =
14632:447:        which >= 0 ? which : dlg_item_number (edit_dlg);
14633:448:    if (which >= 0)
14634:449:        edit_menubar->selected = which;
14635:450:    dlg_select_widget (edit_dlg, edit_menubar);
14636:451:}
14637:452:
14638:453:
14639:454:void edit_menu_cmd (WEdit * e)
14640:455:{
14641:456:    edit_drop_menu_cmd (e, -1);
14642:457:}
14643:458:
14644:459:
14645:460:int edit_drop_hotkey_menu (WEdit * e, int key)
14646:461:{
14647:462:    int m = 0;
14648:463:    switch (key) {
14649:464:    case ALT ('f'):
14650:465:        if (edit_key_emulation == EDIT_KEY_EMULATION_EMACS)
14651:466:            return 0;
14652:467:        m = 0;
14653:468:        break;
14654:469:    case ALT ('e'):
14655:470:        m = 1;
14656:471:        break;
14657:472:    case ALT ('s'):
14658:473:        m = 2;
14659:474:        break;
14660:475:    case ALT ('c'):
14661:476:        m = 3;
14662:477:        break;
14663:478:    case ALT ('o'):
14664:479:        m = 4;
14665:480:        break;
14666:481:    default:
14667:482:        return 0;
14668:483:    }
14669:484:
14670:485:    edit_drop_menu_cmd (e, m);
14671:486:    return 1;
14672:487:}
14673:488:
14674:489:#else
14675:490:
14676:491:
14677:492:void CDrawEditMenuButtons (const char *ident, Window parent,
14678:493:                           Window focus_return, int x, int y)
14679:494:{
14680:495:    int d;
14681:496:
14682:497:    Cdrawmenubutton (catstrs (ident, ".filemenu", 0), parent, focus_return,
14683:498:                     x, y, AUTO_WIDTH, AUTO_HEIGHT, 8, " File ",
14684:499:                     "Open...          C-o", 'O', menu_load_cmd,
14685:500:                     "New              C-n", 'N', menu_new_cmd, "", ' ', 0,
14686:501:                     "Save              F2", 'S', menu_save_cmd,
14687:502:                     "save As...       F12", 'A', menu_save_as_cmd, "",
14688:503:                     ' ', 0, "Insert file...   F15", 'I',
14689:504:                     menu_insert_file_cmd, "copy to File...  C-f", 'F',
14690:505:                     menu_cut_cmd);
14691:506:
14692:507:    Cgethintpos (&x, &d);
14693:508:
14694:509:    Cdrawmenubutton (catstrs (ident, ".editmenu", 0), parent, focus_return,
14695:510:                     x, y, AUTO_WIDTH, AUTO_HEIGHT, 9, " Edit ",
14696:511:                     "Toggle Mark         F3", 'T', menu_mark_cmd, "", ' ',
14697:512:                     0, "toggle Ins./overw.    ", 'I', menu_ins_cmd, "",
14698:513:                     ' ', 0, "Copy                F5", 'C', menu_copy_cmd,
14699:514:                     "Move                F6", 'M', menu_move_cmd,
14700:515:                     "Delete              F8", 'D', menu_delete_cmd, "",
14701:516:                     ' ', 0, "Undo       C-BackSpace", 'U', menu_undo_cmd);
14702:517:
14703:518:    Cgethintpos (&x, &d);
14704:519:
14705:520:    Cdrawmenubutton (catstrs (ident, ".searchmenu", 0), parent,
14706:521:                     focus_return, x, y, AUTO_WIDTH, AUTO_HEIGHT, 3,
14707:522:                     " Search/Replace ", "Search...         F7", 'S',
14708:523:                     menu_search_cmd, "search Again     F17", 'A',
14709:524:                     menu_search_again_cmd, "Replace...        F4", 'R',
14710:525:                     menu_replace_cmd);
14711:526:
14712:527:    Cgethintpos (&x, &d);
14713:528:
14714:529:    Cdrawmenubutton (catstrs (ident, ".commandmenu", 0), parent,
14715:530:                     focus_return, x, y, AUTO_WIDTH, AUTO_HEIGHT, 9,
14716:531:                     " Command ", "Goto line...            M-l", 'G',
14717:532:                     menu_goto_line, "", ' ', 0,
14718:533:                     "Start record macro      C-r", 'S',
14719:534:                     menu_begin_record_cmd, "Finish record macro...  C-r",
14720:535:                     'F', menu_end_record_cmd,
14721:536:                     "Execute macro...   C-a, KEY", 'E',
14722:537:                     menu_exec_macro_cmd, "", ' ', 0,
14723:538:                     "insert Date/time        C-d", 'D', menu_date_cmd, "",
14724:539:                     ' ', 0, "Sort...                 M-s", 'O',
14725:540:                     menu_sort_cmd);
14726:541:}
14727:542:
14728:543:
14729:544:#endif
14730:1:#ifndef LEARN_KEYS_H
14731:2:#define LEARN_KEYS_H
14732:3:
14733:4:#include "coolwidget.h"
14734:5:
14735:6:/* each command can be bound to three different keys */
14736:7:struct key_list {
14737:8:    char *key_name;
14738:9:    int command;
14739:10:    unsigned int keycode0, state0;
14740:11:    unsigned int keycode1, state1;
14741:12:    unsigned int keycode2, state2;
14742:13:};
14743:14:
14744:15:#ifndef EDIT_OPTIONS_C
14745:16:extern struct key_list klist[];
14746:17:#endif
14747:18:
14748:19:int get_defined_key (struct key_list klist[], unsigned int state,
14749:20:                     unsigned int keycode);
14750:21:char *find_section (char *t, const char *section);
14751:22:char *get_options_section (const char *file, const char *section);
14752:23:int save_options_section (const char *file, const char *section,
14753:24:                          const char *text);
14754:25:int load_user_defined_keys (struct key_list klist[], const char *file);
14755:26:int save_user_defined_keys (struct key_list klist[], const char *file);
14756:27:char *get_key_text (struct key_list klist[]);
14757:28:CWidget *Cdrawlearnkeys (Window parent, int x, int y, int width,
14758:29:                         int height);
14759:30:int user_defined_key (unsigned int state, unsigned int keycode);
14760:31:int load_keys (const char *file);
14761:32:
14762:33:
14763:34:#endif                          /* LEARN_KEYS_H */
14764:1:/* editor initialisation and callback handler.
14765:2:
14766:3:   Copyright (C) 1996 the Free Software Foundation
14767:4:
14768:5:   Authors: 1996 Paul Sheer
14769:6:
14770:7:   This program is free software; you can redistribute it and/or modify
14771:8:   it under the terms of the GNU General Public License as published by
14772:9:   the Free Software Foundation; either version 2 of the License, or
14773:10:   (at your option) any later version.
14774:11:
14775:12:   This program is distributed in the hope that it will be useful,
14776:13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
14777:14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
14778:15:   GNU General Public License for more details.
14779:16:
14780:17:   You should have received a copy of the GNU General Public License
14781:18:   along with this program; if not, write to the Free Software
14782:19:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
14783:20:
14784:21:#include <config.h>
14785:22:#include "edit.h"
14786:23:
14787:24:#ifndef MIDNIGHT
14788:25:#include "app_glob.c"
14789:26:#include "dirtools.h"
14790:27:#include "coollocal.h"
14791:28:#include "editcmddef.h"
14792:29:#endif
14793:30:
14794:31:
14795:32:
14796:33:#ifndef MIDNIGHT
14797:34:
14798:35:extern int EditExposeRedraw;
14799:36:CWidget *wedit = 0;
14800:37:
14801:38:void Cedit_destroy (CWidget * w)
14802:39:{
14803:40:    if (w) {
14804:41:        edit_clean (w->editor);
14805:42:        if (w->editor)
14806:43:            free (w->editor);
14807:44:        w->editor = NULL;
14808:45:    } else
14809:46:        Cerror ("Trying to destroy non-existing editor widget.\n");
14810:47:}
14811:48:
14812:49:extern int option_editor_bg_normal;
14813:50:
14814:51:/* starting_directory is for the filebrowser */
14815:52:CWidget *Cdraweditor (const char *identifier, Window parent, int x, int y,
14816:53:                      int width, int height, const char *text,
14817:54:                      const char *filename, const char *starting_directory)
14818:55:{
14819:56:    static made_directory = 0;
14820:57:    char *scroll;
14821:58:    CWidget *w;
14822:59:    WEdit *e;
14823:60:    wedit = w = Csetupwidget (identifier, parent, x, y,
14824:61:                              width + 7, height + 6, CEDITOR_WIDGET,
14825:62:                              INPUT_KEY | KeyReleaseMask |
14826:63:                              ButtonMotionMask,
14827:64:                              Ccolor (option_editor_bg_normal), 1);
14828:65:
14829:66:    w->destroy = Cedit_destroy;
14830:67:    if (filename)
14831:68:        w->label = strdup (filename);
14832:69:    else
14833:70:        w->label = strdup ("");
14834:71:
14835:72:    if (!made_directory) {
14836:73:        mkdir (catstrs (home_dir, EDIT_DIR, 0), 0777);
14837:74:        made_directory = 1;
14838:75:    }
14839:76:    e = w->editor = Cmalloc (sizeof (WEdit));
14840:77:    if (!w->editor) {
14841:78:        Cerror ("Error initialising editor.\n");
14842:79:        return 0;
14843:80:    }
14844:81:    w->editor->widget = w;
14845:82:    e = w->editor =
14846:83:        edit_init (e, height / TEXT_PIX_PER_LINE, width / TEXT_M_WIDTH,
14847:84:                   filename, text, starting_directory);
14848:85:    if (!e) {
14849:86:        Cundrawwidget (w->ident);
14850:87:        return 0;
14851:88:    }
14852:89:    e->macro_i = -1;
14853:90:    e->widget = w;
14854:91:
14855:92:    Cdrawtext (catstrs (identifier, ".text", 0), parent, x,
14856:93:               y + height + 6 + WIDGET_SPACING, "%s", e->filename);
14857:94:    Cdrawvertscrollbar (scroll =
14858:95:                        catstrs (identifier, ".vsc", 0), parent,
14859:96:                        x + width + 7 + WIDGET_SPACING, y, height + 6, 20,
14860:97:                        0, 0);
14861:98:    w->scrollbar = Cwidget (scroll);
14862:99:    w->scrollbar->editor = (void *) w;
14863:100:
14864:101:    return w;
14865:102:}
14866:103:
14867:104:void update_scroll_bar (WEdit * e)
14868:105:{
14869:106:    int i, x1, x2;
14870:107:    CWidget *scroll;
14871:108:    scroll = e->widget->scrollbar;
14872:109:    if (!scroll)
14873:110:        return;
14874:111:
14875:112:    i = e->total_lines - e->start_line + 1;
14876:113:    if (i > e->num_widget_lines)
14877:114:        i = e->num_widget_lines;
14878:115:    if (e->total_lines) {
14879:116:        x1 = (double) 65535.0 *e->start_line / (e->total_lines + 1);
14880:117:        x2 = (double) 65535.0 *i / (e->total_lines + 1);
14881:118:    } else {
14882:119:        x1 = 0;
14883:120:        x2 = 65535;
14884:121:    }
14885:122:    if (x1 != scroll->firstline || x2 != scroll->numlines) {
14886:123:        scroll->firstline = x1;
14887:124:        scroll->numlines = x2;
14888:125:        EditExposeRedraw = 1;
14889:126:        Crenderscrollbar (scroll);
14890:127:        EditExposeRedraw = 0;
14891:128:    }
14892:129:}
14893:130:
14894:131:
14895:132:void Cedit_update_screen (WEdit * e)
14896:133:{
14897:134:    XEvent ev;
14898:135:
14899:136:    if (!e)
14900:137:        return;
14901:138:
14902:139:    edit_scroll_screen_over_cursor (e);
14903:140:    update_curs_row (e);
14904:141:    update_curs_col (e);
14905:142:    update_scroll_bar (e);
14906:143:    edit_status (e);
14907:144:
14908:145:/* pop all events for this window for internal handling */
14909:146:    {
14910:147:        int b = 0;
14911:148:        while (XCheckWindowEvent
14912:149:               (CDisplay, e->widget->winid,
14913:150:                KeyPressMask | ButtonPressMask | ButtonReleaseMask |
14914:151:                ButtonMotionMask, &ev)) {
14915:152:            XSendEvent (CDisplay, e->widget->winid, 0, KeyPressMask, &ev); /* don't discard the event, but resend it */
14916:153:            b = 1;
14917:154:        }
14918:155:        if (b && !(e->force & REDRAW_CHAR_ONLY)
14919:156:            && !(e->force & REDRAW_COMPLETELY)) {
14920:157:            e->force |= REDRAW_PAGE;
14921:158:            return;
14922:159:        }
14923:160:    }
14924:161:
14925:162:    if (e->force & REDRAW_COMPLETELY)
14926:163:        e->force |= REDRAW_PAGE;
14927:164:    edit_render_keypress (e);
14928:165:}
14929:166:
14930:167:
14931:168:/* returns the position in the edit buffer of a window click */
14932:169:long edit_get_click_pos (WEdit * edit, int x, int y)
14933:170:{
14934:171:    long click;
14935:172:/* (1) goto to left margin */
14936:173:    click = edit_bol (edit, edit->curs1);
14937:174:
14938:175:/* (1) move up or down */
14939:176:    if (y > (edit->curs_row + 1))
14940:177:        click =
14941:178:            edit_move_forward (edit, click, y - (edit->curs_row + 1), 0);
14942:179:    if (y < (edit->curs_row + 1))
14943:180:        click = edit_move_backward (edit, click, (edit->curs_row + 1) - y);
14944:181:
14945:182:/* (3) move right to x pos */
14946:183:    click = edit_move_forward3 (edit, click, x - edit->start_col - 1, 0);
14947:184:    return click;
14948:185:}
14949:186:
14950:187:void edit_translate_xy (int xs, int ys, int *x, int *y)
14951:188:{
14952:189:    *x = (xs - EDIT_TEXT_HORIZONTAL_OFFSET) / TEXT_M_WIDTH + 1;
14953:190:    *y = (ys - EDIT_TEXT_VERTICAL_OFFSET) / TEXT_PIX_PER_LINE + 1;
14954:191:}
14955:192:
14956:193:static int just_dropped_something = 0;
14957:194:
14958:195:static void mouse_redraw (WEdit * edit, long click)
14959:196:{
14960:197:    edit->force |= REDRAW_PAGE;
14961:198:    update_curs_row (edit);
14962:199:    update_curs_col (edit);
14963:200:    edit->prev_col = edit_get_col (edit);
14964:201:    Cedit_update_screen (edit);
14965:202:    edit->search_start = click;
14966:203:}
14967:204:
14968:205:static void edit_mouse_mark (WEdit * edit, XEvent * event, CEvent * ce)
14969:206:{
14970:207:    static Window win_press = 0;
14971:208:    static int state = 0;       /* 0 = button up, 1 = button pressed, 2 = button pressed and dragging */
14972:209:    static int x_last, y_last;
14973:210:    long click;
14974:211:
14975:212:    update_curs_row (edit);
14976:213:    update_curs_col (edit);
14977:214:
14978:215:    if (event->type != MotionNotify) {
14979:216:        push_action (edit, KEY_PRESS + edit->start_display);
14980:217:        if (edit->mark2 == -1)
14981:218:            push_action (edit, MARK_1 + edit->mark1); /* mark1 must be following the cursor */
14982:219:    }
14983:220:    if (event->type == ButtonPress) {
14984:221:        long start_mark, end_mark;
14985:222:        state = 1;
14986:223:        win_press = edit->widget->winid;
14987:224:        edit->highlight = 0;
14988:225:        edit_translate_xy (event->xbutton.x, event->xbutton.y, &x_last,
14989:226:                           &y_last);
14990:227:        click = edit_get_click_pos (edit, x_last, y_last);
14991:228:        if (!eval_marks (edit, &start_mark, &end_mark)) {
14992:229:            if (start_mark <= click && click < end_mark) { /* if clicked on highlighted text */
14993:230:                unsigned char *t;
14994:231:                if (edit->mark2 < 0)
14995:232:                    edit_mark_cmd (edit, 0);
14996:233:                t = edit_get_block (edit, start_mark, end_mark);
14997:234:                just_dropped_something = 1;
14998:235:                CDrag (event->xbutton.window, DndText, t,
14999:236:                       end_mark - start_mark,
15000:237:                       event->xbutton.button == Button1 ? Button1Mask : 0);
15001:238:                free (t);
15002:239:                return;
15003:240:            }
15004:241:        }
15005:242:        just_dropped_something = 0;
15006:243:        if (edit->mark2 < 0)
15007:244:            edit_mark_cmd (edit, 0);
15008:245:        edit_cursor_move (edit, click - edit->curs1);
15009:246:        if (ce->double_click) {
15010:247:            edit_mark_cmd (edit, 1);
15011:248:            edit_right_word_move (edit);
15012:249:            edit_mark_cmd (edit, 0);
15013:250:            edit_left_word_move (edit);
15014:251:            edit_mark_cmd (edit, 0);
15015:252:        }
15016:253:        mouse_redraw (edit, click);
15017:254:    } else if (event->type == ButtonRelease && state > 0
15018:255:               && win_press == edit->widget->winid) {
15019:256:        int x, y;
15020:257:        edit_translate_xy (event->xbutton.x, event->xbutton.y, &x, &y);
15021:258:        click = edit_get_click_pos (edit, x, y);
15022:259:        state = 0;
15023:260:        edit_cursor_move (edit, click - edit->curs1);
15024:261:        if (edit->mark2 < 0)
15025:262:            edit_mark_cmd (edit, 0);
15026:263:        mouse_redraw (edit, click);
15027:264:    } else if (event->type == MotionNotify && state > 0
15028:265:               && win_press == edit->widget->winid) {
15029:266:        int x, y;
15030:267:        edit_translate_xy (event->xbutton.x, event->xbutton.y, &x, &y);
15031:268:        if (x == x_last && y == y_last && state == 1)
15032:269:            return;
15033:270:        click = edit_get_click_pos (edit, x, y);
15034:271:        if (state == 1) {
15035:272:            state = 2;
15036:273:            edit_mark_cmd (edit, 1);
15037:274:            edit_mark_cmd (edit, 0);
15038:275:        }
15039:276:        edit_cursor_move (edit, click - edit->curs1);
15040:277:        mouse_redraw (edit, click);
15041:278:    }
15042:279:}
15043:280:
15044:281:void linkscrollbartoeditor (CWidget * w, CWidget * editor, XEvent * xevent,
15045:282:                            CEvent * cwevent, int whichscrbutton)
15046:283:{
15047:284:    int redrawtext = 0, i;
15048:285:    WEdit *e;
15049:286:    e = editor->editor;
15050:287:    if (!e)
15051:288:        return;
15052:289:    if (w->firstline > 65535)
15053:290:        w->firstline = 65535;
15054:291:    if (xevent->type == MotionNotify && whichscrbutton == 3) {
15055:292:        edit_move_display (e,
15056:293:                           (double) w->firstline * e->total_lines /
15057:294:                           65535.0 + 1);
15058:295:        redrawtext = 1;
15059:296:    } else if (xevent->type == ButtonPress
15060:297:               && (cwevent->button == Button1
15061:298:                   || cwevent->button == Button2)) {
15062:299:        switch (whichscrbutton) {
15063:300:        case 1:
15064:301:            edit_move_display (e, e->start_line - e->num_widget_lines + 1);
15065:302:            redrawtext = 1;
15066:303:            break;
15067:304:        case 2:
15068:305:            edit_move_display (e, e->start_line - 1);
15069:306:            redrawtext = 1;
15070:307:            break;
15071:308:        case 5:
15072:309:            edit_move_display (e, e->start_line + 1);
15073:310:            redrawtext = 1;
15074:311:            break;
15075:312:        case 4:
15076:313:            edit_move_display (e, e->start_line + e->num_widget_lines - 1);
15077:314:            redrawtext = 1;
15078:315:            break;
15079:316:        }
15080:317:    }
15081:318:    if (e->total_lines)
15082:319:        w->firstline =
15083:320:            (double) 65535.0 *e->start_line / (e->total_lines + 1);
15084:321:    else
15085:322:    w->firstline = 0;
15086:323:    i = e->total_lines - e->start_line + 1;
15087:324:    if (i > e->num_widget_lines)
15088:325:        i = e->num_widget_lines;
15089:326:    if (e->total_lines)
15090:327:        w->numlines = (double) 65535.0 *i / (e->total_lines + 1);
15091:328:    else
15092:329:    w->numlines = 65535;
15093:330:    if (redrawtext) {
15094:331:        e->force |= REDRAW_PAGE;
15095:332:        Csetcursor (0, 0, 0, 0, 0, 0, 0, 0, 0);
15096:333:        {
15097:334:            int b = 0;
15098:335:            XEvent ev;
15099:336:            while (XCheckWindowEvent
15100:337:                   (CDisplay, xevent->xany.window, ButtonMotionMask,
15101:338:                    &ev)) {
15102:339:                e->force |= REDRAW_PAGE;
15103:340:                XSendEvent (CDisplay, e->widget->winid, 0, KeyPressMask, &ev); /* don't discard the event, but resend it */
15104:341:                b = 1;
15105:342:            }
15106:343:            if (b)
15107:344:                return;
15108:345:        }
15109:346:        edit_render_keypress (e);
15110:347:        edit_status (e);
15111:348:    }
15112:349:}
15113:350:
15114:351:
15115:352:#define dnd_null_term_type(d) \
15116:353:        ((d) == DndFile || (d) == DndText || (d) == DndDir || \
15117:354:        (d) == DndLink || (d) == DndExe || (d) == DndURL)
15118:355:
15119:356:
15120:357:int eh_editor (CWidget * w, XEvent * xevent, CEvent * cwevent)
15121:358:{
15122:359:    WEdit *e = w->editor;
15123:360:    char xlat;
15124:361:    KeySym key;
15125:362:    long k = 1;
15126:363:    int cmd, ch;
15127:364:    static int old_tab_spacing = -1;
15128:365:
15129:366:    if (!e)
15130:367:        return 0;
15131:368:    if (!w->scrollbar)
15132:369:        return 0;
15133:370:
15134:371:    if (old_tab_spacing != option_tab_spacing)
15135:372:        e->force |= REDRAW_COMPLETELY;
15136:373:    old_tab_spacing = option_tab_spacing;
15137:374:
15138:375:    switch (xevent->type) {
15139:376:    case ClientMessage:{
15140:377:            int data_type;
15141:378:            unsigned char *data;
15142:379:            unsigned long size;
15143:380:            int xs, ys;
15144:381:            int x, y, r;
15145:382:            long click;
15146:383:            unsigned int state;
15147:384:            long start_mark = 0, end_mark = 0;
15148:385:
15149:386:/* see just below for a comment on what this is for: */
15150:387:            if (CIsDropAcknowledge (xevent, &state) != DndNotDnd) {
15151:388:                if (!(state & Button1Mask) && just_dropped_something) {
15152:389:                    push_action (e, KEY_PRESS + e->start_display);
15153:390:                    edit_block_delete_cmd (e);
15154:391:                    Cedit_update_screen (e);
15155:392:                }
15156:393:                break;
15157:394:            }
15158:395:            data_type = CGetDrop (xevent, &data, &size, &xs, &ys);
15159:396:            if (data_type == DndNotDnd || xs < 0 || ys < 0
15160:397:                || xs >= w->width || ys >= w->height)
15161:398:                break;
15162:399:            edit_translate_xy (xs, ys, &x, &y);
15163:400:            click = edit_get_click_pos (e, x, y);
15164:401:
15165:402:            r = eval_marks (e, &start_mark, &end_mark);
15166:403:            if (r || click < start_mark || click >= end_mark) { /* musn't be able to drop into a block,
15167:404:                                                                   otherwise a single click will copy a block: */
15168:405:                push_action (e, KEY_PRESS + e->start_display);
15169:406:                edit_cursor_move (e, click - e->curs1);
15170:407:                if (data_type == DndFile) {
15171:408:                    edit_insert_file (e, data);
15172:409:                } else if (data_type != DndFiles) {
15173:410:                    if (dnd_null_term_type (data_type)) {
15174:411:                        int len;
15175:412:                        len = strlen (data);
15176:413:                        size = min (len, size);
15177:414:                    }
15178:415:                    while (size--)
15179:416:                        edit_insert_ahead (e, data[size]);
15180:417:                } else {
15181:418:                    while (size--)
15182:419:                        edit_insert_ahead (e,
15183:420:                                           data[size] ? data[size] : '\n');
15184:421:                }
15185:422:/* The drop has now been successfully recieved. We can now send an acknowledge
15186:423:   event back to the window that send the data. When this window recieves
15187:424:   the acknowledge event, the app can decide whether or not to delete the data.
15188:425:   This allows text to be safely moved betweem text windows without the
15189:426:   risk of data being lost. In our case, drag with button1 is a copy
15190:427:   drag, while drag with any other button is a move drag (i.e. the sending
15191:428:   application must delete its selection after recieving an acknowledge
15192:429:   event). We must not, however, send an acknowledge signal if a filelist
15193:430:   (for example) was passed to us, since the sender might take this to
15194:431:   mean that all those file can be deleted! The two types we can acknowledge
15195:432:   are: */
15196:433:                if (data_type == DndText || data_type == DndRawData)
15197:434:                    CDropAcknowledge (xevent);
15198:435:                e->force |= REDRAW_PAGE;
15199:436:                Cedit_update_screen (e);
15200:437:                break;
15201:438:            } else {
15202:439:                push_action (e, KEY_PRESS + e->start_display);
15203:440:                edit_push_markers (e);
15204:441:                edit_set_markers (e, 0, 0);
15205:442:                e->force |= REDRAW_PAGE;
15206:443:                Cedit_update_screen (e);
15207:444:            }
15208:445:        }
15209:446:        break;
15210:447:    case ResizeNotify:
15211:448:        Csetwidgetsize (w->ident, w->width + xevent->xconfigure.x,
15212:449:                        w->height + xevent->xconfigure.y);
15213:450:        e->num_widget_lines = (w->height - 6) / TEXT_PIX_PER_LINE;
15214:451:        e->num_widget_columns = (w->width - 7) / TEXT_M_WIDTH;
15215:452:        Csetwidgetsize (catstrs (w->ident, ".vsc", 0), 20, w->height);
15216:453:        Csetwidgetposition (catstrs (w->ident, ".vsc", 0),
15217:454:                            (Cwidget (catstrs (w->ident, ".vsc", 0)))->x +
15218:455:                            xevent->xconfigure.x, WIDGET_SPACING + 2);
15219:456:        Csetwidgetposition (catstrs (w->ident, ".text", 0),
15220:457:                            WIDGET_SPACING + 2,
15221:458:                            (Cwidget (catstrs (w->ident, ".text", 0)))->y +
15222:459:                            xevent->xconfigure.y);
15223:460:        edit_status (e);
15224:461:        break;
15225:462:    case ButtonPress:
15226:463:        Cresolvebutton (xevent, cwevent);
15227:464:        CFocusWindow (w->winid);
15228:465:        edit_render_tidbits (w);
15229:466:    case ButtonRelease:
15230:467:    case MotionNotify:
15231:468:        edit_mouse_mark (e, xevent, cwevent);
15232:469:        break;
15233:470:    case Expose:
15234:471:        EditExposeRedraw = 1;
15235:472:        edit_render_expose (e, &(xevent->xexpose));
15236:473:        EditExposeRedraw = 0;
15237:474:        return 0;
15238:475:    case FocusIn:
15239:476:    case FocusOut:
15240:477:        e->force |= REDRAW_CHAR_ONLY;
15241:478:        Cedit_update_screen (e);
15242:479:        break;
15243:480:    case KeyRelease:
15244:481:        break;
15245:482:    case KeyPress:
15246:483:        xlat = 0;
15247:484:        key = CKeySym (xevent);
15248:485:        if (!key)
15249:486:            return 0;
15250:487:        k = (long) k *key;
15251:488:        cwevent->ident = w->ident;
15252:489:        cwevent->key = k;
15253:490:        cwevent->xlat = xlat;
15254:491:        cwevent->state = xevent->xkey.state;
15255:492:        if (!edit_translate_key
15256:493:            (e, xevent->xkey.keycode, k, xevent->xkey.state, &cmd, &ch)) {
15257:494:            KeySym c;
15258:495:            c = CKeySym (xevent);
15259:496:            cmd = CKeySymMod (xevent);
15260:497:            if (cmd > 0)
15261:498:                cmd = CK_Macro (cmd);
15262:499:            else
15263:500:                return 0;
15264:501:        }
15265:502:        cwevent->command = cmd;
15266:503:        k = edit_execute_key_command (e, cmd, ch);
15267:504:        Cedit_update_screen (e); /* command changed display, so update display */
15268:505:        return k;
15269:506:    case EditorCommand:
15270:507:        edit_execute_key_command (e, xevent->xkey.keycode, -1);
15271:508:        Cedit_update_screen (e);
15272:509:        return 1;
15273:510:    }
15274:511:    return 0;
15275:512:}
15276:513:
15277:514:
15278:515:
15279:516:#else
15280:517:
15281:518:WEdit *wedit;
15282:519:WButtonBar *edit_bar;
15283:520:Dlg_head *edit_dlg;
15284:521:WMenu *edit_menubar;
15285:522:
15286:523:
15287:524:static int edit_callback (Dlg_head * h, WEdit * edit, int msg, int par);
15288:525:
15289:526:static int edit_mode_callback (struct Dlg_head *h, int id, int msg)
15290:527:{
15291:528:    return 0;
15292:529:}
15293:530:
15294:531:int edit_event (WEdit * edit, Gpm_Event * event, int *result)
15295:532:{
15296:533:    *result = MOU_NORMAL;
15297:534:    update_curs_row (edit);
15298:535:    update_curs_col (edit);
15299:536:    if (event->type & (GPM_DOWN | GPM_DRAG | GPM_UP)) {
15300:537:        if (event->y > 1 && event->x > 0
15301:538:            && event->x <= edit->num_widget_columns
15302:539:            && event->y <= edit->num_widget_lines + 1) {
15303:540:            if (edit->mark2 != -1 && event->type & (GPM_UP | GPM_DRAG))
15304:541:                return 1;       /* a lone up mustn't do anything */
15305:542:            if (event->type & (GPM_DOWN | GPM_UP))
15306:543:                push_key_press (edit);
15307:544:            edit_cursor_move (edit,
15308:545:                              edit_bol (edit, edit->curs1) - edit->curs1);
15309:546:            if (--event->y > (edit->curs_row + 1))
15310:547:                edit_cursor_move (edit,
15311:548:                                  edit_move_forward (edit, edit->curs1,
15312:549:                                                     event->y -
15313:550:                                                     (edit->curs_row + 1),
15314:551:                                                     0)
15315:552:                                  - edit->curs1);
15316:553:            if (event->y < (edit->curs_row + 1))
15317:554:                edit_cursor_move (edit,
15318:555:                                  +edit_move_backward (edit, edit->curs1,
15319:556:                                                       (edit->curs_row +
15320:557:                                                        1) - event->y)
15321:558:                                  - edit->curs1);
15322:559:            edit_cursor_move (edit,
15323:560:                              (int) edit_move_forward3 (edit, edit->curs1,
15324:561:                                                        event->x -
15325:562:                                                        edit->start_col -
15326:563:                                                        1,
15327:564:                                                        0) - edit->curs1);
15328:565:            edit->prev_col = edit_get_col (edit);
15329:566:            if (event->type & GPM_DOWN) {
15330:567:                edit_mark_cmd (edit, 1); /* reset */
15331:568:                edit->highlight = 0;
15332:569:            }
15333:570:            if (!(event->type & GPM_DRAG))
15334:571:                edit_mark_cmd (edit, 0);
15335:572:            edit->force |= REDRAW_COMPLETELY;
15336:573:            update_curs_row (edit);
15337:574:            update_curs_col (edit);
15338:575:            Cedit_update_screen (edit);
15339:576:            return 1;
15340:577:        }
15341:578:    }
15342:579:    return 0;
15343:580:}
15344:581:
15345:582:
15346:583:
15347:584:int menubar_event (Gpm_Event * event, WMenu * menubar); /* menu.c */
15348:585:
15349:586:int edit_mouse_event (Gpm_Event * event, void *x)
15350:587:{
15351:588:    int result;
15352:589:    if (edit_event ((WEdit *) x, event, &result))
15353:590:        return result;
15354:591:    else
15355:592:        return menubar_event (event, edit_menubar);
15356:593:}
15357:594:
15358:595:extern Menu EditMenuBar[5];
15359:596:
15360:597:int edit (char *_file)
15361:598:{
15362:599:    static int made_directory = 0;
15363:600:    int framed = 0;
15364:601:    int midnight_colors[4];
15365:602:    char *text = 0;
15366:603:
15367:604:    if (!made_directory) {
15368:605:        mkdir (catstrs (home_dir, EDIT_DIR, 0), 0777);
15369:606:        made_directory = 1;
15370:607:    }
15371:608:    if (_file) {
15372:609:        if (!(*_file)) {
15373:610:            _file = 0;
15374:611:            text = "";
15375:612:        }
15376:613:    } else
15377:614:        text = "";
15378:615:
15379:616:    if (!(wedit = edit_init (NULL, LINES - 2, COLS, _file, text, ""))) {
15380:617:        message (1, " Error ", get_error_msg (""));
15381:618:        return 0;
15382:619:    }
15383:620:    wedit->macro_i = -1;
15384:621:
15385:622:    /* Create a new dialog and add it widgets to it */
15386:623:    edit_dlg = create_dlg (0, 0, LINES, COLS, midnight_colors,
15387:624:                           edit_mode_callback, "[Internal File Editor]",
15388:625:                           "edit", DLG_NONE);
15389:626:
15390:627:    edit_dlg->raw = 1;          /*so that tab = '\t' key works */
15391:628:
15392:629:    init_widget (&(wedit->widget), 0, 0, LINES - 1, COLS,
15393:630:                 (callback_fn) edit_callback,
15394:631:                 (destroy_fn) edit_clean, (mouse_h) edit_mouse_event, 0);
15395:632:
15396:633:    widget_want_cursor (wedit->widget, 1);
15397:634:
15398:635:    edit_bar = buttonbar_new (1);
15399:636:
15400:637:    if (!framed) {
15401:638:        switch (edit_key_emulation) {
15402:639:        case EDIT_KEY_EMULATION_NORMAL:
15403:640:            edit_init_menu_normal (); /* editmenu.c */
15404:641:            break;
15405:642:        case EDIT_KEY_EMULATION_EMACS:
15406:643:            edit_init_menu_emacs (); /* editmenu.c */
15407:644:            break;
15408:645:        }
15409:646:        edit_menubar = menubar_new (0, 0, COLS, EditMenuBar, N_menus);
15410:647:    }
15411:648:    add_widget (edit_dlg, wedit);
15412:649:
15413:650:    if (!framed)
15414:651:        add_widget (edit_dlg, edit_menubar);
15415:652:
15416:653:    add_widget (edit_dlg, edit_bar);
15417:654:
15418:655:    run_dlg (edit_dlg);
15419:656:
15420:657:    if (!framed)
15421:658:        edit_done_menu ();      /* editmenu.c */
15422:659:
15423:660:    destroy_dlg (edit_dlg);
15424:661:
15425:662:    return 1;
15426:663:}
15427:664:
15428:665:static void edit_my_define (Dlg_head * h, int idx, char *text,
15429:666:                            void (*fn) (WEdit *), WEdit * edit)
15430:667:{
15431:668:    define_label_data (h, (Widget *) edit, idx, text, (buttonbarfn) fn,
15432:669:                       edit);
15433:670:}
15434:671:
15435:672:
15436:673:void cmd_F1 (WEdit * edit)
15437:674:{
15438:675:    send_message (edit->widget.parent, (Widget *) edit, WIDGET_KEY,
15439:676:                  KEY_F (1));
15440:677:}
15441:678:
15442:679:void cmd_F2 (WEdit * edit)
15443:680:{
15444:681:    send_message (edit->widget.parent, (Widget *) edit, WIDGET_KEY,
15445:682:                  KEY_F (2));
15446:683:}
15447:684:
15448:685:void cmd_F3 (WEdit * edit)
15449:686:{
15450:687:    send_message (edit->widget.parent, (Widget *) edit, WIDGET_KEY,
15451:688:                  KEY_F (3));
15452:689:}
15453:690:
15454:691:void cmd_F4 (WEdit * edit)
15455:692:{
15456:693:    send_message (edit->widget.parent, (Widget *) edit, WIDGET_KEY,
15457:694:                  KEY_F (4));
15458:695:}
15459:696:
15460:697:void cmd_F5 (WEdit * edit)
15461:698:{
15462:699:    send_message (edit->widget.parent, (Widget *) edit, WIDGET_KEY,
15463:700:                  KEY_F (5));
15464:701:}
15465:702:
15466:703:void cmd_F6 (WEdit * edit)
15467:704:{
15468:705:    send_message (edit->widget.parent, (Widget *) edit, WIDGET_KEY,
15469:706:                  KEY_F (6));
15470:707:}
15471:708:
15472:709:void cmd_F7 (WEdit * edit)
15473:710:{
15474:711:    send_message (edit->widget.parent, (Widget *) edit, WIDGET_KEY,
15475:712:                  KEY_F (7));
15476:713:}
15477:714:
15478:715:void cmd_F8 (WEdit * edit)
15479:716:{
15480:717:    send_message (edit->widget.parent, (Widget *) edit, WIDGET_KEY,
15481:718:                  KEY_F (8));
15482:719:}
15483:720:
15484:721:void cmd_F9 (WEdit * edit)
15485:722:{
15486:723:    send_message (edit->widget.parent, (Widget *) edit, WIDGET_KEY,
15487:724:                  KEY_F (9));
15488:725:}
15489:726:
15490:727:void cmd_F10 (WEdit * edit)
15491:728:{
15492:729:    send_message (edit->widget.parent, (Widget *) edit, WIDGET_KEY,
15493:730:                  KEY_F (10));
15494:731:}
15495:732:
15496:733:void edit_labels (WEdit * edit)
15497:734:{
15498:735:    Dlg_head *h = edit->widget.parent;
15499:736:
15500:737:    edit_my_define (h, 1, "Help", cmd_F1, edit);
15501:738:    edit_my_define (h, 2, "Save", cmd_F2, edit);
15502:739:    edit_my_define (h, 3, "Mark", cmd_F3, edit);
15503:740:    edit_my_define (h, 4, "Replac", cmd_F4, edit);
15504:741:    edit_my_define (h, 5, "Copy", cmd_F5, edit);
15505:742:    edit_my_define (h, 6, "Move", cmd_F6, edit);
15506:743:    edit_my_define (h, 7, "Search", cmd_F7, edit);
15507:744:    edit_my_define (h, 8, "Delete", cmd_F8, edit);
15508:745:    if (!edit->have_frame)
15509:746:        edit_my_define (h, 9, "PullDn", edit_menu_cmd, edit);
15510:747:    edit_my_define (h, 10, "Quit", cmd_F10, edit);
15511:748:
15512:749:    redraw_labels (h, (Widget *) edit);
15513:750:}
15514:751:
15515:752:
15516:753:long get_key_state ()
15517:754:{
15518:755:    return (long) get_modifier ();
15519:756:}
15520:757:
15521:758:void edit_adjust_size (Dlg_head * h)
15522:759:{
15523:760:    WEdit *edit;
15524:761:    WButtonBar *edit_bar;
15525:762:
15526:763:    edit = (WEdit *) find_widget_type (h, (void *) &edit_callback); /* <---- ansi standard violation */
15527:764:    edit_bar = (WButtonBar *) edit->widget.parent->current->next->widget;
15528:765:    widget_set_size (&edit->widget, 0, 0, LINES - 1, COLS);
15529:766:    widget_set_size (&edit_bar->widget, LINES - 1, 0, 1, COLS);
15530:767:}
15531:768:
15532:769:void Cedit_update_screen (WEdit * e)
15533:770:{
15534:771:    edit_scroll_screen_over_cursor (e);
15535:772:
15536:773:    update_curs_col (e);
15537:774:    edit_status (e);
15538:775:
15539:776:/* pop all events for this window for internal handling */
15540:777:
15541:778:    if (!is_idle ()) {
15542:779:        e->force |= REDRAW_PAGE;
15543:780:        return;
15544:781:    }
15545:782:    if (e->force & REDRAW_COMPLETELY)
15546:783:        e->force |= REDRAW_PAGE;
15547:784:    edit_render_keypress (e);
15548:785:}
15549:786:
15550:787:static int edit_callback (Dlg_head * h, WEdit * e, int msg, int par)
15551:788:{
15552:789:    switch (msg) {
15553:790:    case WIDGET_INIT:
15554:791:        e->force |= REDRAW_COMPLETELY;
15555:792:        edit_labels (e);
15556:793:        break;
15557:794:    case WIDGET_DRAW:
15558:795:        e->force |= REDRAW_COMPLETELY;
15559:796:        e->num_widget_lines = LINES - 2;
15560:797:        e->num_widget_columns = COLS;
15561:798:    case WIDGET_FOCUS:
15562:799:        Cedit_update_screen (e);
15563:800:        return 1;
15564:801:    case WIDGET_KEY:{
15565:802:            int cmd, ch;
15566:803:            if (edit_drop_hotkey_menu (e, par)) /* first check alt-f, alt-e, alt-s, etc for drop menus */
15567:804:                return 1;
15568:805:            if (!edit_translate_key
15569:806:                (e, 0, par, get_key_state (), &cmd, &ch))
15570:807:                return 0;
15571:808:            edit_execute_key_command (e, cmd, ch);
15572:809:            Cedit_update_screen (e);
15573:810:        }
15574:811:        return 1;
15575:812:    case WIDGET_COMMAND:
15576:813:        edit_execute_key_command (e, par, -1);
15577:814:        Cedit_update_screen (e);
15578:815:        return 1;
15579:816:    case WIDGET_CURSOR:
15580:817:        widget_move (&e->widget, e->curs_row + EDIT_TEXT_VERTICAL_OFFSET,
15581:818:                     e->curs_col + e->start_col);
15582:819:        return 1;
15583:820:    }
15584:821:    return default_proc (h, msg, par);
15585:822:}
15586:823:
15587:824:#endif
15588:1:/*
15589:2:   Copyright (C) 1996 Paul Sheer
15590:3:
15591:4:   This program is free software; you can redistribute it and/or modify
15592:5:   it under the terms of the GNU General Public License as published by
15593:6:   the Free Software Foundation; either version 2 of the License, or
15594:7:   (at your option) any later version.
15595:8:
15596:9:   This program is distributed in the hope that it will be useful,
15597:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
15598:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
15599:12:   GNU General Public License for more details.
15600:13:
15601:14:   You should have received a copy of the GNU General Public License
15602:15:   along with this program; if not, write to the Free Software
15603:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
15604:17: */
15605:18:
15606:19:#include <config.h>
15607:20:#include <stdio.h>
15608:21:#include <my_string.h>
15609:22:#include <stdlib.h>
15610:23:#include <stdarg.h>
15611:24:
15612:25:#include <sys/types.h>
15613:26:#include <sys/stat.h>
15614:27:
15615:28:#ifdef HAVE_UNISTD_H
15616:29:#include <unistd.h>
15617:30:#endif
15618:31:
15619:32:#include <sys/errno.h>
15620:33:
15621:34:#ifdef HAVE_FCNTL_H
15622:35:#include <fcntl.h>
15623:36:#endif
15624:37:
15625:38:#include <X11/Xlib.h>
15626:39:#include <X11/Xutil.h>
15627:40:#include <X11/Xresource.h>
15628:41:#include "lkeysym.h"
15629:42:
15630:43:#include "stringtools.h"
15631:44:#include "app_glob.c"
15632:45:#include "dirtools.h"
15633:46:
15634:47:#include "coolwidget.h"
15635:48:#include "dialog.h"
15636:49:#include "editcmddef.h"
15637:50:
15638:51:#include "mad.h"
15639:52:
15640:53:Window Cdrawfilebrowser (const char *identifier, Window parent, int x,
15641:54:                         int y, const char *dir, const char *file,
15642:55:                         const char *label)
15643:56:{
15644:57:    char *filelist = 0;
15645:58:    char *directorylist = 0;
15646:59:    int y2, x2, x3, y3;
15647:60:    Window win;
15648:61:
15649:62:    win = Cdrawheadedwindow (identifier, parent, x, y, 10, 10, label);
15650:63:    (Cwidget (identifier))->options |= CALWAYS_ON_TOP;
15651:64:    if ((filelist = getfilelist (dir, 'f')) == NULL ||
15652:65:        (directorylist = getfilelist (dir, '/')) == NULL) {
15653:66:        Cerrordialog (parent, 20, 20, " File browser ",
15654:67:                      " Unable to read directory ");
15655:68:        Cundrawwidget (identifier);
15656:69:    }
15657:70:    Cgethintpos (&x, &y);
15658:71:    Cdrawtext (catstrs (identifier, ".dir", 0), win, x, y, dir);
15659:72:    Cgethintpos (0, &y);
15660:73:    y3 = y;
15661:74:    Cdrawtextbox (catstrs (identifier, ".fbox", 0), win, x, y,
15662:75:                  TEXT_M_WIDTH * 17 + 7, TEXT_PIX_PER_LINE * 14 + 6, 0, 0,
15663:76:                  filelist, TEXT_FILES);
15664:77:    Cgethintpos (&x2, &y2);
15665:78:    x3 = x2;
15666:79:    Cdrawtextbox (catstrs (identifier, ".dbox", 0), win, x2,
15667:80:                  y + 40 + 8 + WIDGET_SPACING, TEXT_M_WIDTH * 17 + 7,
15668:81:                  y2 - WIDGET_SPACING * 2 - y - 40 - 8, 0, 0,
15669:82:                  directorylist, TEXT_FILES);
15670:83:    Cgethintpos (&x2, &y2);
15671:84:    Cdrawtextinput (catstrs (identifier, ".finp", 0), win, x, y2,
15672:85:                    x2 - WIDGET_SPACING * 2 - 2, AUTO_HEIGHT, 256, file);
15673:86:    Cdrawbitmapbutton (catstrs (identifier, ".ok", 0), win, x3, y3,
15674:87:                       40, 40, Ccolor (6), C_FLAT, tick_bits);
15675:88:    Cdrawbitmapbutton (catstrs (identifier, ".cancel", 0), win,
15676:89:                       x2 - WIDGET_SPACING * 2 - 40 - 8 - 20, y3, 40, 40,
15677:90:                       Ccolor (18), C_FLAT, cross_bits);
15678:91:    Csetsizehintpos (identifier);
15679:92:    if (directorylist)
15680:93:        free (directorylist);
15681:94:    if (filelist)
15682:95:        free (filelist);
15683:96:    return win;
15684:97:}
15685:98:
15686:99:/* options */
15687:100:#define GETFILE_GET_DIRECTORY                1
15688:101:#define GETFILE_GET_EXISTING_FILE        2
15689:102:#define GETFILE_BROWSER                        4
15690:103:
15691:104:/*
15692:105:   Returns "" on no file entered and NULL on exit (i.e. Cancel button pushed)
15693:106:   else returns the file or directory. Result must be immediately copied.
15694:107:   Result must not be free'd.
15695:108: */
15696:109:char *Chandlebrowser (const char *identifier, CEvent * cwevent,
15697:110:                      int options)
15698:111:{
15699:112:    struct stat st;
15700:113:    char *q;
15701:114:    char *idd = catstrs (identifier, ".dbox", 0);
15702:115:    char *idf = catstrs (identifier, ".fbox", 0);
15703:116:    static char estr[MAX_PATH_LEN];
15704:117:    CWidget *input = Cwidget (catstrs (identifier, ".finp", 0));
15705:118:    CWidget *directory = Cwidget (catstrs (identifier, ".dir", 0));
15706:119:    CWidget *filelist = Cwidget (idf);
15707:120:    CWidget *directorylist = Cwidget (idd);
15708:121:    CWidget *textinput = Cwidget (catstrs (identifier, ".finp", 0));
15709:122:
15710:123:    CSetDndDirectory (directory->text);
15711:124:    if (!strcmp (cwevent->ident, idf)
15712:125:        && !(options & (GETFILE_GET_DIRECTORY | GETFILE_BROWSER))
15713:126:        && (cwevent->button == Button1 || cwevent->key == XK_Return)) {
15714:127:        q = strline (filelist->text,
15715:128:                     strmovelines (filelist->text, 0, filelist->cursor,
15716:129:                                   32000));
15717:130:        Cdrawtextinput (textinput->ident, Cwidget (identifier)->winid,
15718:131:                        textinput->x, textinput->y, textinput->width,
15719:132:                        textinput->height, 256, q);
15720:133:    }
15721:134:    if (!strcmp (cwevent->ident, idd)
15722:135:        && (cwevent->button == Button1 || cwevent->key == XK_Return)) {
15723:136:        q = strline (directorylist->text,
15724:137:                     strmovelines (directorylist->text, 0,
15725:138:                                   directorylist->cursor, 32000));
15726:139:        if (*q != ' ')
15727:140:            Cdrawtextinput (catstrs (identifier, ".finp", 0),
15728:141:                            Cwidget (identifier)->winid, textinput->x,
15729:142:                            textinput->y, textinput->width,
15730:143:                            textinput->height, 256, q + 1);
15731:144:    }
15732:145:    if (!strcmp (cwevent->ident, input->ident)) {
15733:146:        switch (cwevent->command) {
15734:147:        case CK_Down:
15735:148:            CFocus (filelist);
15736:149:            Csettextboxpos (filelist, TEXT_SET_CURSOR_LINE, 0);
15737:150:            break;
15738:151:        case CK_Up:
15739:152:            CFocus (filelist);
15740:153:            Csettextboxpos (filelist, TEXT_SET_CURSOR_LINE, 999999);
15741:154:            break;
15742:155:        case CK_Page_Down:
15743:156:            CFocus (filelist);
15744:157:            Csettextboxpos (filelist, TEXT_SET_CURSOR_LINE,
15745:158:                            filelist->height / TEXT_PIX_PER_LINE - 1);
15746:159:            break;
15747:160:        case CK_Page_Up:
15748:161:            CFocus (filelist);
15749:162:            Csettextboxpos (filelist, TEXT_SET_CURSOR_LINE,
15750:163:                            filelist->numlines -
15751:164:                            filelist->height / TEXT_PIX_PER_LINE + 1);
15752:165:            break;
15753:166:        }
15754:167:    }
15755:168:    if (cwevent->key == XK_Escape
15756:169:        || !strcmp (cwevent->ident, catstrs (identifier, ".cancel", 0)))
15757:170:        return 0;
15758:171:
15759:172:    if (options & GETFILE_GET_DIRECTORY) {
15760:173:        if (!strcmp (cwevent->ident, catstrs (identifier, ".ok", 0))) {
15761:174:            strcpy (estr, path_compress (directory->text, ""));
15762:175:            return estr;
15763:176:        }
15764:177:    }
15765:178:    if (!strcmp (cwevent->ident, catstrs (identifier, ".ok", 0))
15766:179:        || cwevent->key == XK_Return
15767:180:        || (cwevent->double_click
15768:181:            && !strcmp (cwevent->ident, catstrs (identifier, ".finp", 0)))
15769:182:        || (cwevent->double_click
15770:183:            && !strcmp (cwevent->ident, catstrs (identifier, ".dbox", 0)))
15771:184:        || (cwevent->double_click
15772:185:            && !strcmp (cwevent->ident,
15773:186:                        catstrs (identifier, ".fbox", 0)))) {
15774:187:        input->keypressed = 0;
15775:188:        strcpy (estr, path_compress (directory->text, input->text));
15776:189:        q = estr + strlen (estr) - 1;
15777:190:        if (!estr[0])
15778:191:            return "";
15779:192:        if (stat (estr, &st)) {
15780:193:            char *be = "";
15781:194:            switch (errno) {
15782:195:            case EACCES:
15783:196:                be = " Search\n permission\n denied for\n this path.\n";
15784:197:                break;
15785:198:            case ENOENT:
15786:199:/* The user wanted a directory, but typed in one that doesn't exist */
15787:200:                if (*q != '/' && !(options & GETFILE_GET_EXISTING_FILE)
15788:201:                    && !(options &
15789:202:                         (GETFILE_GET_DIRECTORY | GETFILE_BROWSER)))
15790:203:                    return estr; /* user wants a new file */
15791:204:                be = " No such\n file/directory.\n";
15792:205:                break;
15793:206:            case ENOTDIR:
15794:207:                be = " No such\n directory.\n";
15795:208:                break;
15796:209:            default:
15797:210:                be = " Could not get\n info on this\n file/directory.\n";
15798:211:                break;
15799:212:            }
15800:213:            Credrawtextbox (catstrs (identifier, ".fbox", 0), "\n", 0);
15801:214:            Credrawtextbox (catstrs (identifier, ".dbox", 0), be, 0);
15802:215:            return "";
15803:216:        }
15804:217:        if (S_ISDIR (st.st_mode)) {
15805:218:            char *f = getfilelist (estr, 'f');
15806:219:            if (strncmp (f, "Error: ", 7)) {
15807:220:                Credrawtextbox (catstrs (identifier, ".fbox", 0), f, 0);
15808:221:                if (f)
15809:222:                    free (f);
15810:223:                Credrawtextbox (catstrs (identifier, ".dbox", 0), f =
15811:224:                                getfilelist (estr, '/'), 0);
15812:225:                if (*q == '/')
15813:226:                    *q = 0;
15814:227:                Credrawtext (catstrs (identifier, ".dir", 0), estr);
15815:228:            }
15816:229:            if (f)
15817:230:                free (f);
15818:231:            return "";
15819:232:        } else {
15820:233:            if (options & (GETFILE_GET_DIRECTORY | GETFILE_BROWSER)) {
15821:234:                Credrawtextbox (catstrs (identifier, ".fbox", 0), "\n", 0);
15822:235:                Credrawtextbox (catstrs (identifier, ".dbox", 0),
15823:236:                                " No such\n directory.\n", 0);
15824:237:                return "";
15825:238:            }
15826:239:            return estr;        /* entry exists and is a file */
15827:240:        }
15828:241:    }
15829:242:    return "";
15830:243:}
15831:244:
15832:245:
15833:246:/* check getdirectory's mem allocation*********** */
15834:247:
15835:248:/* result must be free'd */
15836:249:char *get_file_or_dir (Window parent, int x, int y,
15837:250:                       const char *dir, const char *file,
15838:251:                       const char *label, int options)
15839:252:{
15840:253:    CEvent cwevent;
15841:254:    XEvent xevent;
15842:255:    CState s;
15843:256:
15844:257:    CBackupState (&s);
15845:258:    CDisable ("*");
15846:259:    CEnable ("_cfileBr*");
15847:260:
15848:261:    if (!(parent | x | y)) {
15849:262:        parent = CMain;
15850:263:        x = 20;
15851:264:        y = 20;
15852:265:    }
15853:266:    Cdrawfilebrowser ("Cgetfile", parent, x, y, dir, file, label);
15854:267:
15855:268:    CFocus (Cwidget ("Cgetfile.finp"));
15856:269:
15857:270:    do {
15858:271:        CNextEvent (&xevent, &cwevent);
15859:272:        if (xevent.type == Expose || !xevent.type
15860:273:            || xevent.type == AlarmEvent || xevent.type == InternalExpose
15861:274:            || xevent.type == TickEvent) {
15862:275:            file = "";
15863:276:            continue;
15864:277:        }
15865:278:        file = Chandlebrowser ("Cgetfile", &cwevent, options);
15866:279:        if (!file)
15867:280:            break;
15868:281:    } while (!(*file));
15869:282:
15870:283:    Cundrawwidget ("Cgetfile");
15871:284:
15872:285:    CRestoreState (&s);
15873:286:
15874:287:    if (file)
15875:288:        return strdup (file);
15876:289:    else
15877:290:        return 0;
15878:291:}
15879:292:
15880:293:int cb_browser (CWidget * w, XEvent * x, CEvent * c)
15881:294:{
15882:295:    char id[32], *s;
15883:296:    strcpy (id, w->ident);
15884:297:    s = strchr (id, '.');
15885:298:    if (s)
15886:299:        *s = 0;
15887:300:    if (!Chandlebrowser (id, c, GETFILE_BROWSER))
15888:301:        Cundrawwidget (id);
15889:302:    return 0;
15890:303:}
15891:304:
15892:305:void Cdrawbrowser (const char *ident, Window parent, int x, int y,
15893:306:                   const char *dir, const char *file, const char *label)
15894:307:{
15895:308:    if (!(parent | x | y)) {
15896:309:        parent = CMain;
15897:310:        x = 20;
15898:311:        y = 20;
15899:312:    }
15900:313:
15901:314:    Cdrawfilebrowser (ident, parent, x, y, dir, file, label);
15902:315:
15903:316:    Caddcallback (catstrs (ident, ".dbox", 0), cb_browser);
15904:317:    Caddcallback (catstrs (ident, ".fbox", 0), cb_browser);
15905:318:    Caddcallback (catstrs (ident, ".finp", 0), cb_browser);
15906:319:    Caddcallback (catstrs (ident, ".ok", 0), cb_browser);
15907:320:    Caddcallback (catstrs (ident, ".cancel", 0), cb_browser);
15908:321:
15909:322:    CFocus (Cwidget (catstrs (ident, ".finp", 0)));
15910:323:}
15911:324:
15912:325:char *Cgetfile (Window parent, int x, int y,
15913:326:                const char *dir, const char *file, const char *label)
15914:327:{
15915:328:    return get_file_or_dir (parent, x, y, dir, file, label, 0);
15916:329:}
15917:330:
15918:331:char *Cgetdirectory (Window parent, int x, int y,
15919:332:                     const char *dir, const char *file, const char *label)
15920:333:{
15921:334:    return get_file_or_dir (parent, x, y, dir, file, label,
15922:335:                            GETFILE_GET_DIRECTORY);
15923:336:}
15924:337:
15925:338:char *Cgetsavefile (Window parent, int x, int y,
15926:339:                    const char *dir, const char *file, const char *label)
15927:340:{
15928:341:    return get_file_or_dir (parent, x, y, dir, file, label, 0);
15929:342:}
15930:343:
15931:344:char *Cgetloadfile (Window parent, int x, int y,
15932:345:                    const char *dir, const char *file, const char *label)
15933:346:{
15934:347:    return get_file_or_dir (parent, x, y, dir, file, label,
15935:348:                            GETFILE_GET_EXISTING_FILE);
15936:349:}
15937:1:/* focus.c - records a history of focusses for reverting focus. also does focus cycling
15938:2:
15939:3:   Copyright (C) 1997 Paul Sheer
15940:4:
15941:5:   This program is free software; you can redistribute it and/or modify
15942:6:   it under the terms of the GNU General Public License as published by
15943:7:   the Free Software Foundation; either version 2 of the License, or
15944:8:   (at your option) any later version.
15945:9:
15946:10:   This program is distributed in the hope that it will be useful,
15947:11:   but WITHOUT ANY WARRANTY; without even the implied warranty of
15948:12:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
15949:13:   GNU General Public License for more details.
15950:14:
15951:15:   You should have received a copy of the GNU General Public License
15952:16:   along with this program; if not, write to the Free Software
15953:17:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
15954:18: */
15955:19:
15956:20:#include <config.h>
15957:21:#include <stdio.h>
15958:22:#include <my_string.h>
15959:23:#include <stdlib.h>
15960:24:#include <stdarg.h>
15961:25:
15962:26:#include <X11/Xlib.h>
15963:27:#include <X11/Xutil.h>
15964:28:#include <X11/Xresource.h>
15965:29:
15966:30:#include "stringtools.h"
15967:31:#include "app_glob.c"
15968:32:
15969:33:#include "coolwidget.h"
15970:34:#include "coollocal.h"
15971:35:
15972:36:#include "mad.h"
15973:37:
15974:38:/* Focus stack: This stack remembers the focus history
15975:39:so that when widgets are destroyed, the focus returns to
15976:40:the most recent widget in the history. This is equivalent
15977:41:to the revert_to in the XSetInputFocus() function,
15978:42:however XSetInputFocus() has an effective history of
15979:43:only one.
15980:44:
15981:45:The commands to change focus are CFocusWindow(Window win)
15982:46:and CFocus(CWidget *w)
15983:47:*/
15984:48:
15985:49:#define FOCUS_STACK_SIZE 128
15986:50:static Window focus_stack[FOCUS_STACK_SIZE];
15987:51:static int focus_sp = 0;
15988:52:Window current_focus = -1;
15989:53:
15990:54:void add_to_focus_stack (Window w)
15991:55:{
15992:56:    int i;
15993:57:    i = focus_sp;
15994:58:    while (i--)
15995:59:        if (focus_stack[i] == w) {
15996:60:            focus_sp = i + 1;
15997:61:            return;
15998:62:        }
15999:63:    if (focus_sp >= FOCUS_STACK_SIZE) {
16000:64:#ifdef FOCUS_DEBUG
16001:65:        printf ("add_to_focus_stack(): focus_sp overflow\n");
16002:66:#endif
16003:67:        return;
16004:68:    }
16005:69:    focus_stack[focus_sp++] = w;
16006:70:#ifdef FOCUS_DEBUG
16007:71:    printf ("add_to_focus_stack(): focus_sp = %d\n", focus_sp);
16008:72:#endif
16009:73:}
16010:74:
16011:75:void focus_stack_remove_window (Window w)
16012:76:{
16013:77:    int i;
16014:78:    i = focus_sp;
16015:79:    while (i--)
16016:80:        if (focus_stack[i] == w) {
16017:81:            focus_stack[i] = 0;
16018:82:            while (focus_sp && !focus_stack[focus_sp - 1])
16019:83:                focus_sp--;
16020:84:#ifdef FOCUS_DEBUG
16021:85:            printf ("focus_stack_remove_window(): focus_sp = %d\n",
16022:86:                    focus_sp);
16023:87:#endif
16024:88:            return;
16025:89:        }
16026:90:}
16027:91:
16028:92:Window CGetFocus (void)
16029:93:{
16030:94:    return current_focus;
16031:95:}
16032:96:
16033:97:void CFocusLast (void)
16034:98:{
16035:99:    Window w;
16036:100:    if (!focus_sp)
16037:101:        return;
16038:102:    w = focus_stack[focus_sp - 1];
16039:103:    if (w == current_focus)
16040:104:        return;
16041:105:    if (w)
16042:106:        CFocusWindow (w);
16043:107:}
16044:108:
16045:109:/* set input focus */
16046:110:/* 
16047:111:   If the window is not yet mapped (the 'case MappingNotify:' statement below
16048:112:   sets the mapped member) then CFocus() sets FOCUS_WHEN_MAPPED and CNextEvent
16049:113:   will focus on the window when it gets MappingNotify.
16050:114:   This is to prevent XLib from reporting an error if we focus on a
16051:115:   window that the server has non created.
16052:116:*/
16053:117:
16054:118:/* CFocusWindow() is a macro for */
16055:119:void CFocusWindowNormal (Window win)
16056:120:{
16057:121:    if (win == (Window) - 1 || !win)
16058:122:        return;
16059:123:    XSetInputFocus (CDisplay, win, RevertToNone, CurrentTime);
16060:124:    add_to_focus_stack (win);
16061:125:    current_focus = win;
16062:126:}
16063:127:
16064:128:void CFocusWindowDebug (Window win, int line, char *file)
16065:129:{
16066:130:    printf ("CFocusWindow(): %s:%d\n", file, line);
16067:131:    CFocusWindowNormal (win);
16068:132:}
16069:133:
16070:134:/* CFocus() is a macro for */
16071:135:void CFocusNormal (CWidget * w)
16072:136:{
16073:137:    if (!w)
16074:138:        return;
16075:139:    if (w->mapped & MAPPED) {
16076:140:        CFocusWindowNormal (w->winid);
16077:141:    } else {
16078:142:        w->mapped |= FOCUS_WHEN_MAPPED;
16079:143:    }
16080:144:}
16081:145:
16082:146:void CFocusDebug (CWidget * w, int line, char *file)
16083:147:{
16084:148:    printf ("CFocus(): %s:%d\n", file, line);
16085:149:    CFocusNormal (w);
16086:150:}
16087:151:
16088:152:
16089:153:/* get next sibling of w that has takes_focus set (i.e. that takes user input of any sort) */
16090:154:CWidget *CNextFocus (CWidget * w)
16091:155:{
16092:156:    int i, j;
16093:157:    i = j = Cfindnextchildof (w->parentid, w->winid);
16094:158:    for (;;) {
16095:159:        if (!i) {
16096:160:            i = Cfindfirstchildof (w->parentid);
16097:161:            if (!i)
16098:162:                return 0;
16099:163:        }
16100:164:        if (CW (i)->takes_focus && !CW (i)->disabled)
16101:165:            return CW (i);
16102:166:        w = CW (i);
16103:167:        i = Cfindnextchildof (w->parentid, w->winid);
16104:168:        if (i == j)             /* done a round trip */
16105:169:            return 0;
16106:170:    }
16107:171:}
16108:172:
16109:173:/* previous sibling of same */
16110:174:CWidget *CPreviousFocus (CWidget * w)
16111:175:{
16112:176:    int i, j;
16113:177:    i = j = Cfindpreviouschildof (w->parentid, w->winid);
16114:178:    for (;;) {
16115:179:        if (!i) {
16116:180:            i = Cfindlastchildof (w->parentid);
16117:181:            if (!i)
16118:182:                return 0;
16119:183:        }
16120:184:        if (CW (i)->takes_focus && !CW (i)->disabled)
16121:185:            return CW (i);
16122:186:        w = CW (i);
16123:187:        i = Cfindpreviouschildof (w->parentid, w->winid);
16124:188:        if (i == j)             /* done a round trip */
16125:189:            return 0;
16126:190:    }
16127:191:}
16128:192:
16129:193:/* first child of widget that takes focus (eg w is a window and
16130:194:    a button in the window is returned) */
16131:195:CWidget *CChildFocus (CWidget * w)
16132:196:{
16133:197:    int j, i = Cfindfirstchildof (w->winid);
16134:198:    if (!i)
16135:199:        return 0;
16136:200:    w = CW (i);
16137:201:    if (w->takes_focus)
16138:202:        return w;
16139:203:    j = i = Cfindnextchildof (w->parentid, w->winid);
16140:204:    for (;;) {
16141:205:        if (!i) {
16142:206:            i = Cfindfirstchildof (w->parentid);
16143:207:            if (!i)
16144:208:                return 0;
16145:209:        }
16146:210:        if (CW (i)->takes_focus)
16147:211:            return CW (i);
16148:212:        w = CW (i);
16149:213:        i = Cfindnextchildof (w->parentid, w->winid);
16150:214:        if (i == j)             /* done a round trip */
16151:215:            return 0;
16152:216:    }
16153:217:}
16154:218:
16155:219:/* search for two generations down for the first descendent that is a widget.
16156:220:   If it does not take focus, then its first child is focussed.
16157:221:   If it has no children, the next descendent is searched for. */
16158:222:CWidget *CFindFirstDescendent (Window win)
16159:223:{
16160:224:    int i, j;
16161:225:
16162:226:    i = Cfindfirstchildof (win);
16163:227:    if (i) {                    /* is it a child ? */
16164:228:        if (CW (i)->takes_focus && !CW (i)->disabled) {
16165:229:            return (CW (i));
16166:230:        } else {
16167:231:            CWidget *w;
16168:232:            w = CChildFocus (CW (i));
16169:233:            if (w)
16170:234:                return w;
16171:235:        }
16172:236:    } else {                    /* not a child */
16173:237:        Window root, parent, *children = 0;
16174:238:        unsigned int nchildren = 0;
16175:239:        XQueryTree (CDisplay, win, &root, &parent, &children, &nchildren);
16176:240:        if (!nchildren) {
16177:241:            if (children)
16178:242:                XFree (children);
16179:243:            return 0;
16180:244:        }
16181:245:        for (j = 0; j < nchildren; j++)
16182:246:            if ((i = Cfindfirstchildof (children[j]))) { /* is it a grandchild ? */
16183:247:                if (CW (i)->takes_focus && !CW (i)->disabled) {
16184:248:                    XFree (children);
16185:249:                    return (CW (i));
16186:250:                } else {
16187:251:                    CWidget *w;
16188:252:                    w = CChildFocus (CW (i));
16189:253:                    if (w) {
16190:254:                        XFree (children);
16191:255:                        return w;
16192:256:                    }
16193:257:                }
16194:258:            }
16195:259:        XFree (children);
16196:260:    }
16197:261:    return 0;                   /* not a grandchild */
16198:262:}
16199:1:/*
16200:2:   Copyright (C) 1996 Paul Sheer
16201:3:
16202:4:   This program is free software; you can redistribute it and/or modify
16203:5:   it under the terms of the GNU General Public License as published by
16204:6:   the Free Software Foundation; either version 2 of the License, or
16205:7:   (at your option) any later version.
16206:8:
16207:9:   This program is distributed in the hope that it will be useful,
16208:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
16209:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16210:12:   GNU General Public License for more details.
16211:13:
16212:14:   You should have received a copy of the GNU General Public License
16213:15:   along with this program; if not, write to the Free Software
16214:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
16215:17: */
16216:18:
16217:19:#include <config.h>
16218:20:
16219:21:/* this is a stripped version of gl from svgalib-1.2.10
16220:22:just to provide dummy setcontext, getcontext
16221:23:and clip functions. It does nothing else really. */
16222:24:
16223:25:/* It bares a vague resemblance to : */
16224:26:
16225:27:/* Framebuffer Graphics Libary for Linux, Copyright 1993 Harm Hanemaayer */
16226:28:/* grlib.c      Main module */
16227:29:
16228:30:
16229:31:#include <stdlib.h>
16230:32:#include <my_string.h>
16231:33:#include "vgagl.h"
16232:34:
16233:35:
16234:36:#define uchar unsigned char
16235:37:#define swap(x, y) { int temp = x; x = y; y = temp; }
16236:38:#define swapb(x, y) { uchar temp = x; x = y; y = temp; }
16237:39:#define max(x, y) ((x > y) ? x : y)
16238:40:#define min(x, y) ((x > y) ? y : x)
16239:41:#define outside(x, y) (x < __clipx1 || x > __clipx2 || y < __clipy1 \
16240:42:        || y > __clipy2)
16241:43:#define x_outside(x) (x < __clipx1 || x > __clipx2)
16242:44:#define y_outside(y) (y < __clipy1 || y > __clipy2)
16243:45:#define clipxleft(x) if (x < __clipx1) x = __clipx1;
16244:46:#define clipxright(x) if (x > __clipx2) x = __clipx2;
16245:47:#define clipytop(y) if (y < __clipy1) y = __clipy1;
16246:48:#define clipybottom(y) if (y > __clipy2) y = __clipy2;
16247:49:
16248:50:
16249:51:#define setpixel (*(__currentcontext.ff.driver_setpixel_func))
16250:52:#define getpixel (*(__currentcontext.ff.driver_getpixel_func))
16251:53:#define hline (*(__currentcontext.ff.driver_hline_func))
16252:54:#define fillbox (*(__currentcontext.ff.driver_fillbox_func))
16253:55:#define putbox (*(__currentcontext.ff.driver_putbox_func))
16254:56:#define getbox (*(__currentcontext.ff.driver_getbox_func))
16255:57:#define putboxmask (*(__currentcontext.ff.driver_putboxmask_func))
16256:58:#define putboxpart (*(__currentcontext.ff.driver_putboxpart_func))
16257:59:#define getboxpart (*(__currentcontext.ff.driver_getboxpart_func))
16258:60:#define copybox (*(__currentcontext.ff.driver_copybox_func))
16259:61:
16260:62:
16261:63:#define __currentcontext currentcontext
16262:64:
16263:65:
16264:66:
16265:67:/* Global variables */
16266:68:
16267:69:GraphicsContext currentcontext;
16268:70:
16269:71:/* Initialization and graphics contexts */
16270:72:
16271:73:void gl_setcontextvirtual (int w, int h, int bpp, int bitspp, void *v)
16272:74:{
16273:75:    memset (&currentcontext, 0, sizeof (GraphicsContext));
16274:76:    WIDTH = w;
16275:77:    HEIGHT = h;
16276:78:    BYTESPERPIXEL = bpp;
16277:79:    BITSPERPIXEL = bitspp;
16278:80:    COLORS = 1 << bitspp;
16279:81:    BYTEWIDTH = WIDTH * BYTESPERPIXEL;
16280:82:    VBUF = v;
16281:83:    MODETYPE = CONTEXT_VIRTUAL;
16282:84:    MODEFLAGS = 0;
16283:85:    __clip = 0;
16284:86:}
16285:87:
16286:88:GraphicsContext *gl_allocatecontext ()
16287:89:{
16288:90:    return malloc (sizeof (GraphicsContext));
16289:91:}
16290:92:
16291:93:void gl_setcontext (GraphicsContext * gc)
16292:94:{
16293:95:    currentcontext = *gc;
16294:96:}
16295:97:
16296:98:void gl_getcontext (GraphicsContext * gc)
16297:99:{
16298:100:    *gc = __currentcontext;
16299:101:}
16300:102:
16301:103:void gl_freecontext (GraphicsContext * gc)
16302:104:{
16303:105:    if (gc->modetype == CONTEXT_VIRTUAL)
16304:106:        free (gc->vbuf);
16305:107:}
16306:108:
16307:109:void gl_setcontextwidth (int w)
16308:110:{
16309:111:    __currentcontext.width = currentcontext.width = w;
16310:112:    __currentcontext.bytewidth = currentcontext.bytewidth =
16311:113:        w * BYTESPERPIXEL;
16312:114:}
16313:115:
16314:116:void gl_setcontextheight (int h)
16315:117:{
16316:118:    __currentcontext.height = currentcontext.height = h;
16317:119:}
16318:120:
16319:121:
16320:122:/* Clipping */
16321:123:
16322:124:void gl_setclippingwindow (int x1, int y1, int x2, int y2)
16323:125:{
16324:126:    __clip = 1;
16325:127:    __clipx1 = x1;
16326:128:    __clipy1 = y1;
16327:129:    __clipx2 = x2;
16328:130:    __clipy2 = y2;
16329:131:}
16330:132:
16331:133:void gl_enableclipping ()
16332:134:{
16333:135:    __clip = 1;
16334:136:    __clipx1 = 0;
16335:137:    __clipy1 = 0;
16336:138:    __clipx2 = WIDTH - 1;
16337:139:    __clipy2 = HEIGHT - 1;
16338:140:}
16339:141:
16340:142:void gl_disableclipping ()
16341:143:{
16342:144:    __clip = 0;
16343:145:}
16344:146:
16345:147:
16346:148:void gl_setpixel (int x, int y, int c)
16347:149:{
16348:150:    return;
16349:151:}
16350:152:
16351:153:void gl_line (int x1, int y1, int x2, int y2, int c)
16352:154:{
16353:155:    return;
16354:156:}
16355:1:/* hintpos.c - routines for easy positioning of widgets
16356:2:   Copyright (C) 1996 Paul Sheer
16357:3:
16358:4:   This program is free software; you can redistribute it and/or modify
16359:5:   it under the terms of the GNU General Public License as published by
16360:6:   the Free Software Foundation; either version 2 of the License, or
16361:7:   (at your option) any later version.
16362:8:
16363:9:   This program is distributed in the hope that it will be useful,
16364:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
16365:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16366:12:   GNU General Public License for more details.
16367:13:
16368:14:   You should have received a copy of the GNU General Public License
16369:15:   along with this program; if not, write to the Free Software
16370:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
16371:17: */
16372:18:
16373:19:#include <config.h>
16374:20:#include <stdio.h>
16375:21:#include <my_string.h>
16376:22:#include <stdlib.h>
16377:23:#include <stdarg.h>
16378:24:
16379:25:#include <X11/Xlib.h>
16380:26:#include <X11/Xutil.h>
16381:27:#include <X11/Xresource.h>
16382:28:#include "lkeysym.h"
16383:29:
16384:30:#include "stringtools.h"
16385:31:#include "app_glob.c"
16386:32:#include "coolwidget.h"
16387:33:#include "coollocal.h"
16388:34:
16389:35:#include "mad.h"
16390:36:
16391:37:static int hint_pos_x = 0;
16392:38:static int hint_pos_y = 0;
16393:39:static int hint_pos_max_x = 0;
16394:40:static int hint_pos_max_y = 0;
16395:41:
16396:42:void Cresethintpos (int x, int y)
16397:43:{
16398:44:    hint_pos_x = x;
16399:45:    hint_pos_y = y;
16400:46:    hint_pos_max_x = x;
16401:47:    hint_pos_max_y = y;
16402:48:}
16403:49:
16404:50:void Csethintpos (int x, int y)
16405:51:{
16406:52:    hint_pos_x = x;
16407:53:    hint_pos_y = y;
16408:54:    hint_pos_max_x = max (x, hint_pos_max_x);
16409:55:    hint_pos_max_y = max (y, hint_pos_max_y);
16410:56:}
16411:57:
16412:58:void Cgethintpos (int *x, int *y)
16413:59:{
16414:60:    if (x)
16415:61:        *x = hint_pos_x;
16416:62:    if (y)
16417:63:        *y = hint_pos_y;
16418:64:}
16419:65:
16420:66:void Cgethintlimits (int *max_x, int *max_y)
16421:67:{
16422:68:    if (max_x)
16423:69:        *max_x = hint_pos_max_x;
16424:70:    if (max_y)
16425:71:        *max_y = hint_pos_max_y;
16426:72:}
16427:1:/*
16428:2:   Copyright (C) 1996 Paul Sheer
16429:3:
16430:4:   This program is free software; you can redistribute it and/or modify
16431:5:   it under the terms of the GNU General Public License as published by
16432:6:   the Free Software Foundation; either version 2 of the License, or
16433:7:   (at your option) any later version.
16434:8:
16435:9:   This program is distributed in the hope that it will be useful,
16436:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
16437:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16438:12:   GNU General Public License for more details.
16439:13:
16440:14:   You should have received a copy of the GNU General Public License
16441:15:   along with this program; if not, write to the Free Software
16442:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
16443:17: */
16444:18:
16445:19:
16446:20:/*general note: widget labels and identifiers are copied from
16447:21:   data passed and free'd on widget undraw. */
16448:22:
16449:23:#include <config.h>
16450:24:#include <stdlib.h>
16451:25:#include <stdio.h>
16452:26:
16453:27:#include <X11/Xlib.h>
16454:28:#include <X11/Xutil.h>
16455:29:
16456:30:#include "stringtools.h"
16457:31:#include "app_glob.c"
16458:32:
16459:33:#include "coolwidget.h"
16460:34:#include "dialog.h"
16461:35:
16462:36:#include "mad.h"
16463:37:
16464:38:
16465:39:#define TPRINTF tiffprintf
16466:40:
16467:41:
16468:42:void greyscaletopix (void *pixdata, unsigned char *data, int width,
16469:43:                     int height, int bytedepth)
16470:44:{
16471:45:    long p = width * height - 1;
16472:46:    int i;
16473:47:    static unsigned long c[256] = { 1 };
16474:48:
16475:49:    quad_t *pixquad = pixdata;
16476:50:    word *pixword = pixdata;
16477:51:    byte *pixbyte = pixdata;
16478:52:
16479:53:    if (*c == 1)
16480:54:        for (i = 0; i < 256; i++)
16481:55:            c[i] = Cgrey (i >> 2);
16482:56:
16483:57:    switch (bytedepth) {
16484:58:    case 1:
16485:59:        do {
16486:60:            *(pixbyte + p) = (byte) c[data[p]];
16487:61:        } while (p--);
16488:62:        break;
16489:63:    case 2:
16490:64:        do {
16491:65:            *(pixword + p) = (word) c[data[p]];
16492:66:        } while (p--);
16493:67:        break;
16494:68:    case 3:{
16495:69:            long q = 0;
16496:70:#if THIS_WAY_OR_THAT_WAY==THIS_WAY /* this code is untested  ************ */
16497:71:            do {
16498:72:                *(pixbyte++) = (quad_t) c[data[q]];
16499:73:                *(pixbyte++) = (quad_t) c[data[q]] >> 8;
16500:74:                *(pixbyte++) = (quad_t) c[data[q++]] >> 16;
16501:75:            } while (q <= p);
16502:76:#else
16503:77:            do {
16504:78:                *(pixbyte++) = (quad_t) c[data[q]] >> 16;
16505:79:                *(pixbyte++) = (quad_t) c[data[q]] >> 8;
16506:80:                *(pixbyte++) = (quad_t) c[data[q++]];
16507:81:            } while (q <= p);
16508:82:#endif
16509:83:            break;
16510:84:        }
16511:85:    case 4:
16512:86:        do {
16513:87:            *(pixquad + p) = (quad_t) c[data[p]];
16514:88:        } while (p--);
16515:89:        break;
16516:90:    }
16517:91:}
16518:92:
16519:93:
16520:94:
16521:95:void color8bittopix (void *pixdata, unsigned char *data, int width,
16522:96:                     int height, int bytedepth)
16523:97:{
16524:98:    long p = width * height - 1;
16525:99:    static unsigned long c[256] = { 1 };
16526:100:    quad_t *pixquad = pixdata;
16527:101:    word *pixword = pixdata;
16528:102:    byte *pixbyte = pixdata;
16529:103:
16530:104:    if (c[0] == 1)
16531:105:        memcpy (c, Cpixel, 256 * sizeof (long));
16532:106:
16533:107:    switch (bytedepth) {
16534:108:    case 1:
16535:109:        do {
16536:110:            *(pixbyte + p) = (byte) c[data[p]];
16537:111:        } while (p--);
16538:112:        break;
16539:113:    case 2:
16540:114:        do {
16541:115:            *(pixword + p) = (word) c[data[p]];
16542:116:        } while (p--);
16543:117:        break;
16544:118:    case 3:{
16545:119:            long q = 0;
16546:120:#if THIS_WAY_OR_THAT_WAY==THIS_WAY /* this code is untested  ************ */
16547:121:            do {
16548:122:                *(pixbyte++) = (quad_t) c[data[q]];
16549:123:                *(pixbyte++) = (quad_t) c[data[q]] >> 8;
16550:124:                *(pixbyte++) = (quad_t) c[data[q++]] >> 16;
16551:125:            } while (q <= p);
16552:126:#else
16553:127:            do {
16554:128:                *(pixbyte++) = (quad_t) c[data[q]] >> 16;
16555:129:                *(pixbyte++) = (quad_t) c[data[q]] >> 8;
16556:130:                *(pixbyte++) = (quad_t) c[data[q++]];
16557:131:            } while (q <= p);
16558:132:#endif
16559:133:            break;
16560:134:        }
16561:135:    case 4:
16562:136:        do {
16563:137:            *(pixquad + p) = (quad_t) c[data[p]];
16564:138:        } while (p--);
16565:139:        break;
16566:140:    }
16567:141:}
16568:142:
16569:143:
16570:144:
16571:145:/* width and height refer to the image. 4 pixels will be added on to
16572:146:   this for the border */
16573:147:CWidget *Cdrawbwimage (const char *identifier, Window parent, int x, int y,
16574:148:                       int width, int height, unsigned char *data)
16575:149:{
16576:150:    int bytespp = 16;
16577:151:    CWidget *w;
16578:152:
16579:153:    if (width & 1)
16580:154:        bytespp = 8;
16581:155:    if (!(width & 3))
16582:156:        bytespp = 32;
16583:157:
16584:158:    w = Csetupwidget (identifier, parent, x, y,
16585:159:                      width + 4, height + 4, CBWIMAGE_WIDGET, INPUT_MOTION,
16586:160:                      C_WHITE, 0);
16587:161:
16588:162:    w->ximage = XCreateImage (CDisplay, Cvisual, Cdepth, ZPixmap,
16589:163:                              0, NULL, width, height, bytespp, 0);
16590:164:
16591:165:    if (w->ximage == NULL) {
16592:166:        Cundrawwidget (identifier);
16593:167:        Cerrordialog (CMain, 20, 20, " Cdrawbwimage ",
16594:168:                      " Cannot create Ximage ");
16595:169:        return NULL;
16596:170:    }
16597:171:
16598:172:    w->ximage->data =
16599:173:        Cmalloc (width * height * w->ximage->bits_per_pixel / 8 + 4);
16600:174:
16601:175:/*now format the one-byte-per-pixel-is-an-eight-bit-grey-level
16602:176:   to a bytedepth-per-pixel-is-an-actual-pixel-value format */
16603:177:/*We shift right by two to bring 0-255 grey-scale down to 0-63 for
16604:178:   the coolwidget palette */
16605:179:
16606:180:    if (w->ximage->bits_per_pixel % 8)
16607:181:        Cerror
16608:182:            ("Non-multiple of 8 bits_per_pixel in XImage not supported.\n");
16609:183:
16610:184:    greyscaletopix (w->ximage->data, data, width, height,
16611:185:                    w->ximage->bits_per_pixel / 8);
16612:186:
16613:187:    return w;
16614:188:}
16615:189:
16616:190:
16617:191:/*data[] must be 1 byte per pixel. Each pixel is a value between 0
16618:192:   and 16+27+64 = 107: 0-16 is widget-cool-colors, 16-42 is 3^3 colors,
16619:193:   43-63 is greyscale-colors. */
16620:194:
16621:195:/*width and height refer to the image. 4 pixels will be added on to
16622:196:   this for the border */
16623:197:CWidget *Cdraw8bitimage (const char *identifier, Window parent, int x,
16624:198:                         int y, int width, int height, unsigned char *data)
16625:199:{
16626:200:    int bytespp = 16;
16627:201:    CWidget *w;
16628:202:
16629:203:    if (width & 1)
16630:204:        bytespp = 8;
16631:205:    if (!(width & 3))
16632:206:        bytespp = 32;
16633:207:
16634:208:    w = Csetupwidget (identifier, parent, x, y,
16635:209:                      width + 4, height + 4, C8BITIMAGE_WIDGET,
16636:210:                      INPUT_MOTION, C_WHITE, 0);
16637:211:
16638:212:    w->ximage = XCreateImage (CDisplay, Cvisual, Cdepth, ZPixmap,
16639:213:                              0, NULL, width, height, bytespp, 0);
16640:214:
16641:215:    if (w->ximage == NULL) {
16642:216:        Cundrawwidget (identifier);
16643:217:        Cerrordialog (CMain, 20, 20, " Cdrawbwimage ",
16644:218:                      " Cannot create Ximage ");
16645:219:        return NULL;
16646:220:    }
16647:221:
16648:222:    w->ximage->data =
16649:223:        Cmalloc (width * height * w->ximage->bits_per_pixel / 8);
16650:224:
16651:225:    if (w->ximage->bits_per_pixel % 8)
16652:226:        Cerror
16653:227:            ("Non-multiple of 8 bits_per_pixel in XImage not supported.\n");
16654:228:
16655:229:    color8bittopix (w->ximage->data, data, width, height,
16656:230:                    w->ximage->bits_per_pixel / 8);
16657:231:
16658:232:    return w;
16659:233:}
16660:234:
16661:235:
16662:236:void Crenderbwimage (CWidget * wdt, int x, int y, int rendw, int rendh)
16663:237:{
16664:238:    int w = wdt->width;
16665:239:    int h = wdt->height;
16666:240:    Window win = wdt->winid;
16667:241:    int xim, yim, xwin, ywin;
16668:242:
16669:243:    xim = x - 2;
16670:244:    yim = y - 2;
16671:245:    xwin = x;
16672:246:    ywin = y;
16673:247:    if (xim < 0) {
16674:248:        rendw += xim;
16675:249:        xim = 0;
16676:250:        xwin = 2;
16677:251:    }
16678:252:    if (yim < 0) {
16679:253:        rendh += yim;
16680:254:        yim = 0;
16681:255:        ywin = 2;
16682:256:    }
16683:257:    XPutImage (CDisplay, win, CGC, wdt->ximage,
16684:258:               xim, yim, xwin, ywin, rendw, rendh);
16685:259:
16686:260:    Crenderbevel (win, 0, 0, w - 1, h - 1, 2, 1);
16687:261:}
16688:262:
16689:263:
16690:264:/*xvtarga.c : */
16691:265:
16692:266:
16693:267:/*This file originally comes from XVIEW version 3.1 image viewing utility.
16694:268:   I modified it to my needs. I suppose it isn't really a copyright violation
16695:269:   because the targa image file format is really simple --- I just got
16696:270:   lazy --- and I've changed the code considerably. Here are the original
16697:271:   comments for the file just to acknowledge the help:  */
16698:272:
16699:273:/*
16700:274: * xvtarga.c - load routine for 'targa' format pictures
16701:275: *
16702:276: * written and submitted by:
16703:277: *     Derek Dongray    (dongray@genrad.com)
16704:278: *
16705:279: * The format read/written is actually Targa type 2 uncompressed as
16706:280: * produced by POVray 1.0
16707:281: *
16708:282: * LoadTarga(fname, pinfo)
16709:283: * WriteTarga(fp, pic, ptype, w,h, rmap,gmap,bmap,numcols, cstyle)
16710:284: */
16711:285:
16712:286:
16713:287:/*
16714:288: * Targa Format (near as I can tell)
16715:289: *   0:
16716:290: *   1: colormap type
16717:291: *   2: image type  (1=colmap RGB, 2=uncomp RGB, 3=uncomp gray)
16718:292: *   3: 
16719:293: *   4: 
16720:294: *   5: colormap_length, low byte
16721:295: *   6: colormap_length, high byte
16722:296: *   7: bits per cmap entry     (8, 24, 32)
16723:297: *
16724:298: *  12: width, low byte
16725:299: *  13: width, high byte
16726:300: *  14: height, low byte
16727:301: *  15: height, high byte
16728:302: *  16: bits per pixel (8, 24)
16729:303: *  17: flags  
16730:304: */
16731:305:
16732:306:
16733:307:void tgaerror (const char *errmessage)
16734:308:{
16735:309:    fprintf (stderr, errmessage); /*OR for the application: */
16736:310:                             /*    Cerror (errmessage); *//********/
16737:311:}
16738:312:
16739:313:
16740:314:/*This loads a targa file and converts it to grey scale if it is color */
16741:315:
16742:316:/*it returns a pointer to the data, which consists of contigous
16743:317:   scanlines from the top left. It also returns the width and height.
16744:318:   The returned data are 8bpp greyscale.
16745:319:   Since loadtarga2grey mallocs, the returned pointer must be free'd */
16746:320:
16747:321:
16748:322:unsigned char *loadtarga2grey (const char *fname, long *width,
16749:323:                               long *height, long rowstart, long rowend)
16750:324:{
16751:325:    FILE *fp;
16752:326:    int i, j, k, row, c, c1, w, h, flags, intlace, topleft, trunc,
16753:327:        bytesperpixel;
16754:328:    unsigned char *pic8 = NULL, *pp;
16755:329:    long filesize;
16756:330:
16757:331:    if ((fp = fopen (fname, "r")) == NULL) {
16758:332:        tgaerror ("Cannot open targa image file.\n");
16759:333:        return NULL;
16760:334:    }
16761:335:    /* compute file length */
16762:336:    fseek (fp, 0L, 2);
16763:337:    filesize = ftell (fp);
16764:338:    fseek (fp, 0L, 0);
16765:339:
16766:340:    if (filesize < 18) {
16767:341:        fclose (fp);
16768:342:        tgaerror ("Targa file is too short.\n");
16769:343:        return NULL;
16770:344:    }
16771:345:    /* Discard the first few bytes of the file. */
16772:346:
16773:347:    for (i = 0; i < 12; i++) {
16774:348:        c = getc (fp);
16775:349:    }
16776:350:
16777:351:
16778:352:    /* read in header information */
16779:353:    c = getc (fp);
16780:354:    c1 = getc (fp);
16781:355:    w = c1 * 256 + c;
16782:356:    *width = w;
16783:357:
16784:358:    c = getc (fp);
16785:359:    c1 = getc (fp);
16786:360:    h = c1 * 256 + c;
16787:361:    *height = h;
16788:362:
16789:363:    if (rowstart > rowend) {
16790:364:        tgaerror ("loadtga2grey called with rowstart > rowend.\n");
16791:365:        return NULL;
16792:366:    }
16793:367:    if (rowstart > h)
16794:368:        rowstart = h;
16795:369:
16796:370:    if (rowstart < 0)
16797:371:        rowstart = 0;
16798:372:
16799:373:    if (rowend > h)
16800:374:        rowend = h;
16801:375:
16802:376:    if (w < 2 || h < 2) {
16803:377:        fclose (fp);
16804:378:        tgaerror ("Error in Targa header (bad image size).\n");
16805:379:        return NULL;
16806:380:    }
16807:381:    c = getc (fp);
16808:382:    if (c != 24 && c != 8) {
16809:383:        fclose (fp);
16810:384:        tgaerror ("Unsupported type (not 24-bit or 8-bit)\n");
16811:385:        return NULL;
16812:386:    }
16813:387:    bytesperpixel = c / 8;
16814:388:
16815:389:    flags = getc (fp);
16816:390:    topleft = (flags & 0x20) >> 5;
16817:391:    intlace = (flags & 0xc0) >> 6;
16818:392:
16819:393:    if (intlace && (rowstart || rowend < h || !topleft)) {
16820:394:        tgaerror
16821:395:            ("Cannot load only a part of an interlaced or inverted tga.\n");
16822:396:        return NULL;
16823:397:    }
16824:398:    if ((pic8 = malloc ((rowend - rowstart) * w + 1)) == NULL
16825:399:        || (pp = malloc (w * 3)) == NULL) {
16826:400:        tgaerror ("Cannot allocate memory for tga file.\n");
16827:401:        return NULL;
16828:402:    }
16829:403:    if (rowstart)
16830:404:        fseek (fp, rowstart * w * bytesperpixel, SEEK_CUR);
16831:405:
16832:406:    trunc = 0;
16833:407:
16834:408:    /* read the data */
16835:409:    for (i = 0; i < rowend - rowstart; i++) {
16836:410:        if (intlace == 2) {     /* four pass interlace */
16837:411:            if (i < (1 * h) / 4)
16838:412:                row = 4 * i;
16839:413:            else if (i < (2 * h) / 4)
16840:414:                row = 4 * (i - ((1 * h) / 4)) + 1;
16841:415:            else if (i < (3 * h) / 4)
16842:416:                row = 4 * (i - ((2 * h) / 4)) + 2;
16843:417:            else
16844:418:                row = 4 * (i - ((3 * h) / 4)) + 3;
16845:419:        } else if (intlace == 1) { /* two pass interlace */
16846:420:            if (i < h / 2)
16847:421:                row = 2 * i;
16848:422:            else
16849:423:                row = 2 * (i - h / 2) + 1;
16850:424:        } else
16851:425:            row = i;            /* no interlace */
16852:426:
16853:427:        if (!topleft)
16854:428:            row = (h - row - 1); /* bottom-left origin: invert y */
16855:429:
16856:430:        if (bytesperpixel == 3) {
16857:431:            c = fread (pp, (size_t) 1, (size_t) w * 3, fp);
16858:432:            if (c != w * 3)
16859:433:                trunc = 1;
16860:434:            for (j = 0, k = 0; j < w; j++, k += 3)
16861:435:/*luminance transformation: */
16862:436:                pic8[j + row * w] =
16863:437:                    (int) (11 * pp[k + 2] + 16 * pp[k + 1] +
16864:438:                           5 * pp[k]) >> 5;
16865:439:        } else {
16866:440:            c = fread (pp, (size_t) 1, (size_t) w, fp);
16867:441:            if (c != w)
16868:442:                trunc = 1;
16869:443:            for (j = 0; j < w; j++)
16870:444:                pic8[j + row * w] = pp[j];
16871:445:        }
16872:446:    }
16873:447:
16874:448:    free (pp);
16875:449:
16876:450:    if (trunc) {
16877:451:        tgaerror ("File appears to be truncated.\n");
16878:452:    }
16879:453:    fclose (fp);
16880:454:
16881:455:    return pic8;
16882:456:}
16883:457:
16884:458:
16885:459:
16886:460:/*returns 1 on error */
16887:461:int writetarga (unsigned char *pic8, const char *fname, long w, long h,
16888:462:                int grey)
16889:463:{
16890:464:    FILE *fp;
16891:465:    int i, j;
16892:466:    long index = 0;
16893:467:
16894:468:    if ((fp = fopen (fname, "w+")) == NULL) {
16895:469:        tgaerror ("Cannot open create/overwrite targa image file.\n");
16896:470:        return 1;
16897:471:    }
16898:472:    /* write header information */
16899:473:
16900:474:    putc (0, fp);
16901:475:    putc (0, fp);
16902:476:
16903:477:    if (grey)
16904:478:        putc (3, fp);
16905:479:    else
16906:480:        putc (2, fp);
16907:481:
16908:482:    for (i = 0; i < 9; i++) {
16909:483:        putc (0, fp);
16910:484:    }
16911:485:
16912:486:    putc (w & 0xFF, fp);
16913:487:    putc (w >> 8, fp);
16914:488:
16915:489:    putc (h & 0xFF, fp);
16916:490:    putc (h >> 8, fp);
16917:491:
16918:492:    if (grey)
16919:493:        putc (8, fp);
16920:494:    else
16921:495:        putc (24, fp);
16922:496:
16923:497:    putc (32, fp);              /*top left displayed */
16924:498:
16925:499:    /* write the data */
16926:500:
16927:501:    for (i = 0; i < h; i++) {
16928:502:        if (grey)
16929:503:            fwrite (pic8 + i * w, w, 1, fp);
16930:504:        else
16931:505:            for (j = 0; j < w; j++) {
16932:506:                fputc (pic8[index], fp);
16933:507:                fputc (pic8[index], fp);
16934:508:                fputc (pic8[index++], fp);
16935:509:            }
16936:510:    }
16937:511:
16938:512:    fclose (fp);
16939:513:    return 0;
16940:514:}
16941:1:#ifndef IMAGE_WIDGET_H
16942:2:#define IMAGE_WIDGET_H
16943:3:
16944:4:#include "3dkit.h"
16945:5:
16946:6:void greyscaletopix (void *pixdata, unsigned char *data, int width,
16947:7:                     int height, int bytedepth);
16948:8:
16949:9:unsigned char *loadtarga2grey (const char *fname, long *width,
16950:10:                               long *height, long rowstart, long rowend);
16951:11:
16952:12:int writetarga (unsigned char *pic8, const char *fname, long w, long h,
16953:13:                int grey);
16954:14:
16955:15:void color8bittopix (void *pixdata, unsigned char *data, int width,
16956:16:                     int height, int bytedepth);
16957:17:
16958:18:#endif
16959:1:/*
16960:2:   Copyright (C) 1996 Paul Sheer
16961:3:
16962:4:   This program is free software; you can redistribute it and/or modify
16963:5:   it under the terms of the GNU General Public License as published by
16964:6:   the Free Software Foundation; either version 2 of the License, or
16965:7:   (at your option) any later version.
16966:8:
16967:9:   This program is distributed in the hope that it will be useful,
16968:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
16969:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16970:12:   GNU General Public License for more details.
16971:13:
16972:14:   You should have received a copy of the GNU General Public License
16973:15:   along with this program; if not, write to the Free Software
16974:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
16975:17: */
16976:18:
16977:19:
16978:20:/* setup application */
16979:21:
16980:22:static unsigned char cool_bits[] = {
16981:23:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
16982:24:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x3f, 0x00, 0x00,
16983:25:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x4f, 0xe4, 0x07,
16984:26:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x4a, 0xa4,
16985:27:    0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xcf, 0x4a,
16986:28:    0xa4, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x33,
16987:29:    0x4b, 0xa4, 0x6f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe8,
16988:30:    0x8c, 0x5c, 0x7c, 0xb2, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
16989:31:    0x16, 0x63, 0xe2, 0x47, 0xcc, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
16990:32:    0x00, 0xb1, 0x10, 0x21, 0x84, 0x30, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00,
16991:33:    0x00, 0x80, 0x4c, 0x8c, 0x20, 0x08, 0x41, 0xb4, 0x00, 0x00, 0x00, 0x00,
16992:34:    0x00, 0x00, 0x40, 0xc2, 0x43, 0x20, 0x08, 0x81, 0xeb, 0x01, 0x00, 0x00,
16993:35:    0x00, 0x00, 0x00, 0x20, 0x31, 0x21, 0x10, 0x08, 0x02, 0xb3, 0x03, 0x00,
16994:36:    0x00, 0x00, 0x00, 0x00, 0xb0, 0x08, 0x26, 0x10, 0x10, 0x84, 0xcc, 0x07,
16995:37:    0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x04, 0x7e, 0x10, 0x10, 0x64, 0xb1,
16996:38:    0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x02, 0x81, 0x1f, 0x10, 0x3e,
16997:39:    0x42, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x81, 0x00, 0xe1, 0xff,
16998:40:    0x41, 0x84, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x81, 0x80, 0x00,
16999:41:    0x81, 0x80, 0x08, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x42, 0x80,
17000:42:    0x00, 0x01, 0x81, 0x10, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x4e,
17001:43:    0x40, 0x00, 0x01, 0x01, 0xa1, 0x7a, 0x00, 0x00, 0x00, 0x00, 0x80, 0x08,
17002:44:    0x31, 0x40, 0x00, 0x01, 0x02, 0xe1, 0x74, 0x00, 0x00, 0x00, 0x00, 0x80,
17003:45:    0x04, 0xc1, 0x40, 0x80, 0x00, 0x02, 0x22, 0xa9, 0x00, 0x00, 0x00, 0x00,
17004:46:    0x80, 0x85, 0x00, 0x43, 0x80, 0x00, 0x02, 0x1a, 0xaa, 0x00, 0x00, 0x00,
17005:47:    0x00, 0x40, 0x87, 0x00, 0x7d, 0x80, 0x00, 0x04, 0x26, 0xb2, 0x00, 0x00,
17006:48:    0x00, 0x00, 0x40, 0x45, 0x00, 0xc1, 0x83, 0x00, 0xfc, 0x41, 0x54, 0x01,
17007:49:    0x00, 0x00, 0x00, 0x40, 0x49, 0x80, 0x00, 0xfc, 0xff, 0x87, 0x40, 0x54,
17008:50:    0x01, 0x00, 0x00, 0x00, 0xf8, 0x59, 0x80, 0x00, 0x08, 0x40, 0x00, 0x81,
17009:51:    0x98, 0x01, 0x00, 0x00, 0x80, 0xdf, 0x6e, 0x80, 0x00, 0x08, 0x40, 0x00,
17010:52:    0x81, 0xa8, 0x01, 0x00, 0x00, 0x78, 0x38, 0x98, 0x40, 0x00, 0x08, 0x40,
17011:53:    0x00, 0x82, 0x26, 0x01, 0x00, 0x80, 0xbf, 0x0f, 0x20, 0x41, 0x00, 0x04,
17012:54:    0x80, 0x00, 0x82, 0x45, 0x03, 0x00, 0x60, 0x70, 0x10, 0x78, 0x47, 0x00,
17013:55:    0x04, 0x80, 0x00, 0x62, 0x48, 0x03, 0x00, 0xfc, 0x0f, 0xe0, 0x8f, 0x79,
17014:56:    0x00, 0x04, 0x80, 0x00, 0x1c, 0x48, 0x03, 0x80, 0xe3, 0x10, 0x38, 0x10,
17015:57:    0xc1, 0x03, 0x04, 0x80, 0x80, 0x27, 0x48, 0x03, 0x60, 0x1c, 0x20, 0x07,
17016:58:    0x20, 0x02, 0xfc, 0x04, 0x80, 0x7c, 0x20, 0x90, 0x03, 0x90, 0x28, 0xe0,
17017:59:    0x04, 0x40, 0x04, 0x10, 0xff, 0xff, 0x23, 0x20, 0x50, 0x03, 0x88, 0x48,
17018:60:    0x1e, 0x04, 0x40, 0x04, 0x10, 0x00, 0x02, 0x20, 0x40, 0x50, 0x03, 0x94,
17019:61:    0x08, 0x01, 0x08, 0x80, 0x04, 0x10, 0x00, 0x02, 0x20, 0x40, 0x70, 0x03,
17020:62:    0x14, 0x09, 0x03, 0x08, 0x80, 0x0b, 0x08, 0x00, 0x02, 0x40, 0x40, 0x50,
17021:63:    0x03, 0xa4, 0x8f, 0x01, 0x10, 0x70, 0x08, 0x08, 0x00, 0x02, 0x40, 0x40,
17022:64:    0x48, 0x03, 0x42, 0x48, 0x04, 0x10, 0x0f, 0x08, 0x08, 0x00, 0x02, 0x40,
17023:65:    0x40, 0x4c, 0x03, 0x42, 0x30, 0x00, 0xf0, 0x10, 0x10, 0x08, 0x00, 0x02,
17024:66:    0x40, 0x40, 0x4b, 0x03, 0x26, 0x28, 0x08, 0x0e, 0x10, 0x10, 0x08, 0x00,
17025:67:    0x02, 0x40, 0xc0, 0x48, 0x03, 0x2a, 0x47, 0xc0, 0x01, 0x20, 0x10, 0x08,
17026:68:    0x00, 0x02, 0x40, 0x30, 0x48, 0x01, 0xf2, 0x40, 0x3c, 0x02, 0x20, 0xf0,
17027:69:    0x09, 0x00, 0x02, 0x40, 0x0f, 0x48, 0x01, 0x22, 0xa0, 0x13, 0x02, 0x20,
17028:70:    0x1c, 0x1e, 0x00, 0x02, 0xf0, 0x08, 0x48, 0x01, 0x22, 0xa0, 0x00, 0x04,
17029:71:    0x20, 0x13, 0xe0, 0x0f, 0xc2, 0x0f, 0x08, 0x48, 0x01, 0x22, 0xa0, 0x20,
17030:72:    0x04, 0xf0, 0x11, 0x00, 0xf2, 0x3f, 0x01, 0x08, 0x48, 0x01, 0x22, 0x20,
17031:73:    0x01, 0x04, 0x0f, 0x11, 0x00, 0x02, 0x00, 0x01, 0x08, 0xc8, 0x00, 0x22,
17032:74:    0xa0, 0x23, 0xf4, 0x00, 0x11, 0x00, 0x02, 0x00, 0x01, 0x08, 0xc8, 0x00,
17033:75:    0x22, 0x60, 0x0d, 0x8f, 0x00, 0x11, 0x00, 0x02, 0x00, 0x01, 0x08, 0x48,
17034:76:    0x00, 0x22, 0x18, 0xf1, 0x80, 0x00, 0x11, 0x00, 0x02, 0x00, 0x01, 0x08,
17035:77:    0x28, 0x00, 0x2c, 0x07, 0x01, 0x80, 0x00, 0x11, 0x00, 0x02, 0x00, 0x01,
17036:78:    0x08, 0x18, 0x00, 0xf0, 0x00, 0x21, 0x80, 0x00, 0x11, 0x00, 0x02, 0x00,
17037:79:    0x01, 0x08, 0x0c, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x11, 0x00, 0x02,
17038:80:    0x00, 0x01, 0x08, 0x03, 0x00, 0x00, 0x00, 0x21, 0x80, 0x00, 0x11, 0x00,
17039:81:    0x02, 0x00, 0x01, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x39,
17040:82:    0x00, 0x02, 0x00, 0x01, 0x38, 0x00, 0x00, 0x00, 0x00, 0x21, 0x80, 0x00,
17041:83:    0xc7, 0x07, 0x02, 0x00, 0x81, 0x07, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80,
17042:84:    0xe0, 0x00, 0xf8, 0x03, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21,
17043:85:    0x80, 0x1c, 0x00, 0x00, 0xfc, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
17044:86:    0x02, 0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
17045:87:    0x00, 0x2c, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
17046:88:    0x00, 0x00, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
17047:89:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
17048:90:    0x00, 0x00
17049:91:};
17050:92:
17051:93:
17052:94:/*
17053:95:Colormap allocation:
17054:96:
17055:97:A colormap is allocated as follows into the array Cpixel:
17056:98:('i' refers to Cpixel[i])
17057:99:
17058:100:These are allocated in sequential palette cells, hence
17059:101:(for pseudocolor only) Cpixel[j + i] = Cpixel[j] + i,
17060:102:for j = 0,16,43. Obviously in TrueColor this is not true.
17061:103:
17062:104:,----------+------------------------------------------.
17063:105:|    i     |   colors                                 |
17064:106:+----------+------------------------------------------+
17065:107:|  0-15    | 16 levels of the widget colors that      |
17066:108:|          | make up button bevels etc. Starting from |
17067:109:|          | (i=0) black (for shadowed bevels), up    |
17068:110:|          | to (i=15) bright highlighted bevels      |
17069:111:|          | those facing up-to-the-left. These       |
17070:112:|          | are sequential (see next block).         |
17071:113:+----------+------------------------------------------+
17072:114:|  16-42   | 3^3 combinations of RGB, vis. (0,0,0),   |
17073:115:|          | (0,0,127), (0,0,255), (0,127,0), ...     |
17074:116:|          | ... (255,255,255).                       |
17075:117:+----------+------------------------------------------+
17076:118:|  43-106  | 64 levels of grey. (optional)            |
17077:119:+----------+------------------------------------------+
17078:120:|  107->   | For other colors. (Not used at present)  |
17079:121:`----------+------------------------------------------'
17080:122:*/
17081:123:
17082:124:/* Thence macros are defined in coolwidgets.h for color lookup */
17083:125:
17084:126:
17085:127:#include <config.h>
17086:128:#include <stdio.h>
17087:129:#include <my_string.h>
17088:130:#include <stdlib.h>
17089:131:
17090:132:#ifdef HAVE_UNISTD_H
17091:133:#include <unistd.h>
17092:134:#endif
17093:135:
17094:136:#include <X11/Xlib.h>
17095:137:#include <X11/Xutil.h>
17096:138:#include <X11/Xresource.h>
17097:139:
17098:140:#define  DEF_APP_GLOB           /* so that globals get defined not externed */
17099:141:
17100:142:#include "coolwidget.h"
17101:143:#include "stringtools.h"
17102:144:
17103:145:#include <signal.h>
17104:146:
17105:147:#ifdef HAVE_SYS_TIME_H
17106:148:#include <sys/time.h>
17107:149:#endif
17108:150:
17109:151:#include "mad.h"
17110:152:
17111:153:static int verbose_operation = 0;
17112:154:CInitData *given = 0;
17113:155:
17114:156:
17115:157:/* defaults */
17116:158:#define DEFAULT_DISPLAY                        NULL
17117:159:#define DEFAULT_GEOM                        NULL
17118:160:#define DEFAULT_FONT                        "8x13bold"
17119:161:#define DEFAULT_BG_COLOR                "grey"
17120:162:#define DEFAULT_WIDGET_COLOR_R                "0.9"
17121:163:#define DEFAULT_WIDGET_COLOR_G                "1.1"
17122:164:#define DEFAULT_WIDGET_COLOR_B                "1.4"
17123:165:
17124:166:#define DEFAULT_BDWIDTH         1
17125:167:
17126:168:struct resource_param {
17127:169:    char *name;
17128:170:    char **value;
17129:171:};
17130:172:
17131:173:static char *init_display = DEFAULT_DISPLAY;
17132:174:static char *init_geometry = DEFAULT_GEOM;
17133:175:static char *init_font = DEFAULT_FONT;
17134:176:static char *init_bg_color = DEFAULT_BG_COLOR;
17135:177:static char *init_fg_color_red = DEFAULT_WIDGET_COLOR_R;
17136:178:static char *init_fg_color_green = DEFAULT_WIDGET_COLOR_G;
17137:179:static char *init_fg_color_blue = DEFAULT_WIDGET_COLOR_B;
17138:180:
17139:181:/* Resources */
17140:182:
17141:183:struct resource_param resources[] = {
17142:184:    {"display", &init_display},
17143:185:    {"geometry", &init_geometry},
17144:186:    {"font", &init_font},
17145:187:    {"background", &init_bg_color},
17146:188:    {"fg_red", &init_fg_color_red},
17147:189:    {"fg_blue", &init_fg_color_blue},
17148:190:    {"fg_green", &init_fg_color_green},
17149:191:    {0, 0}
17150:192:};
17151:193:
17152:194:static void alloccolorerror (void)
17153:195:{
17154:196:    Cerror
17155:197:        ("Cannot allocate colors. Could be to many applications\ntrying to use the colormap. If closing other apps doesn't\nhelp, then your graphics hardware may be inadequite.\n");
17156:198:}
17157:199:
17158:200:static void init_widgets ()
17159:201:{
17160:202:    int i;
17161:203:    CLastwidget = 1;            /*widget[0] is never used since index 0 is used
17162:204:                                   to indicate an error message */
17163:205:    for (i = 0; i < MAX_NUMBER_OF_WIDGETS; i++)
17164:206:        CW (i) = NULL;          /*initialise */
17165:207:}
17166:208:
17167:209:static void open_display (char *app_name)
17168:210:{
17169:211:    if ((CDisplay = XOpenDisplay (init_display)) == NULL) {
17170:212:        fprintf (stderr, "%s: can't open display named \"%s\"\n",
17171:213:                 app_name, XDisplayName (init_display));
17172:214:        exit (1);
17173:215:    }
17174:216:    if (verbose_operation)
17175:217:        printf ("Opened display \"%s\"\n", XDisplayName (init_display));
17176:218:}
17177:219:
17178:220:
17179:221:static void get_resources ()
17180:222:{
17181:223:    int i;
17182:224:    char *type;
17183:225:    XrmValue value;
17184:226:    XrmDatabase rdb;
17185:227:    XrmInitialize ();
17186:228:    rdb = XrmGetFileDatabase (catstrs (getenv ("HOME"), "/.Xdefaults", 0));
17187:229:    if (rdb != NULL) {
17188:230:        for (i = 0; resources[i].name; i++) {
17189:231:            char *rname = catstrs (CAppName, "*", resources[i].name, 0);
17190:232:            if (XrmGetResource (rdb, rname, rname, &type, &value)) {
17191:233:                *resources[i].value = value.addr;
17192:234:            }
17193:235:        }
17194:236:    }
17195:237:}
17196:238:
17197:239:static void load_font ()
17198:240:{
17199:241:    if ((CFontStruct = XLoadQueryFont (CDisplay, init_font)) == NULL) {
17200:242:        fprintf (stderr, "%s: display %s cannot load font %s\n",
17201:243:                 CAppName, DisplayString (CDisplay), init_font);
17202:244:        exit (1);
17203:245:    }
17204:246:#if 0
17205:247:    if (CFontStruct->per_char['I'].width ==
17206:248:        CFontStruct->per_char['M'].width) {
17207:249:        Cfont_is_proportional = 0;
17208:250:        CMean_font_width = CFontStruct->max_bounds.width;
17209:251:    } else {
17210:252:        Cfont_is_proportional = 1;
17211:253:        CMean_font_width =
17212:254:            XTextWidth (CFontStruct,
17213:255:                        "The quick brown fox Jumps over the lazy dog.",
17214:256:                        45) / 45;
17215:257:    }
17216:258:#else
17217:259:    Cfont_is_proportional = 0;
17218:260:    CMean_font_width = CFontStruct->max_bounds.width;
17219:261:#endif
17220:262:}
17221:263:
17222:264:static void visual_comments (long class)
17223:265:{
17224:266:    switch (class) {
17225:267:    case PseudoColor:
17226:268:        printf ("PseudoColor");
17227:269:        if (Cdepth >= 7)
17228:270:            printf (" - depth ok, this will work.\n");
17229:271:        else
17230:272:            printf (" - depth low, this may not work.\n");
17231:273:        break;
17232:274:    case GrayScale:
17233:275:        printf ("Grayscale -\n");
17234:276:        printf
17235:277:            ("Mmmmh, haven't tried this visual class, let's see what happens.\n");
17236:278:        break;
17237:279:    case DirectColor:
17238:280:        printf ("DirectColor -\n");
17239:281:        printf
17240:282:            ("Mmmmh, haven't tried this visual class, let's see what happens.\n");
17241:283:        break;
17242:284:    case StaticColor:
17243:285:        printf ("StaticColor - lets give it a try.\n");
17244:286:        break;
17245:287:    case StaticGray:
17246:288:        printf ("StaticGray - lets give it a try.\n");
17247:289:        break;
17248:290:    case TrueColor:
17249:291:        printf ("TrueColor - fine.\n");
17250:292:        break;
17251:293:    default:
17252:294:        Cerror ("?\nVisual class unknown.\n");
17253:295:        break;
17254:296:    }
17255:297:}
17256:298:
17257:299:/* must be free'd */
17258:300:XColor *get_cells (Colormap cmap, int *size)
17259:301:{
17260:302:    int i;
17261:303:    XColor *c;
17262:304:    *size = DisplayCells (CDisplay, DefaultScreen (CDisplay));
17263:305:    c = Cmalloc (*size * sizeof (XColor));
17264:306:    for (i = 0; i < *size; i++)
17265:307:        c[i].pixel = i;
17266:308:    XQueryColors (CDisplay, cmap, c, *size);
17267:309:    return c;
17268:310:}
17269:311:
17270:312:int CBitsPerRGB = 0;
17271:313:
17272:314:
17273:315:#define BitsPerRGBofVisual(v) (v->bits_per_rgb)
17274:316:
17275:317:
17276:318:/* find the closest color without allocating it */
17277:319:int CGetCloseColor (XColor * cells, int ncells, XColor color, long *error)
17278:320:{
17279:321:    unsigned long merror = (unsigned long) -1;
17280:322:    unsigned long e;
17281:323:    int min = 0, i;
17282:324:    unsigned long mask = 0xFFFF0000;
17283:325:
17284:326:    mask >>= BitsPerRGBofVisual (Cvisual);
17285:327:    for (i = 0; i < ncells; i++) {
17286:328:        e = 8 * abs ((int) (color.red & mask) - (cells[i].red & mask)) +
17287:329:            10 * abs ((int) (color.green & mask) -
17288:330:                      (cells[i].green & mask)) +
17289:331:            5 * abs ((int) (color.blue & mask) - (cells[i].blue & mask));
17290:332:        if (e < merror) {
17291:333:            merror = e;
17292:334:            min = i;
17293:335:        }
17294:336:    }
17295:337:    merror =
17296:338:        8 * abs ((int) (color.red & mask) - (cells[min].red & mask)) +
17297:339:        10 * abs ((int) (color.green & mask) - (cells[min].green & mask)) +
17298:340:        5 * abs ((int) (color.blue & mask) - (cells[min].blue & mask));
17299:341:    if (error)
17300:342:        *error = (long) merror;
17301:343:    return min;
17302:344:}
17303:345:
17304:346:#define grey_intense(i) (i * 65535 / 63)
17305:347:
17306:348:/* return -1 if not found. Meaning that another coolwidget app is not running */
17307:349:int find_coolwidget_grey_scale (XColor * c, int ncells)
17308:350:{
17309:351:    unsigned long mask = 0xFFFF0000;
17310:352:    int i, j;
17311:353:    mask >>= BitsPerRGBofVisual (Cvisual);
17312:354:
17313:355:    for (i = 0; i < ncells; i++) {
17314:356:        for (j = 0; j < 64; j++)
17315:357:            if (!((c[i + j].green & mask) == (grey_intense (j) & mask)
17316:358:                  && c[i + j].red == c[i + j].green
17317:359:                  && c[i + j].green == c[i + j].blue))
17318:360:                goto cont;
17319:361:        return i;
17320:362:      cont:;
17321:363:    }
17322:364:    return -1;
17323:365:}
17324:366:
17325:367:
17326:368:void CAllocColorCells (Colormap colormap, Bool contig,
17327:369:                       unsigned long plane_masks[], unsigned int nplanes,
17328:370:                       unsigned long pixels[], unsigned int npixels)
17329:371:{
17330:372:    if (!XAllocColorCells (CDisplay, colormap, contig,
17331:373:                           plane_masks, nplanes, pixels, npixels))
17332:374:        alloccolorerror ();
17333:375:}
17334:376:
17335:377:void CAllocColor (Colormap cmap, XColor * c)
17336:378:{
17337:379:    if (!XAllocColor (CDisplay, cmap, c))
17338:380:        alloccolorerror ();
17339:381:}
17340:382:
17341:383:/* the 16 coolwidget widget colors: (provided the visual is sufficient) */
17342:384:static void get_button_color (XColor * color, int i)
17343:385:{
17344:386:    double r, g, b, min_wc;
17345:387:
17346:388:    r = 1 / atof (init_fg_color_red);
17347:389:    g = 1 / atof (init_fg_color_green);
17348:390:    b = 1 / atof (init_fg_color_blue);
17349:391:
17350:392:    min_wc = min (r, min (g, b));
17351:393:
17352:394:    color->red =
17353:395:        (float) 65535 *my_pow ((float) i / 20, r) * my_pow (0.75, -min_wc);
17354:396:    color->green =
17355:397:        (float) 65535 *my_pow ((float) i / 20, g) * my_pow (0.75, -min_wc);
17356:398:    color->blue =
17357:399:        (float) 65535 *my_pow ((float) i / 20, b) * my_pow (0.75, -min_wc);
17358:400:    color->flags = DoRed | DoBlue | DoGreen;
17359:401:}
17360:402:
17361:403:/* takes 0-26 and converts it to RGB */
17362:404:static void get_general_colors (XColor * color, int i)
17363:405:{
17364:406:    color->red = (long) (i / 9) * 65535 / 2;
17365:407:    color->green = (long) ((i % 9) / 3) * 65535 / 2;
17366:408:    color->blue = (long) (i % 3) * 65535 / 2;
17367:409:    color->flags = DoRed | DoBlue | DoGreen;
17368:410:}
17369:411:
17370:412:static void get_grey_colors (XColor * color, int i)
17371:413:{
17372:414:    color->red = color->green = grey_intense (i);
17373:415:    color->blue = grey_intense (i);
17374:416:    color->flags = DoRed | DoBlue | DoGreen;
17375:417:}
17376:418:
17377:419:
17378:420:void alloc_grey_scale (Colormap cmap)
17379:421:{
17380:422:    XColor color;
17381:423:    int i;
17382:424:
17383:425:    if (Cusinggreyscale) {
17384:426:        for (i = 0; i < 64; i++) {
17385:427:            get_grey_colors (&color, i);
17386:428:            CAllocColor (cmap, &color);
17387:429:            Cpixel[i + 43] = color.pixel;
17388:430:        }
17389:431:    }
17390:432:}
17391:433:
17392:434:/* this sets up static color, but tries to be more intelligent about the
17393:435:   way it handles grey scales */
17394:436:static void setup_staticcolor ()
17395:437:{
17396:438:    XColor *c;
17397:439:    unsigned short *grey_levels;
17398:440:    XColor color;
17399:441:    int size, i, j, k, n, m = 0, num_greys, grey;
17400:442:    Colormap default_cmap;
17401:443:
17402:444:    default_cmap = DefaultColormap (CDisplay, DefaultScreen (CDisplay));
17403:445:
17404:446:    c = get_cells (default_cmap, &size);
17405:447:    grey_levels = Cmalloc ((size + 2) * sizeof (unsigned short));
17406:448:    num_greys = 0;
17407:449:
17408:450:/* we are probably not going to find our coolwwidget colors here,
17409:451:   so use greyscale for the buttons. first count how many greys,
17410:452:   and sort them: */
17411:453:
17412:454:    grey = 0;
17413:455:    for (i = 0; i < size; i++) {
17414:456:        if (c[i].red == c[i].green && c[i].green == c[i].blue) {
17415:457:            if (grey) {
17416:458:                for (n = 0; n < grey; n++)
17417:459:                    if (c[i].green == grey_levels[n])
17418:460:                        goto cont;
17419:461:                for (n = grey - 1; n >= 0; n--)
17420:462:                    if (grey_levels[n] > c[i].green) {
17421:463:                        memmove (&(grey_levels[n + 1]), &(grey_levels[n]),
17422:464:                                 (grey - n) * sizeof (unsigned short));
17423:465:                        grey_levels[n] = c[i].green;
17424:466:                        grey++;
17425:467:                        goto cont;
17426:468:                    }
17427:469:                grey_levels[grey] = c[i].green;
17428:470:            } else
17429:471:                grey_levels[grey] = c[i].green;
17430:472:            grey++;
17431:473:          cont:;
17432:474:        }
17433:475:    }
17434:476:    num_greys = grey;
17435:477:
17436:478:    if (num_greys <= 2) {       /* there's just no hope  :(   */
17437:479:        if (verbose_operation)
17438:480:            printf ("This will work, but it may look terrible.\n");
17439:481:        for (grey = 0; grey < 16; grey++) {
17440:482:            color.flags = DoRed | DoGreen | DoBlue;
17441:483:            color.red = grey * 65535 / 15;
17442:484:            color.green = grey * 65535 / 15;
17443:485:            color.blue = grey * 65535 / 15;
17444:486:            if (!XAllocColor (CDisplay, default_cmap, &color))
17445:487:                alloccolorerror ();
17446:488:            Cpixel[grey] = color.pixel;
17447:489:        }
17448:490:        alloc_grey_scale (default_cmap);
17449:491:    } else {
17450:492:        j = 0;
17451:493:        k = 0;
17452:494:        for (grey = 0; grey < num_greys; grey++) {
17453:495:/* button colors */
17454:496:            color.red = color.green = grey_levels[grey];
17455:497:            color.blue = grey_levels[grey];
17456:498:            color.flags = DoRed | DoGreen | DoBlue;
17457:499:
17458:500:            for (; j < (grey + 1) * 16 / num_greys; j++) {
17459:501:                CAllocColor (default_cmap, &color);
17460:502:                Cpixel[j] = color.pixel;
17461:503:            }
17462:504:/* grey scale */
17463:505:            if (Cusinggreyscale) {
17464:506:                for (; k < (grey + 1) * 64 / num_greys; k++) {
17465:507:                    CAllocColor (default_cmap, &color);
17466:508:                    Cpixel[k + 43] = color.pixel;
17467:509:                }
17468:510:            }
17469:511:        }
17470:512:    }
17471:513:
17472:514:    for (i = 0; i < 27; i++) {
17473:515:        get_general_colors (&color, i);
17474:516:        m = CGetCloseColor (c, size, color, 0);
17475:517:        CAllocColor (default_cmap, &(c[m]));
17476:518:        Cpixel[16 + i] = c[m].pixel;
17477:519:    }
17478:520:
17479:521:    free (grey_levels);
17480:522:    free (c);
17481:523:}
17482:524:
17483:525:
17484:526:static void setup_alloc_colors ()
17485:527:{
17486:528:    int i;
17487:529:    XColor color;
17488:530:    Colormap default_cmap;
17489:531:
17490:532:    default_cmap = DefaultColormap (CDisplay, DefaultScreen (CDisplay));
17491:533:
17492:534:    color.flags = DoRed | DoGreen | DoBlue;
17493:535:
17494:536:    for (i = 0; i < 16; i++) {
17495:537:        get_button_color (&color, i);
17496:538:        CAllocColor (default_cmap, &color);
17497:539:        Cpixel[i] = color.pixel;
17498:540:    }
17499:541:
17500:542:    for (i = 0; i < 27; i++) {
17501:543:        get_general_colors (&color, i);
17502:544:        CAllocColor (default_cmap, &color);
17503:545:        Cpixel[16 + i] = color.pixel;
17504:546:    }
17505:547:
17506:548:    alloc_grey_scale (default_cmap);
17507:549:}
17508:550:
17509:551:
17510:552:void store_grey_scale (Colormap cmap)
17511:553:{
17512:554:    XColor color;
17513:555:    int i;
17514:556:    if (verbose_operation)
17515:557:        printf ("Storing grey scale.\n");
17516:558:    if (!XAllocColorCells (CDisplay, cmap, 1, Cplane, 6, Cpixel + 43, 1))
17517:559:        alloccolorerror ();
17518:560:    for (i = 0; i < 64; i++) {
17519:561:        Cpixel[43 + i] = Cpixel[43] + i;
17520:562:        color.pixel = Cpixel[43 + i];
17521:563:        get_grey_colors (&color, i);
17522:564:        XStoreColor (CDisplay, cmap, &color);
17523:565:    }
17524:566:}
17525:567:
17526:568:
17527:569:void try_color (Colormap cmap, XColor * c, int size, XColor color, int i)
17528:570:{
17529:571:    int x;
17530:572:    long error;
17531:573:    XColor close;
17532:574:
17533:575:    x = CGetCloseColor (c, size, color, &error);
17534:576:    close = c[x];
17535:577:
17536:578:    if (error) {
17537:579:        if (XAllocColorCells (CDisplay, cmap, 0, Cplane, 0, Cpixel + i, 1)) {
17538:580:            color.pixel = Cpixel[i];
17539:581:            XStoreColor (CDisplay, cmap, &color);
17540:582:            if (verbose_operation)
17541:583:                printf ("S,");
17542:584:            return;
17543:585:        }
17544:586:    }
17545:587:    CAllocColor (cmap, &close);
17546:588:    Cpixel[i] = close.pixel;
17547:589:    if (verbose_operation)
17548:590:        printf ("%ld,", error >> 11);
17549:591:}
17550:592:
17551:593:
17552:594:
17553:595:
17554:596:/*
17555:597:   for PseudoColor displays. This tries to be conservative in the number
17556:598:   of entries its going to store, while still keeping the colors exact.
17557:599:   first it looks for an entry in the default colormap and only stores
17558:600:   in the map if no match is found. Multiple coolwidget applications can
17559:601:   therefore share the same map. At worst 16 + 27 of the palette are used
17560:602:   plus another 64 if you are using greyscale.
17561:603: */
17562:604:static void setup_store_colors ()
17563:605:{
17564:606:    int i, size;
17565:607:    XColor *c;
17566:608:    XColor color;
17567:609:    Colormap default_cmap;
17568:610:
17569:611:    default_cmap = DefaultColormap (CDisplay, DefaultScreen (CDisplay));
17570:612:    c = get_cells (default_cmap, &size);
17571:613:
17572:614:    color.flags = DoRed | DoGreen | DoBlue;
17573:615:
17574:616:/* grey scale has to be contigous to be fast so store a 64 colors */
17575:617:    if (Cusinggreyscale) {
17576:618:/*
17577:619:   i = find_coolwidget_grey_scale (c, size);
17578:620:   if (i >= 0) {
17579:621:   if(verbose_operation)
17580:622:   printf ("found grey scale\n");
17581:623:   alloc_grey_scale (default_cmap);
17582:624:   } else {
17583:625: */
17584:626:        store_grey_scale (default_cmap);
17585:627:/*    } */
17586:628:    }
17587:629:    if (verbose_operation)
17588:630:        printf ("Trying colors...\n");
17589:631:
17590:632:    for (i = 0; i < 16; i++) {
17591:633:        get_button_color (&color, i);
17592:634:        try_color (default_cmap, c, size, color, i);
17593:635:    }
17594:636:
17595:637:    for (i = 0; i < 27; i++) {
17596:638:        get_general_colors (&color, i);
17597:639:        try_color (default_cmap, c, size, color, i + 16);
17598:640:    }
17599:641:    if (verbose_operation)
17600:642:        printf ("\n");
17601:643:    free (c);
17602:644:}
17603:645:
17604:646:
17605:647:
17606:648:
17607:649:static void setup_colormap (long class)
17608:650:{
17609:651:    switch (class) {
17610:652:    case StaticColor:
17611:653:    case StaticGray:
17612:654:        setup_staticcolor ();
17613:655:        break;
17614:656:    case GrayScale:
17615:657:    case DirectColor:
17616:658:    case TrueColor:
17617:659:        setup_alloc_colors ();
17618:660:        return;
17619:661:    case PseudoColor:
17620:662:        setup_store_colors ();
17621:663:        break;
17622:664:    }
17623:665:}
17624:666:
17625:667:
17626:668:
17627:669:static void hints (int x, int y, int width, int height)
17628:670:{
17629:671:    int bitmask;
17630:672:    char default_geometry[80];
17631:673:
17632:674:/* Fill out a XsizeHints structure to inform the window manager
17633:675: * of desired size and location of main window.
17634:676: */
17635:677:    if ((p_XSH = XAllocSizeHints ()) == NULL) {
17636:678:        fprintf (stderr, "Error allocating size hints!\n");
17637:679:        exit (1);
17638:680:    }
17639:681:    p_XSH->flags = (PPosition | PSize | PMinSize);
17640:682:    p_XSH->height = height;
17641:683:    p_XSH->min_height = 80;
17642:684:    p_XSH->width = width;
17643:685:    p_XSH->min_width = 128;
17644:686:    p_XSH->x = x;
17645:687:    p_XSH->y = y;
17646:688:
17647:689:/* Construct a default geometry string */
17648:690:    if (!init_geometry) {
17649:691:        sprintf (default_geometry, "%dx%d+%d+%d", p_XSH->width,
17650:692:                 p_XSH->height, p_XSH->x, p_XSH->y);
17651:693:        init_geometry = default_geometry;
17652:694:    }
17653:695:
17654:696:/* Process the geometry specification */
17655:697:    bitmask = XGeometry (CDisplay, DefaultScreen (CDisplay),
17656:698:                         init_geometry, default_geometry, DEFAULT_BDWIDTH,
17657:699:                         1, 1, 0, 0, &(p_XSH->x), &(p_XSH->y),
17658:700:                         &(p_XSH->width), &(p_XSH->height));
17659:701:
17660:702:/* Check bitmask and set flags in XSizeHints structure */
17661:703:    if (bitmask & (XValue | YValue))
17662:704:        p_XSH->flags |= USPosition;
17663:705:    if (bitmask & (WidthValue | HeightValue))
17664:706:        p_XSH->flags |= USSize;
17665:707:}
17666:708:
17667:709:static void create_main_win (int argc, char **argv)
17668:710:{
17669:711:    XSetWindowAttributes xswa;
17670:712:    XGCValues gcv;
17671:713:    XColor color;
17672:714:    unsigned long bg_pixel;
17673:715:
17674:716:    if (XParseColor
17675:717:        (CDisplay, DefaultColormap (CDisplay, DefaultScreen (CDisplay)),
17676:718:         init_bg_color, &color) == 0
17677:719:        || XAllocColor (CDisplay,
17678:720:                        DefaultColormap (CDisplay,
17679:721:                                         DefaultScreen (CDisplay)),
17680:722:                        &color) == 0)
17681:723:/* Use white background in case of failure */
17682:724:        bg_pixel = WhitePixel (CDisplay, DefaultScreen (CDisplay));
17683:725:    else
17684:726:        bg_pixel = color.pixel;
17685:727:
17686:728:    CMain = XCreateSimpleWindow (CDisplay,
17687:729:                                 DefaultRootWindow (CDisplay),
17688:730:                                 p_XSH->x, p_XSH->y, p_XSH->width,
17689:731:                                 p_XSH->height, DEFAULT_BDWIDTH, C_BLACK,
17690:732:                                 bg_pixel);
17691:733:
17692:734:/* Set up class hint */
17693:735:    if ((p_CH = XAllocClassHint ()) == NULL) {
17694:736:        fprintf (stderr, "Error allocating class hint!\n");
17695:737:        exit (1);
17696:738:    }
17697:739:    p_CH->res_name = CAppName;
17698:740:    p_CH->res_class = CAppName;
17699:741:
17700:742:/* Set up XTextProperty for window name and icon name */
17701:743:    if (XStringListToTextProperty (&CAppName, 1, &WName) == 0) {
17702:744:        fprintf (stderr, "Error creating XTextProperty!\n");
17703:745:        exit (1);
17704:746:    }
17705:747:    if (XStringListToTextProperty (&CAppName, 1, &IName) == 0) {
17706:748:        fprintf (stderr, "Error creating XTextProperty!\n");
17707:749:        exit (1);
17708:750:    }
17709:751:    if ((p_XWMH = XAllocWMHints ()) == NULL) {
17710:752:        fprintf (stderr, "Error allocating Window Manager hints!\n");
17711:753:        exit (1);
17712:754:    }
17713:755:    p_XWMH->flags = (InputHint | StateHint);
17714:756:    p_XWMH->input = True;
17715:757:    p_XWMH->initial_state = NormalState;
17716:758:    XSetWMProperties (CDisplay, CMain, &WName, &IName, argv, argc,
17717:759:                      p_XSH, p_XWMH, p_CH);
17718:760:
17719:761:/* Finally, create a graphics context for the main window */
17720:762:
17721:763:    gcv.font = CFontStruct->fid;
17722:764:    gcv.foreground = C_BLACK;
17723:765:    gcv.background = bg_pixel;
17724:766:    CGC = XCreateGC (CDisplay, CMain,
17725:767:                     (GCFont | GCForeground | GCBackground), &gcv);
17726:768:
17727:769:/* Set main window's attributes (colormap, bit_gravity) */
17728:770:
17729:771:    xswa.colormap = DefaultColormap (CDisplay, DefaultScreen (CDisplay));
17730:772:    xswa.bit_gravity = NorthWestGravity;
17731:773:    XChangeWindowAttributes (CDisplay, CMain, (CWColormap |
17732:774:                                               CWBitGravity), &xswa);
17733:775:
17734:776:/* Select Exposure events for the main window */
17735:777:
17736:778:    XSelectInput (CDisplay, CMain,
17737:779:                  ExposureMask | FocusChangeMask | KeyPressMask |
17738:780:                  KeyReleaseMask);
17739:781:
17740:782:/* Map the main window */
17741:783:
17742:784:    XMapWindow (CDisplay, CMain);
17743:785:    XFlush (CDisplay);
17744:786:    if (XGetWindowAttributes (CDisplay, CMain, &MainXWA) == 0) {
17745:787:        fprintf (stderr, "Error getting attributes of Main.\n");
17746:788:        exit (2);
17747:789:    }
17748:790:}
17749:791:
17750:792:
17751:793:int CSendEvent (XEvent * e);
17752:794:static XEvent xevent;
17753:795:
17754:796:
17755:797:#define ALRM_PER_SECOND 50
17756:798:static int cursor_blink_rate;
17757:799:
17758:800:/*
17759:801:   Aim1: Get the cursor to flash all the time:
17760:802:
17761:803:   Aim2: Have coolwidgets send an alarm event, just like
17762:804:                any other event. For the application to use.
17763:805:
17764:806:   Requirements: XNextEvent must still be the blocker
17765:807:                so that the process doesn't hog when idle.
17766:808:
17767:809:   Problems: If the alarm handler sends an event using
17768:810:                XSendEvent it may hang the program. It
17769:811:                also does not necessarily cause
17770:812:                XNextEvent to unblock.
17771:813:
17772:814:   To solve, we put a pause() before XNextEvent so that it waits for 
17773:815:   an alarm, and also define our own CSendEvent routine with
17774:816:   its own queue. So that things don't slow down, we pause() only
17775:817:   if no events are pending. Also make the alarm rate high (100 X per sec).
17776:818:   (I hope this is the easiest way to do this  :|   )
17777:819:*/
17778:820:
17779:821:void CSetCursorBlinkRate (int b)
17780:822:{
17781:823:    cursor_blink_rate = b;
17782:824:}
17783:825:
17784:826:/* does nothing and calls nothing for t seconds, resolution is ALRM_PER_SECOND */
17785:827:void CSleep (double t)
17786:828:{
17787:829:    float i;
17788:830:    for (i = 0; i < t; i += 1.0 / ALRM_PER_SECOND)
17789:831:        pause ();
17790:832:}
17791:833:
17792:834:
17793:835:static struct itimerval alarm_every = {
17794:836:    {
17795:837:     0, 0},
17796:838:    {
17797:839:     0, 1000000 / ALRM_PER_SECOND}
17798:840:};
17799:841:
17800:842:static struct itimerval alarm_off = {
17801:843:    {
17802:844:     0, 0},
17803:845:    {
17804:846:     0, 0}
17805:847:};
17806:848:
17807:849:static RETSIGTYPE alarmhandler (int x)
17808:850:{
17809:851:    static int count = ALRM_PER_SECOND;
17810:852:    if (count) {
17811:853:        count--;
17812:854:        if (!CQueueSize ()) {
17813:855:            CSendEvent (&xevent);
17814:856:        }
17815:857:    } else {
17816:858:        xevent.type = AlarmEvent;
17817:859:        if (CQueueSize () < 512) { /* say */
17818:860:            CSendEvent (&xevent);
17819:861:        }
17820:862:        xevent.type = TickEvent;
17821:863:        count = ALRM_PER_SECOND / cursor_blink_rate;
17822:864:    }
17823:865:    signal (SIGALRM, alarmhandler);
17824:866:    setitimer (ITIMER_REAL, &alarm_every, NULL);
17825:867:#if (RETSIGTYPE==void)
17826:868:    return;
17827:869:#else
17828:870:    return 1;                   /* :guess --- I don't know what to return here */
17829:871:#endif
17830:872:}
17831:873:
17832:874:
17833:875:
17834:876:static void set_alarm (void)
17835:877:{
17836:878:    memset (&xevent, 0, sizeof (XEvent));
17837:879:    xevent.type = 0;
17838:880:    xevent.xany.display = CDisplay;
17839:881:    xevent.xany.send_event = 1;
17840:882:
17841:883:    CSetCursorBlinkRate (7);    /* theta rhythms ? */
17842:884:
17843:885:    signal (SIGALRM, alarmhandler);
17844:886:    setitimer (ITIMER_REAL, &alarm_every, NULL);
17845:887:}
17846:888:
17847:889:void CEnableAlarm ()
17848:890:{
17849:891:    set_alarm ();
17850:892:}
17851:893:
17852:894:void CDisableAlarm ()
17853:895:{
17854:896:    setitimer (ITIMER_REAL, &alarm_off, NULL);
17855:897:    signal (SIGALRM, 0);
17856:898:}
17857:899:
17858:900:
17859:901:static void draw_logo ()
17860:902:{
17861:903:    Cdrawbitmap ("c00ls0ftware", CMain, 10, 10,
17862:904:                 100, 62, Ccolor (6), Ccolor (12), cool_bits);
17863:905:    Cwidget ("c00ls0ftware")->position = CALWAYS_ON_BOTTOM;
17864:906:}
17865:907:
17866:908:void get_temp_dir (void)
17867:909:{
17868:910:    if (temp_dir)
17869:911:        free (temp_dir);
17870:912:    temp_dir = getenv ("TEMP");
17871:913:    if (temp_dir)
17872:914:        if (*temp_dir) {
17873:915:            temp_dir = strdup (temp_dir);
17874:916:            return;
17875:917:        }
17876:918:    temp_dir = getenv ("TMP");
17877:919:    if (temp_dir)
17878:920:        if (*temp_dir) {
17879:921:            temp_dir = strdup (temp_dir);
17880:922:            return;
17881:923:        }
17882:924:    temp_dir = strdup ("/tmp");
17883:925:}
17884:926:
17885:927:void get_home_dir ()
17886:928:{
17887:929:    if (home_dir)
17888:930:        free (home_dir);
17889:931:    home_dir = getenv ("HOME");
17890:932:    if (home_dir)
17891:933:        if (*home_dir) {
17892:934:            home_dir = strdup (home_dir);
17893:935:            return;
17894:936:        }
17895:937:    home_dir = strdup (current_dir);
17896:938:}
17897:939:
17898:940:void get_dir (void)
17899:941:{
17900:942:    if (!get_current_wd (current_dir, MAX_PATH_LEN))
17901:943:        *current_dir = 0;
17902:944:    get_temp_dir ();
17903:945:    get_home_dir ();
17904:946:}
17905:947:
17906:948:
17907:949:/*-------------------------------------------------------------*/
17908:950:void Cinit (CInitData * config_start)
17909:951:{
17910:952:    given = config_start;
17911:953:    verbose_operation = (given->options & CINIT_OPTION_VERBOSE);
17912:954:
17913:955:    CAppName = given->name;
17914:956:    AppDone = 0;
17915:957:
17916:958:    Cusinggreyscale = (given->options & CINIT_OPTION_USE_GREY);
17917:959:
17918:960:/* Initialise the widget library */
17919:961:    init_widgets ();
17920:962:
17921:963:/* get home dir directory into home_dir and current directory into current_dir */
17922:964:    get_dir ();
17923:965:
17924:966:/* Get resources from the resource file */
17925:967:    get_resources ();
17926:968:    if (given->display)
17927:969:        init_display = given->display;
17928:970:    if (given->geometry)
17929:971:        init_geometry = given->geometry;
17930:972:    if (given->font)
17931:973:        init_font = given->font;
17932:974:    if (given->bg)
17933:975:        init_bg_color = given->bg;
17934:976:    if (given->fg_red)
17935:977:        init_fg_color_red = given->fg_red;
17936:978:    if (given->fg_green)
17937:979:        init_fg_color_green = given->fg_green;
17938:980:    if (given->fg_blue)
17939:981:        init_fg_color_blue = given->fg_blue;
17940:982:
17941:983:/*  Open connection to display selected by user */
17942:984:    open_display (CAppName);
17943:985:
17944:986:/*  Initialise drag and drop capabilities */
17945:987:    CDndInit ();
17946:988:
17947:989:/* Set up font */
17948:990:    load_font ();
17949:991:
17950:992:/* Now set up the visual and colors */
17951:993:
17952:994:    Cdepth = DefaultDepth (CDisplay, DefaultScreen (CDisplay));
17953:995:
17954:996:    Cvisual = DefaultVisual (CDisplay, DefaultScreen (CDisplay));
17955:997:
17956:998:    if (verbose_operation) {
17957:999:        printf
17958:1000:            ("Found default visual, depth = %d,\n       visual class = ",
17959:1001:             Cdepth);
17960:1002:        visual_comments (ClassOfVisual (Cvisual));
17961:1003:    }
17962:1004:
17963:1005:/* Now setup that color map discribed above */
17964:1006:    setup_colormap (ClassOfVisual (Cvisual));
17965:1007:
17966:1008:    hints (given->x, given->y,
17967:1009:           given->width_plus + TEXT_M_WIDTH * given->columns,
17968:1010:           given->height_plus + TEXT_PIX_PER_LINE * given->lines);
17969:1011:
17970:1012:/* Create the main window using the position and size hints. */
17971:1013:    create_main_win (1, &(given->name));
17972:1014:
17973:1015:    draw_logo ();
17974:1016:
17975:1017:/* an alarm handler generates xevent of tyoe AlarmEvent every 1/4 second to flash the cursor */
17976:1018:    set_alarm ();
17977:1019:}
17978:1:/* This is for any undefined keys */
17979:2:
17980:3:#include <X11/keysym.h>
17981:4:
17982:5:#ifndef XK_Page_Up
17983:6:#define XK_Page_Up XK_Prior
17984:7:#endif
17985:8:
17986:9:#ifndef XK_Page_Down
17987:10:#define XK_Page_Down XK_Next
17988:11:#endif
17989:12:
17990:13:#ifndef XK_KP_Page_Up
17991:14:#define XK_KP_Page_Up XK_KP_Prior
17992:15:#endif
17993:16:
17994:17:#ifndef XK_KP_Page_Down
17995:18:#define XK_KP_Page_Down XK_KP_Next
17996:19:#endif
17997:20:
17998:21:#ifndef XK_ISO_Left_Tab
17999:22:#define        XK_ISO_Left_Tab                                        0xFE20
18000:23:#endif
18001:1:/*
18002:2:   Copyright (C) 1996 Paul Sheer
18003:3:
18004:4:   This program is free software; you can redistribute it and/or modify
18005:5:   it under the terms of the GNU General Public License as published by
18006:6:   the Free Software Foundation; either version 2 of the License, or
18007:7:   (at your option) any later version.
18008:8:
18009:9:   This program is distributed in the hope that it will be useful,
18010:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
18011:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
18012:12:   GNU General Public License for more details.
18013:13:
18014:14:   You should have received a copy of the GNU General Public License
18015:15:   along with this program; if not, write to the Free Software
18016:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
18017:17: */
18018:18:
18019:19:#include <config.h>
18020:20:#include <stdlib.h>
18021:21:#include <stdio.h>
18022:22:#include <sys/types.h>
18023:23:#include <sys/stat.h>
18024:24:
18025:25:#ifdef HAVE_FCNTL_H
18026:26:#include <fcntl.h>
18027:27:#endif
18028:28:
18029:29:#ifdef HAVE_UNISTD_H
18030:30:#include <unistd.h>
18031:31:#endif
18032:32:
18033:33:#include "mad.h"
18034:34:
18035:35:/*Loads a file into memory */
18036:36:/*Returns the size if the file in filelen and a pointer to the actual file
18037:37:   which must be free'd. Returns NULL on error. */
18038:38:/*The returned data is terminated by a null character.*/
18039:39:char *loadfile (const char *filename, long *filelen)
18040:40:{
18041:41:    long filel;
18042:42:    int file;
18043:43:    struct stat info;
18044:44:    char *data;
18045:45:
18046:46:    if (!filelen)
18047:47:        filelen = &filel;
18048:48:
18049:49:    if (stat (filename, &info))
18050:50:        return NULL;
18051:51:
18052:52:    if (S_ISDIR (info.st_mode) || S_ISSOCK (info.st_mode)
18053:53:        || S_ISFIFO (info.st_mode) || S_ISCHR (info.st_mode)
18054:54:        || S_ISBLK (info.st_mode)) {
18055:55:        return NULL;
18056:56:    }
18057:57:    *filelen = info.st_size;
18058:58:    if ((data = malloc ((*filelen) + 2)) == NULL)
18059:59:        return NULL;
18060:60:    if ((file = open (filename, O_RDONLY)) < 0) {
18061:61:        free (data);
18062:62:        return NULL;
18063:63:    }
18064:64:    if (read (file, data, *filelen) < *filelen) {
18065:65:        close (file);
18066:66:        free (data);
18067:67:        return NULL;
18068:68:    }
18069:69:    data[*filelen] = 0;
18070:70:    close (file);
18071:71:    return data;
18072:72:}
18073:73:
18074:74:
18075:75:int savefile (const char *filename, const char *data, int len,
18076:76:              int permissions)
18077:77:{
18078:78:    int file;
18079:79:    if ((file = creat (filename, permissions)) < 0)
18080:80:        return -1;
18081:81:    if (write (file, data, len) != len) {
18082:82:        close (file);
18083:83:        return -1;
18084:84:    }
18085:85:    return close (file);
18086:86:}
18087:1:#ifndef LOAD_FILE_H
18088:2:#define LOAD_FILE_H
18089:3:
18090:4:/* Loads a file into memory */
18091:5:/* Returns the size if the file in filelen and a pointer to the actual file
18092:6:   which must be free'd. Returns NULL on error. */
18093:7:/* The returned data is terminated by a null character.*/
18094:8:char *loadfile (const char *filename, long *filelen);
18095:9:
18096:10:/* save a file, returns 0 on success, -1 on error: errno set for open or write */
18097:11:int savefile (const char *filename, const char *data, int len,
18098:12:              int permissions);
18099:13:
18100:14:#endif
18101:1:/*
18102:2:   Copyright (C) 1996 Paul Sheer
18103:3:
18104:4:   This program is free software; you can redistribute it and/or modify
18105:5:   it under the terms of the GNU General Public License as published by
18106:6:   the Free Software Foundation; either version 2 of the License, or
18107:7:   (at your option) any later version.
18108:8:
18109:9:   This program is distributed in the hope that it will be useful,
18110:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
18111:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
18112:12:   GNU General Public License for more details.
18113:13:
18114:14:   You should have received a copy of the GNU General Public License
18115:15:   along with this program; if not, write to the Free Software
18116:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
18117:17: */
18118:18:
18119:19:/* this file is highly dependent on a long int being 4 bytes */
18120:20:
18121:21:#include <config.h>
18122:22:#include <stdlib.h>
18123:23:#include <stdio.h>
18124:24:
18125:25:#include <X11/Xlib.h>
18126:26:#include <X11/Xutil.h>
18127:27:
18128:28:#include <math.h>
18129:29:
18130:30:#include "stringtools.h"
18131:31:#include "app_glob.c"
18132:32:
18133:33:#include "coolwidget.h"
18134:34:
18135:35:#include "mad.h"
18136:36:
18137:37:
18138:38:#define TPRINTF tiffprintf
18139:39:/*tiffprintf*/
18140:40:
18141:41:/* #define ABORT_ON_ERROR */
18142:42:
18143:43:
18144:44:
18145:45:short highbytefirst = 0;
18146:46:
18147:47:short fgetshort (FILE * f)
18148:48:{
18149:49:    if (highbytefirst)
18150:50:        return (getc (f) << 8) + getc (f);
18151:51:    else
18152:52:        return getc (f) + (getc (f) << 8);
18153:53:}
18154:54:
18155:55:
18156:56:long fgetlong (FILE * f)
18157:57:{
18158:58:    if (highbytefirst)
18159:59:        return (getc (f) << 24) + (getc (f) << 16) + (getc (f) << 8) +
18160:60:            getc (f);
18161:61:    else
18162:62:        return getc (f) + (getc (f) << 8) + (getc (f) << 16) +
18163:63:            (getc (f) << 24);
18164:64:}
18165:65:
18166:66:/*
18167:67:Gets an array of unsigned char at offset 'offset' from the beginning
18168:68:of the file, of length 'length' bytes. It returns a pointer to the data
18169:69:although the data is malloced from within the function, the function
18170:70:checks on each call to free previous mallocs, and does so
18171:71:if necessary. Therefore DO NOT FREE the pointer returned by this function.
18172:72:Also copy the results before the next call to fgetstring.
18173:73:*/
18174:74:
18175:75:unsigned char *fgetstring (FILE * f, long offset, long length)
18176:76:{
18177:77:    static unsigned char *str = NULL;
18178:78:
18179:79:    if (str)
18180:80:        free (str);
18181:81:    if ((str = malloc (length + 1)) == NULL) {
18182:82:        printf ("Could not allocate memory in fgetstring.\n");
18183:83:        abort ();
18184:84:    }
18185:85:
18186:86:    fseek (f, offset, SEEK_SET);
18187:87:    fread (str, length, 1, f);
18188:88:    str[length] = 0;
18189:89:
18190:90:    return str;
18191:91:}
18192:92:
18193:93:void tiffprintf (const char *str, ...)
18194:94:{
18195:95:
18196:96:}
18197:97:
18198:98:
18199:99:struct IFDentry {
18200:100:    short tag;
18201:101:    short fieldtype;
18202:102:    long length;
18203:103:    long valueoffset;
18204:104:    short shortvalue;           /*this is duplicate of the lower numbered
18205:105:                                   two bytes of valueoffset, for when valueoffset contains a 
18206:106:                                   short value */
18207:107:};
18208:108:
18209:109:
18210:110:/*gets the value of an IFD entry. If the value is small enough
18211:111:   to fit in the valueoffset it gets it from there.
18212:112:   Handles correctly both arrays and single numbers */
18213:113:void getvalue (FILE * fp, struct IFDentry *entry, long *retval,
18214:114:               long numtoget, int size)
18215:115:{
18216:116:    int j;
18217:117:    if (size == 2 || (entry->fieldtype == 3 && size == 0)) {
18218:118:        TPRINTF (" (short) ");
18219:119:        if (numtoget <= 2) {
18220:120:            retval[0] = entry->shortvalue;
18221:121:            if (numtoget == 2)
18222:122:                if (highbytefirst)
18223:123:                    retval[1] = entry->valueoffset && 0xFFFF;
18224:124:                else
18225:125:                    retval[1] = entry->valueoffset >> 16;
18226:126:        } else {
18227:127:            fseek (fp, entry->valueoffset, SEEK_SET);
18228:128:            for (j = 0; j < numtoget; j++)
18229:129:                retval[j] = fgetshort (fp);
18230:130:        }
18231:131:    }
18232:132:    if (size == 4 || (entry->fieldtype == 4 && size == 0)) {
18233:133:        TPRINTF (" (long) ");
18234:134:        if (numtoget <= 1) {
18235:135:            retval[0] = entry->valueoffset;
18236:136:        } else {
18237:137:            fseek (fp, entry->valueoffset, SEEK_SET);
18238:138:            for (j = 0; j < numtoget; j++)
18239:139:                retval[j] = fgetlong (fp);
18240:140:        }
18241:141:    }
18242:142:}
18243:143:
18244:144:
18245:145:
18246:146:
18247:147:
18248:148:void tifferror (const char *errmessage)
18249:149:{
18250:150:    fprintf (stderr, errmessage); /* OR for the application:  */
18251:151:#ifdef ABORT_ON_ERROR
18252:152:    abort ();
18253:153:#endif
18254:154:/*    Cerror (errmessage);  */
18255:155:/********/
18256:156:}
18257:157:
18258:158:/*
18259:159:The return value must be free'd by the calling application
18260:160:since the function malloc's it.
18261:161:
18262:162:loads an uncompressed class G tiff file. This is a greyscale file.
18263:163:Presently, this routine only supports, topdown orientation (Orientation = 1)
18264:164:1 sample per pixel of 8 bits. It uses the greyresponse curve and assumes the
18265:165:monitor to have a linear response.
18266:166:It will interprete PhotometricInterpretation of 0 or 1 (reverse or normal).
18267:167:It can handle multiple strips of any size and reads and displays most of the
18268:168:important fields (although it only actually interprets class G fields).
18269:169:
18270:170:rowstart and rowend are used to specify what part of the image to load
18271:171:for very large files. If they go past the end of a file. The calling
18272:172:application must check the size of the returned data by looking
18273:173:at the height returned. To load the whole file,set rowstart = 0,
18274:174:rowend = 2^31 - 1.
18275:175:loadgreytiff returns contigous rows, 1 byte/pixel (0-255, black-white),
18276:176:exclusive of rowend. Hence rowend-rowstart rows/scanlines are returned.
18277:177:The first row/scanline is number zero, the last is numbered height - 1.
18278:178:*/
18279:179:
18280:180:
18281:181:unsigned char *loadgreytiff (const char *fname, long *width, long *height,
18282:182:                             long rowstart, long rowend, float gamma)
18283:183:{
18284:184:
18285:185:    FILE *fp = NULL;
18286:186:    int i, j, c;
18287:187:    long IFDoffset;
18288:188:    struct IFDentry *theIFD = NULL;
18289:189:    short numberofIFDentries;
18290:190:    int numinterpreted;
18291:191:    long *greyresponsecurve = NULL;
18292:192:    long *stripbytecounts = NULL, *stripoffsets = NULL;
18293:193:    long numstrips;
18294:194:    float xresolution, yresolution;
18295:195:    long bitspersample[3] = { 8, 8, 8 };
18296:196:    long index;
18297:197:    long maxgrey, mingrey;
18298:198:
18299:199:    unsigned char *pic8 = NULL;
18300:200:    unsigned char *pp = NULL;
18301:201:
18302:202:    int numgreylevels = 0;      /*number of entries in the grey response curve array */
18303:203:
18304:204:/*options: */
18305:205:    int photointerp = 1, spp = 1, comptype = 1, fillorder =
18306:206:        1, planarconfig = 1, orient = 1;
18307:207:    long rps = 0x7FFFFFFF;
18308:208:
18309:209:
18310:210:    if ((fp = fopen (fname, "r")) == NULL) {
18311:211:        tifferror ("Cannot open tiff image file.\n");
18312:212:        goto freeall;
18313:213:    }
18314:214:
18315:215:    if ((c = fgetshort (fp)) != 'I' + 256 * 'I')
18316:216:        highbytefirst = 1;
18317:217:    TPRINTF ("00; %c%c\n", (unsigned char) c, (unsigned char) c);
18318:218:    if ((c = fgetshort (fp)) != 42) {
18319:219:        tifferror ("Not a recognised (meaning of life) tiff file.\n");
18320:220:        goto freeall;
18321:221:    }
18322:222:    TPRINTF ("02; %d\n", c);
18323:223:    IFDoffset = fgetlong (fp);
18324:224:    if (IFDoffset < 8) {
18325:225:        tifferror ("Not a recognised tiff file.\n");
18326:226:        goto freeall;
18327:227:    }
18328:228:    TPRINTF ("04; %ld\n", IFDoffset);
18329:229:
18330:230:    if (fseek (fp, IFDoffset, SEEK_SET)) {
18331:231:        tifferror ("Tiff IFD passed end of file.\n");
18332:232:        goto freeall;
18333:233:    }
18334:234:/*now read the Image File Directory (IFD) */
18335:235:
18336:236:    numberofIFDentries = fgetshort (fp);
18337:237:    TPRINTF ("\nNumber IFD entries = %d\n", numberofIFDentries);
18338:238:
18339:239:    if ((theIFD =
18340:240:         malloc (numberofIFDentries * sizeof (struct IFDentry))) == NULL) {
18341:241:        tifferror ("Cannot allocate memory for tiff file.\n");
18342:242:        goto freeall;
18343:243:    }
18344:244:    for (i = 0; i < numberofIFDentries; i++) {
18345:245:/*TPRINTF's are for debug */
18346:246:/*      TPRINTF ("\n"); */
18347:247:        theIFD[i].tag = fgetshort (fp);
18348:248:/*      TPRINTF ("IFD %ld;%d\n", IFDoffset + 0 + 12 * i, theIFD[i].tag); */
18349:249:        theIFD[i].fieldtype = fgetshort (fp);
18350:250:/*      TPRINTF ("IFD %ld;%d\n", IFDoffset + 2 + 12 * i, theIFD[i].fieldtype); */
18351:251:        theIFD[i].length = fgetlong (fp);
18352:252:/*      TPRINTF ("IFD %ld;%ld\n", IFDoffset + 4 + 12 * i, theIFD[i].length); */
18353:253:        theIFD[i].valueoffset = fgetlong (fp);
18354:254:/*      TPRINTF ("IFD %ld;%ld\n", IFDoffset + 8 + 12 * i, theIFD[i].valueoffset); */
18355:255:        if (!highbytefirst)
18356:256:            theIFD[i].shortvalue = (long) theIFD[i].valueoffset & 0xFFFF;
18357:257:        else
18358:258:            theIFD[i].shortvalue = (long) theIFD[i].valueoffset >> 16;
18359:259:    }
18360:260:
18361:261:
18362:262:/*now loop through the IFD and check tags */
18363:263:
18364:264:    TPRINTF ("\n");
18365:265:
18366:266:    numinterpreted = numberofIFDentries;
18367:267:
18368:268:    for (i = 0; i < numberofIFDentries; i++) {
18369:269:        switch (theIFD[i].tag) {
18370:270:        case 254:
18371:271:            TPRINTF ("NewSubfileType = %ld\n", theIFD[i].valueoffset);
18372:272:            break;
18373:273:        case 256:
18374:274:            getvalue (fp, theIFD + i, width, 1, 0);
18375:275:            TPRINTF ("Image width = %ld\n", *width);
18376:276:            break;
18377:277:        case 257:
18378:278:            getvalue (fp, theIFD + i, height, 1, 0);
18379:279:            TPRINTF ("Image length = %ld\n", *height);
18380:280:            break;
18381:281:        case 258:
18382:282:            getvalue (fp, theIFD + i, bitspersample, theIFD[i].length, 2);
18383:283:            TPRINTF ("BitsPerSample\n");
18384:284:            for (j = 0; j < theIFD[i].length; j++)
18385:285:                TPRINTF ("%ld ", bitspersample[j]);
18386:286:            TPRINTF ("\n");
18387:287:            break;
18388:288:        case 259:
18389:289:            TPRINTF ("Compressing is type %d\n", theIFD[i].shortvalue);
18390:290:            comptype = theIFD[i].shortvalue;
18391:291:            break;
18392:292:        case 262:
18393:293:            TPRINTF ("Photometric interpretation = %d\n",
18394:294:                     (int) theIFD[i].shortvalue);
18395:295:            photointerp = theIFD[i].shortvalue;
18396:296:            break;
18397:297:        case 266:
18398:298:            TPRINTF ("Fillorder = %d\n", theIFD[i].shortvalue);
18399:299:            fillorder = theIFD[i].shortvalue;
18400:300:            break;
18401:301:        case 269:
18402:302:            TPRINTF ("DocumentName: %s\n",
18403:303:                     fgetstring (fp, theIFD[i].valueoffset,
18404:304:                                 theIFD[i].length));
18405:305:            break;
18406:306:        case 270:
18407:307:            TPRINTF ("ImageDescription: %s\n",
18408:308:                     fgetstring (fp, theIFD[i].valueoffset,
18409:309:                                 theIFD[i].length));
18410:310:            break;
18411:311:        case 271:
18412:312:            TPRINTF ("Make: %s\n",
18413:313:                     fgetstring (fp, theIFD[i].valueoffset,
18414:314:                                 theIFD[i].length));
18415:315:            break;
18416:316:        case 272:
18417:317:            TPRINTF ("Model: %s\n",
18418:318:                     fgetstring (fp, theIFD[i].valueoffset,
18419:319:                                 theIFD[i].length));
18420:320:            break;
18421:321:        case 273:
18422:322:            numstrips = theIFD[i].length;
18423:323:
18424:324:            if ((stripoffsets =
18425:325:                 malloc (numstrips * sizeof (long))) == NULL) {
18426:326:                tifferror ("Cannot allocate memory for tiff file.\n");
18427:327:                goto freeall;
18428:328:            }
18429:329:            getvalue (fp, theIFD + i, stripoffsets, numstrips, 0);
18430:330:            TPRINTF ("StripOffsets: %ld\n", numstrips);
18431:331:            for (j = 0; j < numstrips; j++)
18432:332:                TPRINTF ("%ld ", stripoffsets[j]);
18433:333:            TPRINTF ("\n");
18434:334:            break;
18435:335:        case 274:
18436:336:            TPRINTF ("Orientation = %d\n", theIFD[i].shortvalue);
18437:337:            orient = theIFD[i].shortvalue;
18438:338:            break;
18439:339:        case 277:
18440:340:            TPRINTF ("SamplesPerPixel = %d\n", theIFD[i].shortvalue);
18441:341:            spp = theIFD[i].shortvalue;
18442:342:            break;
18443:343:        case 278:
18444:344:            getvalue (fp, theIFD + i, &rps, 1, 0);
18445:345:            TPRINTF ("RowsPerStrip = %ld\n", rps);
18446:346:            break;
18447:347:        case 279:
18448:348:            numstrips = theIFD[i].length;
18449:349:            if ((stripbytecounts =
18450:350:                 malloc (numstrips * sizeof (long))) == NULL) {
18451:351:                tifferror ("Cannot allocate memory for tiff file.\n");
18452:352:                goto freeall;
18453:353:            }
18454:354:            getvalue (fp, theIFD + i, stripbytecounts, numstrips, 0);
18455:355:            TPRINTF ("StripByteCounts: %ld\n", numstrips);
18456:356:            for (j = 0; j < numstrips; j++)
18457:357:                TPRINTF ("%ld ", stripbytecounts[j]);
18458:358:            TPRINTF ("\n");
18459:359:            break;
18460:360:        case 282:
18461:361:            TPRINTF ("Xresolution at %ld\n", theIFD[i].valueoffset);
18462:362:            fseek (fp, theIFD[i].valueoffset, SEEK_SET);
18463:363:            xresolution = (float) fgetlong (fp) / fgetlong (fp);
18464:364:            TPRINTF ("  %f\n", xresolution);
18465:365:            break;
18466:366:        case 283:
18467:367:            TPRINTF ("Yresolution at %ld\n", theIFD[i].valueoffset);
18468:368:            fseek (fp, theIFD[i].valueoffset, SEEK_SET);
18469:369:            yresolution = (float) fgetlong (fp) / fgetlong (fp);
18470:370:            TPRINTF ("  %f\n", yresolution);
18471:371:            break;
18472:372:        case 284:
18473:373:            TPRINTF ("PlanarConfiguration = %d\n", theIFD[i].shortvalue);
18474:374:            planarconfig = theIFD[i].shortvalue;
18475:375:            break;
18476:376:        case 285:
18477:377:            TPRINTF ("PageName: %s\n",
18478:378:                     fgetstring (fp, theIFD[i].valueoffset,
18479:379:                                 theIFD[i].length));
18480:380:            break;
18481:381:        case 290:
18482:382:            TPRINTF ("GrayResponseUnit = %d\n", theIFD[i].shortvalue);
18483:383:            break;
18484:384:        case 291:
18485:385:            TPRINTF ("GrayResponseCurve at %ld, length %ld\n",
18486:386:                     theIFD[i].valueoffset, theIFD[i].length);
18487:387:            numgreylevels = theIFD[i].length;
18488:388:
18489:389:            if ((greyresponsecurve =
18490:390:                 malloc (numgreylevels * sizeof (long))) == NULL) {
18491:391:                abort ();
18492:392:                tifferror ("Cannot allocate memory for tiff file.\n");
18493:393:                goto freeall;
18494:394:            }
18495:395:            getvalue (fp, theIFD + i, greyresponsecurve, numgreylevels, 2);
18496:396:            for (j = 0; j < numgreylevels; j++)
18497:397:                TPRINTF ("%ld ", greyresponsecurve[j]);
18498:398:            TPRINTF ("\n");
18499:399:            break;
18500:400:        case 296:
18501:401:            TPRINTF ("ResolutionUnit = %d\n", theIFD[i].shortvalue);
18502:402:            break;
18503:403:        case 301:
18504:404:            TPRINTF ("Color response curve present at %ld, length %ld\n",
18505:405:                     theIFD[i].valueoffset, theIFD[i].length);
18506:406:            break;
18507:407:        case 320:
18508:408:            TPRINTF ("Colormap present at %ld\n", theIFD[i].valueoffset);
18509:409:            break;
18510:410:        default:
18511:411:            TPRINTF ("Tag %d unread.\n", theIFD[i].tag);
18512:412:            numinterpreted--;
18513:413:        }
18514:414:    }
18515:415:
18516:416:    TPRINTF ("Number of fields interpreted = %d\n\n", numinterpreted);
18517:417:
18518:418:/*now that we've read most of what we might want to know, we can't
18519:419:   scratch all images that are too tedious to interpret. What we
18520:420:   are looking for is a class G greyscale with no compression */
18521:421:
18522:422:    if (spp != 1 || bitspersample[0] != 8 || comptype != 1
18523:423:        || fillorder != 1 || orient != 1) {
18524:424:        tifferror ("This kind of tiff file is not supported.\n");
18525:425:        goto freeall;
18526:426:    }
18527:427:
18528:428:/*printf("rowstart = %ld, rowend = %ld.\n", rowstart, rowend);
18529:429:*/
18530:430:
18531:431:/*check that rowstart and rowend are ok*/
18532:432:
18533:433:    if (rowstart > rowend) {
18534:434:        tifferror ("Tiff called with rowstart > rowend.\n");
18535:435:        goto freeall;
18536:436:    }
18537:437:
18538:438:    if (rowstart > *height)
18539:439:        rowstart = *height;
18540:440:
18541:441:    if (rowstart < 0)
18542:442:        rowstart = 0;
18543:443:
18544:444:    if (rowend > *height)
18545:445:        rowend = *height;
18546:446:
18547:447:/*printf("width = %ld\n", *width);
18548:448:printf("changeto rowstart = %ld, rowend = %ld.\n", rowstart, rowend);
18549:449:*/
18550:450:
18551:451:    if ((pic8 = malloc ((rowend - rowstart) * *width + 1)) == NULL) {
18552:452:        tifferror ("Cannot allocate memory for tiff file.\n");
18553:453:        goto freeall;
18554:454:    }
18555:455:
18556:456:    index = 0;
18557:457:    if (gamma == 0)
18558:458:        gamma = 1.5;
18559:459:
18560:460:    maxgrey = 0;
18561:461:    mingrey = 1 << 30;
18562:462:    if (numgreylevels) {
18563:463:        for (i = 0; i < numgreylevels; i++) {
18564:464:            maxgrey = max (maxgrey, greyresponsecurve[i]);
18565:465:            mingrey = min (mingrey, greyresponsecurve[i]);
18566:466:        }
18567:467:        for (i = 0; i < numgreylevels; i++)
18568:468:            greyresponsecurve[i] =
18569:469:                (double) 255 *pow ((double) 1 -
18570:470:                                   (double) ((double) greyresponsecurve[i]
18571:471:                                             - mingrey) / (maxgrey -
18572:472:                                                           mingrey),
18573:473:                                   (double) 1 / gamma);
18574:474:    }
18575:475:
18576:476:    if (rowend > rowstart)
18577:477:        for (i = rowstart; i < rowend; i++) {
18578:478:            /*:loop through all rows */
18579:479:
18580:480:            pp = fgetstring (fp,
18581:481:                             stripoffsets[i / rps] + (i % rps) * *width,
18582:482:                             *width);
18583:483:            /*:load the row */
18584:484:
18585:485:/*OR  pp = fdecodeLZW (fp, stripoffsets[i/rps] + (i%rps) * *width, *width); <-- for later*/
18586:486:
18587:487:            if (numgreylevels) {
18588:488:                for (j = 0; j < *width; j++)
18589:489:                    pic8[index++] = greyresponsecurve[pp[j]];
18590:490:            } else {
18591:491:                if (photointerp == 1)
18592:492:                    for (j = 0; j < *width; j++)
18593:493:                        pic8[index++] = pp[j];
18594:494:                else
18595:495:                    for (j = 0; j < *width; j++)
18596:496:                        pic8[index++] = 255 - pp[j];
18597:497:            }
18598:498:            if (index > (rowend - rowstart) * *width) {
18599:499:                printf ("Index past end of array\n\n");
18600:500:                abort ();
18601:501:            }
18602:502:        }
18603:503:
18604:504:  freeall:
18605:505:
18606:506:
18607:507:    if (greyresponsecurve)
18608:508:        free (greyresponsecurve);
18609:509:    if (stripbytecounts)
18610:510:        free (stripbytecounts);
18611:511:    if (stripoffsets)
18612:512:        free (stripoffsets);
18613:513:    if (theIFD)
18614:514:        free (theIFD);
18615:515:
18616:516:    if (fp)
18617:517:        fclose (fp);
18618:518:
18619:519:    return pic8;
18620:520:}
18621:1:#ifndef LOAD_TIFF_H
18622:2:#define LOAD_TIFF_H
18623:3:
18624:4:unsigned char *loadgreytiff (const char *fname, long *width, long *height,
18625:5:                             long rowstart, long rowend, float gamma);
18626:6:
18627:7:#endif
18628:1:/* The Memory Allocation Debugging system
18629:2:   Copyright (C) 1994 Janne Kukonlehto.
18630:3:
18631:4:   To use MAD define HAVE_MAD and include "mad.h" in all the *.c files.
18632:5:
18633:6:   This program is free software; you can redistribute it and/or modify
18634:7:   it under the terms of the GNU General Public License as published by
18635:8:   the Free Software Foundation; either version 2 of the License, or
18636:9:   (at your option) any later version.
18637:10:   
18638:11:   This program is distributed in the hope that it will be useful,
18639:12:   but WITHOUT ANY WARRANTY; without even the implied warranty of
18640:13:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
18641:14:   GNU General Public License for more details.
18642:15:
18643:16:   You should have received a copy of the GNU General Public License
18644:17:   along with this program; if not, write to the Free Software
18645:18:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
18646:19:
18647:20:#include <config.h>
18648:21:#include "mad.h"
18649:22:#undef malloc
18650:23:#undef calloc
18651:24:#undef realloc
18652:25:#undef xmalloc
18653:26:#undef strdup
18654:27:#undef free
18655:28:#include <stdlib.h>
18656:29:#include <stdio.h>
18657:30:#include <my_string.h>
18658:31:
18659:32:/* Here to avoid non empty translation units */
18660:33:#ifdef HAVE_MAD
18661:34:
18662:35:/* Maximum number of memory area handles,
18663:36:   increase this if you run out of handles */
18664:37:#define MAD_MAX_AREAS 3000
18665:38:/* Maximum file name length */
18666:39:#define MAD_MAX_FILE 50
18667:40:/* Signature for detecting overwrites */
18668:41:#define MAD_SIGNATURE (('M'<<24)|('a'<<16)|('d'<<8)|('S'))
18669:42:
18670:43:typedef struct {
18671:44:    int in_use;
18672:45:    long *start_sig;
18673:46:    char file[MAD_MAX_FILE];
18674:47:    int line;
18675:48:    void *data;
18676:49:    long *end_sig;
18677:50:} mad_mem_area;
18678:51:
18679:52:static mad_mem_area mem_areas[MAD_MAX_AREAS];
18680:53:static void *watch_free_pointer = 0;
18681:54:
18682:55:/* This function is only called by the mad_check function */
18683:56:static void mad_abort (char *message, int area, char *file, int line)
18684:57:{
18685:58:    fprintf (stderr, "MAD: %s in area %d.\r\n", message, area);
18686:59:    fprintf (stderr, "     Allocated in file \"%s\" at line %d.\r\n",
18687:60:             mem_areas[area].file, mem_areas[area].line);
18688:61:    fprintf (stderr, "     Discovered in file \"%s\" at line %d.\r\n",
18689:62:             file, line);
18690:63:    fprintf (stderr, "MAD: Core dumping...\r\n");
18691:64:    kill (getpid (), 3);
18692:65:}
18693:66:
18694:67:/* Checks all the allocated memory areas.
18695:68:   This is called everytime memory is allocated or freed.
18696:69:   You can also call it anytime you think memory might be corrupted. */
18697:70:void mad_check (char *file, int line)
18698:71:{
18699:72:    int i;
18700:73:
18701:74:    for (i = 0; i < MAD_MAX_AREAS; i++) {
18702:75:        if (!mem_areas[i].in_use)
18703:76:            continue;
18704:77:        if (*(mem_areas[i].start_sig) != MAD_SIGNATURE)
18705:78:            mad_abort ("Overwrite error: Bad start signature", i, file,
18706:79:                       line);
18707:80:        if (*(mem_areas[i].end_sig) != MAD_SIGNATURE)
18708:81:            mad_abort ("Overwrite error: Bad end signature", i, file,
18709:82:                       line);
18710:83:    }
18711:84:}
18712:85:
18713:86:/* Allocates a memory area. Used instead of malloc and calloc. */
18714:87:void *mad_alloc (int size, char *file, int line)
18715:88:{
18716:89:    int i;
18717:90:    char *area;
18718:91:
18719:92:    mad_check (file, line);
18720:93:    for (i = 0; i < MAD_MAX_AREAS; i++) {
18721:94:        if (!mem_areas[i].in_use)
18722:95:            break;
18723:96:    }
18724:97:    if (i >= MAD_MAX_AREAS) {
18725:98:        fprintf (stderr,
18726:99:                 "MAD: Out of memory area handles. Increase the value of MAD_MAX_AREAS.\r\n");
18727:100:        fprintf (stderr, "     Discovered in file \"%s\" at line %d.\r\n",
18728:101:                 file, line);
18729:102:        fprintf (stderr, "MAD: Aborting...\r\n");
18730:103:        abort ();
18731:104:    }
18732:105:
18733:106:    mem_areas[i].in_use = 1;
18734:107:    size = (size + 3) & (~3);   /* Alignment */
18735:108:    area = (char *) malloc (size + 2 * sizeof (long));
18736:109:    if (!area) {
18737:110:        fprintf (stderr, "MAD: Out of memory.\r\n");
18738:111:        fprintf (stderr, "     Discovered in file \"%s\" at line %d.\r\n",
18739:112:                 file, line);
18740:113:        fprintf (stderr, "MAD: Aborting...\r\n");
18741:114:        abort ();
18742:115:    }
18743:116:
18744:117:    mem_areas[i].start_sig = (long *) area;
18745:118:    mem_areas[i].data = (area + sizeof (long));
18746:119:    mem_areas[i].end_sig = (long *) (area + size + sizeof (long));
18747:120:    *(mem_areas[i].start_sig) = MAD_SIGNATURE;
18748:121:    *(mem_areas[i].end_sig) = MAD_SIGNATURE;
18749:122:
18750:123:    if (strlen (file) >= MAD_MAX_FILE)
18751:124:        file[MAD_MAX_FILE - 1] = 0;
18752:125:    strcpy (mem_areas[i].file, file);
18753:126:    mem_areas[i].line = line;
18754:127:
18755:128:    return mem_areas[i].data;
18756:129:}
18757:130:
18758:131:/* Reallocates a memory area. Used instead of realloc. */
18759:132:void *mad_realloc (void *ptr, int newsize, char *file, int line)
18760:133:{
18761:134:    int i;
18762:135:    char *area;
18763:136:
18764:137:    mad_check (file, line);
18765:138:
18766:139:    for (i = 0; i < MAD_MAX_AREAS; i++) {
18767:140:        if (!mem_areas[i].in_use)
18768:141:            continue;
18769:142:        if (mem_areas[i].data == ptr)
18770:143:            break;
18771:144:    }
18772:145:    if (i >= MAD_MAX_AREAS) {
18773:146:        fprintf (stderr,
18774:147:                 "MAD: Attempted to realloc unallocated pointer: %ux.\r\n",
18775:148:                 ptr);
18776:149:        fprintf (stderr, "     Discovered in file \"%s\" at line %d.\r\n",
18777:150:                 file, line);
18778:151:        fprintf (stderr, "MAD: Aborting...\r\n");
18779:152:        abort ();
18780:153:    }
18781:154:
18782:155:    newsize = (newsize + 3) & (~3); /* Alignment */
18783:156:    area =
18784:157:        (char *) realloc (mem_areas[i].start_sig,
18785:158:                          newsize + 2 * sizeof (long));
18786:159:    if (!area) {
18787:160:        fprintf (stderr, "MAD: Out of memory.\r\n");
18788:161:        fprintf (stderr, "     Discovered in file \"%s\" at line %d.\r\n",
18789:162:                 file, line);
18790:163:        fprintf (stderr, "MAD: Aborting...\r\n");
18791:164:        abort ();
18792:165:    }
18793:166:
18794:167:    mem_areas[i].start_sig = (long *) area;
18795:168:    mem_areas[i].data = (area + sizeof (long));
18796:169:    mem_areas[i].end_sig = (long *) (area + newsize + sizeof (long));
18797:170:    *(mem_areas[i].start_sig) = MAD_SIGNATURE;
18798:171:    *(mem_areas[i].end_sig) = MAD_SIGNATURE;
18799:172:
18800:173:    if (strlen (file) >= MAD_MAX_FILE)
18801:174:        file[MAD_MAX_FILE - 1] = 0;
18802:175:    strcpy (mem_areas[i].file, file);
18803:176:    mem_areas[i].line = line;
18804:177:
18805:178:    return mem_areas[i].data;
18806:179:}
18807:180:
18808:181:/* Duplicates a character string. Used instead of strdup. */
18809:182:char *mad_strdup (char *s, char *file, int line)
18810:183:{
18811:184:    char *t;
18812:185:
18813:186:    t = (char *) mad_alloc (strlen (s) + 1, file, line);
18814:187:    strcpy (t, s);
18815:188:    return t;
18816:189:}
18817:190:
18818:191:/* Frees a memory area. Used instead of free. */
18819:192:void mad_free (void *ptr, char *file, int line)
18820:193:{
18821:194:    int i;
18822:195:
18823:196:    mad_check (file, line);
18824:197:
18825:198:    if (watch_free_pointer && ptr == watch_free_pointer) {
18826:199:        printf ("watch free pointer found\n");
18827:200:    }
18828:201:
18829:202:    if (ptr == NULL) {
18830:203:        fprintf (stderr,
18831:204:                 "MAD: Attempted to free a NULL pointer in file \"%s\" at line %d.\n",
18832:205:                 file, line);
18833:206:        return;
18834:207:    }
18835:208:
18836:209:    for (i = 0; i < MAD_MAX_AREAS; i++) {
18837:210:        if (!mem_areas[i].in_use)
18838:211:            continue;
18839:212:        if (mem_areas[i].data == ptr)
18840:213:            break;
18841:214:    }
18842:215:    if (i >= MAD_MAX_AREAS) {
18843:216:        fprintf (stderr,
18844:217:                 "MAD: Attempted to free an unallocated pointer: %X.\r\n",
18845:218:                 ptr);
18846:219:        fprintf (stderr, "     Discovered in file \"%s\" at line %d.\r\n",
18847:220:                 file, line);
18848:221:        fprintf (stderr, "MAD: Aborting...\r\n");
18849:222:        abort ();
18850:223:    }
18851:224:
18852:225:    free (mem_areas[i].start_sig);
18853:226:    mem_areas[i].in_use = 0;
18854:227:}
18855:228:
18856:229:/* Outputs a list of unfreed memory areas,
18857:230:   to be called as a last thing before exiting */
18858:231:void mad_finalize (char *file, int line)
18859:232:{
18860:233:    int i;
18861:234:
18862:235:    mad_check (file, line);
18863:236:
18864:237:    /* Following can be commented out if you don't want to see the
18865:238:       memory leaks of the Midnight Commander */
18866:239:#if 1
18867:240:    for (i = 0; i < MAD_MAX_AREAS; i++) {
18868:241:        if (!mem_areas[i].in_use)
18869:242:            continue;
18870:243:        fprintf (stderr, "MAD: Unfreed pointer: %X.\n", mem_areas[i].data);
18871:244:        fprintf (stderr, "     Allocated in file \"%s\" at line %d.\r\n",
18872:245:                 mem_areas[i].file, mem_areas[i].line);
18873:246:        fprintf (stderr, "     Discovered in file \"%s\" at line %d.\r\n",
18874:247:                 file, line);
18875:248:    }
18876:249:#endif
18877:250:}
18878:251:
18879:252:#endif                          /* HAVE_MAD */
18880:1:#ifndef __MAD_H
18881:2:#define __MAD_H
18882:3:
18883:4:#ifdef HAVE_MAD
18884:5:#   define INLINE
18885:6:#else
18886:7:#   ifndef INLINE
18887:8:#       define INLINE inline
18888:9:#   endif
18889:10:#endif
18890:11:
18891:12:#ifdef HAVE_MAD
18892:13:
18893:14:/* The Memory Allocation Debugging system */
18894:15:
18895:16:/* GNU headers define this as macros */
18896:17:#ifdef malloc
18897:18:#   undef malloc
18898:19:#endif
18899:20:
18900:21:#ifdef calloc
18901:22:#   undef calloc
18902:23:#endif
18903:24:
18904:25:#define malloc(x)        mad_alloc (x, __FILE__, __LINE__)
18905:26:#define calloc(x, y)        mad_alloc (x * y, __FILE__, __LINE__)
18906:27:#define realloc(x, y)        mad_realloc (x, y, __FILE__, __LINE__)
18907:28:#define xmalloc(x, y)        mad_alloc (x, __FILE__, __LINE__)
18908:29:#define strdup(x)        mad_strdup (x, __FILE__, __LINE__)
18909:30:#define free(x)                mad_free (x, __FILE__, __LINE__)
18910:31:
18911:32:void mad_check (char *file, int line);
18912:33:void *mad_alloc (int size, char *file, int line);
18913:34:void *mad_realloc (void *ptr, int newsize, char *file, int line);
18914:35:char *mad_strdup (char *s, char *file, int line);
18915:36:void mad_free (void *ptr, char *file, int line);
18916:37:void mad_finalize (char *file, int line);
18917:38:
18918:39:#else
18919:40:
18920:41:#define mad_finalize(x, y)
18921:42:#define mad_check(file,line)
18922:43:
18923:44:#endif                          /* HAVE_MAD */
18924:45:
18925:46:#endif                          /* __MAD_H */
18926:1:/* manpage.c - draws an interactive man page browser
18927:2:   Copyright (C) 1997 Paul Sheer
18928:3:
18929:4:   This program is free software; you can redistribute it and/or modify
18930:5:   it under the terms of the GNU General Public License as published by
18931:6:   the Free Software Foundation; either version 2 of the License, or
18932:7:   (at your option) any later version.
18933:8:
18934:9:   This program is distributed in the hope that it will be useful,
18935:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
18936:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
18937:12:   GNU General Public License for more details.
18938:13:
18939:14:   You should have received a copy of the GNU General Public License
18940:15:   along with this program; if not, write to the Free Software
18941:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
18942:17: */
18943:18:
18944:19:#include <config.h>
18945:20:#include <stdio.h>
18946:21:#include <my_string.h>
18947:22:#include <stdlib.h>
18948:23:#include <stdarg.h>
18949:24:#ifdef HAVE_UNISTD_H
18950:25:#include <unistd.h>
18951:26:#endif
18952:27:#include <sys/errno.h>
18953:28:
18954:29:#include <X11/Xlib.h>
18955:30:#include <X11/Xutil.h>
18956:31:#include <X11/Xresource.h>
18957:32:#include "lkeysym.h"
18958:33:
18959:34:#include "stringtools.h"
18960:35:#include "app_glob.c"
18961:36:#include "dirtools.h"
18962:37:
18963:38:#include "coolwidget.h"
18964:39:#include "coollocal.h"
18965:40:#include "loadfile.h"
18966:41:
18967:42:#include "mad.h"
18968:43:#include "dialog.h"
18969:44:#include "edit.h"
18970:45:#include "editcmddef.h"
18971:46:
18972:47:
18973:48:/* must be a power of 2 */
18974:49:#define NUM_HISTORY 16
18975:50:static char *history[NUM_HISTORY] =
18976:51:    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
18977:52:static unsigned int history_current = 0;
18978:53:
18979:54:#define r_is_printable(x) ((x >= ' ' && x <= '~') || x >= 160)
18980:55:#define my_is_letter(ch) ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || ch == '\b' || ch == '_' || ch == '-' || ch >= 160)
18981:56:
18982:57:void check_prev_next (void)
18983:58:{
18984:59:    if (history[history_current & (NUM_HISTORY - 1)])
18985:60:        Cwidget ("mandisplayfile.next")->disabled = 0;
18986:61:    else
18987:62:        Cwidget ("mandisplayfile.next")->disabled = 1;
18988:63:    if (history[(history_current - 2) & (NUM_HISTORY - 1)])
18989:64:        Cwidget ("mandisplayfile.prev")->disabled = 0;
18990:65:    else
18991:66:        Cwidget ("mandisplayfile.prev")->disabled = 1;
18992:67:}
18993:68:
18994:69:void add_to_history (char *t)
18995:70:{
18996:71:    char **h;
18997:72:    history_current &= (NUM_HISTORY - 1);
18998:73:    if (history[history_current])
18999:74:        free (history[history_current]);
19000:75:    h = &(history[(history_current + 1) & (NUM_HISTORY - 1)]);
19001:76:    if (*h) {
19002:77:        free (*h);
19003:78:        *h = 0;
19004:79:    }
19005:80:    history[history_current++] = strdup (t);
19006:81:}
19007:82:
19008:83:int mansearch_callback (CWidget * w, XEvent * x, CEvent * c);
19009:84:int mansearchagain_callback (CWidget * w, XEvent * x, CEvent * c);
19010:85:
19011:86:int manpageclear_callback (CWidget * w, XEvent * x, CEvent * c)
19012:87:{
19013:88:    int i;
19014:89:    Cundrawwidget ("mandisplayfile");
19015:90:    for (i = 0; i < NUM_HISTORY; i++) {
19016:91:        if (history[i]) {
19017:92:            free (history[i]);
19018:93:            history[i] = 0;
19019:94:        }
19020:95:    }
19021:96:    history_current = 0;
19022:97:    return 0;
19023:98:}
19024:99:
19025:100:int manpage_callback (CWidget * w, XEvent * x, CEvent * c)
19026:101:{
19027:102:    int p, q;
19028:103:    unsigned char m[128] = "";
19029:104:    char *t;
19030:105:    if (c->key == XK_Escape || c->kind == CBITMAPBUTTON_WIDGET) {
19031:106:        Cundrawwidget ("mandisplayfile");
19032:107:        return 0;
19033:108:    }
19034:109:    if (c->command == CK_Find) {
19035:110:        mansearch_callback (w, x, c);
19036:111:    }
19037:112:    if (c->command == CK_Find_Again) {
19038:113:        mansearchagain_callback (w, x, c);
19039:114:    }
19040:115:    if (c->double_click) {
19041:116:        unsigned char *text = (unsigned char *) w->text;
19042:117:        q = strmovelines (text, w->current, c->yt - w->firstline,
19043:118:                          w->width);
19044:119:        q = strfrombeginline (text, q, c->xt);
19045:120:        p = q;
19046:121:        if (my_is_letter (text[q])) {
19047:122:            while (--q >= 0)
19048:123:                if (!my_is_letter (text[q]))
19049:124:                    break;
19050:125:            q++;
19051:126:            while (text[++p])
19052:127:                if (!my_is_letter (text[p]))
19053:128:                    break;
19054:129:            strncpy (m, text + q, min (p - q, 127));
19055:130:            m[min (p - q, 127)] = 0;
19056:131:            t = str_strip_nroff ((char *) m, 0);
19057:132:            Cmanpagedialog (0, 0, 0, 0, 0, t);
19058:133:            free (t);
19059:134:        }
19060:135:    }
19061:136:    check_prev_next ();
19062:137:    return 0;
19063:138:}
19064:139:
19065:140:
19066:141:int manpageprev_callback (CWidget * w, XEvent * x, CEvent * c)
19067:142:{
19068:143:    history_current--;
19069:144:    check_prev_next ();
19070:145:    Credrawtextbox ("mandisplayfile.text",
19071:146:                    history[(history_current - 1) & (NUM_HISTORY - 1)], 1);
19072:147:    return 0;
19073:148:}
19074:149:
19075:150:int manpagenext_callback (CWidget * w, XEvent * x, CEvent * c)
19076:151:{
19077:152:    history_current++;
19078:153:    check_prev_next ();
19079:154:    Credrawtextbox ("mandisplayfile.text",
19080:155:                    history[(history_current - 1) & (NUM_HISTORY - 1)], 1);
19081:156:    return 0;
19082:157:}
19083:158:
19084:159:extern int replace_scanf;
19085:160:extern int replace_regexp;
19086:161:extern int replace_whole;
19087:162:extern int replace_case;
19088:163:
19089:164:int text_get_byte (unsigned char *text, long index)
19090:165:{
19091:166:    return text[index];
19092:167:}
19093:168:
19094:169:void Ctextboxsearch (CWidget * w, int again)
19095:170:{
19096:171:    static char *old = NULL;
19097:172:    char *exp = "";
19098:173:    int isfocussed = 0;
19099:174:
19100:175:    exp = old ? old : exp;
19101:176:    if (again) {
19102:177:        if (!old)
19103:178:            return;
19104:179:        exp = strdup (old);
19105:180:    } else {
19106:181:        isfocussed = (w->winid == CGetFocus ());
19107:182:        edit_search_replace_dialog (w->parentid, 20, 20, &exp, 0, 0,
19108:183:                                    " Search ", 0);
19109:184:    }
19110:185:
19111:186:    if (exp) {
19112:187:        if (*exp) {
19113:188:            int len, l;
19114:189:            char *t;
19115:190:            long search_start;
19116:191:            if (old)
19117:192:                free (old);
19118:193:            old = strdup (exp);
19119:194:/* here we run strip on everything from here
19120:195:   to the end of the file then search through
19121:196:   the stripped text */
19122:197:            search_start =
19123:198:                strmovelines (w->text, w->current,
19124:199:                              (isfocussed ? w->cursor - w->firstline : 0) +
19125:200:                              1, 32000);
19126:201:            t = str_strip_nroff (w->text + search_start, &l);
19127:202:            search_start =
19128:203:                edit_find (0, exp, &len, l,
19129:204:                           (int (*)(void *, long)) text_get_byte,
19130:205:                           (void *) t);
19131:206:            if (search_start == -3) {
19132:207:                Cerrordialogue (w->parentid, 20, 20, " Error ",
19133:208:                                " Invalid regular expression ");
19134:209:            } else if (search_start >= 0) {
19135:210:                int l;
19136:211:                l = strcountlines (t, 0, search_start, 32000) + 1;
19137:212:                l += isfocussed ? w->cursor : w->firstline;
19138:213:                Csettextboxpos (w, TEXT_SETLINE, l);
19139:214:                Csettextboxpos (w, TEXT_SET_CURSOR_LINE, l);
19140:215:                Cexpose (w->ident);
19141:216:            } else {
19142:217:                Cerrordialogue (w->parentid, 20, 20, " Search ",
19143:218:                                " Search search string not found. ");
19144:219:            }
19145:220:            free (t);
19146:221:        }
19147:222:        free (exp);
19148:223:    }
19149:224:}
19150:225:
19151:226:int mansearch_callback (CWidget * w, XEvent * x, CEvent * c)
19152:227:{
19153:228:    Ctextboxsearch (Cwidget ("mandisplayfile.text"), 0);
19154:229:    return 0;
19155:230:}
19156:231:
19157:232:int mansearchagain_callback (CWidget * w, XEvent * x, CEvent * c)
19158:233:{
19159:234:    Ctextboxsearch (Cwidget ("mandisplayfile.text"), 1);
19160:235:    return 0;
19161:236:}
19162:237:
19163:238:char *read_pipe (int fd, int *len);
19164:239:int my_popen (int *in, int *out, int *err, int mix, const char *file,
19165:240:              char *const argv[]);
19166:241:
19167:242:CWidget *Cmanpagedialog (Window in, int x, int y, int columns, int lines,
19168:243:                         const char *manpage)
19169:244:{
19170:245:    char *t;
19171:246:    char *argv[] = { MAN_COMMAND, MAN_ARGS, 0, 0 };
19172:247:    int i = 0, man_pipe, fre = 1;
19173:248:
19174:249:    if (manpage) {
19175:250:        while (argv[i])
19176:251:            i++;
19177:252:        argv[i] = (char *) manpage;
19178:253:
19179:254:        if (my_popen (0, &man_pipe, 0, 1, MAN_COMMAND, argv) <= 0) { /* "1" is to pipe both stderr AND stdout into man_pipe */
19180:255:            Cerrordialog (CMain, 20, 20, " Manual page ",
19181:256:                          " Fail trying to run man, check your man command in global.h ");
19182:257:            return 0;
19183:258:        }
19184:259:        t = read_pipe (man_pipe, 0);
19185:260:        close (man_pipe);
19186:261:    } else {
19187:262:        if (!(t = history[(history_current - 1) & (NUM_HISTORY - 1)])) {
19188:263:            Cerrordialog (CMain, 20, 20, " Manual Page ",
19189:264:                          " No man pages open ");
19190:265:            return 0;
19191:266:        }
19192:267:        fre = 0;
19193:268:    }
19194:269:
19195:270:    if (!t) {
19196:271:        Cerrordialog (CMain, 20, 20, " Manual Page ",
19197:272:                      get_sys_error
19198:273:                      (" Error reading from pipe, check your man command in the file global.h "));
19199:274:        return 0;
19200:275:    } else if (*t) {
19201:276:        if (fre)
19202:277:            add_to_history (t);
19203:278:        if (Cwidget ("mandisplayfile")) {
19204:279:            Credrawtextbox ("mandisplayfile.text", t, 0);
19205:280:        } else {
19206:281:            Window win;
19207:282:            CWidget *w;
19208:283:            win =
19209:284:                Cdrawheadedwindow ("mandisplayfile", in, x, y, 10, 10,
19210:285:                                   " Manual Page ");
19211:286:            Cgethintpos (&x, &y);
19212:287:            w = Cdrawtextbox ("mandisplayfile.text", win,
19213:288:                              x, y, columns * TEXT_M_WIDTH + 7,
19214:289:                              lines * TEXT_PIX_PER_LINE, 0, 0, t,
19215:290:                              MAN_PAGE | TEXT_BOX_NO_CURSOR);
19216:291:            Cgethintpos (0, &y);
19217:292:            Cdrawbutton ("mandisplayfile.prev", win, x, y, AUTO_WIDTH,
19218:293:                         AUTO_HEIGHT, " Previous ");
19219:294:            Cgethintpos (&x, 0);
19220:295:            Cdrawbutton ("mandisplayfile.next", win, x, y, AUTO_WIDTH,
19221:296:                         AUTO_HEIGHT, " Next ");
19222:297:            Cgethintpos (&x, 0);
19223:298:            Cdrawbutton ("mandisplayfile.search", win, x, y, AUTO_WIDTH,
19224:299:                         AUTO_HEIGHT, " Search ");
19225:300:            Cgethintpos (&x, 0);
19226:301:            Cdrawbutton ("mandisplayfile.again", win, x, y, AUTO_WIDTH,
19227:302:                         AUTO_HEIGHT, " Again ");
19228:303:            Cgethintpos (&x, 0);
19229:304:            Cdrawbitmapbutton ("mandisplayfile.done", win, x, y, 40, 40,
19230:305:                               Ccolor (6), C_FLAT, tick_bits);
19231:306:            Cgethintpos (&x, 0);
19232:307:            Cdrawbitmapbutton ("mandisplayfile.clear", win, x, y, 40, 40,
19233:308:                               Ccolor (18), C_FLAT, cross_bits);
19234:309:            Csetsizehintpos ("mandisplayfile");
19235:310:            Caddcallback ("mandisplayfile.done", manpage_callback);
19236:311:            Caddcallback ("mandisplayfile.clear", manpageclear_callback);
19237:312:            Caddcallback ("mandisplayfile.text", manpage_callback);
19238:313:            Caddcallback ("mandisplayfile.next", manpagenext_callback);
19239:314:            Caddcallback ("mandisplayfile.prev", manpageprev_callback);
19240:315:            Caddcallback ("mandisplayfile.search", mansearch_callback);
19241:316:            Caddcallback ("mandisplayfile.again", mansearchagain_callback);
19242:317:        }
19243:318:        check_prev_next ();
19244:319:        if (t && fre)
19245:320:            free (t);
19246:321:    } else {
19247:322:        Cerrordialog (CMain, 20, 20, " Manual page ",
19248:323:                      " Fail trying to popen man, check your man command in the file global.h ");
19249:324:        return 0;
19250:325:    }
19251:326:    return Cwidget ("mandisplayfile");
19252:327:}
19253:1:/* mathfuncs.c: standalone log(), sqrt(), pow() functions not requiring libm
19254:2:
19255:3:   Copyright (C) 1996 Paul Sheer
19256:4:
19257:5:   This program is free software; you can redistribute it and/or modify
19258:6:   it under the terms of the GNU General Public License as published by
19259:7:   the Free Software Foundation; either version 2 of the License, or
19260:8:   (at your option) any later version.
19261:9:
19262:10:   This program is distributed in the hope that it will be useful,
19263:11:   but WITHOUT ANY WARRANTY; without even the implied warranty of
19264:12:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
19265:13:   GNU General Public License for more details.
19266:14:
19267:15:   You should have received a copy of the GNU General Public License
19268:16:   along with this program; if not, write to the Free Software
19269:17:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
19270:18: */
19271:19:
19272:20:#include <stdlib.h>
19273:21:#include <stdio.h>
19274:22:
19275:23:/* this file is to avoid having to link with the whole libm when all
19276:24:   we need is a pow() function. But its more an interesting exercise. */
19277:25:
19278:26:/* to force use of softcoded pow even on linux-x86's: */
19279:27:/* #define USE_OWN_POW */
19280:28:
19281:29:#define floating_p_error(x) float_error(__FILE__, __LINE__)
19282:30:
19283:31:static void float_error (char *file, int line)
19284:32:{
19285:33:    fprintf (stderr, "%s:%d: floating point error\n", file, line);
19286:34:    abort ();
19287:35:}
19288:36:
19289:37:#if !defined(__i386__) || !defined(__GNUC__) || defined(USE_OWN_POW)
19290:38:
19291:39:/*
19292:40:   Libc pow() using an FPU is timed to be
19293:41:   23 times faster than this soft-coded
19294:42:   pow function. In the test below.
19295:43:   486DX4-100
19296:44:   gcc-2.7.2 -O3 -fomit-frame-pointer
19297:45:   libc-5.4.17 -O2
19298:46:*/
19299:47:
19300:48:/*
19301:49:   Principles:
19302:50:
19303:51:   x^y :
19304:52:
19305:53:   taylor(x^y) =
19306:54:      ... + y^5*z^5/120 + y^4*z^4/24 + y^3*z^3/6 + y^2*z^2/2 + y*z + 1,
19307:55:         where z = log_e(x)
19308:56:
19309:57:   log_e(q + x) :
19310:58:
19311:59:   taylor(log_e(q + x)) =
19312:60:      log_e(q) + ... + x^5/(5*q^5)-x^4/(4*q^4) + x^3/(3*q^3)-x^2/(2*q^2) + x/q
19313:61: */
19314:62:
19315:63:/* results are this accurate */
19316:64:#define F_ACCURACY 1e-15
19317:65:
19318:66:/* e^4, e, e^0.25 */
19319:67:#define VITAMIN_E4   54.598150033144239078
19320:68:#define VITAMIN_E    2.7182818284590452353
19321:69:#define VITAMIN_E25  1.2840254166877414840
19322:70:
19323:71:#define my_fabs(t) ((t) >= 0 ? (t) : -(t))
19324:72:
19325:73:double my_log (double x)
19326:74:{
19327:75:    int i = 1, j;
19328:76:    double t, q = 1, ans = 0;
19329:77:
19330:78:    if (x <= 0)
19331:79:        floating_p_error (0);
19332:80:
19333:81:/* find an initial approximation */
19334:82:    if (x > 1.0) {
19335:83:        do {
19336:84:            ans += 4;
19337:85:        } while ((q *= VITAMIN_E4) < x);
19338:86:        do {
19339:87:            ans -= 1;
19340:88:        } while ((q /= VITAMIN_E) > x);
19341:89:        while ((q *= VITAMIN_E25) < x)
19342:90:            ans += 0.25;
19343:91:        q /= VITAMIN_E25;
19344:92:    } else if (x < 1.0) {
19345:93:        do {
19346:94:            ans -= 4;
19347:95:        } while ((q /= VITAMIN_E4) > x);
19348:96:        do {
19349:97:            ans += 1;
19350:98:        } while ((q *= VITAMIN_E) < x);
19351:99:        do {
19352:100:            ans -= 0.25;
19353:101:        } while ((q /= VITAMIN_E25) > x);
19354:102:    } else
19355:103:        return 0.0;
19356:104:
19357:105:    x -= q;
19358:106:
19359:107:/* taylor series */
19360:108:    do {
19361:109:        t = 1;
19362:110:        for (j = 0; j < i; j++)
19363:111:            t *= -x / q;
19364:112:        t /= (double) i++;
19365:113:        ans -= t;
19366:114:        if (i > 200)            /* shouldn't happen */
19367:115:            floating_p_error (0);
19368:116:    } while (my_fabs (t * ans) > F_ACCURACY);
19369:117:
19370:118:    return ans;
19371:119:}
19372:120:
19373:121:
19374:122:double my_sqrt (double x)
19375:123:{
19376:124:    double last_ans, ans = 2;
19377:125:
19378:126:    if (x < 0.0)
19379:127:        floating_p_error (0);
19380:128:    if (x == 0.0)
19381:129:        return 0.0;
19382:130:
19383:131:    do {
19384:132:        last_ans = ans;
19385:133:        ans = (ans + x / ans) / 2;
19386:134:    } while (my_fabs ((ans - last_ans) / ans) > F_ACCURACY);
19387:135:
19388:136:    return ans;
19389:137:}
19390:138:
19391:139:
19392:140:double my_pow (double x, double y)
19393:141:{
19394:142:    double z, ans = 1, ans2 = 1, t;
19395:143:    long i, j, inv = 0;
19396:144:    unsigned long max, negative = 0;
19397:145:
19398:146:    if (y == 0.0)
19399:147:        return 1.0;
19400:148:    if (x == 0.0) {
19401:149:        if (y < 0.0) {
19402:150:            floating_p_error (0);
19403:151:        } else
19404:152:            return 0.0;
19405:153:    }
19406:154:    if (y == 1.0)
19407:155:        return x;
19408:156:    if (y < 0.0) {
19409:157:        y = -y;
19410:158:        inv = 1;
19411:159:    }
19412:160:    z = my_log (x);
19413:161:
19414:162:    max = (unsigned long) -1;
19415:163:    if ((double) y > (double) max / 4) {
19416:164:        if (inv)
19417:165:            return 0.0;
19418:166:        else
19419:167:            floating_p_error (0);
19420:168:    }
19421:169:
19422:170:    if (x < 0.0) {
19423:171:        negative = ((long) y);
19424:172:        if (y != (double) negative)
19425:173:            floating_p_error (0);
19426:174:        negative &= 1;
19427:175:        x = -x;
19428:176:    }
19429:177:
19430:178:    y *= 2;
19431:179:    j = y;
19432:180:    y -= (double) j;
19433:181:    y /= 2;
19434:182:
19435:183:    ans2 = x;
19436:184:
19437:185:/* calc to the nearest 0.5 of a power, */
19438:186:    if (j % 2)
19439:187:        ans = my_sqrt (x);
19440:188:
19441:189:/* multiply it up in squares */
19442:190:    while ((j >>= 1)) {
19443:191:        if (j & 1)
19444:192:            ans *= ans2;
19445:193:        ans2 *= ans2;
19446:194:    }
19447:195:
19448:196:    j = 1;
19449:197:    ans2 = 1;
19450:198:/* taylor series for the remaining */
19451:199:    do {
19452:200:        t = 1;
19453:201:        for (i = 1; i <= j; i++)
19454:202:            t *= y * z / i;
19455:203:        ans2 += t;
19456:204:        j++;
19457:205:        if (j > 200)
19458:206:            floating_p_error (0); /* shouldn't happen */
19459:207:    } while (my_fabs (t / (ans * ans2)) > F_ACCURACY);
19460:208:
19461:209:    if (negative)
19462:210:        ans = -ans;
19463:211:
19464:212:    if (inv)
19465:213:        return 1.0 / (ans * ans2);
19466:214:    else
19467:215:        return ans * ans2;
19468:216:}
19469:217:
19470:218:
19471:219:#else                           /* defined(__i386__) && defined(__GNUC__) */
19472:220:
19473:221:/* The following routines are from libc-5.4.17
19474:222:   written by Hongjiu Lu, but are changed a lot here */
19475:223:
19476:224:
19477:225:double my_log (double x)
19478:226:{
19479:227:    if (x <= 0.0)
19480:228:        floating_p_error (0);
19481:229:
19482:230:    __asm__ __volatile__ ("fldln2\n\t"
19483:231:                          "fxch %%st(1)\n\t" "fyl2x":"=t" (x):"0" (x));
19484:232:    return x;
19485:233:}
19486:234:
19487:235:double my_sqrt (double x)
19488:236:{
19489:237:    const double zero = 0.0;
19490:238:
19491:239:    if (x >= zero) {
19492:240:        if (x != zero) {
19493:241:            __asm__ __volatile__ ("fsqrt":"=t" (x):"0" (x));
19494:242:        }
19495:243:        return x;
19496:244:    }
19497:245:    floating_p_error (0);
19498:246:    return 0;
19499:247:}
19500:248:
19501:249:double my_pow (double x, double y)
19502:250:{
19503:251:    int negative;
19504:252:    __volatile__ unsigned short cw, saved_cw;
19505:253:
19506:254:    if (y == 0.0)
19507:255:        return 1.0;
19508:256:    if (x == 0.0) {
19509:257:        if (y < 0.0)
19510:258:            floating_p_error (0);
19511:259:        else
19512:260:            return 0.0;
19513:261:    }
19514:262:    if (y == 1.0)
19515:263:        return x;
19516:264:
19517:265:    if (x < 0.0) {
19518:266:        long long tmp;
19519:267:        tmp = (long long) y;
19520:268:        negative = tmp & 1;
19521:269:        if (y != (double) tmp)
19522:270:            floating_p_error (0);
19523:271:        x = -x;
19524:272:    } else {
19525:273:        negative = 0;
19526:274:    }
19527:275:
19528:276:    __asm__ __volatile__ ("fnstcw %0":"=m" (cw):);
19529:277:    saved_cw = cw;
19530:278:
19531:279:    cw &= 0xf3ff;
19532:280:    cw |= 0x003f;
19533:281:
19534:282:    __asm__ __volatile__ ("fldcw %0"::"m" (cw));
19535:283:
19536:284:    __asm__
19537:285:        __volatile__ ("fyl2x;fstl %2;frndint;fstl %%st(2);fsubrp;f2xm1;"
19538:286:                      "fld1;faddp;fscale":"=t" (x):"0" (x), "u" (y));
19539:287:
19540:288:    __asm__ __volatile__ ("fldcw %0"::"m" (saved_cw));
19541:289:
19542:290:    return (negative) ? -x : x;
19543:291:}
19544:292:
19545:293:#endif                          /* defined(__i386__) && defined(__GNUC__) */
19546:294:
19547:295:/* #define TEST_MY_POW */
19548:296:
19549:297:#ifdef TEST_MY_POW
19550:298:
19551:299:void main (void)
19552:300:{
19553:301:    int i = 0;
19554:302:    double p, q, h, g;
19555:303:    for (q = -10; q < 10; q += 0.23) {
19556:304:        for (p = 0.1; p < 10; p += 0.23) {
19557:305:            i++;
19558:306:            g = pow (p, q);
19559:307:            h = my_pow (p, q);
19560:308:            if (g != 0) {
19561:309:                if (my_fabs (h - g) / g > 1e-13)
19562:310:                    abort ();
19563:311:            } else {
19564:312:                if (h != 0)
19565:313:                    abort ();
19566:314:            }
19567:315:        }
19568:316:    }
19569:317:    printf ("Done %d.\n", i);
19570:318:}
19571:319:
19572:320:#endif                          /* TEST_MY_POW */
19573:1:/*
19574:2:   Copyright (C) 1996 Paul Sheer
19575:3:
19576:4:   This program is free software; you can redistribute it and/or modify
19577:5:   it under the terms of the GNU General Public License as published by
19578:6:   the Free Software Foundation; either version 2 of the License, or
19579:7:   (at your option) any later version.
19580:8:
19581:9:   This program is distributed in the hope that it will be useful,
19582:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
19583:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
19584:12:   GNU General Public License for more details.
19585:13:
19586:14:   You should have received a copy of the GNU General Public License
19587:15:   along with this program; if not, write to the Free Software
19588:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
19589:17: */
19590:18:
19591:19:
19592:20:#include <config.h>
19593:21:#include <stdio.h>
19594:22:#include <my_string.h>
19595:23:#include <stdlib.h>
19596:24:#include <stdarg.h>
19597:25:
19598:26:#include <X11/Xlib.h>
19599:27:#include <X11/Xutil.h>
19600:28:#include <X11/Xresource.h>
19601:29:#include "lkeysym.h"
19602:30:
19603:31:#include "stringtools.h"
19604:32:#include "app_glob.c"
19605:33:#include "coolwidget.h"
19606:34:#include "coollocal.h"
19607:35:
19608:36:#include "mad.h"
19609:37:
19610:38:int eh_menu (CWidget * w, XEvent * xevent, CEvent * cwevent);
19611:39:
19612:40:void Crenderbutton (CWidget * wdt);
19613:41:
19614:42:void destroy_menu (CWidget * w)
19615:43:{
19616:44:    int i;
19617:45:    if (!w)
19618:46:        return;
19619:47:    if (!w->menu)
19620:48:        return;
19621:49:    for (i = 0; i < w->numlines; i++)
19622:50:        if (w->menu[i].text)
19623:51:            free (w->menu[i].text);
19624:52:    free (w->menu);
19625:53:}
19626:54:
19627:55:
19628:56:#define WB 4
19629:57:#define WBI 5
19630:58:#define SEP 4
19631:59:#define SEPI 2
19632:60:
19633:61:int whereis_pointer (int x, int y, int w, int h, int n)
19634:62:{
19635:63:    int hl;
19636:64:    hl = TEXT_PIX_PER_LINE;
19637:65:
19638:66:    if (x < WBI || x > w - 1 - WBI)
19639:67:        return -1;
19640:68:
19641:69:    if (y < WBI + SEPI || y > h - 1 - WBI - SEPI)
19642:70:        return -1;
19643:71:
19644:72:    return (y - WBI - SEPI) / (hl + SEP);
19645:73:}
19646:74:
19647:75:void menu_draw (Window win, int w, int h, struct menu_item m[], int n,
19648:76:                int light)
19649:77:{
19650:78:    int i, hl;
19651:79:
19652:80:    hl = TEXT_PIX_PER_LINE;
19653:81:
19654:82:    Crenderbevel (win, 0, 0, w - 1, h - 1, 2, 0);
19655:83:    Crenderbevel (win, WB, WB, w - 1 - WB, h - 1 - WB, WBI - WB, 1);
19656:84:
19657:85:    Csetcolor (C_BLACK);
19658:86:    for (i = 0; i < n; i++) {
19659:87:        if (i == light && m[i].text[2] != 0) {
19660:88:            Csetcolor (C_BLACK);
19661:89:            Crect (win, WBI + SEPI, i * (hl + SEP) + SEPI + WBI,
19662:90:                   w - 2 * (WBI + SEPI), hl);
19663:91:            Csetcolor (Ccolor (16));
19664:92:        } else {
19665:93:            Csetcolor (C_FLAT);
19666:94:            Crect (win, WBI + SEPI, i * (hl + SEP) + SEPI + WBI,
19667:95:                   w - 2 * (WBI + SEPI), hl);
19668:96:            Csetcolor (C_BLACK);
19669:97:        }
19670:98:        if (m[i].text[2] == 0) {
19671:99:            Crenderbevel (win, WB + SEPI + 2,
19672:100:                          i * (hl + SEP) + SEPI + WBI + hl / 2 - (WBI -
19673:101:                                                                  WB + 1),
19674:102:                          w - 1 - WB - SEPI - 2,
19675:103:                          i * (hl + SEP) + SEPI + WBI + hl / 2 - (WBI -
19676:104:                                                                  WB + 1) +
19677:105:                          (WBI - WB + 1) * 2 - 1, WBI - WB, 1);
19678:106:        }
19679:107:        XDrawString (CDisplay, win, CGC,
19680:108:                     CFontStruct->max_bounds.width / 2 + WBI + SEPI - 4,
19681:109:                     FONT_OFFSET_Y - 1 + WBI + i * (hl + SEP) + SEPI,
19682:110:                     m[i].text, strlen (m[i].text));
19683:111:    }
19684:112:}
19685:113:
19686:114:void Crender_menu (CWidget * w)
19687:115:{
19688:116:    int n, hl = TEXT_PIX_PER_LINE;
19689:117:    if (!w)
19690:118:        return;
19691:119:    n = w->numlines;
19692:120:    w->height = WBI * 2 + n * hl + (n - 1) * SEP + SEPI * 2;
19693:121:    XResizeWindow (CDisplay, w->winid, w->width, w->height);
19694:122:    XRaiseWindow (CDisplay, w->winid);
19695:123:    w->droppedmenu->current = w->current;
19696:124:    menu_draw (w->winid, w->width, w->height, w->menu, w->numlines,
19697:125:               w->current);
19698:126:}
19699:127:
19700:128:/* gets a widgets position relative to some ancestor widget */
19701:129:void CGetWindowPosition (Window win, Window ancestor, int *x_return,
19702:130:                         int *y_return)
19703:131:{
19704:132:    CWidget *w;
19705:133:    int x = 0, y = 0;
19706:134:
19707:135:    while (win != ancestor) {
19708:136:        w = CW (CWidgetOf (win));
19709:137:        if (!w)
19710:138:            break;
19711:139:        win = w->parentid;
19712:140:        x += w->x;
19713:141:        y += w->y;
19714:142:    }
19715:143:
19716:144:    *x_return = x;
19717:145:    *y_return = y;
19718:146:}
19719:147:
19720:148:CWidget *hold_the_menu = 0;
19721:149:
19722:150:void pull_up (CWidget * button)
19723:151:{
19724:152:    if (button == hold_the_menu)
19725:153:        return;
19726:154:    if (!button)
19727:155:        return;
19728:156:    if (button->kind != CMENU_BUTTON_WIDGET)
19729:157:        return;
19730:158:    if (button->droppedmenu) {
19731:159:        Cundrawwidget (button->droppedmenu->ident);
19732:160:        button->droppedmenu = 0;
19733:161:    }
19734:162:}
19735:163:
19736:164:void pull_down (CWidget * button)
19737:165:{                               /* must create a new widget */
19738:166:    CWidget *menu;
19739:167:    CWidget *sib;
19740:168:    int hl = TEXT_PIX_PER_LINE;
19741:169:    int width, height, n;
19742:170:    int x, y;
19743:171:    char *s;
19744:172:
19745:173:    if (button->droppedmenu)
19746:174:        return;
19747:175:
19748:176:    sib = button;
19749:177:    while ((sib = CNextFocus (sib)) != button) /* pull up any other sibling menus */
19750:178:        pull_up (sib);
19751:179:
19752:180:    n = button->numlines;
19753:181:    s = button->menu[0].text;
19754:182:
19755:183:    CGetWindowPosition (button->winid, CMain, &x, &y);
19756:184:
19757:185:    height = WBI * 2 + n * hl + (n - 1) * SEP + SEPI * 2;
19758:186:    width =
19759:187:        max (WBI * 2 + SEPI * 2 + XTextWidth (CFontStruct, s, strlen (s)),
19760:188:             XTextWidth (CFontStruct, "M", 1) * 20);
19761:189:
19762:190:    menu = Csetupwidget (catstrs (button->ident, ".pull", 0), CMain, x,
19763:191:                         y + button->height, width, height, CMENU_WIDGET,
19764:192:                         INPUT_MOTION | INPUT_BUTTON, C_FLAT, 0);
19765:193:
19766:194:/* no destroy 'cos gets ->menu gets destroyed by other menu-button-widget */
19767:195:    menu->numlines = n;
19768:196:    menu->menu = button->menu;
19769:197:    menu->eh = eh_menu;
19770:198:    menu->droppedmenu = button;
19771:199:    button->droppedmenu = menu;
19772:200:}
19773:201:
19774:202:void CPullDown (CWidget * button)
19775:203:{
19776:204:    pull_down (button);
19777:205:}
19778:206:
19779:207:void CPullUp (CWidget * button)
19780:208:{
19781:209:    pull_up (button);
19782:210:}
19783:211:
19784:212:int eh_menubutton (CWidget * w, XEvent * xevent, CEvent * cwevent)
19785:213:{
19786:214:    int c;
19787:215:    CWidget *f;
19788:216:    switch (xevent->type) {
19789:217:    case FocusOut:{
19790:218:            XEvent e;
19791:219:            e.type = FocusOut;
19792:220:            while (XCheckWindowEvent
19793:221:                   (CDisplay, cwevent->window, FocusChangeMask, &e));
19794:222:            if (e.type != FocusOut)
19795:223:                break;
19796:224:            pull_up (w);
19797:225:        }
19798:226:    case FocusIn:
19799:227:        Crenderbutton (w);
19800:228:        Cexposewindowarea (w->parentid, 0, w->x - FOCUS_RING,
19801:229:                           w->y - FOCUS_RING, w->width + FOCUS_RING * 2,
19802:230:                           w->height + FOCUS_RING * 2);
19803:231:        break;
19804:232:    case KeyPress:
19805:233:        c = CKeySym (xevent);
19806:234:        if (c == XK_Escape) {
19807:235:            CFocusWindow (w->menu_focus_return);
19808:236:            return 1;
19809:237:        }
19810:238:/*****************/
19811:239:        if ((c == XK_Tab && xevent->xkey.state & ShiftMask)
19812:240:            || c == XK_Left) {
19813:241:            f = CPreviousFocus (w);
19814:242:            while (f->kind != CMENU_BUTTON_WIDGET
19815:243:                   && (unsigned long) f != (unsigned long) w)
19816:244:                f = CPreviousFocus (f);
19817:245:            if (f) {
19818:246:                CFocus (f);
19819:247:                if (w->droppedmenu)
19820:248:                    pull_down (f);
19821:249:            }
19822:250:            return 1;
19823:251:        }
19824:252:        if (c == XK_Tab || c == XK_Right) {
19825:253:            f = CNextFocus (w);
19826:254:            while (f->kind != CMENU_BUTTON_WIDGET
19827:255:                   && (unsigned long) f != (unsigned long) w)
19828:256:                f = CNextFocus (f);
19829:257:            if (f) {
19830:258:                CFocus (f);
19831:259:                if (w->droppedmenu)
19832:260:                    pull_down (f);
19833:261:            }
19834:262:            return 1;
19835:263:        }
19836:264:        if (c == XK_Up && w->droppedmenu) {
19837:265:            if (w->droppedmenu->current == -1)
19838:266:                w->droppedmenu->current = 0;
19839:267:            do {
19840:268:                w->droppedmenu->current =
19841:269:                    (w->droppedmenu->current + w->droppedmenu->numlines -
19842:270:                     1) % w->droppedmenu->numlines;
19843:271:            } while (w->droppedmenu->menu[w->droppedmenu->current].
19844:272:                     text[2] == 0);
19845:273:            Crender_menu (w->droppedmenu);
19846:274:            return 1;
19847:275:        }
19848:276:        if (c == XK_Down && w->droppedmenu) {
19849:277:            do {
19850:278:                w->droppedmenu->current =
19851:279:                    (w->droppedmenu->current +
19852:280:                     1) % w->droppedmenu->numlines;
19853:281:            } while (w->droppedmenu->menu[w->droppedmenu->current].
19854:282:                     text[2] == 0);
19855:283:            Crender_menu (w->droppedmenu);
19856:284:            return 1;
19857:285:        }
19858:286:        if (c != XK_Return && c != XK_space && c != XK_Down)
19859:287:            break;
19860:288:        if (w->droppedmenu && (c == XK_Return || c == XK_space)) {
19861:289:            hold_the_menu = w;
19862:290:            if (w->droppedmenu->current >= 0)
19863:291:                if (w->droppedmenu->menu[w->droppedmenu->current].
19864:292:                    call_back)
19865:293:                    (*
19866:294:                     (w->droppedmenu->menu[w->droppedmenu->current].
19867:295:                      call_back)) ();
19868:296:            hold_the_menu = 0;
19869:297:            pull_up (w);
19870:298:            break;
19871:299:        }
19872:300:    case ButtonPress:
19873:301:        if (xevent->type == ButtonPress)
19874:302:            w->options = CBUTTON_PRESSED;
19875:303:        CFocus (w);
19876:304:        Crenderbutton (w);
19877:305:        if (w->droppedmenu)
19878:306:            pull_up (w);
19879:307:        else
19880:308:            pull_down (w);
19881:309:        cwevent->ident = w->ident; /* return the event */
19882:310:        break;
19883:311:    case ButtonRelease:
19884:312:        w->options = CBUTTON_HIGHLIGHT;
19885:313:        Crenderbutton (w);
19886:314:        return 1;
19887:315:    case EnterNotify:
19888:316:        w->options = CBUTTON_HIGHLIGHT;
19889:317:        Crenderbutton (w);
19890:318:        break;
19891:319:    case Expose:
19892:320:        if (xevent->xexpose.count)
19893:321:            break;
19894:322:    case LeaveNotify:
19895:323:        w->options = 0;
19896:324:        Crenderbutton (w);
19897:325:        break;
19898:326:    }
19899:327:    return 0;
19900:328:}
19901:329:
19902:330:
19903:331:
19904:332:int eh_menu (CWidget * w, XEvent * xevent, CEvent * cwevent)
19905:333:{
19906:334:    static Window win = 0;
19907:335:    static int current = -30000;
19908:336:    switch (xevent->type) {
19909:337:    case MotionNotify:
19910:338:        w->current =
19911:339:            whereis_pointer (xevent->xmotion.x, xevent->xmotion.y,
19912:340:                             w->width, w->height, w->numlines);
19913:341:        if (w->current == current && w->winid == win)
19914:342:            break;
19915:343:        current = w->current;
19916:344:        win = w->winid;
19917:345:        Crender_menu (w);
19918:346:        break;
19919:347:    case ButtonRelease:
19920:348:        w->current =
19921:349:            whereis_pointer (xevent->xmotion.x, xevent->xmotion.y,
19922:350:                             w->width, w->height, w->numlines);
19923:351:        hold_the_menu = w->droppedmenu;
19924:352:        if (w->current >= 0 && w->current < w->numlines)
19925:353:            if (w->menu[w->current].call_back)
19926:354:                (*(w->menu[w->current].call_back)) ();
19927:355:        hold_the_menu = 0;
19928:356:        pull_up (w->droppedmenu);
19929:357:        break;
19930:358:/*    case EnterNotify: */
19931:359:    case ButtonPress:
19932:360:        w->current =
19933:361:            whereis_pointer (xevent->xmotion.x, xevent->xmotion.y,
19934:362:                             w->width, w->height, w->numlines);
19935:363:        Crender_menu (w);
19936:364:        break;
19937:365:    case Expose:
19938:366:        if (xevent->xexpose.count)
19939:367:            break;
19940:368:    case LeaveNotify:
19941:369:        current = w->current = w->droppedmenu->current;
19942:370:        Crender_menu (w);
19943:371:        break;
19944:372:    }
19945:373:    return 0;
19946:374:}
19947:375:
19948:376:int find_hotkey (CWidget * w);
19949:377:
19950:378:CWidget *Cdrawmenubutton (const char *ident, Window parent,
19951:379:                          Window focus_return, int x, int y, int width,
19952:380:                          int height, int num_items, const char *label,
19953:381:                          const char *text, int hot_key, callfn call_back,
19954:382:                          ...)
19955:383:{
19956:384:    va_list ap;
19957:385:    CWidget *wdt;
19958:386:    struct menu_item *m;
19959:387:    int i;
19960:388:    int w, h;
19961:389:
19962:390:    if (width == AUTO_WIDTH || height == AUTO_HEIGHT)
19963:391:        Ctextsize (&w, &h, label);
19964:392:    if (width == AUTO_WIDTH)
19965:393:        width = w + 4 + BUTTON_RELIEF * 2;
19966:394:    if (height == AUTO_HEIGHT)
19967:395:        height = h + 4 + BUTTON_RELIEF * 2;
19968:396:
19969:397:
19970:398:    wdt = Csetupwidget (ident, parent, x, y,
19971:399:                        width, height, CMENU_BUTTON_WIDGET, INPUT_BUTTON,
19972:400:                        C_FLAT, 1);
19973:401:
19974:402:    Csethintpos (x + width + WIDGET_SPACING, y + height + WIDGET_SPACING);
19975:403:
19976:404:    wdt->label = strdup (label);
19977:405:    wdt->hotkey = find_hotkey (wdt);
19978:406:
19979:407:    m = Cmalloc (num_items * sizeof (struct menu_item));
19980:408:
19981:409:    m[0].text = strdup (catstrs (" ", text, " ", 0));
19982:410:    m[0].hot_key = hot_key;
19983:411:    m[0].call_back = call_back;
19984:412:
19985:413:    va_start (ap, call_back);
19986:414:    if (num_items > 1)
19987:415:        for (i = 1; i < num_items; i++) {
19988:416:            m[i].text =
19989:417:                strdup (catstrs (" ", va_arg (ap, char *), " ", 0));
19990:418:            m[i].hot_key = va_arg (ap, KeySym);
19991:419:            m[i].call_back = va_arg (ap, callfn);
19992:420:        }
19993:421:    va_end (ap);
19994:422:
19995:423:    wdt->destroy = destroy_menu;
19996:424:    wdt->numlines = num_items;
19997:425:    wdt->menu = m;
19998:426:    wdt->eh = eh_menubutton;
19999:427:    wdt->menu_focus_return = focus_return;
20000:428:
20001:429:    return wdt;
20002:430:}
20003:431:
20004:432:
20005:433:
20006:434:void Caddmenuitem (const char *ident, const char *text, int hot_key,
20007:435:                   callfn call_back)
20008:436:{
20009:437:    struct menu_item *m;
20010:438:    CWidget *w;
20011:439:
20012:440:    w = Cwidget (ident);
20013:441:
20014:442:    m = Cmalloc ((w->numlines + 1) * sizeof (struct menu_item));
20015:443:    memcpy (m, w->menu, w->numlines * sizeof (struct menu_item));
20016:444:    free (w->menu);
20017:445:    w->menu = m;
20018:446:    m[w->numlines].text = strdup (catstrs (" ", text, " ", 0));
20019:447:    m[w->numlines].hot_key = hot_key;
20020:448:    m[w->numlines].call_back = call_back;
20021:449:
20022:450:    w->numlines++;
20023:451:
20024:452:    if (w->droppedmenu != 0) {
20025:453:        w->droppedmenu->menu = m;
20026:454:        w->droppedmenu->numlines = w->numlines;
20027:455:        w->droppedmenu->current = w->current;
20028:456:        Crender_menu (w->droppedmenu);
20029:457:    }
20030:458:}
20031:459:
20032:460:
20033:461:static void remove_item (CWidget * w, int i)
20034:462:{
20035:463:    if (i >= w->numlines)
20036:464:        return;
20037:465:    if (w->menu[i].text)
20038:466:        free (w->menu[i].text);
20039:467:    w->numlines--;
20040:468:    memmove (&w->menu[i], &w->menu[i + 1],
20041:469:             (w->numlines - i) * sizeof (struct menu_item));
20042:470:    if (w->current == i)
20043:471:        w->current = -1;
20044:472:    else if (w->current > i)
20045:473:        w->current--;
20046:474:    if (w->droppedmenu != 0) {
20047:475:        w->droppedmenu->numlines = w->numlines;
20048:476:        w->droppedmenu->current = w->current;
20049:477:    }
20050:478:}
20051:479:
20052:480:
20053:481:/*
20054:482:   Starts from the bottom of the menu and searches for the first
20055:483:   menu item containing text (strstr != NULL), and deletes it.
20056:484:   (this is untested).
20057:485: */
20058:486:void Cremovemenuitem (const char *ident, const char *text)
20059:487:{
20060:488:    struct menu_item *m;
20061:489:    CWidget *w;
20062:490:    int i;
20063:491:
20064:492:    w = Cwidget (ident);
20065:493:
20066:494:    if (!w->numlines)
20067:495:        return;
20068:496:
20069:497:    m = w->menu;
20070:498:
20071:499:    for (i = w->numlines - 1; i >= 0; i--) {
20072:500:        if (!text)
20073:501:            goto remove;
20074:502:        if (strstr (m[i].text, text) || !*text) {
20075:503:          remove:;
20076:504:            remove_item (w, i);
20077:505:            Crender_menu (w->droppedmenu);
20078:506:            return;
20079:507:        }
20080:508:    }
20081:509:}
20082:1:#ifndef _MY_STRING_H
20083:2:#define _MY_STRING_H
20084:3:
20085:4:#include <stdlib.h>             /* this my not be needed */
20086:5:#include <sys/types.h>          /* this my not be needed */
20087:6:#include <ctype.h>              /* this my not be needed */
20088:7:
20089:8:#include <stdarg.h>
20090:9:
20091:10:#define MAX_PATH_LEN 512
20092:11:
20093:12:/* string include, hopefully works across all unixes */
20094:13:
20095:14:#ifndef INHIBIT_STRING_HEADER
20096:15:# if defined (HAVE_STRING_H) || defined (STDC_HEADERS) || defined (_LIBC)
20097:16:#  include <string.h>
20098:17:# else
20099:18:#  include <strings.h>
20100:19:# endif
20101:20:#endif
20102:21:
20103:22:#ifndef STDC_HEADERS
20104:23:# ifndef HAVE_STRCHR
20105:24:#  define strchr index
20106:25:#  define strrchr rindex
20107:26:# endif
20108:27:
20109:28:size_t strnlen (const char *s, size_t count);
20110:29:
20111:30:# ifndef HAVE_MEMCPY
20112:31:#  define memcpy(d, s, n) bcopy ((s), (d), (n))
20113:32:# endif
20114:33:# ifndef HAVE_MEMCMP
20115:34:int memcmp (const void *cs, const void *ct, size_t count);
20116:35:# endif
20117:36:# ifndef HAVE_MEMCHR
20118:37:void *memchr (const void *s, int c, size_t n);
20119:38:# endif
20120:39:#ifndef HAVE_STRCASECMP
20121:40:int strcasecmp (const char *s1, const char *s2);
20122:41:#endif
20123:42:#ifndef HAVE_STRNCASECMP
20124:43:int strncasecmp (const char *s1, const char *s2, size_t n);
20125:44:#endif
20126:45:# ifndef HAVE_STRDUP
20127:46:char *strdup (const char *s);
20128:47:#  endif
20129:48:#ifndef HAVE_MEMMOVE
20130:49:void *memmove (void *dest, const void *src, size_t n);
20131:50:# endif
20132:51:# ifndef HAVE_MEMSET
20133:52:void *memset (void *dest, int c, size_t n);
20134:53:# endif
20135:54:# ifndef HAVE_STRSPN
20136:55:size_t strspn (const char *s, const char *accept);
20137:56:# endif
20138:57:# ifndef HAVE_STRSTR
20139:58:char *strstr (const char *s1, const char *s2);
20140:59:# endif
20141:60:# ifndef HAVE_VPRINTF
20142:61:int vsprintf (char *buf, const char *fmt, va_list args);
20143:62:# endif
20144:63:#endif
20145:64:
20146:65:#endif                          /*  _MY_STRING_H  */
20147:1:/* options - global options that may be set on the command line
20148:2:   Copyright (C) 1997 Paul Sheer
20149:3:
20150:4:   This program is free software; you can redistribute it and/or modify
20151:5:   it under the terms of the GNU General Public License as published by
20152:6:   the Free Software Foundation; either version 2 of the License, or
20153:7:   (at your option) any later version.
20154:8:
20155:9:   This program is distributed in the hope that it will be useful,
20156:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
20157:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
20158:12:   GNU General Public License for more details.
20159:13:
20160:14:   You should have received a copy of the GNU General Public License
20161:15:   along with this program; if not, write to the Free Software
20162:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
20163:17: */
20164:18:
20165:19:
20166:20:#include <config.h>
20167:21:#include "edit.h"
20168:22:#include "cmdlineopt.h"
20169:23:
20170:24:/* #define OMIT_NON_COOLEDIT_OPTIONS */
20171:25:
20172:26:#ifdef OMIT_NON_COOLEDIT_OPTIONS
20173:27:
20174:28:extern int option_save_setup_on_exit;
20175:29:extern int option_suppress_load_files;
20176:30:
20177:31:#endif
20178:32:
20179:33:extern int option_text_fg_normal;
20180:34:extern int option_text_fg_bold;
20181:35:extern int option_text_fg_italic;
20182:36:
20183:37:extern int option_text_bg_normal;
20184:38:extern int option_text_bg_marked;
20185:39:extern int option_text_bg_highlighted;
20186:40:
20187:41:static struct {
20188:42:    char *name;
20189:43:    int *value;
20190:44:} integer_options[] = {
20191:45:    {
20192:46:    "option_international_characters", &option_international_characters}, {
20193:47:    "option_tab_spacing", &option_tab_spacing}, {
20194:48:    "option_fill_tabs_with_spaces", &option_fill_tabs_with_spaces}, {
20195:49:    "option_return_does_auto_indent", &option_return_does_auto_indent}, {
20196:50:    "option_backspace_through_tabs", &option_backspace_through_tabs}, {
20197:51:    "option_fake_half_tabs", &option_fake_half_tabs}, {
20198:52:    "option_editor_fg_normal", &option_editor_fg_normal}, {
20199:53:    "option_editor_fg_bold", &option_editor_fg_bold}, {
20200:54:    "option_editor_fg_italic", &option_editor_fg_italic}, {
20201:55:    "option_editor_bg_normal", &option_editor_bg_normal}, {
20202:56:    "option_editor_bg_abnormal", &option_editor_bg_abnormal}, {
20203:57:    "option_editor_bg_marked", &option_editor_bg_marked}, {
20204:58:    "option_editor_bg_marked_abnormal", &option_editor_bg_marked_abnormal},
20205:59:    {
20206:60:    "option_editor_bg_highlighted", &option_editor_bg_highlighted}, {
20207:61:    "option_editor_fg_cursor", &option_editor_fg_cursor}, {
20208:62:    "option_text_fg_normal", &option_text_fg_normal}, {
20209:63:    "option_text_fg_bold", &option_text_fg_bold}, {
20210:64:    "option_text_fg_italic", &option_text_fg_italic}, {
20211:65:    "option_text_bg_normal", &option_text_bg_normal}, {
20212:66:    "option_text_bg_marked", &option_text_bg_marked}, {
20213:67:    "option_text_bg_highlighted", &option_text_bg_highlighted},
20214:68:#ifdef OMIT_NON_COOLEDIT_OPTIONS
20215:69:    {
20216:70:    "option_save_setup_on_exit", &option_save_setup_on_exit}, {
20217:71:    "option_suppress_load_files", &option_suppress_load_files},
20218:72:#endif
20219:73:    {
20220:74:    0, 0}
20221:75:};
20222:76:
20223:77:extern char *option_display;
20224:78:extern char *option_geometry;
20225:79:extern char *option_background_color;
20226:80:extern char *option_foreground_red;
20227:81:extern char *option_foreground_green;
20228:82:extern char *option_foreground_blue;
20229:83:extern char *option_font;
20230:84:
20231:85:static struct {
20232:86:    char *name;
20233:87:    char **value;
20234:88:} string_options[] = {
20235:89:    {
20236:90:    "option_whole_chars_search", &option_whole_chars_search}, {
20237:91:    "option_whole_chars_move", &option_whole_chars_move}, {
20238:92:    "option_display", &option_display}, {
20239:93:    "option_geometry", &option_geometry}, {
20240:94:    "option_background_color", &option_background_color}, {
20241:95:    "option_foreground_red", &option_foreground_red}, {
20242:96:    "option_foreground_green", &option_foreground_green}, {
20243:97:    "option_foreground_blue", &option_foreground_blue}, {
20244:98:    "option_font", &option_font}, {
20245:99:    0, 0}
20246:100:};
20247:101:
20248:102:int load_setup (const char *file)
20249:103:{
20250:104:    char *p, *q;
20251:105:    static char *s = 0;
20252:106:    int fin = 0;
20253:107:
20254:108:    if (!file) {
20255:109:        if (s) {
20256:110:            free (s);
20257:111:            s = 0;
20258:112:        }
20259:113:        return 0;
20260:114:    }
20261:115:    p = q = get_options_section (file, "[Options]");
20262:116:    s = p;
20263:117:
20264:118:    if (!s)
20265:119:        return -1;
20266:120:
20267:121:    for (fin = 0; !fin;) {
20268:122:        if (*q == '\n' || !*q) {
20269:123:            int i;
20270:124:            if (!*q)
20271:125:                fin = 1;
20272:126:            *q = 0;
20273:127:            for (i = 0; string_options[i].name; i++) {
20274:128:                int l;
20275:129:                l = strlen (string_options[i].name);
20276:130:                l = strnlen (p, l);
20277:131:                if (p[l] && strchr ("\t =", p[l])) {
20278:132:                    if (!strncasecmp (p, string_options[i].name, l)) {
20279:133:                        *(string_options[i].value) =
20280:134:                            p + l + strspn (p + l, " =\t");
20281:135:                        break;
20282:136:                    }
20283:137:                }
20284:138:            }
20285:139:            for (i = 0; integer_options[i].name; i++) {
20286:140:                int l;
20287:141:                l = strlen (integer_options[i].name);
20288:142:                l = strnlen (p, l);
20289:143:                if (p[l] && strchr ("\t =", p[l])) {
20290:144:                    if (!strncasecmp (p, integer_options[i].name, l)) {
20291:145:                        *(integer_options[i].value) =
20292:146:                            atoi (p + l + strspn (p + l, " =\t"));
20293:147:                        break;
20294:148:                    }
20295:149:                }
20296:150:            }
20297:151:            p = (++q);
20298:152:        } else {
20299:153:            q++;
20300:154:        }
20301:155:    }
20302:156:    return 0;
20303:157:}
20304:158:
20305:159:int save_setup (const char *file)
20306:160:{
20307:161:    char *p, *s;
20308:162:    int r, i;
20309:163:
20310:164:    p = s = Cmalloc (8192);
20311:165:
20312:166:    for (i = 0; string_options[i].name; i++) {
20313:167:        if (*string_options[i].value) {
20314:168:            sprintf (p, "%s = %s\n%n", string_options[i].name,
20315:169:                     *string_options[i].value, &r);
20316:170:            p += r;
20317:171:        }
20318:172:    }
20319:173:    for (i = 0; integer_options[i].name; i++) {
20320:174:        sprintf (p, "%s = %d\n%n", integer_options[i].name,
20321:175:                 *integer_options[i].value, &r);
20322:176:        p += r;
20323:177:    }
20324:178:    *p = 0;
20325:179:
20326:180:    r = save_options_section (file, "[Options]", s);
20327:181:    free (s);
20328:182:    return r;
20329:183:}
20330:184:
20331:185:int cb_save_options (CWidget * w, XEvent * xe, CEvent * cw)
20332:186:{
20333:187:    return 0;
20334:188:}
20335:189:
20336:190:void draw_options_dialog (Window parent, int x, int y)
20337:191:{
20338:192:    Window win;
20339:193:    XEvent xev;
20340:194:    CEvent cev;
20341:195:    int o, x2, y2;
20342:196:    CState s;
20343:197:    CWidget *m;
20344:198:
20345:199:    CBackupState (&s);
20346:200:    CDisable ("*");
20347:201:
20348:202:    win = Cdrawheadedwindow ("options", parent, x, y, 10, 10, " Options ");
20349:203:    Cgethintpos (&x, &y);
20350:204:
20351:205:    o = (32 - (TEXT_PIX_PER_LINE + 2 + TEXT_RELIEF * 2)) / 2;
20352:206:
20353:207:    Cdrawswitch ("options.int_char", win, x, y, C_BLACK, C_FLAT,
20354:208:                 option_international_characters);
20355:209:    Cgethintpos (0, &y2);
20356:210:    Cdrawtext ("options.tint_char", win, 32 + WIDGET_SPACING + x, y + o,
20357:211:               " Display international characters ");
20358:212:
20359:213:    Cdrawswitch ("options.tab_space", win, x, y2, C_BLACK, C_FLAT,
20360:214:                 option_fill_tabs_with_spaces);
20361:215:    Cgethintpos (0, &y);
20362:216:    Cdrawtext ("options.ttab_space", win, 32 + WIDGET_SPACING + x, y2 + o,
20363:217:               " Fill tabs with spaces ");
20364:218:
20365:219:    Cdrawswitch ("options.auto_ind", win, x, y, C_BLACK, C_FLAT,
20366:220:                 option_return_does_auto_indent);
20367:221:    Cgethintpos (0, &y2);
20368:222:    Cdrawtext ("options.tauto_ind", win, 32 + WIDGET_SPACING + x, y + o,
20369:223:               " Return does auto indent ");
20370:224:
20371:225:    Cdrawswitch ("options.back_thru", win, x, y2, C_BLACK, C_FLAT,
20372:226:                 option_backspace_through_tabs);
20373:227:    Cgethintpos (0, &y);
20374:228:    Cdrawtext ("options.tback_thru", win, 32 + WIDGET_SPACING + x, y2 + o,
20375:229:               " Backspace through all tabs ");
20376:230:
20377:231:    Cdrawswitch ("options.half_tab", win, x, y, C_BLACK, C_FLAT,
20378:232:                 option_fake_half_tabs);
20379:233:    Cgethintpos (0, &y2);
20380:234:    Cdrawtext ("options.thalf_tab", win, 32 + WIDGET_SPACING + x, y + o,
20381:235:               " Emulate half tabs with spaces ");
20382:236:
20383:237:#ifdef OMIT_NON_COOLEDIT_OPTIONS
20384:238:    Cdrawswitch ("options.save_exit", win, x, y2, C_BLACK, C_FLAT,
20385:239:                 option_save_setup_on_exit);
20386:240:    Cgethintpos (0, &y);
20387:241:    Cdrawtext ("options.tsave_exit", win, 32 + WIDGET_SPACING + x, y2 + o,
20388:242:               " Save setup on exit ");
20389:243:
20390:244:    Cdrawswitch ("options.no_load", win, x, y, C_BLACK, C_FLAT,
20391:245:                 !option_suppress_load_files);
20392:246:    Cgethintpos (0, &y2);
20393:247:    Cdrawtext ("options.tno_load", win, 32 + WIDGET_SPACING + x, y + o,
20394:248:               " Load back desktop on startup ");
20395:249:#endif
20396:250:
20397:251:    Cdrawtext ("options.ttab_spacing", win, x, y2, " Tab spacing: ");
20398:252:    Cgethintpos (&x2, 0);
20399:253:    Cdrawtextinput ("options.tab_spacing", win, x2, y2, TEXT_M_WIDTH * 4,
20400:254:                    AUTO_HEIGHT, 8, itoa (option_tab_spacing));
20401:255:
20402:256:    Cgethintpos (0, &y);
20403:257:    Cdrawtext ("options.twc_search", win, x, y, " Whole chars search: ");
20404:258:    Cgethintpos (&x2, 0);
20405:259:    Cdrawtextinput ("options.wc_search", win, x2, y, TEXT_M_WIDTH * 16,
20406:260:                    AUTO_HEIGHT, 258, option_whole_chars_search);
20407:261:    Cgethintpos (0, &y);
20408:262:    Cdrawtext ("options.twc_move", win, x, y, " Whole chars move: ");
20409:263:    Cgethintpos (&x2, 0);
20410:264:    Cdrawtextinput ("options.wc_move", win, x2, y, TEXT_M_WIDTH * 16,
20411:265:                    AUTO_HEIGHT, 258, option_whole_chars_move);
20412:266:
20413:267:/*
20414:268:extern int option_international_characters;
20415:269:extern int option_fill_tabs_with_spaces;
20416:270:extern int option_return_does_auto_indent;
20417:271:extern int option_backspace_through_tabs;
20418:272:extern int option_fake_half_tabs;
20419:273:
20420:274:extern int option_tab_spacing;
20421:275:extern int option_tab_spacing_spaces;
20422:276:*/
20423:277:
20424:278:    Cgethintpos (0, &y);
20425:279:    Csetsizehintpos ("options");
20426:280:    m = Cwidget ("options");
20427:281:    Cdrawbitmapbutton ("options.ok", win, x, y, 40, 40, Ccolor (6), C_FLAT,
20428:282:                       tick_bits);
20429:283:    Cgethintpos (&x2, 0);
20430:284:    Cdrawbitmapbutton ("options.cancel", win, x2, y, 40, 40, Ccolor (18),
20431:285:                       C_FLAT, cross_bits);
20432:286:    Cgethintpos (&x2, 0);
20433:287:    Cdrawbutton ("options.save", win, x2, y, AUTO_WIDTH, AUTO_HEIGHT,
20434:288:                 " Save ");
20435:289:    Caddcallback ("options.save", cb_save_options);
20436:290:    Csetsizehintpos ("options");
20437:291:
20438:292:    CFocus (Cwidget ("options.ok"));
20439:293:
20440:294:    for (;;) {
20441:295:        CNextEvent (&xev, &cev);
20442:296:        if (!strcmp (cev.ident, "options.cancel")
20443:297:            || (CKeySym (&xev) == XK_Escape && xev.type == KeyPress))
20444:298:            break;
20445:299:        if (!strcmp (cev.ident, "options.ok")
20446:300:            || (CKeySym (&xev) == XK_Return && xev.type == KeyPress)) {
20447:301:            option_international_characters =
20448:302:                (Cwidget ("options.int_char"))->keypressed;
20449:303:            option_fill_tabs_with_spaces =
20450:304:                (Cwidget ("options.tab_space"))->keypressed;
20451:305:            option_return_does_auto_indent =
20452:306:                (Cwidget ("options.auto_ind"))->keypressed;
20453:307:            option_backspace_through_tabs =
20454:308:                (Cwidget ("options.back_thru"))->keypressed;
20455:309:            option_fake_half_tabs =
20456:310:                (Cwidget ("options.half_tab"))->keypressed;
20457:311:            option_tab_spacing =
20458:312:                atoi ((Cwidget ("options.tab_spacing"))->text);
20459:313:            option_whole_chars_search =
20460:314:                strdup ((Cwidget ("options.wc_search"))->text);
20461:315:            option_whole_chars_move =
20462:316:                strdup ((Cwidget ("options.wc_move"))->text);
20463:317:#ifdef OMIT_NON_COOLEDIT_OPTIONS
20464:318:            option_save_setup_on_exit =
20465:319:                (Cwidget ("options.save_exit"))->keypressed;
20466:320:            option_suppress_load_files =
20467:321:                !(Cwidget ("options.no_load"))->keypressed;
20468:322:#endif
20469:323:            break;
20470:324:        }
20471:325:    }
20472:326:    Cundrawwidget ("options");
20473:327:    CRestoreState (&s);
20474:328:}
20475:1:int option_international_characters = 0;
20476:2:int option_tab_spacing = 8;
20477:3:int option_hard_tab_only = 0;
20478:4:int option_fill_tabs_with_spaces = 0;
20479:5:int option_return_does_auto_indent = 0;
20480:6:int option_backspace_through_tabs = 0;
20481:7:int option_fake_half_tabs = 1;
20482:1:/* pipe.c - for opening a process as a pipe and reading both stderr and stdout together */
20483:2:/*
20484:3:   Copyright (C) 1997 Paul Sheer
20485:4:
20486:5:   This program is free software; you can redistribute it and/or modify
20487:6:   it under the terms of the GNU General Public License as published by
20488:7:   the Free Software Foundation; either version 2 of the License, or
20489:8:   (at your option) any later version.
20490:9:
20491:10:   This program is distributed in the hope that it will be useful,
20492:11:   but WITHOUT ANY WARRANTY; without even the implied warranty of
20493:12:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
20494:13:   GNU General Public License for more details.
20495:14:
20496:15:   You should have received a copy of the GNU General Public License
20497:16:   along with this program; if not, write to the Free Software
20498:17:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
20499:18: */
20500:19:#include <config.h>
20501:20:#include "global.h"
20502:21:#include <stdlib.h>
20503:22:#include <stdio.h>
20504:23:#include <sys/time.h>
20505:24:#include <sys/types.h>
20506:25:#include <sys/stat.h>
20507:26:
20508:27:#ifdef HAVE_FCNTL_H
20509:28:#include <fcntl.h>
20510:29:#endif
20511:30:
20512:31:#include <signal.h>
20513:32:#ifdef HAVE_UNISTD_H
20514:33:#   include <unistd.h>
20515:34:#endif
20516:35:
20517:36:#include "my_string.h"
20518:37:#ifdef HAVE_SYS_SELECT_H
20519:38:#  include <sys/select.h>
20520:39:#endif
20521:40:#include <errno.h>
20522:41:
20523:42:#include "mad.h"
20524:43:
20525:44:int data_read_ready (int f);
20526:45:int data_read_wait (int f);
20527:46:int data_write_ready (int f);
20528:47:int data_write_wait (int f);
20529:48:pid_t my_popen (int *in, int *out, int *err, int mix, const char *file,
20530:49:                char *const argv[]);
20531:50:char *read_pipe (int fd, int *len);
20532:51:
20533:52:#undef min
20534:53:#define min(x,y)     (((x) < (y)) ? (x) : (y))
20535:54:
20536:55:/*
20537:56:   This opens a process as a pipe. 'in', 'out' and 'err' are pointers to file handles
20538:57:   which are filled in by popen. 'in' refers to stdin of the process, to
20539:58:   which you can write. 'out' and 'err' refer to stdout and stderr of the process
20540:59:   from which you can read. 'in', 'out' and 'err' can be passed
20541:60:   as NULL if you want to ignore output or input of those pipes.
20542:61:   If 'mix' is non-zero, then both stderr and stdout of the process
20543:62:   can be read from 'out'. If mix is non-zero, then 'err' must be passed as NULL.
20544:63:   Popen forks and then calls execvp (see execvp(3)) --- which must also take argv[0]
20545:64:   and args must terminate with a NULL.
20546:65:   Returns -1 if the fork failed, and -2 if pipe() failed.
20547:66:   Otherwise returns the pid of the child.
20548:67: */
20549:68:pid_t my_popen (int *in, int *out, int *err, int mix, const char *file,
20550:69:                char *const argv[])
20551:70:{
20552:71:    pid_t p;
20553:72:    int e;
20554:73:    int f0[2], f1[2], f2[2];
20555:74:
20556:75:    e = (pipe (f0) | pipe (f1) | pipe (f2));
20557:76:
20558:77:    if (e) {
20559:78:        close (f0[0]);
20560:79:        close (f0[1]);
20561:80:        close (f1[0]);
20562:81:        close (f1[1]);
20563:82:        close (f2[0]);
20564:83:        close (f2[1]);
20565:84:        return -2;
20566:85:    }
20567:86:
20568:87:    p = fork ();
20569:88:
20570:89:    if (p == -1) {
20571:90:        close (f0[0]);
20572:91:        close (f0[1]);
20573:92:        close (f1[0]);
20574:93:        close (f1[1]);
20575:94:        close (f2[0]);
20576:95:        close (f2[1]);
20577:96:        return -1;
20578:97:    }
20579:98:    if (p) {
20580:99:        if (in) {
20581:100:            *in = f0[1];
20582:101:        } else {
20583:102:            close (f0[1]);
20584:103:        }
20585:104:        if (out) {
20586:105:            *out = f1[0];
20587:106:        } else {
20588:107:            close (f1[0]);
20589:108:        }
20590:109:        if (err) {
20591:110:            *err = f2[0];
20592:111:        } else {
20593:112:            close (f2[0]);
20594:113:        }
20595:114:        close (f0[0]);
20596:115:        close (f1[1]);
20597:116:        close (f2[1]);
20598:117:        return p;
20599:118:    } else {
20600:119:        int nulldevice;
20601:120:        signal (SIGALRM, SIG_IGN);
20602:121:
20603:122:        nulldevice = open ("/dev/null", O_WRONLY);
20604:123:
20605:124:        close (0);
20606:125:        dup (f0[0]);
20607:126:        close (1);
20608:127:        if (out)
20609:128:            dup (f1[1]);
20610:129:        else
20611:130:            dup (nulldevice);
20612:131:        close (2);
20613:132:        if (err)
20614:133:            dup (f2[1]);
20615:134:        else {
20616:135:            if (mix)
20617:136:                dup (f1[1]);
20618:137:            else
20619:138:                dup (nulldevice);
20620:139:        }
20621:140:        close (f0[0]);
20622:141:        close (f0[1]);
20623:142:        close (f1[0]);
20624:143:        close (f1[1]);
20625:144:        close (f2[0]);
20626:145:        close (f2[1]);
20627:146:
20628:147:        close (nulldevice);
20629:148:        execvp (file, argv);
20630:149:        exit (0);
20631:150:    }
20632:151:}
20633:152:
20634:153:
20635:154:#define CHUNK 65536
20636:155:#define MAX_BLOCKS 64
20637:156:
20638:157:/*
20639:158:   Reads all available data up to a maximum of 4MB and
20640:159:   mallocs space for it plus one byte, and sets that byte
20641:160:   to zero. If len is non-NULL len must point to the maximum
20642:161:   number of bytes you would like to read, which, on return,
20643:162:   will be replaced by the amount of bytes actually read.
20644:163:   Returns NULL if memory not available and
20645:164:   sets errno = ENOMEM. Returns NULL if error from read()
20646:165:   call, in which case errno will be set as of read().
20647:166:   Result must be free'd. This blocks waiting for data
20648:167:   using data_read_wait() below, even if fd is normally
20649:168:   non-blocking. Does not close() fd.
20650:169: */
20651:170:char *read_pipe (int fd, int *len)
20652:171:{
20653:172:    char *blocks[MAX_BLOCKS], *t, *p;
20654:173:    int i, j, count, l = 0, max_len;
20655:174:
20656:175:    memset (blocks, 0, sizeof (char *) * MAX_BLOCKS);
20657:176:    if (len)
20658:177:        max_len = *len;
20659:178:    else
20660:179:        max_len = MAX_BLOCKS * CHUNK;
20661:180:
20662:181:    for (i = 0; i < MAX_BLOCKS; i++) {
20663:182:        blocks[i] = malloc (CHUNK);
20664:183:        if (!blocks[i]) {
20665:184:            errno = ENOMEM;
20666:185:            goto freeall;
20667:186:        }
20668:187:        for (j = 0; j < CHUNK;) {
20669:188:            data_read_wait (fd);
20670:189:            count = read (fd, blocks[i] + j, min (CHUNK - j, max_len - l));
20671:190:            if (count < 1)
20672:191:                break;
20673:192:            j += count;
20674:193:            if (l + j == max_len)
20675:194:                break;
20676:195:        }
20677:196:        if (count == -1)
20678:197:            goto freeall;
20679:198:        l += j;
20680:199:        if (j < CHUNK)
20681:200:            break;
20682:201:    }
20683:202:
20684:203:    p = t = malloc (l + 1);
20685:204:    if (!t) {
20686:205:        errno = ENOMEM;
20687:206:        goto freeall;
20688:207:    }
20689:208:    t[l] = 0;                   /* can read data as a NULL-terminated string */
20690:209:
20691:210:    if (len)
20692:211:        *len = l;
20693:212:
20694:213:    for (i = 0; i < MAX_BLOCKS && l > 0; i++, l -= CHUNK, p += CHUNK) {
20695:214:        memcpy (p, blocks[i], min (l, CHUNK));
20696:215:        free (blocks[i]);
20697:216:    }
20698:217:    if (blocks[i])
20699:218:        free (blocks[i]);
20700:219:    return t;
20701:220:
20702:221:  freeall:
20703:222:    for (i = 0; i < MAX_BLOCKS; i++)
20704:223:        if (blocks[i])
20705:224:            free (blocks[i]);
20706:225:    return 0;
20707:226:}
20708:227:
20709:228:
20710:229:static inline int data_select (int f, int waits, char read_write)
20711:230:{
20712:231:    fd_set fds;
20713:232:    struct timeval tv;
20714:233:    int result;
20715:234:
20716:235:    if (waits) {
20717:236:        if (read_write == 'r') {
20718:237:            for (;;) {
20719:238:                FD_ZERO (&fds);
20720:239:                FD_SET (f, &fds);
20721:240:                result = select (f + 1, &fds, 0, 0, 0);
20722:241:                if (result == -1 && errno == EINTR) {
20723:242:                    tv.tv_sec = 0;
20724:243:                    tv.tv_usec = 50;
20725:244:                    select (0, 0, 0, 0, &tv); /* non-blocking io, therefore wait 50 us before trying again */
20726:245:                    continue;
20727:246:                }
20728:247:                break;
20729:248:            }
20730:249:            return result;
20731:250:        } else {
20732:251:            for (;;) {
20733:252:                FD_ZERO (&fds);
20734:253:                FD_SET (f, &fds);
20735:254:                result = select (f + 1, 0, &fds, 0, 0);
20736:255:                if (result == -1 && errno == EINTR) {
20737:256:                    tv.tv_sec = 0;
20738:257:                    tv.tv_usec = 50;
20739:258:                    select (0, 0, 0, 0, &tv); /* non-blocking io, therefore wait 50 us before trying again */
20740:259:                    continue;
20741:260:                }
20742:261:                break;
20743:262:            }
20744:263:            return result;
20745:264:        }
20746:265:    } else {
20747:266:        if (read_write == 'r') {
20748:267:            FD_ZERO (&fds);
20749:268:            FD_SET (f, &fds);
20750:269:            tv.tv_sec = 0;
20751:270:            tv.tv_usec = 0;
20752:271:            return select (f + 1, &fds, 0, 0, &tv);
20753:272:        }
20754:273:    }
20755:274:    FD_ZERO (&fds);
20756:275:    FD_SET (f, &fds);
20757:276:    tv.tv_sec = 0;
20758:277:    tv.tv_usec = 0;
20759:278:    return select (f + 1, 0, &fds, 0, &tv);
20760:279:}
20761:280:
20762:281:
20763:282:/*
20764:283:   The following procedures can be used as checks before
20765:284:   read() and write() to prevent or force blocking.
20766:285: */
20767:286:
20768:287:/* this will check if data is available from f and then return immediately */
20769:288:int data_read_ready (int f)
20770:289:{
20771:290:    return data_select (f, 0, 'r');
20772:291:}
20773:292:
20774:293:/* blocks until data is ready to be read */
20775:294:int data_read_wait (int f)
20776:295:{
20777:296:    return data_select (f, 1, 'r');
20778:297:}
20779:298:
20780:299:/* this will check if f is ready to receive data */
20781:300:int data_write_ready (int f)
20782:301:{
20783:302:    return data_select (f, 0, 'w');
20784:303:}
20785:304:
20786:305:/* waits until data is ready to be written and return immediately */
20787:306:int data_write_wait (int f)
20788:307:{
20789:308:    return data_select (f, 1, 'w');
20790:309:}
20791:1:#include <math.h>
20792:2:#include "quickmath.h"
20793:3:
20794:4:inline double fsqr (double x)
20795:5:{
20796:6:    return x * x;
20797:7:}
20798:8:
20799:9:inline long lsqr (long x)
20800:10:{
20801:11:    return (long) x *x;
20802:12:}
20803:13:
20804:14:inline double fmax (double a, double b)
20805:15:{
20806:16:    return max (a, b);
20807:17:}
20808:18:
20809:19:inline double fmin (double a, double b)
20810:20:{
20811:21:    return min (a, b);
20812:22:}
20813:23:
20814:24:inline double fsgn (double a)
20815:25:{
20816:26:    return (a == 0.0 ? 0.0 : (a > 0.0 ? 1.0 : -1.0));
20817:27:}
20818:28:
20819:29:inline double dot (Vec a, Vec b)
20820:30:{
20821:31:    return a.x * b.x + a.y * b.y + a.z * b.z;
20822:32:}
20823:33:
20824:34:Vec cross (Vec a, Vec b)
20825:35:{
20826:36:    Vec c;
20827:37:    c.x = a.y * b.z - a.z * b.y;
20828:38:    c.y = a.z * b.x - a.x * b.z;
20829:39:    c.z = a.x * b.y - a.y * b.x;
20830:40:    return c;
20831:41:}
20832:42:
20833:43:Vec plus (Vec a, Vec b)
20834:44:{
20835:45:    Vec c;
20836:46:    c.x = a.x + b.x;
20837:47:    c.y = a.y + b.y;
20838:48:    c.z = a.z + b.z;
20839:49:    return c;
20840:50:}
20841:51:
20842:52:Vec minus (Vec a, Vec b)
20843:53:{
20844:54:    Vec c;
20845:55:    c.x = a.x - b.x;
20846:56:    c.y = a.y - b.y;
20847:57:    c.z = a.z - b.z;
20848:58:    return c;
20849:59:}
20850:60:
20851:61:Vec times (Vec a, double f)
20852:62:{
20853:63:    Vec c;
20854:64:    c.x = a.x * f;
20855:65:    c.y = a.y * f;
20856:66:    c.z = a.z * f;
20857:67:    return c;
20858:68:}
20859:69:
20860:70:double norm (Vec a)
20861:71:{
20862:72:    return sqrt (sqr (a.x) + sqr (a.y) + sqr (a.z));
20863:73:}
20864:74:
20865:75:void orth_vectors (Vec X, Vec * r1, Vec * r2, double r)
20866:76:{
20867:77:    if (X.x == 0 && X.y == 0) {
20868:78:        r1->x = 1;
20869:79:        r1->y = 0;
20870:80:        r1->z = 0;
20871:81:    } else {
20872:82:        r1->x = X.y / sqrt (X.x * X.x + X.y * X.y);
20873:83:        r1->y = -X.x / sqrt (X.x * X.x + X.y * X.y);
20874:84:        r1->z = 0;
20875:85:    }
20876:86:    *r1 = times (*r1, r);       /* r1 now has length r */
20877:87:
20878:88:    *r2 = cross (X, *r1);
20879:89:    *r2 = times (*r2, r / norm (*r2)); /* r2 now has length r */
20880:90:
20881:91:/* r1 and r2 are now two vectors prependicular to each other and to (x,y,z) */
20882:92:}
20883:1:#ifndef QUICK_MATH_H
20884:2:#define QUICK_MATH_H
20885:3:
20886:4:#include "../config.h"
20887:5:
20888:6:#ifndef PI
20889:7:#define PI 3.14159265358979323846
20890:8:#endif
20891:9:
20892:10:typedef struct {
20893:11:    double x, y, z;
20894:12:} Vec;
20895:13:
20896:14:
20897:15:#define sqr(x) ((x)*(x))
20898:16:
20899:17:#define fswap(a, b) \
20900:18:{ \
20901:19:    double __t_var = (a); \
20902:20:    (a) = (b); \
20903:21:    (b) = __t_var; \
20904:22:}
20905:23:
20906:24:
20907:25:#define swap(a, b) \
20908:26:{ \
20909:27:    long __t_var = (a); \
20910:28:    (a) = (b); \
20911:29:    (b) = __t_var; \
20912:30:}
20913:31:
20914:32:#define max(x,y)     (((x) > (y)) ? (x) : (y))
20915:33:#define min(x,y)     (((x) < (y)) ? (x) : (y))
20916:34:
20917:35:#ifndef __GNUC__
20918:36:
20919:37:double fsqr (double x);
20920:38:long lsqr (long x);
20921:39:double fmax (double a, double b);
20922:40:double fmin (double a, double b);
20923:41:double fsgn (double a);
20924:42:double dot (Vec a, Vec b);
20925:43:Vec cross (Vec a, Vec b);
20926:44:Vec plus (Vec a, Vec b);
20927:45:Vec minus (Vec a, Vec b);
20928:46:Vec times (Vec a, double f);
20929:47:double norm (Vec a);
20930:48:
20931:49:#else
20932:50:
20933:51:extern inline double fsqr (double x)
20934:52:{
20935:53:    return x * x;
20936:54:}
20937:55:
20938:56:extern inline long lsqr (long x)
20939:57:{
20940:58:    return (long) x *x;
20941:59:}
20942:60:
20943:61:extern inline double fmax (double a, double b)
20944:62:{
20945:63:    return max (a, b);
20946:64:}
20947:65:
20948:66:extern inline double fmin (double a, double b)
20949:67:{
20950:68:    return min (a, b);
20951:69:}
20952:70:
20953:71:extern inline double fsgn (double a)
20954:72:{
20955:73:    return (a == 0.0 ? 0.0 : (a > 0.0 ? 1.0 : -1.0));
20956:74:}
20957:75:
20958:76:extern inline double dot (Vec a, Vec b)
20959:77:{
20960:78:    return a.x * b.x + a.y * b.y + a.z * b.z;
20961:79:}
20962:80:
20963:81:extern inline Vec cross (Vec a, Vec b)
20964:82:{
20965:83:    Vec c;
20966:84:    c.x = a.y * b.z - a.z * b.y;
20967:85:    c.y = a.z * b.x - a.x * b.z;
20968:86:    c.z = a.x * b.y - a.y * b.x;
20969:87:    return c;
20970:88:}
20971:89:
20972:90:extern inline Vec plus (Vec a, Vec b)
20973:91:{
20974:92:    Vec c;
20975:93:    c.x = a.x + b.x;
20976:94:    c.y = a.y + b.y;
20977:95:    c.z = a.z + b.z;
20978:96:    return c;
20979:97:}
20980:98:
20981:99:extern inline Vec minus (Vec a, Vec b)
20982:100:{
20983:101:    Vec c;
20984:102:    c.x = a.x - b.x;
20985:103:    c.y = a.y - b.y;
20986:104:    c.z = a.z - b.z;
20987:105:    return c;
20988:106:}
20989:107:
20990:108:extern inline Vec times (Vec a, double f)
20991:109:{
20992:110:    Vec c;
20993:111:    c.x = a.x * f;
20994:112:    c.y = a.y * f;
20995:113:    c.z = a.z * f;
20996:114:    return c;
20997:115:}
20998:116:
20999:117:extern inline double norm (Vec a)
21000:118:{
21001:119:    return sqrt (sqr (a.x) + sqr (a.y) + sqr (a.z));
21002:120:}
21003:121:
21004:122:#endif
21005:123:
21006:124:void orth_vectors (Vec X, Vec * r1, Vec * r2, double r);
21007:125:
21008:126:#endif
21009:1:/* Extended regular expression matching and search library,
21010:2:   version 0.12.
21011:3:   (Implements POSIX draft P10003.2/D11.2, except for
21012:4:   internationalization features.)
21013:5:
21014:6:   Copyright (C) 1993, 1994, 1995 Free Software Foundation, Inc.
21015:7:
21016:8:   This program is free software; you can redistribute it and/or modify
21017:9:   it under the terms of the GNU General Public License as published by
21018:10:   the Free Software Foundation; either version 2, or (at your option)
21019:11:   any later version.
21020:12:
21021:13:   This program is distributed in the hope that it will be useful,
21022:14:   but WITHOUT ANY WARRANTY; without even the implied warranty of
21023:15:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
21024:16:   GNU General Public License for more details.
21025:17:
21026:18:   You should have received a copy of the GNU General Public License
21027:19:   along with this program; if not, write to the Free Software
21028:20:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
21029:21:
21030:22:#ifdef DEBUG
21031:23:#undef DEBUG
21032:24:#endif
21033:25:
21034:26:/* AIX requires this to be the first thing in the file. */
21035:27:#if defined (_AIX) && !defined (REGEX_MALLOC)
21036:28:#pragma alloca
21037:29:#endif
21038:30:
21039:31:#define _GNU_SOURCE
21040:32:
21041:33:#ifdef HAVE_CONFIG_H
21042:34:#include <config.h>
21043:35:#endif
21044:36:
21045:37:/* We need this for `regex.h', and perhaps for the Emacs include files.  */
21046:38:#include <sys/types.h>
21047:39:
21048:40:/* This is for other GNU distributions with internationalized messages.  */
21049:41:#if HAVE_LIBINTL_H || defined (_LIBC)
21050:42:# include <libintl.h>
21051:43:#else
21052:44:# define gettext(msgid) (msgid)
21053:45:#endif
21054:46:
21055:47:/* The `emacs' switch turns on certain matching commands
21056:48:   that make sense only in Emacs. */
21057:49:#ifdef emacs
21058:50:
21059:51:#include "lisp.h"
21060:52:#include "buffer.h"
21061:53:#include "syntax.h"
21062:54:
21063:55:#else                           /* not emacs */
21064:56:
21065:57:/* If we are not linking with Emacs proper,
21066:58:   we can't use the relocating allocator
21067:59:   even if config.h says that we can.  */
21068:60:#undef REL_ALLOC
21069:61:
21070:62:#if defined (STDC_HEADERS) || defined (_LIBC)
21071:63:#include <stdlib.h>
21072:64:#else
21073:65:char *malloc ();
21074:66:char *realloc ();
21075:67:#endif
21076:68:
21077:69:/* When used in Emacs's lib-src, we need to get bzero and bcopy somehow.
21078:70:   If nothing else has been done, use the method below.  */
21079:71:#ifdef INHIBIT_STRING_HEADER
21080:72:#if !(defined (HAVE_BZERO) && defined (HAVE_BCOPY))
21081:73:#if !defined (bzero) && !defined (bcopy)
21082:74:#undef INHIBIT_STRING_HEADER
21083:75:#endif
21084:76:#endif
21085:77:#endif
21086:78:
21087:79:/* This is the normal way of making sure we have a bcopy and a bzero.
21088:80:   This is used in most programs--a few other programs avoid this
21089:81:   by defining INHIBIT_STRING_HEADER.  */
21090:82:#ifndef INHIBIT_STRING_HEADER
21091:83:#if defined (HAVE_STRING_H) || defined (STDC_HEADERS) || defined (_LIBC)
21092:84:#include <string.h>
21093:85:#ifndef bcmp
21094:86:#define bcmp(s1, s2, n)        memcmp ((s1), (s2), (n))
21095:87:#endif
21096:88:#ifndef bcopy
21097:89:#define bcopy(s, d, n)        memcpy ((d), (s), (n))
21098:90:#endif
21099:91:#ifndef bzero
21100:92:#define bzero(s, n)        memset ((s), 0, (n))
21101:93:#endif
21102:94:#else
21103:95:#include <strings.h>
21104:96:#endif
21105:97:#endif
21106:98:
21107:99:/* Define the syntax stuff for \<, \>, etc.  */
21108:100:
21109:101:/* This must be nonzero for the wordchar and notwordchar pattern
21110:102:   commands in re_match_2.  */
21111:103:#ifndef Sword
21112:104:#define Sword 1
21113:105:#endif
21114:106:
21115:107:#ifdef SWITCH_ENUM_BUG
21116:108:#define SWITCH_ENUM_CAST(x) ((int)(x))
21117:109:#else
21118:110:#define SWITCH_ENUM_CAST(x) (x)
21119:111:#endif
21120:112:
21121:113:#ifdef SYNTAX_TABLE
21122:114:
21123:115:extern char *re_syntax_table;
21124:116:
21125:117:#else                           /* not SYNTAX_TABLE */
21126:118:
21127:119:/* How many characters in the character set.  */
21128:120:#define CHAR_SET_SIZE 256
21129:121:
21130:122:static char re_syntax_table[CHAR_SET_SIZE];
21131:123:
21132:124:static void init_syntax_once ()
21133:125:{
21134:126:    register int c;
21135:127:    static int done = 0;
21136:128:
21137:129:    if (done)
21138:130:        return;
21139:131:
21140:132:    bzero (re_syntax_table, sizeof re_syntax_table);
21141:133:
21142:134:    for (c = 'a'; c <= 'z'; c++)
21143:135:        re_syntax_table[c] = Sword;
21144:136:
21145:137:    for (c = 'A'; c <= 'Z'; c++)
21146:138:        re_syntax_table[c] = Sword;
21147:139:
21148:140:    for (c = '0'; c <= '9'; c++)
21149:141:        re_syntax_table[c] = Sword;
21150:142:
21151:143:    re_syntax_table['_'] = Sword;
21152:144:
21153:145:    done = 1;
21154:146:}
21155:147:
21156:148:#endif                          /* not SYNTAX_TABLE */
21157:149:
21158:150:#define SYNTAX(c) re_syntax_table[c]
21159:151:
21160:152:#endif                          /* not emacs */
21161:153:
21162:154:/* Get the interface, including the syntax bits.  */
21163:155:#include "regex.h"
21164:156:
21165:157:/* isalpha etc. are used for the character classes.  */
21166:158:#include <ctype.h>
21167:159:
21168:160:/* Jim Meyering writes:
21169:161:
21170:162:   "... Some ctype macros are valid only for character codes that
21171:163:   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
21172:164:   using /bin/cc or gcc but without giving an ansi option).  So, all
21173:165:   ctype uses should be through macros like ISPRINT...  If
21174:166:   STDC_HEADERS is defined, then autoconf has verified that the ctype
21175:167:   macros don't need to be guarded with references to isascii. ...
21176:168:   Defining isascii to 1 should let any compiler worth its salt
21177:169:   eliminate the && through constant folding."  */
21178:170:
21179:171:#if defined (STDC_HEADERS) || (!defined (isascii) && !defined (HAVE_ISASCII))
21180:172:#define ISASCII(c) 1
21181:173:#else
21182:174:#define ISASCII(c) isascii(c)
21183:175:#endif
21184:176:
21185:177:#ifdef isblank
21186:178:#define ISBLANK(c) (ISASCII (c) && isblank (c))
21187:179:#else
21188:180:#define ISBLANK(c) ((c) == ' ' || (c) == '\t')
21189:181:#endif
21190:182:#ifdef isgraph
21191:183:#define ISGRAPH(c) (ISASCII (c) && isgraph (c))
21192:184:#else
21193:185:#define ISGRAPH(c) (ISASCII (c) && isprint (c) && !isspace (c))
21194:186:#endif
21195:187:
21196:188:#define ISPRINT(c) (ISASCII (c) && isprint (c))
21197:189:#define ISDIGIT(c) (ISASCII (c) && isdigit (c))
21198:190:#define ISALNUM(c) (ISASCII (c) && isalnum (c))
21199:191:#define ISALPHA(c) (ISASCII (c) && isalpha (c))
21200:192:#define ISCNTRL(c) (ISASCII (c) && iscntrl (c))
21201:193:#define ISLOWER(c) (ISASCII (c) && islower (c))
21202:194:#define ISPUNCT(c) (ISASCII (c) && ispunct (c))
21203:195:#define ISSPACE(c) (ISASCII (c) && isspace (c))
21204:196:#define ISUPPER(c) (ISASCII (c) && isupper (c))
21205:197:#define ISXDIGIT(c) (ISASCII (c) && isxdigit (c))
21206:198:
21207:199:#ifndef NULL
21208:200:#define NULL (void *)0
21209:201:#endif
21210:202:
21211:203:/* We remove any previous definition of `SIGN_EXTEND_CHAR',
21212:204:   since ours (we hope) works properly with all combinations of
21213:205:   machines, compilers, `char' and `unsigned char' argument types.
21214:206:   (Per Bothner suggested the basic approach.)  */
21215:207:#undef SIGN_EXTEND_CHAR
21216:208:#if __STDC__
21217:209:#define SIGN_EXTEND_CHAR(c) ((signed char) (c))
21218:210:#else                           /* not __STDC__ */
21219:211:/* As in Harbison and Steele.  */
21220:212:#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
21221:213:#endif
21222:214:
21223:215:/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
21224:216:   use `alloca' instead of `malloc'.  This is because using malloc in
21225:217:   re_search* or re_match* could cause memory leaks when C-g is used in
21226:218:   Emacs; also, malloc is slower and causes storage fragmentation.  On
21227:219:   the other hand, malloc is more portable, and easier to debug.  
21228:220:   
21229:221:   Because we sometimes use alloca, some routines have to be macros,
21230:222:   not functions -- `alloca'-allocated space disappears at the end of the
21231:223:   function it is called in.  */
21232:224:
21233:225:#ifdef REGEX_MALLOC
21234:226:
21235:227:#define REGEX_ALLOCATE malloc
21236:228:#define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)
21237:229:#define REGEX_FREE free
21238:230:
21239:231:#else                           /* not REGEX_MALLOC  */
21240:232:
21241:233:/* Emacs already defines alloca, sometimes.  */
21242:234:#ifndef alloca
21243:235:
21244:236:/* Make alloca work the best possible way.  */
21245:237:#ifdef __GNUC__
21246:238:#define alloca __builtin_alloca
21247:239:#else                           /* not __GNUC__ */
21248:240:#if HAVE_ALLOCA_H
21249:241:#include <alloca.h>
21250:242:#else                           /* not __GNUC__ or HAVE_ALLOCA_H */
21251:243:#ifndef _AIX                    /* Already did AIX, up at the top.  */
21252:244:char *alloca ();
21253:245:#endif                          /* not _AIX */
21254:246:#endif                          /* not HAVE_ALLOCA_H */
21255:247:#endif                          /* not __GNUC__ */
21256:248:
21257:249:#endif                          /* not alloca */
21258:250:
21259:251:#define REGEX_ALLOCATE alloca
21260:252:
21261:253:/* Assumes a `char *destination' variable.  */
21262:254:#define REGEX_REALLOCATE(source, osize, nsize)                                \
21263:255:  (destination = (char *) alloca (nsize),                                \
21264:256:   bcopy (source, destination, osize),                                        \
21265:257:   destination)
21266:258:
21267:259:/* No need to do anything to free, after alloca.  */
21268:260:#define REGEX_FREE(arg) ((void)0) /* Do nothing!  But inhibit gcc warning.  */
21269:261:
21270:262:#endif                          /* not REGEX_MALLOC */
21271:263:
21272:264:/* Define how to allocate the failure stack.  */
21273:265:
21274:266:#ifdef REL_ALLOC
21275:267:#define REGEX_ALLOCATE_STACK(size)                                \
21276:268:  r_alloc (&failure_stack_ptr, (size))
21277:269:#define REGEX_REALLOCATE_STACK(source, osize, nsize)                \
21278:270:  r_re_alloc (&failure_stack_ptr, (nsize))
21279:271:#define REGEX_FREE_STACK(ptr)                                        \
21280:272:  r_alloc_free (&failure_stack_ptr)
21281:273:
21282:274:#else                           /* not REL_ALLOC */
21283:275:
21284:276:#ifdef REGEX_MALLOC
21285:277:
21286:278:#define REGEX_ALLOCATE_STACK malloc
21287:279:#define REGEX_REALLOCATE_STACK(source, osize, nsize) realloc (source, nsize)
21288:280:#define REGEX_FREE_STACK free
21289:281:
21290:282:#else                           /* not REGEX_MALLOC */
21291:283:
21292:284:#define REGEX_ALLOCATE_STACK alloca
21293:285:
21294:286:#define REGEX_REALLOCATE_STACK(source, osize, nsize)                        \
21295:287:   REGEX_REALLOCATE (source, osize, nsize)
21296:288:/* No need to explicitly free anything.  */
21297:289:#define REGEX_FREE_STACK(arg)
21298:290:
21299:291:#endif                          /* not REGEX_MALLOC */
21300:292:#endif                          /* not REL_ALLOC */
21301:293:
21302:294:
21303:295:/* True if `size1' is non-NULL and PTR is pointing anywhere inside
21304:296:   `string1' or just past its end.  This works if PTR is NULL, which is
21305:297:   a good thing.  */
21306:298:#define FIRST_STRING_P(ptr)                                         \
21307:299:  (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)
21308:300:
21309:301:/* (Re)Allocate N items of type T using malloc, or fail.  */
21310:302:#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
21311:303:#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
21312:304:#define RETALLOC_IF(addr, n, t) \
21313:305:  if (addr) RETALLOC((addr), (n), t); else (addr) = TALLOC ((n), t)
21314:306:#define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
21315:307:
21316:308:#define BYTEWIDTH 8             /* In bits.  */
21317:309:
21318:310:#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
21319:311:
21320:312:#undef MAX
21321:313:#undef MIN
21322:314:#define MAX(a, b) ((a) > (b) ? (a) : (b))
21323:315:#define MIN(a, b) ((a) < (b) ? (a) : (b))
21324:316:
21325:317:typedef char boolean;
21326:318:#define false 0
21327:319:#define true 1
21328:320:
21329:321:static int re_match_2_internal ();
21330:322:
21331:323:/* These are the command codes that appear in compiled regular
21332:324:   expressions.  Some opcodes are followed by argument bytes.  A
21333:325:   command code can specify any interpretation whatsoever for its
21334:326:   arguments.  Zero bytes may appear in the compiled regular expression.  */
21335:327:
21336:328:typedef enum {
21337:329:    no_op = 0,
21338:330:
21339:331:    /* Succeed right away--no more backtracking.  */
21340:332:    succeed,
21341:333:
21342:334:    /* Followed by one byte giving n, then by n literal bytes.  */
21343:335:    exactn,
21344:336:
21345:337:    /* Matches any (more or less) character.  */
21346:338:    anychar,
21347:339:
21348:340:    /* Matches any one char belonging to specified set.  First
21349:341:       following byte is number of bitmap bytes.  Then come bytes
21350:342:       for a bitmap saying which chars are in.  Bits in each byte
21351:343:       are ordered low-bit-first.  A character is in the set if its
21352:344:       bit is 1.  A character too large to have a bit in the map is
21353:345:       automatically not in the set.  */
21354:346:    charset,
21355:347:
21356:348:    /* Same parameters as charset, but match any character that is
21357:349:       not one of those specified.  */
21358:350:    charset_not,
21359:351:
21360:352:    /* Start remembering the text that is matched, for storing in a
21361:353:       register.  Followed by one byte with the register number, in
21362:354:       the range 0 to one less than the pattern buffer's re_nsub
21363:355:       field.  Then followed by one byte with the number of groups
21364:356:       inner to this one.  (This last has to be part of the
21365:357:       start_memory only because we need it in the on_failure_jump
21366:358:       of re_match_2.)  */
21367:359:    start_memory,
21368:360:
21369:361:    /* Stop remembering the text that is matched and store it in a
21370:362:       memory register.  Followed by one byte with the register
21371:363:       number, in the range 0 to one less than `re_nsub' in the
21372:364:       pattern buffer, and one byte with the number of inner groups,
21373:365:       just like `start_memory'.  (We need the number of inner
21374:366:       groups here because we don't have any easy way of finding the
21375:367:       corresponding start_memory when we're at a stop_memory.)  */
21376:368:    stop_memory,
21377:369:
21378:370:    /* Match a duplicate of something remembered. Followed by one
21379:371:       byte containing the register number.  */
21380:372:    duplicate,
21381:373:
21382:374:    /* Fail unless at beginning of line.  */
21383:375:    begline,
21384:376:
21385:377:    /* Fail unless at end of line.  */
21386:378:    endline,
21387:379:
21388:380:    /* Succeeds if at beginning of buffer (if emacs) or at beginning
21389:381:       of string to be matched (if not).  */
21390:382:    begbuf,
21391:383:
21392:384:    /* Analogously, for end of buffer/string.  */
21393:385:    endbuf,
21394:386:
21395:387:    /* Followed by two byte relative address to which to jump.  */
21396:388:    jump,
21397:389:
21398:390:    /* Same as jump, but marks the end of an alternative.  */
21399:391:    jump_past_alt,
21400:392:
21401:393:    /* Followed by two-byte relative address of place to resume at
21402:394:       in case of failure.  */
21403:395:    on_failure_jump,
21404:396:
21405:397:    /* Like on_failure_jump, but pushes a placeholder instead of the
21406:398:       current string position when executed.  */
21407:399:    on_failure_keep_string_jump,
21408:400:
21409:401:    /* Throw away latest failure point and then jump to following
21410:402:       two-byte relative address.  */
21411:403:    pop_failure_jump,
21412:404:
21413:405:    /* Change to pop_failure_jump if know won't have to backtrack to
21414:406:       match; otherwise change to jump.  This is used to jump
21415:407:       back to the beginning of a repeat.  If what follows this jump
21416:408:       clearly won't match what the repeat does, such that we can be
21417:409:       sure that there is no use backtracking out of repetitions
21418:410:       already matched, then we change it to a pop_failure_jump.
21419:411:       Followed by two-byte address.  */
21420:412:    maybe_pop_jump,
21421:413:
21422:414:    /* Jump to following two-byte address, and push a dummy failure
21423:415:       point. This failure point will be thrown away if an attempt
21424:416:       is made to use it for a failure.  A `+' construct makes this
21425:417:       before the first repeat.  Also used as an intermediary kind
21426:418:       of jump when compiling an alternative.  */
21427:419:    dummy_failure_jump,
21428:420:
21429:421:    /* Push a dummy failure point and continue.  Used at the end of
21430:422:       alternatives.  */
21431:423:    push_dummy_failure,
21432:424:
21433:425:    /* Followed by two-byte relative address and two-byte number n.
21434:426:       After matching N times, jump to the address upon failure.  */
21435:427:    succeed_n,
21436:428:
21437:429:    /* Followed by two-byte relative address, and two-byte number n.
21438:430:       Jump to the address N times, then fail.  */
21439:431:    jump_n,
21440:432:
21441:433:    /* Set the following two-byte relative address to the
21442:434:       subsequent two-byte number.  The address *includes* the two
21443:435:       bytes of number.  */
21444:436:    set_number_at,
21445:437:
21446:438:    wordchar,                   /* Matches any word-constituent character.  */
21447:439:    notwordchar,                /* Matches any char that is not a word-constituent.  */
21448:440:
21449:441:    wordbeg,                    /* Succeeds if at word beginning.  */
21450:442:    wordend,                    /* Succeeds if at word end.  */
21451:443:
21452:444:    wordbound,                  /* Succeeds if at a word boundary.  */
21453:445:    notwordbound                /* Succeeds if not at a word boundary.  */
21454:446:#ifdef emacs
21455:447:        , before_dot,           /* Succeeds if before point.  */
21456:448:    at_dot,                     /* Succeeds if at point.  */
21457:449:    after_dot,                  /* Succeeds if after point.  */
21458:450:
21459:451:    /* Matches any character whose syntax is specified.  Followed by
21460:452:       a byte which contains a syntax code, e.g., Sword.  */
21461:453:    syntaxspec,
21462:454:
21463:455:    /* Matches any character whose syntax is not that specified.  */
21464:456:    notsyntaxspec
21465:457:#endif                          /* emacs */
21466:458:} re_opcode_t;
21467:459:
21468:460:/* Common operations on the compiled pattern.  */
21469:461:
21470:462:/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
21471:463:
21472:464:#define STORE_NUMBER(destination, number)                                \
21473:465:  do {                                                                        \
21474:466:    (destination)[0] = (number) & 0377;                                        \
21475:467:    (destination)[1] = (number) >> 8;                                        \
21476:468:  } while (0)
21477:469:
21478:470:/* Same as STORE_NUMBER, except increment DESTINATION to
21479:471:   the byte after where the number is stored.  Therefore, DESTINATION
21480:472:   must be an lvalue.  */
21481:473:
21482:474:#define STORE_NUMBER_AND_INCR(destination, number)                        \
21483:475:  do {                                                                        \
21484:476:    STORE_NUMBER (destination, number);                                        \
21485:477:    (destination) += 2;                                                        \
21486:478:  } while (0)
21487:479:
21488:480:/* Put into DESTINATION a number stored in two contiguous bytes starting
21489:481:   at SOURCE.  */
21490:482:
21491:483:#define EXTRACT_NUMBER(destination, source)                                \
21492:484:  do {                                                                        \
21493:485:    (destination) = *(source) & 0377;                                        \
21494:486:    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;                \
21495:487:  } while (0)
21496:488:
21497:489:#ifdef DEBUG
21498:490:static void extract_number (dest, source)
21499:491:int *dest;
21500:492:unsigned char *source;
21501:493:{
21502:494:    int temp = SIGN_EXTEND_CHAR (*(source + 1));
21503:495:    *dest = *source & 0377;
21504:496:    *dest += temp << 8;
21505:497:}
21506:498:
21507:499:#ifndef EXTRACT_MACROS          /* To debug the macros.  */
21508:500:#undef EXTRACT_NUMBER
21509:501:#define EXTRACT_NUMBER(dest, src) extract_number (&dest, src)
21510:502:#endif                          /* not EXTRACT_MACROS */
21511:503:
21512:504:#endif                          /* DEBUG */
21513:505:
21514:506:/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.
21515:507:   SOURCE must be an lvalue.  */
21516:508:
21517:509:#define EXTRACT_NUMBER_AND_INCR(destination, source)                        \
21518:510:  do {                                                                        \
21519:511:    EXTRACT_NUMBER (destination, source);                                \
21520:512:    (source) += 2;                                                         \
21521:513:  } while (0)
21522:514:
21523:515:#ifdef DEBUG
21524:516:static void extract_number_and_incr (destination, source)
21525:517:int *destination;
21526:518:unsigned char **source;
21527:519:{
21528:520:    extract_number (destination, *source);
21529:521:    *source += 2;
21530:522:}
21531:523:
21532:524:#ifndef EXTRACT_MACROS
21533:525:#undef EXTRACT_NUMBER_AND_INCR
21534:526:#define EXTRACT_NUMBER_AND_INCR(dest, src) \
21535:527:  extract_number_and_incr (&dest, &src)
21536:528:#endif                          /* not EXTRACT_MACROS */
21537:529:
21538:530:#endif                          /* DEBUG */
21539:531:
21540:532:/* If DEBUG is defined, Regex prints many voluminous messages about what
21541:533:   it is doing (if the variable `debug' is nonzero).  If linked with the
21542:534:   main program in `iregex.c', you can enter patterns and strings
21543:535:   interactively.  And if linked with the main program in `main.c' and
21544:536:   the other test files, you can run the already-written tests.  */
21545:537:
21546:538:#ifdef DEBUG
21547:539:
21548:540:/* We use standard I/O for debugging.  */
21549:541:#include <stdio.h>
21550:542:
21551:543:/* It is useful to test things that ``must'' be true when debugging.  */
21552:544:#include <assert.h>
21553:545:
21554:546:static int debug = 0;
21555:547:
21556:548:#define DEBUG_STATEMENT(e) e
21557:549:#define DEBUG_PRINT1(x) if (debug) printf (x)
21558:550:#define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
21559:551:#define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
21560:552:#define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
21561:553:#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)                                 \
21562:554:  if (debug) print_partial_compiled_pattern (s, e)
21563:555:#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)                        \
21564:556:  if (debug) print_double_string (w, s1, sz1, s2, sz2)
21565:557:
21566:558:
21567:559:/* Print the fastmap in human-readable form.  */
21568:560:
21569:561:void print_fastmap (fastmap)
21570:562:char *fastmap;
21571:563:{
21572:564:    unsigned was_a_range = 0;
21573:565:    unsigned i = 0;
21574:566:
21575:567:    while (i < (1 << BYTEWIDTH)) {
21576:568:        if (fastmap[i++]) {
21577:569:            was_a_range = 0;
21578:570:            putchar (i - 1);
21579:571:            while (i < (1 << BYTEWIDTH) && fastmap[i]) {
21580:572:                was_a_range = 1;
21581:573:                i++;
21582:574:            }
21583:575:            if (was_a_range) {
21584:576:                printf ("-");
21585:577:                putchar (i - 1);
21586:578:            }
21587:579:        }
21588:580:    }
21589:581:    putchar ('\n');
21590:582:}
21591:583:
21592:584:
21593:585:/* Print a compiled pattern string in human-readable form, starting at
21594:586:   the START pointer into it and ending just before the pointer END.  */
21595:587:
21596:588:void print_partial_compiled_pattern (start, end)
21597:589:unsigned char *start;
21598:590:unsigned char *end;
21599:591:{
21600:592:    int mcnt, mcnt2;
21601:593:    unsigned char *p = start;
21602:594:    unsigned char *pend = end;
21603:595:
21604:596:    if (start == NULL) {
21605:597:        printf ("(null)\n");
21606:598:        return;
21607:599:    }
21608:600:
21609:601:    /* Loop over pattern commands.  */
21610:602:    while (p < pend) {
21611:603:        printf ("%d:\t", p - start);
21612:604:
21613:605:        switch ((re_opcode_t) * p++) {
21614:606:        case no_op:
21615:607:            printf ("/no_op");
21616:608:            break;
21617:609:
21618:610:        case exactn:
21619:611:            mcnt = *p++;
21620:612:            printf ("/exactn/%d", mcnt);
21621:613:            do {
21622:614:                putchar ('/');
21623:615:                putchar (*p++);
21624:616:            }
21625:617:            while (--mcnt);
21626:618:            break;
21627:619:
21628:620:        case start_memory:
21629:621:            mcnt = *p++;
21630:622:            printf ("/start_memory/%d/%d", mcnt, *p++);
21631:623:            break;
21632:624:
21633:625:        case stop_memory:
21634:626:            mcnt = *p++;
21635:627:            printf ("/stop_memory/%d/%d", mcnt, *p++);
21636:628:            break;
21637:629:
21638:630:        case duplicate:
21639:631:            printf ("/duplicate/%d", *p++);
21640:632:            break;
21641:633:
21642:634:        case anychar:
21643:635:            printf ("/anychar");
21644:636:            break;
21645:637:
21646:638:        case charset:
21647:639:        case charset_not:
21648:640:            {
21649:641:                register int c, last = -100;
21650:642:                register int in_range = 0;
21651:643:
21652:644:                printf ("/charset [%s",
21653:645:                        (re_opcode_t) * (p - 1) == charset_not ? "^" : "");
21654:646:
21655:647:                assert (p + *p < pend);
21656:648:
21657:649:                for (c = 0; c < 256; c++)
21658:650:                    if (c / 8 < *p && (p[1 + (c / 8)] & (1 << (c % 8)))) {
21659:651:                        /* Are we starting a range?  */
21660:652:                        if (last + 1 == c && !in_range) {
21661:653:                            putchar ('-');
21662:654:                            in_range = 1;
21663:655:                        }
21664:656:                        /* Have we broken a range?  */
21665:657:                        else if (last + 1 != c && in_range) {
21666:658:                            putchar (last);
21667:659:                            in_range = 0;
21668:660:                        }
21669:661:
21670:662:                        if (!in_range)
21671:663:                            putchar (c);
21672:664:
21673:665:                        last = c;
21674:666:                    }
21675:667:
21676:668:                if (in_range)
21677:669:                    putchar (last);
21678:670:
21679:671:                putchar (']');
21680:672:
21681:673:                p += 1 + *p;
21682:674:            }
21683:675:            break;
21684:676:
21685:677:        case begline:
21686:678:            printf ("/begline");
21687:679:            break;
21688:680:
21689:681:        case endline:
21690:682:            printf ("/endline");
21691:683:            break;
21692:684:
21693:685:        case on_failure_jump:
21694:686:            extract_number_and_incr (&mcnt, &p);
21695:687:            printf ("/on_failure_jump to %d", p + mcnt - start);
21696:688:            break;
21697:689:
21698:690:        case on_failure_keep_string_jump:
21699:691:            extract_number_and_incr (&mcnt, &p);
21700:692:            printf ("/on_failure_keep_string_jump to %d",
21701:693:                    p + mcnt - start);
21702:694:            break;
21703:695:
21704:696:        case dummy_failure_jump:
21705:697:            extract_number_and_incr (&mcnt, &p);
21706:698:            printf ("/dummy_failure_jump to %d", p + mcnt - start);
21707:699:            break;
21708:700:
21709:701:        case push_dummy_failure:
21710:702:            printf ("/push_dummy_failure");
21711:703:            break;
21712:704:
21713:705:        case maybe_pop_jump:
21714:706:            extract_number_and_incr (&mcnt, &p);
21715:707:            printf ("/maybe_pop_jump to %d", p + mcnt - start);
21716:708:            break;
21717:709:
21718:710:        case pop_failure_jump:
21719:711:            extract_number_and_incr (&mcnt, &p);
21720:712:            printf ("/pop_failure_jump to %d", p + mcnt - start);
21721:713:            break;
21722:714:
21723:715:        case jump_past_alt:
21724:716:            extract_number_and_incr (&mcnt, &p);
21725:717:            printf ("/jump_past_alt to %d", p + mcnt - start);
21726:718:            break;
21727:719:
21728:720:        case jump:
21729:721:            extract_number_and_incr (&mcnt, &p);
21730:722:            printf ("/jump to %d", p + mcnt - start);
21731:723:            break;
21732:724:
21733:725:        case succeed_n:
21734:726:            extract_number_and_incr (&mcnt, &p);
21735:727:            extract_number_and_incr (&mcnt2, &p);
21736:728:            printf ("/succeed_n to %d, %d times", p + mcnt - start, mcnt2);
21737:729:            break;
21738:730:
21739:731:        case jump_n:
21740:732:            extract_number_and_incr (&mcnt, &p);
21741:733:            extract_number_and_incr (&mcnt2, &p);
21742:734:            printf ("/jump_n to %d, %d times", p + mcnt - start, mcnt2);
21743:735:            break;
21744:736:
21745:737:        case set_number_at:
21746:738:            extract_number_and_incr (&mcnt, &p);
21747:739:            extract_number_and_incr (&mcnt2, &p);
21748:740:            printf ("/set_number_at location %d to %d", p + mcnt - start,
21749:741:                    mcnt2);
21750:742:            break;
21751:743:
21752:744:        case wordbound:
21753:745:            printf ("/wordbound");
21754:746:            break;
21755:747:
21756:748:        case notwordbound:
21757:749:            printf ("/notwordbound");
21758:750:            break;
21759:751:
21760:752:        case wordbeg:
21761:753:            printf ("/wordbeg");
21762:754:            break;
21763:755:
21764:756:        case wordend:
21765:757:            printf ("/wordend");
21766:758:
21767:759:#ifdef emacs
21768:760:        case before_dot:
21769:761:            printf ("/before_dot");
21770:762:            break;
21771:763:
21772:764:        case at_dot:
21773:765:            printf ("/at_dot");
21774:766:            break;
21775:767:
21776:768:        case after_dot:
21777:769:            printf ("/after_dot");
21778:770:            break;
21779:771:
21780:772:        case syntaxspec:
21781:773:            printf ("/syntaxspec");
21782:774:            mcnt = *p++;
21783:775:            printf ("/%d", mcnt);
21784:776:            break;
21785:777:
21786:778:        case notsyntaxspec:
21787:779:            printf ("/notsyntaxspec");
21788:780:            mcnt = *p++;
21789:781:            printf ("/%d", mcnt);
21790:782:            break;
21791:783:#endif                          /* emacs */
21792:784:
21793:785:        case wordchar:
21794:786:            printf ("/wordchar");
21795:787:            break;
21796:788:
21797:789:        case notwordchar:
21798:790:            printf ("/notwordchar");
21799:791:            break;
21800:792:
21801:793:        case begbuf:
21802:794:            printf ("/begbuf");
21803:795:            break;
21804:796:
21805:797:        case endbuf:
21806:798:            printf ("/endbuf");
21807:799:            break;
21808:800:
21809:801:        default:
21810:802:            printf ("?%d", *(p - 1));
21811:803:        }
21812:804:
21813:805:        putchar ('\n');
21814:806:    }
21815:807:
21816:808:    printf ("%d:\tend of pattern.\n", p - start);
21817:809:}
21818:810:
21819:811:
21820:812:void print_compiled_pattern (bufp)
21821:813:struct re_pattern_buffer *bufp;
21822:814:{
21823:815:    unsigned char *buffer = bufp->buffer;
21824:816:
21825:817:    print_partial_compiled_pattern (buffer, buffer + bufp->used);
21826:818:    printf ("%d bytes used/%d bytes allocated.\n", bufp->used,
21827:819:            bufp->allocated);
21828:820:
21829:821:    if (bufp->fastmap_accurate && bufp->fastmap) {
21830:822:        printf ("fastmap: ");
21831:823:        print_fastmap (bufp->fastmap);
21832:824:    }
21833:825:
21834:826:    printf ("re_nsub: %d\t", bufp->re_nsub);
21835:827:    printf ("regs_alloc: %d\t", bufp->regs_allocated);
21836:828:    printf ("can_be_null: %d\t", bufp->can_be_null);
21837:829:    printf ("newline_anchor: %d\n", bufp->newline_anchor);
21838:830:    printf ("no_sub: %d\t", bufp->no_sub);
21839:831:    printf ("not_bol: %d\t", bufp->not_bol);
21840:832:    printf ("not_eol: %d\t", bufp->not_eol);
21841:833:    printf ("syntax: %d\n", bufp->syntax);
21842:834:    /* Perhaps we should print the translate table?  */
21843:835:}
21844:836:
21845:837:
21846:838:void print_double_string (where, string1, size1, string2, size2)
21847:839:const char *where;
21848:840:const char *string1;
21849:841:const char *string2;
21850:842:int size1;
21851:843:int size2;
21852:844:{
21853:845:    unsigned this_char;
21854:846:
21855:847:    if (where == NULL)
21856:848:        printf ("(null)");
21857:849:    else {
21858:850:        if (FIRST_STRING_P (where)) {
21859:851:            for (this_char = where - string1; this_char < size1;
21860:852:                 this_char++)
21861:853:                putchar (string1[this_char]);
21862:854:
21863:855:            where = string2;
21864:856:        }
21865:857:
21866:858:        for (this_char = where - string2; this_char < size2; this_char++)
21867:859:            putchar (string2[this_char]);
21868:860:    }
21869:861:}
21870:862:
21871:863:#else                           /* not DEBUG */
21872:864:
21873:865:#undef assert
21874:866:#define assert(e)
21875:867:
21876:868:#define DEBUG_STATEMENT(e)
21877:869:#define DEBUG_PRINT1(x)
21878:870:#define DEBUG_PRINT2(x1, x2)
21879:871:#define DEBUG_PRINT3(x1, x2, x3)
21880:872:#define DEBUG_PRINT4(x1, x2, x3, x4)
21881:873:#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)
21882:874:#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
21883:875:
21884:876:#endif                          /* not DEBUG */
21885:877:
21886:878:/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can
21887:879:   also be assigned to arbitrarily: each pattern buffer stores its own
21888:880:   syntax, so it can be changed between regex compilations.  */
21889:881:/* This has no initializer because initialized variables in Emacs
21890:882:   become read-only after dumping.  */
21891:883:reg_syntax_t re_syntax_options;
21892:884:
21893:885:
21894:886:/* Specify the precise syntax of regexps for compilation.  This provides
21895:887:   for compatibility for various utilities which historically have
21896:888:   different, incompatible syntaxes.
21897:889:
21898:890:   The argument SYNTAX is a bit mask comprised of the various bits
21899:891:   defined in regex.h.  We return the old syntax.  */
21900:892:
21901:893:reg_syntax_t re_set_syntax (syntax)
21902:894:reg_syntax_t syntax;
21903:895:{
21904:896:    reg_syntax_t ret = re_syntax_options;
21905:897:
21906:898:    re_syntax_options = syntax;
21907:899:    return ret;
21908:900:}
21909:901:
21910:902:/* This table gives an error message for each of the error codes listed
21911:903:   in regex.h.  Obviously the order here has to be same as there.
21912:904:   POSIX doesn't require that we do anything for REG_NOERROR,
21913:905:   but why not be nice?  */
21914:906:
21915:907:static const char *re_error_msgid[] = { "Success", /* REG_NOERROR */
21916:908:    "No match",                 /* REG_NOMATCH */
21917:909:    "Invalid regular expression", /* REG_BADPAT */
21918:910:    "Invalid collation character", /* REG_ECOLLATE */
21919:911:    "Invalid character class name", /* REG_ECTYPE */
21920:912:    "Trailing backslash",       /* REG_EESCAPE */
21921:913:    "Invalid back reference",   /* REG_ESUBREG */
21922:914:    "Unmatched [ or [^",        /* REG_EBRACK */
21923:915:    "Unmatched ( or \\(",       /* REG_EPAREN */
21924:916:    "Unmatched \\{",            /* REG_EBRACE */
21925:917:    "Invalid content of \\{\\}", /* REG_BADBR */
21926:918:    "Invalid range end",        /* REG_ERANGE */
21927:919:    "Memory exhausted",         /* REG_ESPACE */
21928:920:    "Invalid preceding regular expression", /* REG_BADRPT */
21929:921:    "Premature end of regular expression", /* REG_EEND */
21930:922:    "Regular expression too big", /* REG_ESIZE */
21931:923:    "Unmatched ) or \\)",       /* REG_ERPAREN */
21932:924:};
21933:925:
21934:926:/* Avoiding alloca during matching, to placate r_alloc.  */
21935:927:
21936:928:/* Define MATCH_MAY_ALLOCATE unless we need to make sure that the
21937:929:   searching and matching functions should not call alloca.  On some
21938:930:   systems, alloca is implemented in terms of malloc, and if we're
21939:931:   using the relocating allocator routines, then malloc could cause a
21940:932:   relocation, which might (if the strings being searched are in the
21941:933:   ralloc heap) shift the data out from underneath the regexp
21942:934:   routines.
21943:935:
21944:936:   Here's another reason to avoid allocation: Emacs 
21945:937:   processes input from X in a signal handler; processing X input may
21946:938:   call malloc; if input arrives while a matching routine is calling
21947:939:   malloc, then we're scrod.  But Emacs can't just block input while
21948:940:   calling matching routines; then we don't notice interrupts when
21949:941:   they come in.  So, Emacs blocks input around all regexp calls
21950:942:   except the matching calls, which it leaves unprotected, in the
21951:943:   faith that they will not malloc.  */
21952:944:
21953:945:/* Normally, this is fine.  */
21954:946:#define MATCH_MAY_ALLOCATE
21955:947:
21956:948:/* When using GNU C, we are not REALLY using the C alloca, no matter
21957:949:   what config.h may say.  So don't take precautions for it.  */
21958:950:#ifdef __GNUC__
21959:951:#undef C_ALLOCA
21960:952:#endif
21961:953:
21962:954:/* The match routines may not allocate if (1) they would do it with malloc
21963:955:   and (2) it's not safe for them to use malloc.
21964:956:   Note that if REL_ALLOC is defined, matching would not use malloc for the
21965:957:   failure stack, but we would still use it for the register vectors;
21966:958:   so REL_ALLOC should not affect this.  */
21967:959:#if (defined (C_ALLOCA) || defined (REGEX_MALLOC)) && defined (emacs)
21968:960:#undef MATCH_MAY_ALLOCATE
21969:961:#endif
21970:962:
21971:963:
21972:964:/* Failure stack declarations and macros; both re_compile_fastmap and
21973:965:   re_match_2 use a failure stack.  These have to be macros because of
21974:966:   REGEX_ALLOCATE_STACK.  */
21975:967:
21976:968:
21977:969:/* Number of failure points for which to initially allocate space
21978:970:   when matching.  If this number is exceeded, we allocate more
21979:971:   space, so it is not a hard limit.  */
21980:972:#ifndef INIT_FAILURE_ALLOC
21981:973:#define INIT_FAILURE_ALLOC 5
21982:974:#endif
21983:975:
21984:976:/* Roughly the maximum number of failure points on the stack.  Would be
21985:977:   exactly that if always used MAX_FAILURE_SPACE each time we failed.
21986:978:   This is a variable only so users of regex can assign to it; we never
21987:979:   change it ourselves.  */
21988:980:#if defined (MATCH_MAY_ALLOCATE)
21989:981:int re_max_failures = 200000;
21990:982:#else
21991:983:int re_max_failures = 2000;
21992:984:#endif
21993:985:
21994:986:union fail_stack_elt {
21995:987:    unsigned char *pointer;
21996:988:    int integer;
21997:989:};
21998:990:
21999:991:typedef union fail_stack_elt fail_stack_elt_t;
22000:992:
22001:993:typedef struct {
22002:994:    fail_stack_elt_t *stack;
22003:995:    unsigned size;
22004:996:    unsigned avail;             /* Offset of next open position.  */
22005:997:} fail_stack_type;
22006:998:
22007:999:#define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
22008:1000:#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
22009:1001:#define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)
22010:1002:
22011:1003:
22012:1004:/* Define macros to initialize and free the failure stack.
22013:1005:   Do `return -2' if the alloc fails.  */
22014:1006:
22015:1007:#ifdef MATCH_MAY_ALLOCATE
22016:1008:#define INIT_FAIL_STACK()                                                \
22017:1009:  do {                                                                        \
22018:1010:    fail_stack.stack = (fail_stack_elt_t *)                                \
22019:1011:      REGEX_ALLOCATE_STACK (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));        \
22020:1012:                                                                        \
22021:1013:    if (fail_stack.stack == NULL)                                        \
22022:1014:      return -2;                                                        \
22023:1015:                                                                        \
22024:1016:    fail_stack.size = INIT_FAILURE_ALLOC;                                \
22025:1017:    fail_stack.avail = 0;                                                \
22026:1018:  } while (0)
22027:1019:
22028:1020:#define RESET_FAIL_STACK()  REGEX_FREE_STACK (fail_stack.stack)
22029:1021:#else
22030:1022:#define INIT_FAIL_STACK()                                                \
22031:1023:  do {                                                                        \
22032:1024:    fail_stack.avail = 0;                                                \
22033:1025:  } while (0)
22034:1026:
22035:1027:#define RESET_FAIL_STACK()
22036:1028:#endif
22037:1029:
22038:1030:
22039:1031:/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.
22040:1032:
22041:1033:   Return 1 if succeeds, and 0 if either ran out of memory
22042:1034:   allocating space for it or it was already too large.  
22043:1035:   
22044:1036:   REGEX_REALLOCATE_STACK requires `destination' be declared.   */
22045:1037:
22046:1038:#define DOUBLE_FAIL_STACK(fail_stack)                                        \
22047:1039:  ((fail_stack).size > re_max_failures * MAX_FAILURE_ITEMS                \
22048:1040:   ? 0                                                                        \
22049:1041:   : ((fail_stack).stack = (fail_stack_elt_t *)                                \
22050:1042:        REGEX_REALLOCATE_STACK ((fail_stack).stack,                         \
22051:1043:          (fail_stack).size * sizeof (fail_stack_elt_t),                \
22052:1044:          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),        \
22053:1045:                                                                        \
22054:1046:      (fail_stack).stack == NULL                                        \
22055:1047:      ? 0                                                                \
22056:1048:      : ((fail_stack).size <<= 1,                                         \
22057:1049:         1)))
22058:1050:
22059:1051:
22060:1052:/* Push pointer POINTER on FAIL_STACK. 
22061:1053:   Return 1 if was able to do so and 0 if ran out of memory allocating
22062:1054:   space to do so.  */
22063:1055:#define PUSH_PATTERN_OP(POINTER, FAIL_STACK)                                \
22064:1056:  ((FAIL_STACK_FULL ()                                                        \
22065:1057:    && !DOUBLE_FAIL_STACK (FAIL_STACK))                                        \
22066:1058:   ? 0                                                                        \
22067:1059:   : ((FAIL_STACK).stack[(FAIL_STACK).avail++].pointer = POINTER,        \
22068:1060:      1))
22069:1061:
22070:1062:/* Push a pointer value onto the failure stack.
22071:1063:   Assumes the variable `fail_stack'.  Probably should only
22072:1064:   be called from within `PUSH_FAILURE_POINT'.  */
22073:1065:#define PUSH_FAILURE_POINTER(item)                                        \
22074:1066:  fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (item)
22075:1067:
22076:1068:/* This pushes an integer-valued item onto the failure stack.
22077:1069:   Assumes the variable `fail_stack'.  Probably should only
22078:1070:   be called from within `PUSH_FAILURE_POINT'.  */
22079:1071:#define PUSH_FAILURE_INT(item)                                        \
22080:1072:  fail_stack.stack[fail_stack.avail++].integer = (item)
22081:1073:
22082:1074:/* Push a fail_stack_elt_t value onto the failure stack.
22083:1075:   Assumes the variable `fail_stack'.  Probably should only
22084:1076:   be called from within `PUSH_FAILURE_POINT'.  */
22085:1077:#define PUSH_FAILURE_ELT(item)                                        \
22086:1078:  fail_stack.stack[fail_stack.avail++] =  (item)
22087:1079:
22088:1080:/* These three POP... operations complement the three PUSH... operations.
22089:1081:   All assume that `fail_stack' is nonempty.  */
22090:1082:#define POP_FAILURE_POINTER() fail_stack.stack[--fail_stack.avail].pointer
22091:1083:#define POP_FAILURE_INT() fail_stack.stack[--fail_stack.avail].integer
22092:1084:#define POP_FAILURE_ELT() fail_stack.stack[--fail_stack.avail]
22093:1085:
22094:1086:/* Used to omit pushing failure point id's when we're not debugging.  */
22095:1087:#ifdef DEBUG
22096:1088:#define DEBUG_PUSH PUSH_FAILURE_INT
22097:1089:#define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_INT ()
22098:1090:#else
22099:1091:#define DEBUG_PUSH(item)
22100:1092:#define DEBUG_POP(item_addr)
22101:1093:#endif
22102:1094:
22103:1095:/* prevents a warning: unused variable 'destination': */
22104:1096:#ifdef REGEX_MALLOC
22105:1097:#define DEFINE_DESTINATION
22106:1098:#else
22107:1099:#define DEFINE_DESTINATION char *destination;
22108:1100:#endif
22109:1101:
22110:1102:/* Push the information about the state we will need
22111:1103:   if we ever fail back to it.  
22112:1104:   
22113:1105:   Requires variables fail_stack, regstart, regend, reg_info, and
22114:1106:   num_regs be declared.  DOUBLE_FAIL_STACK requires `destination' be
22115:1107:   declared.
22116:1108:   
22117:1109:   Does `return FAILURE_CODE' if runs out of memory.  */
22118:1110:
22119:1111:#define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)        \
22120:1112:  do {                                                                        \
22121:1113:    /* Must be int, so when we don't save any registers, the arithmetic        \
22122:1114:       of 0 + -1 isn't done as unsigned.  */                                \
22123:1115:    int this_reg;                                                        \
22124:1116:    DEFINE_DESTINATION                                                        \
22125:1117:                                                                            \
22126:1118:    DEBUG_STATEMENT (failure_id++);                                        \
22127:1119:    DEBUG_STATEMENT (nfailure_points_pushed++);                                \
22128:1120:    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);                \
22129:1121:    DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
22130:1122:    DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
22131:1123:                                                                        \
22132:1124:    DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);                \
22133:1125:    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);        \
22134:1126:                                                                        \
22135:1127:    /* Ensure we have enough space allocated for what we will push.  */        \
22136:1128:    while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)                        \
22137:1129:      {                                                                        \
22138:1130:        if (!DOUBLE_FAIL_STACK (fail_stack))                                \
22139:1131:          return failure_code;                                                \
22140:1132:                                                                        \
22141:1133:        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",                \
22142:1134:                       (fail_stack).size);                                \
22143:1135:        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
22144:1136:      }                                                                        \
22145:1137:                                                                        \
22146:1138:    /* Push the info, starting with the registers.  */                        \
22147:1139:    DEBUG_PRINT1 ("\n");                                                \
22148:1140:                                                                        \
22149:1141:    for (this_reg = lowest_active_reg; this_reg <= highest_active_reg;        \
22150:1142:         this_reg++)                                                        \
22151:1143:      {                                                                        \
22152:1144:        DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);                        \
22153:1145:        DEBUG_STATEMENT (num_regs_pushed++);                                \
22154:1146:                                                                        \
22155:1147:        DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);                \
22156:1148:        PUSH_FAILURE_POINTER (regstart[this_reg]);                        \
22157:1149:                                                                        \
22158:1150:        DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);                \
22159:1151:        PUSH_FAILURE_POINTER (regend[this_reg]);                        \
22160:1152:                                                                        \
22161:1153:        DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);        \
22162:1154:        DEBUG_PRINT2 (" match_null=%d",                                        \
22163:1155:                      REG_MATCH_NULL_STRING_P (reg_info[this_reg]));        \
22164:1156:        DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));        \
22165:1157:        DEBUG_PRINT2 (" matched_something=%d",                                \
22166:1158:                      MATCHED_SOMETHING (reg_info[this_reg]));                \
22167:1159:        DEBUG_PRINT2 (" ever_matched=%d",                                \
22168:1160:                      EVER_MATCHED_SOMETHING (reg_info[this_reg]));        \
22169:1161:        DEBUG_PRINT1 ("\n");                                                \
22170:1162:        PUSH_FAILURE_ELT (reg_info[this_reg].word);                        \
22171:1163:      }                                                                        \
22172:1164:                                                                        \
22173:1165:    DEBUG_PRINT2 ("  Pushing  low active reg: %d\n", lowest_active_reg);\
22174:1166:    PUSH_FAILURE_INT (lowest_active_reg);                                \
22175:1167:                                                                        \
22176:1168:    DEBUG_PRINT2 ("  Pushing high active reg: %d\n", highest_active_reg);\
22177:1169:    PUSH_FAILURE_INT (highest_active_reg);                                \
22178:1170:                                                                        \
22179:1171:    DEBUG_PRINT2 ("  Pushing pattern 0x%x: ", pattern_place);                \
22180:1172:    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);                \
22181:1173:    PUSH_FAILURE_POINTER (pattern_place);                                \
22182:1174:                                                                        \
22183:1175:    DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);                \
22184:1176:    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
22185:1177:                                 size2);                                \
22186:1178:    DEBUG_PRINT1 ("'\n");                                                \
22187:1179:    PUSH_FAILURE_POINTER (string_place);                                \
22188:1180:                                                                        \
22189:1181:    DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);                \
22190:1182:    DEBUG_PUSH (failure_id);                                                \
22191:1183:  } while (0)
22192:1184:
22193:1185:/* This is the number of items that are pushed and popped on the stack
22194:1186:   for each register.  */
22195:1187:#define NUM_REG_ITEMS  3
22196:1188:
22197:1189:/* Individual items aside from the registers.  */
22198:1190:#ifdef DEBUG
22199:1191:#define NUM_NONREG_ITEMS 5      /* Includes failure point id.  */
22200:1192:#else
22201:1193:#define NUM_NONREG_ITEMS 4
22202:1194:#endif
22203:1195:
22204:1196:/* We push at most this many items on the stack.  */
22205:1197:#define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
22206:1198:
22207:1199:/* We actually push this many items.  */
22208:1200:#define NUM_FAILURE_ITEMS                                                \
22209:1201:  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS         \
22210:1202:    + NUM_NONREG_ITEMS)
22211:1203:
22212:1204:/* How many items can still be added to the stack without overflowing it.  */
22213:1205:#define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
22214:1206:
22215:1207:
22216:1208:/* Pops what PUSH_FAIL_STACK pushes.
22217:1209:
22218:1210:   We restore into the parameters, all of which should be lvalues:
22219:1211:     STR -- the saved data position.
22220:1212:     PAT -- the saved pattern position.
22221:1213:     LOW_REG, HIGH_REG -- the highest and lowest active registers.
22222:1214:     REGSTART, REGEND -- arrays of string positions.
22223:1215:     REG_INFO -- array of information about each subexpression.
22224:1216:   
22225:1217:   Also assumes the variables `fail_stack' and (if debugging), `bufp',
22226:1218:   `pend', `string1', `size1', `string2', and `size2'.  */
22227:1219:
22228:1220:#define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
22229:1221:{                                                                        \
22230:1222:  DEBUG_STATEMENT (fail_stack_elt_t failure_id;)                        \
22231:1223:  int this_reg;                                                                \
22232:1224:  const unsigned char *string_temp;                                        \
22233:1225:                                                                        \
22234:1226:  assert (!FAIL_STACK_EMPTY ());                                        \
22235:1227:                                                                        \
22236:1228:  /* Remove failure points and point to how many regs pushed.  */        \
22237:1229:  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");                                \
22238:1230:  DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);        \
22239:1231:  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);        \
22240:1232:                                                                        \
22241:1233:  assert (fail_stack.avail >= NUM_NONREG_ITEMS);                        \
22242:1234:                                                                        \
22243:1235:  DEBUG_POP (&failure_id);                                                \
22244:1236:  DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);                \
22245:1237:                                                                        \
22246:1238:  /* If the saved string location is NULL, it came from an                \
22247:1239:     on_failure_keep_string_jump opcode, and we want to throw away the        \
22248:1240:     saved NULL, thus retaining our current position in the string.  */        \
22249:1241:  string_temp = POP_FAILURE_POINTER ();                                        \
22250:1242:  if (string_temp != NULL)                                                \
22251:1243:    str = (const char *) string_temp;                                        \
22252:1244:                                                                        \
22253:1245:  DEBUG_PRINT2 ("  Popping string 0x%x: `", str);                        \
22254:1246:  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);        \
22255:1247:  DEBUG_PRINT1 ("'\n");                                                        \
22256:1248:                                                                        \
22257:1249:  pat = (unsigned char *) POP_FAILURE_POINTER ();                        \
22258:1250:  DEBUG_PRINT2 ("  Popping pattern 0x%x: ", pat);                        \
22259:1251:  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);                        \
22260:1252:                                                                        \
22261:1253:  /* Restore register info.  */                                                \
22262:1254:  high_reg = (unsigned) POP_FAILURE_INT ();                                \
22263:1255:  DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);                \
22264:1256:                                                                        \
22265:1257:  low_reg = (unsigned) POP_FAILURE_INT ();                                \
22266:1258:  DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);                \
22267:1259:                                                                        \
22268:1260:  for (this_reg = high_reg; this_reg >= low_reg; this_reg--)                \
22269:1261:    {                                                                        \
22270:1262:      DEBUG_PRINT2 ("    Popping reg: %d\n", this_reg);                        \
22271:1263:                                                                        \
22272:1264:      reg_info[this_reg].word = POP_FAILURE_ELT ();                        \
22273:1265:      DEBUG_PRINT2 ("      info: 0x%x\n", reg_info[this_reg]);                \
22274:1266:                                                                        \
22275:1267:      regend[this_reg] = (const char *) POP_FAILURE_POINTER ();                \
22276:1268:      DEBUG_PRINT2 ("      end: 0x%x\n", regend[this_reg]);                \
22277:1269:                                                                        \
22278:1270:      regstart[this_reg] = (const char *) POP_FAILURE_POINTER ();        \
22279:1271:      DEBUG_PRINT2 ("      start: 0x%x\n", regstart[this_reg]);                \
22280:1272:    }                                                                        \
22281:1273:                                                                        \
22282:1274:  set_regs_matched_done = 0;                                                \
22283:1275:  DEBUG_STATEMENT (nfailure_points_popped++);                                \
22284:1276:}                               /* POP_FAILURE_POINT */
22285:1277:
22286:1278:
22287:1279:
22288:1280:/* Structure for per-register (a.k.a. per-group) information.
22289:1281:   Other register information, such as the
22290:1282:   starting and ending positions (which are addresses), and the list of
22291:1283:   inner groups (which is a bits list) are maintained in separate
22292:1284:   variables.  
22293:1285:   
22294:1286:   We are making a (strictly speaking) nonportable assumption here: that
22295:1287:   the compiler will pack our bit fields into something that fits into
22296:1288:   the type of `word', i.e., is something that fits into one item on the
22297:1289:   failure stack.  */
22298:1290:
22299:1291:typedef union {
22300:1292:    fail_stack_elt_t word;
22301:1293:    struct {
22302:1294:        /* This field is one if this group can match the empty string,
22303:1295:           zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
22304:1296:#define MATCH_NULL_UNSET_VALUE 3
22305:1297:        unsigned match_null_string_p:2;
22306:1298:        unsigned is_active:1;
22307:1299:        unsigned matched_something:1;
22308:1300:        unsigned ever_matched_something:1;
22309:1301:    } bits;
22310:1302:} register_info_type;
22311:1303:
22312:1304:#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
22313:1305:#define IS_ACTIVE(R)  ((R).bits.is_active)
22314:1306:#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
22315:1307:#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
22316:1308:
22317:1309:
22318:1310:/* Call this when have matched a real character; it sets `matched' flags
22319:1311:   for the subexpressions which we are currently inside.  Also records
22320:1312:   that those subexprs have matched.  */
22321:1313:#define SET_REGS_MATCHED()                                                \
22322:1314:  do                                                                        \
22323:1315:    {                                                                        \
22324:1316:      if (!set_regs_matched_done)                                        \
22325:1317:        {                                                                \
22326:1318:          unsigned r;                                                        \
22327:1319:          set_regs_matched_done = 1;                                        \
22328:1320:          for (r = lowest_active_reg; r <= highest_active_reg; r++)        \
22329:1321:            {                                                                \
22330:1322:              MATCHED_SOMETHING (reg_info[r])                                \
22331:1323:                = EVER_MATCHED_SOMETHING (reg_info[r])                        \
22332:1324:                = 1;                                                        \
22333:1325:            }                                                                \
22334:1326:        }                                                                \
22335:1327:    }                                                                        \
22336:1328:  while (0)
22337:1329:
22338:1330:/* Registers are set to a sentinel when they haven't yet matched.  */
22339:1331:static char reg_unset_dummy;
22340:1332:#define REG_UNSET_VALUE (&reg_unset_dummy)
22341:1333:#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)
22342:1334:
22343:1335:/* Subroutine declarations and macros for regex_compile.  */
22344:1336:
22345:1337:static void store_op1 (), store_op2 ();
22346:1338:static void insert_op1 (), insert_op2 ();
22347:1339:static boolean at_begline_loc_p (), at_endline_loc_p ();
22348:1340:static boolean group_in_compile_stack ();
22349:1341:static reg_errcode_t compile_range ();
22350:1342:
22351:1343:/* Fetch the next character in the uncompiled pattern---translating it 
22352:1344:   if necessary.  Also cast from a signed character in the constant
22353:1345:   string passed to us by the user to an unsigned char that we can use
22354:1346:   as an array index (in, e.g., `translate').  */
22355:1347:#define PATFETCH(c)                                                        \
22356:1348:  do {if (p == pend) return REG_EEND;                                        \
22357:1349:    c = (unsigned char) *p++;                                                \
22358:1350:    if (translate) c = translate[c];                                         \
22359:1351:  } while (0)
22360:1352:
22361:1353:/* Fetch the next character in the uncompiled pattern, with no
22362:1354:   translation.  */
22363:1355:#define PATFETCH_RAW(c)                                                        \
22364:1356:  do {if (p == pend) return REG_EEND;                                        \
22365:1357:    c = (unsigned char) *p++;                                                 \
22366:1358:  } while (0)
22367:1359:
22368:1360:/* Go backwards one character in the pattern.  */
22369:1361:#define PATUNFETCH p--
22370:1362:
22371:1363:
22372:1364:/* If `translate' is non-null, return translate[D], else just D.  We
22373:1365:   cast the subscript to translate because some data is declared as
22374:1366:   `char *', to avoid warnings when a string constant is passed.  But
22375:1367:   when we use a character as a subscript we must make it unsigned.  */
22376:1368:#define TRANSLATE(d) (translate ? translate[(unsigned char) (d)] : (d))
22377:1369:
22378:1370:
22379:1371:/* Macros for outputting the compiled pattern into `buffer'.  */
22380:1372:
22381:1373:/* If the buffer isn't allocated when it comes in, use this.  */
22382:1374:#define INIT_BUF_SIZE  32
22383:1375:
22384:1376:/* Make sure we have at least N more bytes of space in buffer.  */
22385:1377:#define GET_BUFFER_SPACE(n)                                                \
22386:1378:    while (b - bufp->buffer + (n) > bufp->allocated)                        \
22387:1379:      EXTEND_BUFFER ()
22388:1380:
22389:1381:/* Make sure we have one more byte of buffer space and then add C to it.  */
22390:1382:#define BUF_PUSH(c)                                                        \
22391:1383:  do {                                                                        \
22392:1384:    GET_BUFFER_SPACE (1);                                                \
22393:1385:    *b++ = (unsigned char) (c);                                                \
22394:1386:  } while (0)
22395:1387:
22396:1388:
22397:1389:/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
22398:1390:#define BUF_PUSH_2(c1, c2)                                                \
22399:1391:  do {                                                                        \
22400:1392:    GET_BUFFER_SPACE (2);                                                \
22401:1393:    *b++ = (unsigned char) (c1);                                        \
22402:1394:    *b++ = (unsigned char) (c2);                                        \
22403:1395:  } while (0)
22404:1396:
22405:1397:
22406:1398:/* As with BUF_PUSH_2, except for three bytes.  */
22407:1399:#define BUF_PUSH_3(c1, c2, c3)                                                \
22408:1400:  do {                                                                        \
22409:1401:    GET_BUFFER_SPACE (3);                                                \
22410:1402:    *b++ = (unsigned char) (c1);                                        \
22411:1403:    *b++ = (unsigned char) (c2);                                        \
22412:1404:    *b++ = (unsigned char) (c3);                                        \
22413:1405:  } while (0)
22414:1406:
22415:1407:
22416:1408:/* Store a jump with opcode OP at LOC to location TO.  We store a
22417:1409:   relative address offset by the three bytes the jump itself occupies.  */
22418:1410:#define STORE_JUMP(op, loc, to) \
22419:1411:  store_op1 (op, loc, (to) - (loc) - 3)
22420:1412:
22421:1413:/* Likewise, for a two-argument jump.  */
22422:1414:#define STORE_JUMP2(op, loc, to, arg) \
22423:1415:  store_op2 (op, loc, (to) - (loc) - 3, arg)
22424:1416:
22425:1417:/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
22426:1418:#define INSERT_JUMP(op, loc, to) \
22427:1419:  insert_op1 (op, loc, (to) - (loc) - 3, b)
22428:1420:
22429:1421:/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
22430:1422:#define INSERT_JUMP2(op, loc, to, arg) \
22431:1423:  insert_op2 (op, loc, (to) - (loc) - 3, arg, b)
22432:1424:
22433:1425:
22434:1426:/* This is not an arbitrary limit: the arguments which represent offsets
22435:1427:   into the pattern are two bytes long.  So if 2^16 bytes turns out to
22436:1428:   be too small, many things would have to change.  */
22437:1429:#define MAX_BUF_SIZE (1L << 16)
22438:1430:
22439:1431:
22440:1432:/* Extend the buffer by twice its current size via realloc and
22441:1433:   reset the pointers that pointed into the old block to point to the
22442:1434:   correct places in the new one.  If extending the buffer results in it
22443:1435:   being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
22444:1436:#define EXTEND_BUFFER()                                                        \
22445:1437:  do {                                                                         \
22446:1438:    unsigned char *old_buffer = bufp->buffer;                                \
22447:1439:    if (bufp->allocated == MAX_BUF_SIZE)                                 \
22448:1440:      return REG_ESIZE;                                                        \
22449:1441:    bufp->allocated <<= 1;                                                \
22450:1442:    if (bufp->allocated > MAX_BUF_SIZE)                                        \
22451:1443:      bufp->allocated = MAX_BUF_SIZE;                                         \
22452:1444:    bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated);\
22453:1445:    if (bufp->buffer == NULL)                                                \
22454:1446:      return REG_ESPACE;                                                \
22455:1447:    /* If the buffer moved, move all the pointers into it.  */                \
22456:1448:    if (old_buffer != bufp->buffer)                                        \
22457:1449:      {                                                                        \
22458:1450:        b = (b - old_buffer) + bufp->buffer;                                \
22459:1451:        begalt = (begalt - old_buffer) + bufp->buffer;                        \
22460:1452:        if (fixup_alt_jump)                                                \
22461:1453:          fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\
22462:1454:        if (laststart)                                                        \
22463:1455:          laststart = (laststart - old_buffer) + bufp->buffer;                \
22464:1456:        if (pending_exact)                                                \
22465:1457:          pending_exact = (pending_exact - old_buffer) + bufp->buffer;        \
22466:1458:      }                                                                        \
22467:1459:  } while (0)
22468:1460:
22469:1461:
22470:1462:/* Since we have one byte reserved for the register number argument to
22471:1463:   {start,stop}_memory, the maximum number of groups we can report
22472:1464:   things about is what fits in that byte.  */
22473:1465:#define MAX_REGNUM 255
22474:1466:
22475:1467:/* But patterns can have more than `MAX_REGNUM' registers.  We just
22476:1468:   ignore the excess.  */
22477:1469:typedef unsigned regnum_t;
22478:1470:
22479:1471:
22480:1472:/* Macros for the compile stack.  */
22481:1473:
22482:1474:/* Since offsets can go either forwards or backwards, this type needs to
22483:1475:   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
22484:1476:typedef int pattern_offset_t;
22485:1477:
22486:1478:typedef struct {
22487:1479:    pattern_offset_t begalt_offset;
22488:1480:    pattern_offset_t fixup_alt_jump;
22489:1481:    pattern_offset_t inner_group_offset;
22490:1482:    pattern_offset_t laststart_offset;
22491:1483:    regnum_t regnum;
22492:1484:} compile_stack_elt_t;
22493:1485:
22494:1486:
22495:1487:typedef struct {
22496:1488:    compile_stack_elt_t *stack;
22497:1489:    unsigned size;
22498:1490:    unsigned avail;             /* Offset of next open position.  */
22499:1491:} compile_stack_type;
22500:1492:
22501:1493:
22502:1494:#define INIT_COMPILE_STACK_SIZE 32
22503:1495:
22504:1496:#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
22505:1497:#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)
22506:1498:
22507:1499:/* The next available element.  */
22508:1500:#define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])
22509:1501:
22510:1502:
22511:1503:/* Set the bit for character C in a list.  */
22512:1504:#define SET_LIST_BIT(c)                               \
22513:1505:  (b[((unsigned char) (c)) / BYTEWIDTH]               \
22514:1506:   |= 1 << (((unsigned char) c) % BYTEWIDTH))
22515:1507:
22516:1508:
22517:1509:/* Get the next unsigned number in the uncompiled pattern.  */
22518:1510:#define GET_UNSIGNED_NUMBER(num)                                         \
22519:1511:  { if (p != pend)                                                        \
22520:1512:     {                                                                        \
22521:1513:       PATFETCH (c);                                                         \
22522:1514:       while (ISDIGIT (c))                                                 \
22523:1515:         {                                                                 \
22524:1516:           if (num < 0)                                                        \
22525:1517:              num = 0;                                                        \
22526:1518:           num = num * 10 + c - '0';                                         \
22527:1519:           if (p == pend)                                                 \
22528:1520:              break;                                                         \
22529:1521:           PATFETCH (c);                                                \
22530:1522:         }                                                                 \
22531:1523:       }                                                                 \
22532:1524:    }
22533:1525:
22534:1526:#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
22535:1527:
22536:1528:#define IS_CHAR_CLASS(string)                                                \
22537:1529:   (STREQ (string, "alpha") || STREQ (string, "upper")                        \
22538:1530:    || STREQ (string, "lower") || STREQ (string, "digit")                \
22539:1531:    || STREQ (string, "alnum") || STREQ (string, "xdigit")                \
22540:1532:    || STREQ (string, "space") || STREQ (string, "print")                \
22541:1533:    || STREQ (string, "punct") || STREQ (string, "graph")                \
22542:1534:    || STREQ (string, "cntrl") || STREQ (string, "blank"))
22543:1535:
22544:1536:#ifndef MATCH_MAY_ALLOCATE
22545:1537:
22546:1538:/* If we cannot allocate large objects within re_match_2_internal,
22547:1539:   we make the fail stack and register vectors global.
22548:1540:   The fail stack, we grow to the maximum size when a regexp
22549:1541:   is compiled.
22550:1542:   The register vectors, we adjust in size each time we
22551:1543:   compile a regexp, according to the number of registers it needs.  */
22552:1544:
22553:1545:static fail_stack_type fail_stack;
22554:1546:
22555:1547:/* Size with which the following vectors are currently allocated.
22556:1548:   That is so we can make them bigger as needed,
22557:1549:   but never make them smaller.  */
22558:1550:static int regs_allocated_size;
22559:1551:
22560:1552:static const char **regstart, **regend;
22561:1553:static const char **old_regstart, **old_regend;
22562:1554:static const char **best_regstart, **best_regend;
22563:1555:static register_info_type *reg_info;
22564:1556:static const char **reg_dummy;
22565:1557:static register_info_type *reg_info_dummy;
22566:1558:
22567:1559:/* Make the register vectors big enough for NUM_REGS registers,
22568:1560:   but don't make them smaller.  */
22569:1561:
22570:1562:static regex_grow_registers (num_regs)
22571:1563:int num_regs;
22572:1564:{
22573:1565:    if (num_regs > regs_allocated_size) {
22574:1566:        RETALLOC_IF (regstart, num_regs, const char *);
22575:1567:        RETALLOC_IF (regend, num_regs, const char *);
22576:1568:        RETALLOC_IF (old_regstart, num_regs, const char *);
22577:1569:        RETALLOC_IF (old_regend, num_regs, const char *);
22578:1570:        RETALLOC_IF (best_regstart, num_regs, const char *);
22579:1571:        RETALLOC_IF (best_regend, num_regs, const char *);
22580:1572:        RETALLOC_IF (reg_info, num_regs, register_info_type);
22581:1573:        RETALLOC_IF (reg_dummy, num_regs, const char *);
22582:1574:        RETALLOC_IF (reg_info_dummy, num_regs, register_info_type);
22583:1575:
22584:1576:        regs_allocated_size = num_regs;
22585:1577:    }
22586:1578:}
22587:1579:
22588:1580:#endif                          /* not MATCH_MAY_ALLOCATE */
22589:1581:
22590:1582:/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.
22591:1583:   Returns one of error codes defined in `regex.h', or zero for success.
22592:1584:
22593:1585:   Assumes the `allocated' (and perhaps `buffer') and `translate'
22594:1586:   fields are set in BUFP on entry.
22595:1587:
22596:1588:   If it succeeds, results are put in BUFP (if it returns an error, the
22597:1589:   contents of BUFP are undefined):
22598:1590:     `buffer' is the compiled pattern;
22599:1591:     `syntax' is set to SYNTAX;
22600:1592:     `used' is set to the length of the compiled pattern;
22601:1593:     `fastmap_accurate' is zero;
22602:1594:     `re_nsub' is the number of subexpressions in PATTERN;
22603:1595:     `not_bol' and `not_eol' are zero;
22604:1596:   
22605:1597:   The `fastmap' and `newline_anchor' fields are neither
22606:1598:   examined nor set.  */
22607:1599:
22608:1600:/* Return, freeing storage we allocated.  */
22609:1601:#define FREE_STACK_RETURN(value)                \
22610:1602:  return (free (compile_stack.stack), value)
22611:1603:
22612:1604:static reg_errcode_t regex_compile (pattern, size, syntax, bufp)
22613:1605:const char *pattern;
22614:1606:int size;
22615:1607:reg_syntax_t syntax;
22616:1608:struct re_pattern_buffer *bufp;
22617:1609:{
22618:1610:    /* We fetch characters from PATTERN here.  Even though PATTERN is
22619:1611:       `char *' (i.e., signed), we declare these variables as unsigned, so
22620:1612:       they can be reliably used as array indices.  */
22621:1613:    register unsigned char c, c1;
22622:1614:
22623:1615:    /* A random temporary spot in PATTERN.  */
22624:1616:    const char *p1;
22625:1617:
22626:1618:    /* Points to the end of the buffer, where we should append.  */
22627:1619:    register unsigned char *b;
22628:1620:
22629:1621:    /* Keeps track of unclosed groups.  */
22630:1622:    compile_stack_type compile_stack;
22631:1623:
22632:1624:    /* Points to the current (ending) position in the pattern.  */
22633:1625:    const char *p = pattern;
22634:1626:    const char *pend = pattern + size;
22635:1627:
22636:1628:    /* How to translate the characters in the pattern.  */
22637:1629:    char *translate = bufp->translate;
22638:1630:
22639:1631:    /* Address of the count-byte of the most recently inserted `exactn'
22640:1632:       command.  This makes it possible to tell if a new exact-match
22641:1633:       character can be added to that command or if the character requires
22642:1634:       a new `exactn' command.  */
22643:1635:    unsigned char *pending_exact = 0;
22644:1636:
22645:1637:    /* Address of start of the most recently finished expression.
22646:1638:       This tells, e.g., postfix * where to find the start of its
22647:1639:       operand.  Reset at the beginning of groups and alternatives.  */
22648:1640:    unsigned char *laststart = 0;
22649:1641:
22650:1642:    /* Address of beginning of regexp, or inside of last group.  */
22651:1643:    unsigned char *begalt;
22652:1644:
22653:1645:    /* Place in the uncompiled pattern (i.e., the {) to
22654:1646:       which to go back if the interval is invalid.  */
22655:1647:    const char *beg_interval;
22656:1648:
22657:1649:    /* Address of the place where a forward jump should go to the end of
22658:1650:       the containing expression.  Each alternative of an `or' -- except the
22659:1651:       last -- ends with a forward jump of this sort.  */
22660:1652:    unsigned char *fixup_alt_jump = 0;
22661:1653:
22662:1654:    /* Counts open-groups as they are encountered.  Remembered for the
22663:1655:       matching close-group on the compile stack, so the same register
22664:1656:       number is put in the stop_memory as the start_memory.  */
22665:1657:    regnum_t regnum = 0;
22666:1658:
22667:1659:#ifdef DEBUG
22668:1660:    DEBUG_PRINT1 ("\nCompiling pattern: ");
22669:1661:    if (debug) {
22670:1662:        unsigned debug_count;
22671:1663:
22672:1664:        for (debug_count = 0; debug_count < size; debug_count++)
22673:1665:            putchar (pattern[debug_count]);
22674:1666:        putchar ('\n');
22675:1667:    }
22676:1668:#endif                          /* DEBUG */
22677:1669:
22678:1670:    /* Initialize the compile stack.  */
22679:1671:    compile_stack.stack =
22680:1672:        TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);
22681:1673:    if (compile_stack.stack == NULL)
22682:1674:        return REG_ESPACE;
22683:1675:
22684:1676:    compile_stack.size = INIT_COMPILE_STACK_SIZE;
22685:1677:    compile_stack.avail = 0;
22686:1678:
22687:1679:    /* Initialize the pattern buffer.  */
22688:1680:    bufp->syntax = syntax;
22689:1681:    bufp->fastmap_accurate = 0;
22690:1682:    bufp->not_bol = bufp->not_eol = 0;
22691:1683:
22692:1684:    /* Set `used' to zero, so that if we return an error, the pattern
22693:1685:       printer (for debugging) will think there's no pattern.  We reset it
22694:1686:       at the end.  */
22695:1687:    bufp->used = 0;
22696:1688:
22697:1689:    /* Always count groups, whether or not bufp->no_sub is set.  */
22698:1690:    bufp->re_nsub = 0;
22699:1691:
22700:1692:#if !defined (emacs) && !defined (SYNTAX_TABLE)
22701:1693:    /* Initialize the syntax table.  */
22702:1694:    init_syntax_once ();
22703:1695:#endif
22704:1696:
22705:1697:    if (bufp->allocated == 0) {
22706:1698:        if (bufp->buffer) {     /* If zero allocated, but buffer is non-null, try to realloc
22707:1699:                                   enough space.  This loses if buffer's address is bogus, but
22708:1700:                                   that is the user's responsibility.  */
22709:1701:            RETALLOC (bufp->buffer, INIT_BUF_SIZE, unsigned char);
22710:1702:        } else {                /* Caller did not allocate a buffer.  Do it for them.  */
22711:1703:            bufp->buffer = TALLOC (INIT_BUF_SIZE, unsigned char);
22712:1704:        }
22713:1705:        if (!bufp->buffer)
22714:1706:            FREE_STACK_RETURN (REG_ESPACE);
22715:1707:
22716:1708:        bufp->allocated = INIT_BUF_SIZE;
22717:1709:    }
22718:1710:
22719:1711:    begalt = b = bufp->buffer;
22720:1712:
22721:1713:    /* Loop through the uncompiled pattern until we're at the end.  */
22722:1714:    while (p != pend) {
22723:1715:        PATFETCH (c);
22724:1716:
22725:1717:        switch (c) {
22726:1718:        case '^':
22727:1719:            {
22728:1720:                if (            /* If at start of pattern, it's an operator.  */
22729:1721:                       p == pattern + 1
22730:1722:                       /* If context independent, it's an operator.  */
22731:1723:                       || syntax & RE_CONTEXT_INDEP_ANCHORS
22732:1724:                       /* Otherwise, depends on what's come before.  */
22733:1725:                       || at_begline_loc_p (pattern, p, syntax))
22734:1726:                    BUF_PUSH (begline);
22735:1727:                else
22736:1728:                    goto normal_char;
22737:1729:            }
22738:1730:            break;
22739:1731:
22740:1732:
22741:1733:        case '$':
22742:1734:            {
22743:1735:                if (            /* If at end of pattern, it's an operator.  */
22744:1736:                       p == pend
22745:1737:                       /* If context independent, it's an operator.  */
22746:1738:                       || syntax & RE_CONTEXT_INDEP_ANCHORS
22747:1739:                       /* Otherwise, depends on what's next.  */
22748:1740:                       || at_endline_loc_p (p, pend, syntax))
22749:1741:                    BUF_PUSH (endline);
22750:1742:                else
22751:1743:                    goto normal_char;
22752:1744:            }
22753:1745:            break;
22754:1746:
22755:1747:
22756:1748:        case '+':
22757:1749:        case '?':
22758:1750:            if ((syntax & RE_BK_PLUS_QM)
22759:1751:                || (syntax & RE_LIMITED_OPS))
22760:1752:                goto normal_char;
22761:1753:          handle_plus:
22762:1754:        case '*':
22763:1755:            /* If there is no previous pattern... */
22764:1756:            if (!laststart) {
22765:1757:                if (syntax & RE_CONTEXT_INVALID_OPS)
22766:1758:                    FREE_STACK_RETURN (REG_BADRPT);
22767:1759:                else if (!(syntax & RE_CONTEXT_INDEP_OPS))
22768:1760:                    goto normal_char;
22769:1761:            }
22770:1762:
22771:1763:            {
22772:1764:                /* Are we optimizing this jump?  */
22773:1765:                boolean keep_string_p = false;
22774:1766:
22775:1767:                /* 1 means zero (many) matches is allowed.  */
22776:1768:                char zero_times_ok = 0, many_times_ok = 0;
22777:1769:
22778:1770:                /* If there is a sequence of repetition chars, collapse it
22779:1771:                   down to just one (the right one).  We can't combine
22780:1772:                   interval operators with these because of, e.g., `a{2}*',
22781:1773:                   which should only match an even number of `a's.  */
22782:1774:
22783:1775:                for (;;) {
22784:1776:                    zero_times_ok |= c != '+';
22785:1777:                    many_times_ok |= c != '?';
22786:1778:
22787:1779:                    if (p == pend)
22788:1780:                        break;
22789:1781:
22790:1782:                    PATFETCH (c);
22791:1783:
22792:1784:                    if (c == '*'
22793:1785:                        || (!(syntax & RE_BK_PLUS_QM)
22794:1786:                            && (c == '+' || c == '?')));
22795:1787:
22796:1788:                    else if (syntax & RE_BK_PLUS_QM && c == '\\') {
22797:1789:                        if (p == pend)
22798:1790:                            FREE_STACK_RETURN (REG_EESCAPE);
22799:1791:
22800:1792:                        PATFETCH (c1);
22801:1793:                        if (!(c1 == '+' || c1 == '?')) {
22802:1794:                            PATUNFETCH;
22803:1795:                            PATUNFETCH;
22804:1796:                            break;
22805:1797:                        }
22806:1798:
22807:1799:                        c = c1;
22808:1800:                    } else {
22809:1801:                        PATUNFETCH;
22810:1802:                        break;
22811:1803:                    }
22812:1804:
22813:1805:                    /* If we get here, we found another repeat character.  */
22814:1806:                }
22815:1807:
22816:1808:                /* Star, etc. applied to an empty pattern is equivalent
22817:1809:                   to an empty pattern.  */
22818:1810:                if (!laststart)
22819:1811:                    break;
22820:1812:
22821:1813:                /* Now we know whether or not zero matches is allowed
22822:1814:                   and also whether or not two or more matches is allowed.  */
22823:1815:                if (many_times_ok) { /* More than one repetition is allowed, so put in at the
22824:1816:                                        end a backward relative jump from `b' to before the next
22825:1817:                                        jump we're going to put in below (which jumps from
22826:1818:                                        laststart to after this jump).  
22827:1819:
22828:1820:                                        But if we are at the `*' in the exact sequence `.*\n',
22829:1821:                                        insert an unconditional jump backwards to the .,
22830:1822:                                        instead of the beginning of the loop.  This way we only
22831:1823:                                        push a failure point once, instead of every time
22832:1824:                                        through the loop.  */
22833:1825:                    assert (p - 1 > pattern);
22834:1826:
22835:1827:                    /* Allocate the space for the jump.  */
22836:1828:                    GET_BUFFER_SPACE (3);
22837:1829:
22838:1830:                    /* We know we are not at the first character of the pattern,
22839:1831:                       because laststart was nonzero.  And we've already
22840:1832:                       incremented `p', by the way, to be the character after
22841:1833:                       the `*'.  Do we have to do something analogous here
22842:1834:                       for null bytes, because of RE_DOT_NOT_NULL?  */
22843:1835:                    if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
22844:1836:                        && zero_times_ok
22845:1837:                        && p < pend && TRANSLATE (*p) == TRANSLATE ('\n')
22846:1838:                        && !(syntax & RE_DOT_NEWLINE)) { /* We have .*\n.  */
22847:1839:                        STORE_JUMP (jump, b, laststart);
22848:1840:                        keep_string_p = true;
22849:1841:                    } else
22850:1842:                        /* Anything else.  */
22851:1843:                        STORE_JUMP (maybe_pop_jump, b, laststart - 3);
22852:1844:
22853:1845:                    /* We've added more stuff to the buffer.  */
22854:1846:                    b += 3;
22855:1847:                }
22856:1848:
22857:1849:                /* On failure, jump from laststart to b + 3, which will be the
22858:1850:                   end of the buffer after this jump is inserted.  */
22859:1851:                GET_BUFFER_SPACE (3);
22860:1852:                INSERT_JUMP (keep_string_p ? on_failure_keep_string_jump
22861:1853:                             : on_failure_jump, laststart, b + 3);
22862:1854:                pending_exact = 0;
22863:1855:                b += 3;
22864:1856:
22865:1857:                if (!zero_times_ok) {
22866:1858:                    /* At least one repetition is required, so insert a
22867:1859:                       `dummy_failure_jump' before the initial
22868:1860:                       `on_failure_jump' instruction of the loop. This
22869:1861:                       effects a skip over that instruction the first time
22870:1862:                       we hit that loop.  */
22871:1863:                    GET_BUFFER_SPACE (3);
22872:1864:                    INSERT_JUMP (dummy_failure_jump, laststart,
22873:1865:                                 laststart + 6);
22874:1866:                    b += 3;
22875:1867:                }
22876:1868:            }
22877:1869:            break;
22878:1870:
22879:1871:
22880:1872:        case '.':
22881:1873:            laststart = b;
22882:1874:            BUF_PUSH (anychar);
22883:1875:            break;
22884:1876:
22885:1877:
22886:1878:        case '[':
22887:1879:            {
22888:1880:                boolean had_char_class = false;
22889:1881:
22890:1882:                if (p == pend)
22891:1883:                    FREE_STACK_RETURN (REG_EBRACK);
22892:1884:
22893:1885:                /* Ensure that we have enough space to push a charset: the
22894:1886:                   opcode, the length count, and the bitset; 34 bytes in all.  */
22895:1887:                GET_BUFFER_SPACE (34);
22896:1888:
22897:1889:                laststart = b;
22898:1890:
22899:1891:                /* We test `*p == '^' twice, instead of using an if
22900:1892:                   statement, so we only need one BUF_PUSH.  */
22901:1893:                BUF_PUSH (*p == '^' ? charset_not : charset);
22902:1894:                if (*p == '^')
22903:1895:                    p++;
22904:1896:
22905:1897:                /* Remember the first position in the bracket expression.  */
22906:1898:                p1 = p;
22907:1899:
22908:1900:                /* Push the number of bytes in the bitmap.  */
22909:1901:                BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);
22910:1902:
22911:1903:                /* Clear the whole map.  */
22912:1904:                bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);
22913:1905:
22914:1906:                /* charset_not matches newline according to a syntax bit.  */
22915:1907:                if ((re_opcode_t) b[-2] == charset_not
22916:1908:                    && (syntax & RE_HAT_LISTS_NOT_NEWLINE))
22917:1909:                    SET_LIST_BIT ('\n');
22918:1910:
22919:1911:                /* Read in characters and ranges, setting map bits.  */
22920:1912:                for (;;) {
22921:1913:                    if (p == pend)
22922:1914:                        FREE_STACK_RETURN (REG_EBRACK);
22923:1915:
22924:1916:                    PATFETCH (c);
22925:1917:
22926:1918:                    /* \ might escape characters inside [...] and [^...].  */
22927:1919:                    if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS)
22928:1920:                        && c == '\\') {
22929:1921:                        if (p == pend)
22930:1922:                            FREE_STACK_RETURN (REG_EESCAPE);
22931:1923:
22932:1924:                        PATFETCH (c1);
22933:1925:                        SET_LIST_BIT (c1);
22934:1926:                        continue;
22935:1927:                    }
22936:1928:
22937:1929:                    /* Could be the end of the bracket expression.  If it's
22938:1930:                       not (i.e., when the bracket expression is `[]' so
22939:1931:                       far), the ']' character bit gets set way below.  */
22940:1932:                    if (c == ']' && p != p1 + 1)
22941:1933:                        break;
22942:1934:
22943:1935:                    /* Look ahead to see if it's a range when the last thing
22944:1936:                       was a character class.  */
22945:1937:                    if (had_char_class && c == '-' && *p != ']')
22946:1938:                        FREE_STACK_RETURN (REG_ERANGE);
22947:1939:
22948:1940:                    /* Look ahead to see if it's a range when the last thing
22949:1941:                       was a character: if this is a hyphen not at the
22950:1942:                       beginning or the end of a list, then it's the range
22951:1943:                       operator.  */
22952:1944:                    if (c == '-' && !(p - 2 >= pattern && p[-2] == '[')
22953:1945:                        && !(p - 3 >= pattern && p[-3] == '['
22954:1946:                             && p[-2] == '^')
22955:1947:                        && *p != ']') {
22956:1948:                        reg_errcode_t ret
22957:1949:                            =
22958:1950:                            compile_range (&p, pend, translate, syntax, b);
22959:1951:                        if (ret != REG_NOERROR)
22960:1952:                            FREE_STACK_RETURN (ret);
22961:1953:                    }
22962:1954:
22963:1955:                    else if (p[0] == '-' && p[1] != ']') { /* This handles ranges made up of characters only.  */
22964:1956:                        reg_errcode_t ret;
22965:1957:
22966:1958:                        /* Move past the `-'.  */
22967:1959:                        PATFETCH (c1);
22968:1960:
22969:1961:                        ret =
22970:1962:                            compile_range (&p, pend, translate, syntax, b);
22971:1963:                        if (ret != REG_NOERROR)
22972:1964:                            FREE_STACK_RETURN (ret);
22973:1965:                    }
22974:1966:
22975:1967:                    /* See if we're at the beginning of a possible character
22976:1968:                       class.  */
22977:1969:
22978:1970:                    else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':') { /* Leave room for the null.  */
22979:1971:                        char str[CHAR_CLASS_MAX_LENGTH + 1];
22980:1972:
22981:1973:                        PATFETCH (c);
22982:1974:                        c1 = 0;
22983:1975:
22984:1976:                        /* If pattern is `[[:'.  */
22985:1977:                        if (p == pend)
22986:1978:                            FREE_STACK_RETURN (REG_EBRACK);
22987:1979:
22988:1980:                        for (;;) {
22989:1981:                            PATFETCH (c);
22990:1982:                            if (c == ':' || c == ']' || p == pend
22991:1983:                                || c1 == CHAR_CLASS_MAX_LENGTH)
22992:1984:                                break;
22993:1985:                            str[c1++] = c;
22994:1986:                        }
22995:1987:                        str[c1] = '\0';
22996:1988:
22997:1989:                        /* If isn't a word bracketed by `[:' and:`]':
22998:1990:                           undo the ending character, the letters, and leave 
22999:1991:                           the leading `:' and `[' (but set bits for them).  */
23000:1992:                        if (c == ':' && *p == ']') {
23001:1993:                            int ch;
23002:1994:                            boolean is_alnum = STREQ (str, "alnum");
23003:1995:                            boolean is_alpha = STREQ (str, "alpha");
23004:1996:                            boolean is_blank = STREQ (str, "blank");
23005:1997:                            boolean is_cntrl = STREQ (str, "cntrl");
23006:1998:                            boolean is_digit = STREQ (str, "digit");
23007:1999:                            boolean is_graph = STREQ (str, "graph");
23008:2000:                            boolean is_lower = STREQ (str, "lower");
23009:2001:                            boolean is_print = STREQ (str, "print");
23010:2002:                            boolean is_punct = STREQ (str, "punct");
23011:2003:                            boolean is_space = STREQ (str, "space");
23012:2004:                            boolean is_upper = STREQ (str, "upper");
23013:2005:                            boolean is_xdigit = STREQ (str, "xdigit");
23014:2006:
23015:2007:                            if (!IS_CHAR_CLASS (str))
23016:2008:                                FREE_STACK_RETURN (REG_ECTYPE);
23017:2009:
23018:2010:                            /* Throw away the ] at the end of the character
23019:2011:                               class.  */
23020:2012:                            PATFETCH (c);
23021:2013:
23022:2014:                            if (p == pend)
23023:2015:                                FREE_STACK_RETURN (REG_EBRACK);
23024:2016:
23025:2017:                            for (ch = 0; ch < 1 << BYTEWIDTH; ch++) {
23026:2018:                                /* This was split into 3 if's to
23027:2019:                                   avoid an arbitrary limit in some compiler.  */
23028:2020:                                if ((is_alnum && ISALNUM (ch))
23029:2021:                                    || (is_alpha && ISALPHA (ch))
23030:2022:                                    || (is_blank && ISBLANK (ch))
23031:2023:                                    || (is_cntrl && ISCNTRL (ch)))
23032:2024:                                    SET_LIST_BIT (ch);
23033:2025:                                if ((is_digit && ISDIGIT (ch))
23034:2026:                                    || (is_graph && ISGRAPH (ch))
23035:2027:                                    || (is_lower && ISLOWER (ch))
23036:2028:                                    || (is_print && ISPRINT (ch)))
23037:2029:                                    SET_LIST_BIT (ch);
23038:2030:                                if ((is_punct && ISPUNCT (ch))
23039:2031:                                    || (is_space && ISSPACE (ch))
23040:2032:                                    || (is_upper && ISUPPER (ch))
23041:2033:                                    || (is_xdigit && ISXDIGIT (ch)))
23042:2034:                                    SET_LIST_BIT (ch);
23043:2035:                            }
23044:2036:                            had_char_class = true;
23045:2037:                        } else {
23046:2038:                            c1++;
23047:2039:                            while (c1--)
23048:2040:                                PATUNFETCH;
23049:2041:                            SET_LIST_BIT ('[');
23050:2042:                            SET_LIST_BIT (':');
23051:2043:                            had_char_class = false;
23052:2044:                        }
23053:2045:                    } else {
23054:2046:                        had_char_class = false;
23055:2047:                        SET_LIST_BIT (c);
23056:2048:                    }
23057:2049:                }
23058:2050:
23059:2051:                /* Discard any (non)matching list bytes that are all 0 at the
23060:2052:                   end of the map.  Decrease the map-length byte too.  */
23061:2053:                while ((int) b[-1] > 0 && b[b[-1] - 1] == 0)
23062:2054:                    b[-1]--;
23063:2055:                b += b[-1];
23064:2056:            }
23065:2057:            break;
23066:2058:
23067:2059:
23068:2060:        case '(':
23069:2061:            if (syntax & RE_NO_BK_PARENS)
23070:2062:                goto handle_open;
23071:2063:            else
23072:2064:                goto normal_char;
23073:2065:
23074:2066:
23075:2067:        case ')':
23076:2068:            if (syntax & RE_NO_BK_PARENS)
23077:2069:                goto handle_close;
23078:2070:            else
23079:2071:                goto normal_char;
23080:2072:
23081:2073:
23082:2074:        case '\n':
23083:2075:            if (syntax & RE_NEWLINE_ALT)
23084:2076:                goto handle_alt;
23085:2077:            else
23086:2078:                goto normal_char;
23087:2079:
23088:2080:
23089:2081:        case '|':
23090:2082:            if (syntax & RE_NO_BK_VBAR)
23091:2083:                goto handle_alt;
23092:2084:            else
23093:2085:                goto normal_char;
23094:2086:
23095:2087:
23096:2088:        case '{':
23097:2089:            if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)
23098:2090:                goto handle_interval;
23099:2091:            else
23100:2092:                goto normal_char;
23101:2093:
23102:2094:
23103:2095:        case '\\':
23104:2096:            if (p == pend)
23105:2097:                FREE_STACK_RETURN (REG_EESCAPE);
23106:2098:
23107:2099:            /* Do not translate the character after the \, so that we can
23108:2100:               distinguish, e.g., \B from \b, even if we normally would
23109:2101:               translate, e.g., B to b.  */
23110:2102:            PATFETCH_RAW (c);
23111:2103:
23112:2104:            switch (c) {
23113:2105:            case '(':
23114:2106:                if (syntax & RE_NO_BK_PARENS)
23115:2107:                    goto normal_backslash;
23116:2108:
23117:2109:              handle_open:
23118:2110:                bufp->re_nsub++;
23119:2111:                regnum++;
23120:2112:
23121:2113:                if (COMPILE_STACK_FULL) {
23122:2114:                    RETALLOC (compile_stack.stack, compile_stack.size << 1,
23123:2115:                              compile_stack_elt_t);
23124:2116:                    if (compile_stack.stack == NULL)
23125:2117:                        return REG_ESPACE;
23126:2118:
23127:2119:                    compile_stack.size <<= 1;
23128:2120:                }
23129:2121:
23130:2122:                /* These are the values to restore when we hit end of this
23131:2123:                   group.  They are all relative offsets, so that if the
23132:2124:                   whole pattern moves because of realloc, they will still
23133:2125:                   be valid.  */
23134:2126:                COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;
23135:2127:                COMPILE_STACK_TOP.fixup_alt_jump
23136:2128:                    =
23137:2129:                    fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
23138:2130:                COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;
23139:2131:                COMPILE_STACK_TOP.regnum = regnum;
23140:2132:
23141:2133:                /* We will eventually replace the 0 with the number of
23142:2134:                   groups inner to this one.  But do not push a
23143:2135:                   start_memory for groups beyond the last one we can
23144:2136:                   represent in the compiled pattern.  */
23145:2137:                if (regnum <= MAX_REGNUM) {
23146:2138:                    COMPILE_STACK_TOP.inner_group_offset =
23147:2139:                        b - bufp->buffer + 2;
23148:2140:                    BUF_PUSH_3 (start_memory, regnum, 0);
23149:2141:                }
23150:2142:
23151:2143:                compile_stack.avail++;
23152:2144:
23153:2145:                fixup_alt_jump = 0;
23154:2146:                laststart = 0;
23155:2147:                begalt = b;
23156:2148:                /* If we've reached MAX_REGNUM groups, then this open
23157:2149:                   won't actually generate any code, so we'll have to
23158:2150:                   clear pending_exact explicitly.  */
23159:2151:                pending_exact = 0;
23160:2152:                break;
23161:2153:
23162:2154:
23163:2155:            case ')':
23164:2156:                if (syntax & RE_NO_BK_PARENS)
23165:2157:                    goto normal_backslash;
23166:2158:
23167:2159:                if (COMPILE_STACK_EMPTY)
23168:2160:                    if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
23169:2161:                        goto normal_backslash;
23170:2162:                    else
23171:2163:                        FREE_STACK_RETURN (REG_ERPAREN);
23172:2164:
23173:2165:              handle_close:
23174:2166:                if (fixup_alt_jump) { /* Push a dummy failure point at the end of the
23175:2167:                                         alternative for a possible future
23176:2168:                                         `pop_failure_jump' to pop.  See comments at
23177:2169:                                         `push_dummy_failure' in `re_match_2'.  */
23178:2170:                    BUF_PUSH (push_dummy_failure);
23179:2171:
23180:2172:                    /* We allocated space for this jump when we assigned
23181:2173:                       to `fixup_alt_jump', in the `handle_alt' case below.  */
23182:2174:                    STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
23183:2175:                }
23184:2176:
23185:2177:                /* See similar code for backslashed left paren above.  */
23186:2178:                if (COMPILE_STACK_EMPTY)
23187:2179:                    if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
23188:2180:                        goto normal_char;
23189:2181:                    else
23190:2182:                        FREE_STACK_RETURN (REG_ERPAREN);
23191:2183:
23192:2184:                /* Since we just checked for an empty stack above, this
23193:2185:                   ``can't happen''.  */
23194:2186:                assert (compile_stack.avail != 0);
23195:2187:                {
23196:2188:                    /* We don't just want to restore into `regnum', because
23197:2189:                       later groups should continue to be numbered higher,
23198:2190:                       as in `(ab)c(de)' -- the second group is #2.  */
23199:2191:                    regnum_t this_group_regnum;
23200:2192:
23201:2193:                    compile_stack.avail--;
23202:2194:                    begalt =
23203:2195:                        bufp->buffer + COMPILE_STACK_TOP.begalt_offset;
23204:2196:                    fixup_alt_jump =
23205:2197:                        COMPILE_STACK_TOP.fixup_alt_jump ? bufp->buffer +
23206:2198:                        COMPILE_STACK_TOP.fixup_alt_jump - 1 : 0;
23207:2199:                    laststart =
23208:2200:                        bufp->buffer + COMPILE_STACK_TOP.laststart_offset;
23209:2201:                    this_group_regnum = COMPILE_STACK_TOP.regnum;
23210:2202:                    /* If we've reached MAX_REGNUM groups, then this open
23211:2203:                       won't actually generate any code, so we'll have to
23212:2204:                       clear pending_exact explicitly.  */
23213:2205:                    pending_exact = 0;
23214:2206:
23215:2207:                    /* We're at the end of the group, so now we know how many
23216:2208:                       groups were inside this one.  */
23217:2209:                    if (this_group_regnum <= MAX_REGNUM) {
23218:2210:                        unsigned char *inner_group_loc
23219:2211:                            =
23220:2212:                            bufp->buffer +
23221:2213:                            COMPILE_STACK_TOP.inner_group_offset;
23222:2214:
23223:2215:                        *inner_group_loc = regnum - this_group_regnum;
23224:2216:                        BUF_PUSH_3 (stop_memory, this_group_regnum,
23225:2217:                                    regnum - this_group_regnum);
23226:2218:                    }
23227:2219:                }
23228:2220:                break;
23229:2221:
23230:2222:
23231:2223:            case '|':          /* `\|'.  */
23232:2224:                if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)
23233:2225:                    goto normal_backslash;
23234:2226:              handle_alt:
23235:2227:                if (syntax & RE_LIMITED_OPS)
23236:2228:                    goto normal_char;
23237:2229:
23238:2230:                /* Insert before the previous alternative a jump which
23239:2231:                   jumps to this alternative if the former fails.  */
23240:2232:                GET_BUFFER_SPACE (3);
23241:2233:                INSERT_JUMP (on_failure_jump, begalt, b + 6);
23242:2234:                pending_exact = 0;
23243:2235:                b += 3;
23244:2236:
23245:2237:                /* The alternative before this one has a jump after it
23246:2238:                   which gets executed if it gets matched.  Adjust that
23247:2239:                   jump so it will jump to this alternative's analogous
23248:2240:                   jump (put in below, which in turn will jump to the next
23249:2241:                   (if any) alternative's such jump, etc.).  The last such
23250:2242:                   jump jumps to the correct final destination.  A picture:
23251:2243:                   _____ _____ 
23252:2244:                   |   | |   |   
23253:2245:                   |   v |   v 
23254:2246:                   a | b   | c   
23255:2247:
23256:2248:                   If we are at `b', then fixup_alt_jump right now points to a
23257:2249:                   three-byte space after `a'.  We'll put in the jump, set
23258:2250:                   fixup_alt_jump to right after `b', and leave behind three
23259:2251:                   bytes which we'll fill in when we get to after `c'.  */
23260:2252:
23261:2253:                if (fixup_alt_jump)
23262:2254:                    STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
23263:2255:
23264:2256:                /* Mark and leave space for a jump after this alternative,
23265:2257:                   to be filled in later either by next alternative or
23266:2258:                   when know we're at the end of a series of alternatives.  */
23267:2259:                fixup_alt_jump = b;
23268:2260:                GET_BUFFER_SPACE (3);
23269:2261:                b += 3;
23270:2262:
23271:2263:                laststart = 0;
23272:2264:                begalt = b;
23273:2265:                break;
23274:2266:
23275:2267:
23276:2268:            case '{':
23277:2269:                /* If \{ is a literal.  */
23278:2270:                if (!(syntax & RE_INTERVALS)
23279:2271:                    /* If we're at `\{' and it's not the open-interval 
23280:2272:                       operator.  */
23281:2273:                    || ((syntax & RE_INTERVALS)
23282:2274:                        && (syntax & RE_NO_BK_BRACES))
23283:2275:                    || (p - 2 == pattern && p == pend))
23284:2276:                    goto normal_backslash;
23285:2277:
23286:2278:              handle_interval:
23287:2279:                {
23288:2280:                    /* If got here, then the syntax allows intervals.  */
23289:2281:
23290:2282:                    /* At least (most) this many matches must be made.  */
23291:2283:                    int lower_bound = -1, upper_bound = -1;
23292:2284:
23293:2285:                    beg_interval = p - 1;
23294:2286:
23295:2287:                    if (p == pend) {
23296:2288:                        if (syntax & RE_NO_BK_BRACES)
23297:2289:                            goto unfetch_interval;
23298:2290:                        else
23299:2291:                            FREE_STACK_RETURN (REG_EBRACE);
23300:2292:                    }
23301:2293:
23302:2294:                    GET_UNSIGNED_NUMBER (lower_bound);
23303:2295:
23304:2296:                    if (c == ',') {
23305:2297:                        GET_UNSIGNED_NUMBER (upper_bound);
23306:2298:                        if (upper_bound < 0)
23307:2299:                            upper_bound = RE_DUP_MAX;
23308:2300:                    } else
23309:2301:                        /* Interval such as `{1}' => match exactly once. */
23310:2302:                        upper_bound = lower_bound;
23311:2303:
23312:2304:                    if (lower_bound < 0 || upper_bound > RE_DUP_MAX
23313:2305:                        || lower_bound > upper_bound) {
23314:2306:                        if (syntax & RE_NO_BK_BRACES)
23315:2307:                            goto unfetch_interval;
23316:2308:                        else
23317:2309:                            FREE_STACK_RETURN (REG_BADBR);
23318:2310:                    }
23319:2311:
23320:2312:                    if (!(syntax & RE_NO_BK_BRACES)) {
23321:2313:                        if (c != '\\')
23322:2314:                            FREE_STACK_RETURN (REG_EBRACE);
23323:2315:
23324:2316:                        PATFETCH (c);
23325:2317:                    }
23326:2318:
23327:2319:                    if (c != '}') {
23328:2320:                        if (syntax & RE_NO_BK_BRACES)
23329:2321:                            goto unfetch_interval;
23330:2322:                        else
23331:2323:                            FREE_STACK_RETURN (REG_BADBR);
23332:2324:                    }
23333:2325:
23334:2326:                    /* We just parsed a valid interval.  */
23335:2327:
23336:2328:                    /* If it's invalid to have no preceding re.  */
23337:2329:                    if (!laststart) {
23338:2330:                        if (syntax & RE_CONTEXT_INVALID_OPS)
23339:2331:                            FREE_STACK_RETURN (REG_BADRPT);
23340:2332:                        else if (syntax & RE_CONTEXT_INDEP_OPS)
23341:2333:                            laststart = b;
23342:2334:                        else
23343:2335:                            goto unfetch_interval;
23344:2336:                    }
23345:2337:
23346:2338:                    /* If the upper bound is zero, don't want to succeed at
23347:2339:                       all; jump from `laststart' to `b + 3', which will be
23348:2340:                       the end of the buffer after we insert the jump.  */
23349:2341:                    if (upper_bound == 0) {
23350:2342:                        GET_BUFFER_SPACE (3);
23351:2343:                        INSERT_JUMP (jump, laststart, b + 3);
23352:2344:                        b += 3;
23353:2345:                    }
23354:2346:
23355:2347:                    /* Otherwise, we have a nontrivial interval.  When
23356:2348:                       we're all done, the pattern will look like:
23357:2349:                       set_number_at <jump count> <upper bound>
23358:2350:                       set_number_at <succeed_n count> <lower bound>
23359:2351:                       succeed_n <after jump addr> <succeed_n count>
23360:2352:                       <body of loop>
23361:2353:                       jump_n <succeed_n addr> <jump count>
23362:2354:                       (The upper bound and `jump_n' are omitted if
23363:2355:                       `upper_bound' is 1, though.)  */
23364:2356:                    else {      /* If the upper bound is > 1, we need to insert
23365:2357:                                   more at the end of the loop.  */
23366:2358:                        unsigned nbytes = 10 + (upper_bound > 1) * 10;
23367:2359:
23368:2360:                        GET_BUFFER_SPACE (nbytes);
23369:2361:
23370:2362:                        /* Initialize lower bound of the `succeed_n', even
23371:2363:                           though it will be set during matching by its
23372:2364:                           attendant `set_number_at' (inserted next),
23373:2365:                           because `re_compile_fastmap' needs to know.
23374:2366:                           Jump to the `jump_n' we might insert below.  */
23375:2367:                        INSERT_JUMP2 (succeed_n, laststart,
23376:2368:                                      b + 5 + (upper_bound > 1) * 5,
23377:2369:                                      lower_bound);
23378:2370:                        b += 5;
23379:2371:
23380:2372:                        /* Code to initialize the lower bound.  Insert 
23381:2373:                           before the `succeed_n'.  The `5' is the last two
23382:2374:                           bytes of this `set_number_at', plus 3 bytes of
23383:2375:                           the following `succeed_n'.  */
23384:2376:                        insert_op2 (set_number_at, laststart, 5,
23385:2377:                                    lower_bound, b);
23386:2378:                        b += 5;
23387:2379:
23388:2380:                        if (upper_bound > 1) { /* More than one repetition is allowed, so
23389:2381:                                                  append a backward jump to the `succeed_n'
23390:2382:                                                  that starts this interval.
23391:2383:
23392:2384:                                                  When we've reached this during matching,
23393:2385:                                                  we'll have matched the interval once, so
23394:2386:                                                  jump back only `upper_bound - 1' times.  */
23395:2387:                            STORE_JUMP2 (jump_n, b, laststart + 5,
23396:2388:                                         upper_bound - 1);
23397:2389:                            b += 5;
23398:2390:
23399:2391:                            /* The location we want to set is the second
23400:2392:                               parameter of the `jump_n'; that is `b-2' as
23401:2393:                               an absolute address.  `laststart' will be
23402:2394:                               the `set_number_at' we're about to insert;
23403:2395:                               `laststart+3' the number to set, the source
23404:2396:                               for the relative address.  But we are
23405:2397:                               inserting into the middle of the pattern --
23406:2398:                               so everything is getting moved up by 5.
23407:2399:                               Conclusion: (b - 2) - (laststart + 3) + 5,
23408:2400:                               i.e., b - laststart.
23409:2401:
23410:2402:                               We insert this at the beginning of the loop
23411:2403:                               so that if we fail during matching, we'll
23412:2404:                               reinitialize the bounds.  */
23413:2405:                            insert_op2 (set_number_at, laststart,
23414:2406:                                        b - laststart, upper_bound - 1, b);
23415:2407:                            b += 5;
23416:2408:                        }
23417:2409:                    }
23418:2410:                    pending_exact = 0;
23419:2411:                    beg_interval = NULL;
23420:2412:                }
23421:2413:                break;
23422:2414:
23423:2415:              unfetch_interval:
23424:2416:                /* If an invalid interval, match the characters as literals.  */
23425:2417:                assert (beg_interval);
23426:2418:                p = beg_interval;
23427:2419:                beg_interval = NULL;
23428:2420:
23429:2421:                /* normal_char and normal_backslash need `c'.  */
23430:2422:                PATFETCH (c);
23431:2423:
23432:2424:                if (!(syntax & RE_NO_BK_BRACES)) {
23433:2425:                    if (p > pattern && p[-1] == '\\')
23434:2426:                        goto normal_backslash;
23435:2427:                }
23436:2428:                goto normal_char;
23437:2429:
23438:2430:#ifdef emacs
23439:2431:                /* There is no way to specify the before_dot and after_dot
23440:2432:                   operators.  rms says this is ok.  --karl  */
23441:2433:            case '=':
23442:2434:                BUF_PUSH (at_dot);
23443:2435:                break;
23444:2436:
23445:2437:            case 's':
23446:2438:                laststart = b;
23447:2439:                PATFETCH (c);
23448:2440:                BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
23449:2441:                break;
23450:2442:
23451:2443:            case 'S':
23452:2444:                laststart = b;
23453:2445:                PATFETCH (c);
23454:2446:                BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
23455:2447:                break;
23456:2448:#endif                          /* emacs */
23457:2449:
23458:2450:
23459:2451:            case 'w':
23460:2452:                laststart = b;
23461:2453:                BUF_PUSH (wordchar);
23462:2454:                break;
23463:2455:
23464:2456:
23465:2457:            case 'W':
23466:2458:                laststart = b;
23467:2459:                BUF_PUSH (notwordchar);
23468:2460:                break;
23469:2461:
23470:2462:
23471:2463:            case '<':
23472:2464:                BUF_PUSH (wordbeg);
23473:2465:                break;
23474:2466:
23475:2467:            case '>':
23476:2468:                BUF_PUSH (wordend);
23477:2469:                break;
23478:2470:
23479:2471:            case 'b':
23480:2472:                BUF_PUSH (wordbound);
23481:2473:                break;
23482:2474:
23483:2475:            case 'B':
23484:2476:                BUF_PUSH (notwordbound);
23485:2477:                break;
23486:2478:
23487:2479:            case '`':
23488:2480:                BUF_PUSH (begbuf);
23489:2481:                break;
23490:2482:
23491:2483:            case '\'':
23492:2484:                BUF_PUSH (endbuf);
23493:2485:                break;
23494:2486:
23495:2487:            case '1':
23496:2488:            case '2':
23497:2489:            case '3':
23498:2490:            case '4':
23499:2491:            case '5':
23500:2492:            case '6':
23501:2493:            case '7':
23502:2494:            case '8':
23503:2495:            case '9':
23504:2496:                if (syntax & RE_NO_BK_REFS)
23505:2497:                    goto normal_char;
23506:2498:
23507:2499:                c1 = c - '0';
23508:2500:
23509:2501:                if (c1 > regnum)
23510:2502:                    FREE_STACK_RETURN (REG_ESUBREG);
23511:2503:
23512:2504:                /* Can't back reference to a subexpression if inside of it.  */
23513:2505:                if (group_in_compile_stack (compile_stack, c1))
23514:2506:                    goto normal_char;
23515:2507:
23516:2508:                laststart = b;
23517:2509:                BUF_PUSH_2 (duplicate, c1);
23518:2510:                break;
23519:2511:
23520:2512:
23521:2513:            case '+':
23522:2514:            case '?':
23523:2515:                if (syntax & RE_BK_PLUS_QM)
23524:2516:                    goto handle_plus;
23525:2517:                else
23526:2518:                    goto normal_backslash;
23527:2519:
23528:2520:            default:
23529:2521:              normal_backslash:
23530:2522:                /* You might think it would be useful for \ to mean
23531:2523:                   not to translate; but if we don't translate it
23532:2524:                   it will never match anything.  */
23533:2525:                c = TRANSLATE (c);
23534:2526:                goto normal_char;
23535:2527:            }
23536:2528:            break;
23537:2529:
23538:2530:
23539:2531:        default:
23540:2532:            /* Expects the character in `c'.  */
23541:2533:          normal_char:
23542:2534:            /* If no exactn currently being built.  */
23543:2535:            if (!pending_exact
23544:2536:                /* If last exactn not at current position.  */
23545:2537:                || pending_exact + *pending_exact + 1 != b
23546:2538:                /* We have only one byte following the exactn for the count.  */
23547:2539:                || *pending_exact == (1 << BYTEWIDTH) - 1
23548:2540:                /* If followed by a repetition operator.  */
23549:2541:                || *p == '*' || *p == '^' || ((syntax & RE_BK_PLUS_QM)
23550:2542:                                              ? *p == '\\' && (p[1] == '+'
23551:2543:                                                               || p[1] ==
23552:2544:                                                               '?')
23553:2545:                                              : (*p == '+' || *p == '?'))
23554:2546:                || ((syntax & RE_INTERVALS)
23555:2547:                    && ((syntax & RE_NO_BK_BRACES)
23556:2548:                        ? *p == '{' : (p[0] == '\\' && p[1] == '{')))) {
23557:2549:                /* Start building a new exactn.  */
23558:2550:
23559:2551:                laststart = b;
23560:2552:
23561:2553:                BUF_PUSH_2 (exactn, 0);
23562:2554:                pending_exact = b - 1;
23563:2555:            }
23564:2556:
23565:2557:            BUF_PUSH (c);
23566:2558:            (*pending_exact)++;
23567:2559:            break;
23568:2560:        }                       /* switch (c) */
23569:2561:    }                           /* while p != pend */
23570:2562:
23571:2563:
23572:2564:    /* Through the pattern now.  */
23573:2565:
23574:2566:    if (fixup_alt_jump)
23575:2567:        STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
23576:2568:
23577:2569:    if (!COMPILE_STACK_EMPTY)
23578:2570:        FREE_STACK_RETURN (REG_EPAREN);
23579:2571:
23580:2572:    /* If we don't want backtracking, force success
23581:2573:       the first time we reach the end of the compiled pattern.  */
23582:2574:    if (syntax & RE_NO_POSIX_BACKTRACKING)
23583:2575:        BUF_PUSH (succeed);
23584:2576:
23585:2577:    free (compile_stack.stack);
23586:2578:
23587:2579:    /* We have succeeded; set the length of the buffer.  */
23588:2580:    bufp->used = b - bufp->buffer;
23589:2581:
23590:2582:#ifdef DEBUG
23591:2583:    if (debug) {
23592:2584:        DEBUG_PRINT1 ("\nCompiled pattern: \n");
23593:2585:        print_compiled_pattern (bufp);
23594:2586:    }
23595:2587:#endif                          /* DEBUG */
23596:2588:
23597:2589:#ifndef MATCH_MAY_ALLOCATE
23598:2590:    /* Initialize the failure stack to the largest possible stack.  This
23599:2591:       isn't necessary unless we're trying to avoid calling alloca in
23600:2592:       the search and match routines.  */
23601:2593:    {
23602:2594:        int num_regs = bufp->re_nsub + 1;
23603:2595:
23604:2596:        /* Since DOUBLE_FAIL_STACK refuses to double only if the current size
23605:2597:           is strictly greater than re_max_failures, the largest possible stack
23606:2598:           is 2 * re_max_failures failure points.  */
23607:2599:        if (fail_stack.size < (2 * re_max_failures * MAX_FAILURE_ITEMS)) {
23608:2600:            fail_stack.size = (2 * re_max_failures * MAX_FAILURE_ITEMS);
23609:2601:
23610:2602:#ifdef emacs
23611:2603:            if (!fail_stack.stack)
23612:2604:                fail_stack.stack
23613:2605:                    = (fail_stack_elt_t *) xmalloc (fail_stack.size
23614:2606:                                                    *
23615:2607:                                                    sizeof
23616:2608:                                                    (fail_stack_elt_t));
23617:2609:            else
23618:2610:                fail_stack.stack
23619:2611:                    = (fail_stack_elt_t *) xrealloc (fail_stack.stack,
23620:2612:                                                     (fail_stack.size
23621:2613:                                                      *
23622:2614:                                                      sizeof
23623:2615:                                                      (fail_stack_elt_t)));
23624:2616:#else                           /* not emacs */
23625:2617:            if (!fail_stack.stack)
23626:2618:                fail_stack.stack
23627:2619:                    = (fail_stack_elt_t *) malloc (fail_stack.size
23628:2620:                                                   *
23629:2621:                                                   sizeof
23630:2622:                                                   (fail_stack_elt_t));
23631:2623:            else
23632:2624:                fail_stack.stack
23633:2625:                    = (fail_stack_elt_t *) realloc (fail_stack.stack,
23634:2626:                                                    (fail_stack.size
23635:2627:                                                     *
23636:2628:                                                     sizeof
23637:2629:                                                     (fail_stack_elt_t)));
23638:2630:#endif                          /* not emacs */
23639:2631:        }
23640:2632:
23641:2633:        regex_grow_registers (num_regs);
23642:2634:    }
23643:2635:#endif                          /* not MATCH_MAY_ALLOCATE */
23644:2636:
23645:2637:    return REG_NOERROR;
23646:2638:}                               /* regex_compile */
23647:2639:
23648:2640:/* Subroutines for `regex_compile'.  */
23649:2641:
23650:2642:/* Store OP at LOC followed by two-byte integer parameter ARG.  */
23651:2643:
23652:2644:static void store_op1 (op, loc, arg)
23653:2645:re_opcode_t op;
23654:2646:unsigned char *loc;
23655:2647:int arg;
23656:2648:{
23657:2649:    *loc = (unsigned char) op;
23658:2650:    STORE_NUMBER (loc + 1, arg);
23659:2651:}
23660:2652:
23661:2653:
23662:2654:/* Like `store_op1', but for two two-byte parameters ARG1 and ARG2.  */
23663:2655:
23664:2656:static void store_op2 (op, loc, arg1, arg2)
23665:2657:re_opcode_t op;
23666:2658:unsigned char *loc;
23667:2659:int arg1, arg2;
23668:2660:{
23669:2661:    *loc = (unsigned char) op;
23670:2662:    STORE_NUMBER (loc + 1, arg1);
23671:2663:    STORE_NUMBER (loc + 3, arg2);
23672:2664:}
23673:2665:
23674:2666:
23675:2667:/* Copy the bytes from LOC to END to open up three bytes of space at LOC
23676:2668:   for OP followed by two-byte integer parameter ARG.  */
23677:2669:
23678:2670:static void insert_op1 (op, loc, arg, end)
23679:2671:re_opcode_t op;
23680:2672:unsigned char *loc;
23681:2673:int arg;
23682:2674:unsigned char *end;
23683:2675:{
23684:2676:    register unsigned char *pfrom = end;
23685:2677:    register unsigned char *pto = end + 3;
23686:2678:
23687:2679:    while (pfrom != loc)
23688:2680:        *--pto = *--pfrom;
23689:2681:
23690:2682:    store_op1 (op, loc, arg);
23691:2683:}
23692:2684:
23693:2685:
23694:2686:/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
23695:2687:
23696:2688:static void insert_op2 (op, loc, arg1, arg2, end)
23697:2689:re_opcode_t op;
23698:2690:unsigned char *loc;
23699:2691:int arg1, arg2;
23700:2692:unsigned char *end;
23701:2693:{
23702:2694:    register unsigned char *pfrom = end;
23703:2695:    register unsigned char *pto = end + 5;
23704:2696:
23705:2697:    while (pfrom != loc)
23706:2698:        *--pto = *--pfrom;
23707:2699:
23708:2700:    store_op2 (op, loc, arg1, arg2);
23709:2701:}
23710:2702:
23711:2703:
23712:2704:/* P points to just after a ^ in PATTERN.  Return true if that ^ comes
23713:2705:   after an alternative or a begin-subexpression.  We assume there is at
23714:2706:   least one character before the ^.  */
23715:2707:
23716:2708:static boolean at_begline_loc_p (pattern, p, syntax)
23717:2709:const char *pattern, *p;
23718:2710:reg_syntax_t syntax;
23719:2711:{
23720:2712:    const char *prev = p - 2;
23721:2713:    boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
23722:2714:
23723:2715:    return
23724:2716:        /* After a subexpression?  */
23725:2717:        (*prev == '(' && (syntax & RE_NO_BK_PARENS || prev_prev_backslash))
23726:2718:        /* After an alternative?  */
23727:2719:        || (*prev == '|'
23728:2720:            && (syntax & RE_NO_BK_VBAR || prev_prev_backslash));
23729:2721:}
23730:2722:
23731:2723:
23732:2724:/* The dual of at_begline_loc_p.  This one is for $.  We assume there is
23733:2725:   at least one character after the $, i.e., `P < PEND'.  */
23734:2726:
23735:2727:static boolean at_endline_loc_p (p, pend, syntax)
23736:2728:const char *p, *pend;
23737:2729:int syntax;
23738:2730:{
23739:2731:    const char *next = p;
23740:2732:    boolean next_backslash = *next == '\\';
23741:2733:    const char *next_next = p + 1 < pend ? p + 1 : 0;
23742:2734:
23743:2735:    return
23744:2736:        /* Before a subexpression?  */
23745:2737:        (syntax & RE_NO_BK_PARENS ? *next == ')'
23746:2738:         : next_backslash && next_next && *next_next == ')')
23747:2739:        /* Before an alternative?  */
23748:2740:        || (syntax & RE_NO_BK_VBAR ? *next == '|'
23749:2741:            : next_backslash && next_next && *next_next == '|');
23750:2742:}
23751:2743:
23752:2744:
23753:2745:/* Returns true if REGNUM is in one of COMPILE_STACK's elements and 
23754:2746:   false if it's not.  */
23755:2747:
23756:2748:static boolean group_in_compile_stack (compile_stack, regnum)
23757:2749:compile_stack_type compile_stack;
23758:2750:regnum_t regnum;
23759:2751:{
23760:2752:    int this_element;
23761:2753:
23762:2754:    for (this_element = compile_stack.avail - 1;
23763:2755:         this_element >= 0; this_element--)
23764:2756:        if (compile_stack.stack[this_element].regnum == regnum)
23765:2757:            return true;
23766:2758:
23767:2759:    return false;
23768:2760:}
23769:2761:
23770:2762:
23771:2763:/* Read the ending character of a range (in a bracket expression) from the
23772:2764:   uncompiled pattern *P_PTR (which ends at PEND).  We assume the
23773:2765:   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
23774:2766:   Then we set the translation of all bits between the starting and
23775:2767:   ending characters (inclusive) in the compiled pattern B.
23776:2768:   
23777:2769:   Return an error code.
23778:2770:   
23779:2771:   We use these short variable names so we can use the same macros as
23780:2772:   `regex_compile' itself.  */
23781:2773:
23782:2774:static reg_errcode_t compile_range (p_ptr, pend, translate, syntax, b)
23783:2775:const char **p_ptr, *pend;
23784:2776:char *translate;
23785:2777:reg_syntax_t syntax;
23786:2778:unsigned char *b;
23787:2779:{
23788:2780:    unsigned this_char;
23789:2781:
23790:2782:    const char *p = *p_ptr;
23791:2783:    int range_start, range_end;
23792:2784:
23793:2785:    if (p == pend)
23794:2786:        return REG_ERANGE;
23795:2787:
23796:2788:    /* Even though the pattern is a signed `char *', we need to fetch
23797:2789:       with unsigned char *'s; if the high bit of the pattern character
23798:2790:       is set, the range endpoints will be negative if we fetch using a
23799:2791:       signed char *.
23800:2792:
23801:2793:       We also want to fetch the endpoints without translating them; the 
23802:2794:       appropriate translation is done in the bit-setting loop below.  */
23803:2795:    /* The SVR4 compiler on the 3B2 had trouble with unsigned const char *.  */
23804:2796:    range_start = ((const unsigned char *) p)[-2];
23805:2797:    range_end = ((const unsigned char *) p)[0];
23806:2798:
23807:2799:    /* Have to increment the pointer into the pattern string, so the
23808:2800:       caller isn't still at the ending character.  */
23809:2801:    (*p_ptr)++;
23810:2802:
23811:2803:    /* If the start is after the end, the range is empty.  */
23812:2804:    if (range_start > range_end)
23813:2805:        return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;
23814:2806:
23815:2807:    /* Here we see why `this_char' has to be larger than an `unsigned
23816:2808:       char' -- the range is inclusive, so if `range_end' == 0xff
23817:2809:       (assuming 8-bit characters), we would otherwise go into an infinite
23818:2810:       loop, since all characters <= 0xff.  */
23819:2811:    for (this_char = range_start; this_char <= range_end; this_char++) {
23820:2812:        SET_LIST_BIT (TRANSLATE (this_char));
23821:2813:    }
23822:2814:
23823:2815:    return REG_NOERROR;
23824:2816:}
23825:2817:
23826:2818:/* re_compile_fastmap computes a ``fastmap'' for the compiled pattern in
23827:2819:   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
23828:2820:   characters can start a string that matches the pattern.  This fastmap
23829:2821:   is used by re_search to skip quickly over impossible starting points.
23830:2822:
23831:2823:   The caller must supply the address of a (1 << BYTEWIDTH)-byte data
23832:2824:   area as BUFP->fastmap.
23833:2825:   
23834:2826:   We set the `fastmap', `fastmap_accurate', and `can_be_null' fields in
23835:2827:   the pattern buffer.
23836:2828:
23837:2829:   Returns 0 if we succeed, -2 if an internal error.   */
23838:2830:
23839:2831:int re_compile_fastmap (bufp)
23840:2832:struct re_pattern_buffer *bufp;
23841:2833:{
23842:2834:    int j, k;
23843:2835:#ifdef MATCH_MAY_ALLOCATE
23844:2836:    fail_stack_type fail_stack;
23845:2837:#endif
23846:2838:#ifndef REGEX_MALLOC
23847:2839:    char *destination;
23848:2840:#endif
23849:2841:    /* We don't push any register information onto the failure stack.  */
23850:2842:    unsigned num_regs = 0;
23851:2843:
23852:2844:    register char *fastmap = bufp->fastmap;
23853:2845:    unsigned char *pattern = bufp->buffer;
23854:2846:    unsigned long size = bufp->used;
23855:2847:    unsigned char *p = pattern;
23856:2848:    register unsigned char *pend = pattern + size;
23857:2849:
23858:2850:    /* This holds the pointer to the failure stack, when
23859:2851:       it is allocated relocatably.  */
23860:2852:#ifdef REL_ALLOC
23861:2853:    fail_stack_elt_t *failure_stack_ptr;
23862:2854:#endif
23863:2855:
23864:2856:    /* Assume that each path through the pattern can be null until
23865:2857:       proven otherwise.  We set this false at the bottom of switch
23866:2858:       statement, to which we get only if a particular path doesn't
23867:2859:       match the empty string.  */
23868:2860:    boolean path_can_be_null = true;
23869:2861:
23870:2862:    /* We aren't doing a `succeed_n' to begin with.  */
23871:2863:    boolean succeed_n_p = false;
23872:2864:
23873:2865:    assert (fastmap != NULL && p != NULL);
23874:2866:
23875:2867:    INIT_FAIL_STACK ();
23876:2868:    bzero (fastmap, 1 << BYTEWIDTH); /* Assume nothing's valid.  */
23877:2869:    bufp->fastmap_accurate = 1; /* It will be when we're done.  */
23878:2870:    bufp->can_be_null = 0;
23879:2871:
23880:2872:    while (1) {
23881:2873:        if (p == pend || *p == succeed) {
23882:2874:            /* We have reached the (effective) end of pattern.  */
23883:2875:            if (!FAIL_STACK_EMPTY ()) {
23884:2876:                bufp->can_be_null |= path_can_be_null;
23885:2877:
23886:2878:                /* Reset for next path.  */
23887:2879:                path_can_be_null = true;
23888:2880:
23889:2881:                p = fail_stack.stack[--fail_stack.avail].pointer;
23890:2882:
23891:2883:                continue;
23892:2884:            } else
23893:2885:                break;
23894:2886:        }
23895:2887:
23896:2888:        /* We should never be about to go beyond the end of the pattern.  */
23897:2889:        assert (p < pend);
23898:2890:
23899:2891:        switch (SWITCH_ENUM_CAST ((re_opcode_t) * p++)) {
23900:2892:
23901:2893:            /* I guess the idea here is to simply not bother with a fastmap
23902:2894:               if a backreference is used, since it's too hard to figure out
23903:2895:               the fastmap for the corresponding group.  Setting
23904:2896:               `can_be_null' stops `re_search_2' from using the fastmap, so
23905:2897:               that is all we do.  */
23906:2898:        case duplicate:
23907:2899:            bufp->can_be_null = 1;
23908:2900:            goto done;
23909:2901:
23910:2902:
23911:2903:            /* Following are the cases which match a character.  These end
23912:2904:               with `break'.  */
23913:2905:
23914:2906:        case exactn:
23915:2907:            fastmap[p[1]] = 1;
23916:2908:            break;
23917:2909:
23918:2910:
23919:2911:        case charset:
23920:2912:            for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
23921:2913:                if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
23922:2914:                    fastmap[j] = 1;
23923:2915:            break;
23924:2916:
23925:2917:
23926:2918:        case charset_not:
23927:2919:            /* Chars beyond end of map must be allowed.  */
23928:2920:            for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
23929:2921:                fastmap[j] = 1;
23930:2922:
23931:2923:            for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
23932:2924:                if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
23933:2925:                    fastmap[j] = 1;
23934:2926:            break;
23935:2927:
23936:2928:
23937:2929:        case wordchar:
23938:2930:            for (j = 0; j < (1 << BYTEWIDTH); j++)
23939:2931:                if (SYNTAX (j) == Sword)
23940:2932:                    fastmap[j] = 1;
23941:2933:            break;
23942:2934:
23943:2935:
23944:2936:        case notwordchar:
23945:2937:            for (j = 0; j < (1 << BYTEWIDTH); j++)
23946:2938:                if (SYNTAX (j) != Sword)
23947:2939:                    fastmap[j] = 1;
23948:2940:            break;
23949:2941:
23950:2942:
23951:2943:        case anychar:
23952:2944:            {
23953:2945:                int fastmap_newline = fastmap['\n'];
23954:2946:
23955:2947:                /* `.' matches anything ...  */
23956:2948:                for (j = 0; j < (1 << BYTEWIDTH); j++)
23957:2949:                    fastmap[j] = 1;
23958:2950:
23959:2951:                /* ... except perhaps newline.  */
23960:2952:                if (!(bufp->syntax & RE_DOT_NEWLINE))
23961:2953:                    fastmap['\n'] = fastmap_newline;
23962:2954:
23963:2955:                /* Return if we have already set `can_be_null'; if we have,
23964:2956:                   then the fastmap is irrelevant.  Something's wrong here.  */
23965:2957:                else if (bufp->can_be_null)
23966:2958:                    goto done;
23967:2959:
23968:2960:                /* Otherwise, have to check alternative paths.  */
23969:2961:                break;
23970:2962:            }
23971:2963:
23972:2964:#ifdef emacs
23973:2965:        case syntaxspec:
23974:2966:            k = *p++;
23975:2967:            for (j = 0; j < (1 << BYTEWIDTH); j++)
23976:2968:                if (SYNTAX (j) == (enum syntaxcode) k)
23977:2969:                    fastmap[j] = 1;
23978:2970:            break;
23979:2971:
23980:2972:
23981:2973:        case notsyntaxspec:
23982:2974:            k = *p++;
23983:2975:            for (j = 0; j < (1 << BYTEWIDTH); j++)
23984:2976:                if (SYNTAX (j) != (enum syntaxcode) k)
23985:2977:                    fastmap[j] = 1;
23986:2978:            break;
23987:2979:
23988:2980:
23989:2981:            /* All cases after this match the empty string.  These end with
23990:2982:               `continue'.  */
23991:2983:
23992:2984:
23993:2985:        case before_dot:
23994:2986:        case at_dot:
23995:2987:        case after_dot:
23996:2988:            continue;
23997:2989:#endif                          /* not emacs */
23998:2990:
23999:2991:
24000:2992:        case no_op:
24001:2993:        case begline:
24002:2994:        case endline:
24003:2995:        case begbuf:
24004:2996:        case endbuf:
24005:2997:        case wordbound:
24006:2998:        case notwordbound:
24007:2999:        case wordbeg:
24008:3000:        case wordend:
24009:3001:        case push_dummy_failure:
24010:3002:            continue;
24011:3003:
24012:3004:
24013:3005:        case jump_n:
24014:3006:        case pop_failure_jump:
24015:3007:        case maybe_pop_jump:
24016:3008:        case jump:
24017:3009:        case jump_past_alt:
24018:3010:        case dummy_failure_jump:
24019:3011:            EXTRACT_NUMBER_AND_INCR (j, p);
24020:3012:            p += j;
24021:3013:            if (j > 0)
24022:3014:                continue;
24023:3015:
24024:3016:            /* Jump backward implies we just went through the body of a
24025:3017:               loop and matched nothing.  Opcode jumped to should be
24026:3018:               `on_failure_jump' or `succeed_n'.  Just treat it like an
24027:3019:               ordinary jump.  For a * loop, it has pushed its failure
24028:3020:               point already; if so, discard that as redundant.  */
24029:3021:            if ((re_opcode_t) * p != on_failure_jump
24030:3022:                && (re_opcode_t) * p != succeed_n)
24031:3023:                continue;
24032:3024:
24033:3025:            p++;
24034:3026:            EXTRACT_NUMBER_AND_INCR (j, p);
24035:3027:            p += j;
24036:3028:
24037:3029:            /* If what's on the stack is where we are now, pop it.  */
24038:3030:            if (!FAIL_STACK_EMPTY ()
24039:3031:                && fail_stack.stack[fail_stack.avail - 1].pointer == p)
24040:3032:                fail_stack.avail--;
24041:3033:
24042:3034:            continue;
24043:3035:
24044:3036:
24045:3037:        case on_failure_jump:
24046:3038:        case on_failure_keep_string_jump:
24047:3039:          handle_on_failure_jump:
24048:3040:            EXTRACT_NUMBER_AND_INCR (j, p);
24049:3041:
24050:3042:            /* For some patterns, e.g., `(a?)?', `p+j' here points to the
24051:3043:               end of the pattern.  We don't want to push such a point,
24052:3044:               since when we restore it above, entering the switch will
24053:3045:               increment `p' past the end of the pattern.  We don't need
24054:3046:               to push such a point since we obviously won't find any more
24055:3047:               fastmap entries beyond `pend'.  Such a pattern can match
24056:3048:               the null string, though.  */
24057:3049:            if (p + j < pend) {
24058:3050:                if (!PUSH_PATTERN_OP (p + j, fail_stack)) {
24059:3051:                    RESET_FAIL_STACK ();
24060:3052:                    return -2;
24061:3053:                }
24062:3054:            } else
24063:3055:                bufp->can_be_null = 1;
24064:3056:
24065:3057:            if (succeed_n_p) {
24066:3058:                EXTRACT_NUMBER_AND_INCR (k, p); /* Skip the n.  */
24067:3059:                succeed_n_p = false;
24068:3060:            }
24069:3061:
24070:3062:            continue;
24071:3063:
24072:3064:
24073:3065:        case succeed_n:
24074:3066:            /* Get to the number of times to succeed.  */
24075:3067:            p += 2;
24076:3068:
24077:3069:            /* Increment p past the n for when k != 0.  */
24078:3070:            EXTRACT_NUMBER_AND_INCR (k, p);
24079:3071:            if (k == 0) {
24080:3072:                p -= 4;
24081:3073:                succeed_n_p = true; /* Spaghetti code alert.  */
24082:3074:                goto handle_on_failure_jump;
24083:3075:            }
24084:3076:            continue;
24085:3077:
24086:3078:
24087:3079:        case set_number_at:
24088:3080:            p += 4;
24089:3081:            continue;
24090:3082:
24091:3083:
24092:3084:        case start_memory:
24093:3085:        case stop_memory:
24094:3086:            p += 2;
24095:3087:            continue;
24096:3088:
24097:3089:
24098:3090:        default:
24099:3091:            abort ();           /* We have listed all the cases.  */
24100:3092:        }                       /* switch *p++ */
24101:3093:
24102:3094:        /* Getting here means we have found the possible starting
24103:3095:           characters for one path of the pattern -- and that the empty
24104:3096:           string does not match.  We need not follow this path further.
24105:3097:           Instead, look at the next alternative (remembered on the
24106:3098:           stack), or quit if no more.  The test at the top of the loop
24107:3099:           does these things.  */
24108:3100:        path_can_be_null = false;
24109:3101:        p = pend;
24110:3102:    }                           /* while p */
24111:3103:
24112:3104:    /* Set `can_be_null' for the last path (also the first path, if the
24113:3105:       pattern is empty).  */
24114:3106:    bufp->can_be_null |= path_can_be_null;
24115:3107:
24116:3108:  done:
24117:3109:    RESET_FAIL_STACK ();
24118:3110:    return 0;
24119:3111:}                               /* re_compile_fastmap */
24120:3112:
24121:3113:/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
24122:3114:   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use
24123:3115:   this memory for recording register information.  STARTS and ENDS
24124:3116:   must be allocated using the malloc library routine, and must each
24125:3117:   be at least NUM_REGS * sizeof (regoff_t) bytes long.
24126:3118:
24127:3119:   If NUM_REGS == 0, then subsequent matches should allocate their own
24128:3120:   register data.
24129:3121:
24130:3122:   Unless this function is called, the first search or match using
24131:3123:   PATTERN_BUFFER will allocate its own register data, without
24132:3124:   freeing the old data.  */
24133:3125:
24134:3126:void re_set_registers (bufp, regs, num_regs, starts, ends)
24135:3127:struct re_pattern_buffer *bufp;
24136:3128:struct re_registers *regs;
24137:3129:unsigned num_regs;
24138:3130:regoff_t *starts, *ends;
24139:3131:{
24140:3132:    if (num_regs) {
24141:3133:        bufp->regs_allocated = REGS_REALLOCATE;
24142:3134:        regs->num_regs = num_regs;
24143:3135:        regs->start = starts;
24144:3136:        regs->end = ends;
24145:3137:    } else {
24146:3138:        bufp->regs_allocated = REGS_UNALLOCATED;
24147:3139:        regs->num_regs = 0;
24148:3140:        regs->start = regs->end = (regoff_t *) 0;
24149:3141:    }
24150:3142:}
24151:3143:
24152:3144:/* Searching routines.  */
24153:3145:
24154:3146:/* Like re_search_2, below, but only one string is specified, and
24155:3147:   doesn't let you say where to stop matching. */
24156:3148:
24157:3149:int re_search (bufp, string, size, startpos, range, regs)
24158:3150:struct re_pattern_buffer *bufp;
24159:3151:const char *string;
24160:3152:int size, startpos, range;
24161:3153:struct re_registers *regs;
24162:3154:{
24163:3155:    return re_search_2 (bufp, NULL, 0, string, size, startpos, range,
24164:3156:                        regs, size);
24165:3157:}
24166:3158:
24167:3159:
24168:3160:/* Using the compiled pattern in BUFP->buffer, first tries to match the
24169:3161:   virtual concatenation of STRING1 and STRING2, starting first at index
24170:3162:   STARTPOS, then at STARTPOS + 1, and so on.
24171:3163:   
24172:3164:   STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.
24173:3165:   
24174:3166:   RANGE is how far to scan while trying to match.  RANGE = 0 means try
24175:3167:   only at STARTPOS; in general, the last start tried is STARTPOS +
24176:3168:   RANGE.
24177:3169:   
24178:3170:   In REGS, return the indices of the virtual concatenation of STRING1
24179:3171:   and STRING2 that matched the entire BUFP->buffer and its contained
24180:3172:   subexpressions.
24181:3173:   
24182:3174:   Do not consider matching one past the index STOP in the virtual
24183:3175:   concatenation of STRING1 and STRING2.
24184:3176:
24185:3177:   We return either the position in the strings at which the match was
24186:3178:   found, -1 if no match, or -2 if error (such as failure
24187:3179:   stack overflow).  */
24188:3180:
24189:3181:int
24190:3182:re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs,
24191:3183:             stop)
24192:3184:struct re_pattern_buffer *bufp;
24193:3185:const char *string1, *string2;
24194:3186:int size1, size2;
24195:3187:int startpos;
24196:3188:int range;
24197:3189:struct re_registers *regs;
24198:3190:int stop;
24199:3191:{
24200:3192:    int val;
24201:3193:    register char *fastmap = bufp->fastmap;
24202:3194:    register char *translate = bufp->translate;
24203:3195:    int total_size = size1 + size2;
24204:3196:    int endpos = startpos + range;
24205:3197:
24206:3198:    /* Check for out-of-range STARTPOS.  */
24207:3199:    if (startpos < 0 || startpos > total_size)
24208:3200:        return -1;
24209:3201:
24210:3202:    /* Fix up RANGE if it might eventually take us outside
24211:3203:       the virtual concatenation of STRING1 and STRING2.  */
24212:3204:    if (endpos < -1)
24213:3205:        range = -1 - startpos;
24214:3206:    else if (endpos > total_size)
24215:3207:        range = total_size - startpos;
24216:3208:
24217:3209:    /* If the search isn't to be a backwards one, don't waste time in a
24218:3210:       search for a pattern that must be anchored.  */
24219:3211:    if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf
24220:3212:        && range > 0) {
24221:3213:        if (startpos > 0)
24222:3214:            return -1;
24223:3215:        else
24224:3216:            range = 1;
24225:3217:    }
24226:3218:
24227:3219:    /* Update the fastmap now if not correct already.  */
24228:3220:    if (fastmap && !bufp->fastmap_accurate)
24229:3221:        if (re_compile_fastmap (bufp) == -2)
24230:3222:            return -2;
24231:3223:
24232:3224:    /* Loop through the string, looking for a place to start matching.  */
24233:3225:    for (;;) {
24234:3226:        /* If a fastmap is supplied, skip quickly over characters that
24235:3227:           cannot be the start of a match.  If the pattern can match the
24236:3228:           null string, however, we don't need to skip characters; we want
24237:3229:           the first null string.  */
24238:3230:        if (fastmap && startpos < total_size && !bufp->can_be_null) {
24239:3231:            if (range > 0) {    /* Searching forwards.  */
24240:3232:                register const char *d;
24241:3233:                register int lim = 0;
24242:3234:                int irange = range;
24243:3235:
24244:3236:                if (startpos < size1 && startpos + range >= size1)
24245:3237:                    lim = range - (size1 - startpos);
24246:3238:
24247:3239:                d = (startpos >=
24248:3240:                     size1 ? string2 - size1 : string1) + startpos;
24249:3241:
24250:3242:                /* Written out as an if-else to avoid testing `translate'
24251:3243:                   inside the loop.  */
24252:3244:                if (translate)
24253:3245:                    while (range > lim && !fastmap[(unsigned char)
24254:3246:                                                   translate[(unsigned
24255:3247:                                                              char) *d++]])
24256:3248:                        range--;
24257:3249:                else
24258:3250:                    while (range > lim && !fastmap[(unsigned char) *d++])
24259:3251:                        range--;
24260:3252:
24261:3253:                startpos += irange - range;
24262:3254:            } else {            /* Searching backwards.  */
24263:3255:
24264:3256:                register char c = (size1 == 0 || startpos >= size1
24265:3257:                                   ? string2[startpos - size1]
24266:3258:                                   : string1[startpos]);
24267:3259:
24268:3260:                if (!fastmap[(unsigned char) TRANSLATE (c)])
24269:3261:                    goto advance;
24270:3262:            }
24271:3263:        }
24272:3264:
24273:3265:        /* If can't match the null string, and that's all we have left, fail.  */
24274:3266:        if (range >= 0 && startpos == total_size && fastmap
24275:3267:            && !bufp->can_be_null)
24276:3268:            return -1;
24277:3269:
24278:3270:        val = re_match_2_internal (bufp, string1, size1, string2, size2,
24279:3271:                                   startpos, regs, stop);
24280:3272:#ifndef REGEX_MALLOC
24281:3273:#ifdef C_ALLOCA
24282:3274:        alloca (0);
24283:3275:#endif
24284:3276:#endif
24285:3277:
24286:3278:        if (val >= 0)
24287:3279:            return startpos;
24288:3280:
24289:3281:        if (val == -2)
24290:3282:            return -2;
24291:3283:
24292:3284:      advance:
24293:3285:        if (!range)
24294:3286:            break;
24295:3287:        else if (range > 0) {
24296:3288:            range--;
24297:3289:            startpos++;
24298:3290:        } else {
24299:3291:            range++;
24300:3292:            startpos--;
24301:3293:        }
24302:3294:    }
24303:3295:    return -1;
24304:3296:}                               /* re_search_2 */
24305:3297:
24306:3298:/* Declarations and macros for re_match_2.  */
24307:3299:
24308:3300:static int bcmp_translate ();
24309:3301:static boolean alt_match_null_string_p (),
24310:3302:common_op_match_null_string_p (), group_match_null_string_p ();
24311:3303:
24312:3304:/* This converts PTR, a pointer into one of the search strings `string1'
24313:3305:   and `string2' into an offset from the beginning of that string.  */
24314:3306:#define POINTER_TO_OFFSET(ptr)                        \
24315:3307:  (FIRST_STRING_P (ptr)                                \
24316:3308:   ? ((regoff_t) ((ptr) - string1))                \
24317:3309:   : ((regoff_t) ((ptr) - string2 + size1)))
24318:3310:
24319:3311:/* Macros for dealing with the split strings in re_match_2.  */
24320:3312:
24321:3313:#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
24322:3314:
24323:3315:/* Call before fetching a character with *d.  This switches over to
24324:3316:   string2 if necessary.  */
24325:3317:#define PREFETCH()                                                        \
24326:3318:  while (d == dend)                                                            \
24327:3319:    {                                                                        \
24328:3320:      /* End of string2 => fail.  */                                        \
24329:3321:      if (dend == end_match_2)                                                 \
24330:3322:        goto fail;                                                        \
24331:3323:      /* End of string1 => advance to string2.  */                         \
24332:3324:      d = string2;                                                        \
24333:3325:      dend = end_match_2;                                                \
24334:3326:    }
24335:3327:
24336:3328:
24337:3329:/* Test if at very beginning or at very end of the virtual concatenation
24338:3330:   of `string1' and `string2'.  If only one string, it's `string2'.  */
24339:3331:#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
24340:3332:#define AT_STRINGS_END(d) ((d) == end2)
24341:3333:
24342:3334:
24343:3335:/* Test if D points to a character which is word-constituent.  We have
24344:3336:   two special cases to check for: if past the end of string1, look at
24345:3337:   the first character in string2; and if before the beginning of
24346:3338:   string2, look at the last character in string1.  */
24347:3339:#define WORDCHAR_P(d)                                                        \
24348:3340:  (SYNTAX ((d) == end1 ? *string2                                        \
24349:3341:           : (d) == string2 - 1 ? *(end1 - 1) : *(d))                        \
24350:3342:   == Sword)
24351:3343:
24352:3344:/* Test if the character before D and the one at D differ with respect
24353:3345:   to being word-constituent.  */
24354:3346:#define AT_WORD_BOUNDARY(d)                                                \
24355:3347:  (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)                                \
24356:3348:   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
24357:3349:
24358:3350:
24359:3351:/* Free everything we malloc.  */
24360:3352:#ifdef MATCH_MAY_ALLOCATE
24361:3353:#define FREE_VAR(var) if (var) REGEX_FREE (var); var = NULL
24362:3354:#define FREE_VARIABLES()                                                \
24363:3355:  do {                                                                        \
24364:3356:    REGEX_FREE_STACK (fail_stack.stack);                                \
24365:3357:    FREE_VAR (regstart);                                                \
24366:3358:    FREE_VAR (regend);                                                        \
24367:3359:    FREE_VAR (old_regstart);                                                \
24368:3360:    FREE_VAR (old_regend);                                                \
24369:3361:    FREE_VAR (best_regstart);                                                \
24370:3362:    FREE_VAR (best_regend);                                                \
24371:3363:    FREE_VAR (reg_info);                                                \
24372:3364:    FREE_VAR (reg_dummy);                                                \
24373:3365:    FREE_VAR (reg_info_dummy);                                                \
24374:3366:  } while (0)
24375:3367:#else
24376:3368:#define FREE_VARIABLES() ((void)0) /* Do nothing!  But inhibit gcc warning.  */
24377:3369:#endif                          /* not MATCH_MAY_ALLOCATE */
24378:3370:
24379:3371:/* These values must meet several constraints.  They must not be valid
24380:3372:   register values; since we have a limit of 255 registers (because
24381:3373:   we use only one byte in the pattern for the register number), we can
24382:3374:   use numbers larger than 255.  They must differ by 1, because of
24383:3375:   NUM_FAILURE_ITEMS above.  And the value for the lowest register must
24384:3376:   be larger than the value for the highest register, so we do not try
24385:3377:   to actually save any registers when none are active.  */
24386:3378:#define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
24387:3379:#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
24388:3380:
24389:3381:/* Matching routines.  */
24390:3382:
24391:3383:#ifndef emacs                   /* Emacs never uses this.  */
24392:3384:/* re_match is like re_match_2 except it takes only a single string.  */
24393:3385:
24394:3386:int re_match (bufp, string, size, pos, regs)
24395:3387:struct re_pattern_buffer *bufp;
24396:3388:const char *string;
24397:3389:int size, pos;
24398:3390:struct re_registers *regs;
24399:3391:{
24400:3392:    int result = re_match_2_internal (bufp, NULL, 0, string, size,
24401:3393:                                      pos, regs, size);
24402:3394:#ifndef REGEX_MALLOC
24403:3395:    alloca (0);
24404:3396:#endif
24405:3397:    return result;
24406:3398:}
24407:3399:#endif                          /* not emacs */
24408:3400:
24409:3401:
24410:3402:/* re_match_2 matches the compiled pattern in BUFP against the
24411:3403:   the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1
24412:3404:   and SIZE2, respectively).  We start matching at POS, and stop
24413:3405:   matching at STOP.
24414:3406:   
24415:3407:   If REGS is non-null and the `no_sub' field of BUFP is nonzero, we
24416:3408:   store offsets for the substring each group matched in REGS.  See the
24417:3409:   documentation for exactly how many groups we fill.
24418:3410:
24419:3411:   We return -1 if no match, -2 if an internal error (such as the
24420:3412:   failure stack overflowing).  Otherwise, we return the length of the
24421:3413:   matched substring.  */
24422:3414:
24423:3415:int re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
24424:3416:struct re_pattern_buffer *bufp;
24425:3417:const char *string1, *string2;
24426:3418:int size1, size2;
24427:3419:int pos;
24428:3420:struct re_registers *regs;
24429:3421:int stop;
24430:3422:{
24431:3423:    int result = re_match_2_internal (bufp, string1, size1, string2, size2,
24432:3424:                                      pos, regs, stop);
24433:3425:#ifndef REGEX_MALLOC
24434:3426:    alloca (0);
24435:3427:#endif
24436:3428:    return result;
24437:3429:}
24438:3430:
24439:3431:/* This is a separate function so that we can force an alloca cleanup
24440:3432:   afterwards.  */
24441:3433:static int
24442:3434:re_match_2_internal (bufp, string1, size1, string2, size2, pos, regs, stop)
24443:3435:struct re_pattern_buffer *bufp;
24444:3436:const char *string1, *string2;
24445:3437:int size1, size2;
24446:3438:int pos;
24447:3439:struct re_registers *regs;
24448:3440:int stop;
24449:3441:{
24450:3442:    /* General temporaries.  */
24451:3443:    int mcnt;
24452:3444:    unsigned char *p1;
24453:3445:
24454:3446:    /* Just past the end of the corresponding string.  */
24455:3447:    const char *end1, *end2;
24456:3448:
24457:3449:    /* Pointers into string1 and string2, just past the last characters in
24458:3450:       each to consider matching.  */
24459:3451:    const char *end_match_1, *end_match_2;
24460:3452:
24461:3453:    /* Where we are in the data, and the end of the current string.  */
24462:3454:    const char *d, *dend;
24463:3455:
24464:3456:    /* Where we are in the pattern, and the end of the pattern.  */
24465:3457:    unsigned char *p = bufp->buffer;
24466:3458:    register unsigned char *pend = p + bufp->used;
24467:3459:
24468:3460:    /* Mark the opcode just after a start_memory, so we can test for an
24469:3461:       empty subpattern when we get to the stop_memory.  */
24470:3462:    unsigned char *just_past_start_mem = 0;
24471:3463:
24472:3464:    /* We use this to map every character in the string.  */
24473:3465:    char *translate = bufp->translate;
24474:3466:
24475:3467:    /* Failure point stack.  Each place that can handle a failure further
24476:3468:       down the line pushes a failure point on this stack.  It consists of
24477:3469:       restart, regend, and reg_info for all registers corresponding to
24478:3470:       the subexpressions we're currently inside, plus the number of such
24479:3471:       registers, and, finally, two char *'s.  The first char * is where
24480:3472:       to resume scanning the pattern; the second one is where to resume
24481:3473:       scanning the strings.  If the latter is zero, the failure point is
24482:3474:       a ``dummy''; if a failure happens and the failure point is a dummy,
24483:3475:       it gets discarded and the next next one is tried.  */
24484:3476:#ifdef MATCH_MAY_ALLOCATE       /* otherwise, this is global.  */
24485:3477:    fail_stack_type fail_stack;
24486:3478:#endif
24487:3479:#ifdef DEBUG
24488:3480:    static unsigned failure_id = 0;
24489:3481:    unsigned nfailure_points_pushed = 0, nfailure_points_popped = 0;
24490:3482:#endif
24491:3483:
24492:3484:    /* This holds the pointer to the failure stack, when
24493:3485:       it is allocated relocatably.  */
24494:3486:#ifdef REL_ALLOC
24495:3487:    fail_stack_elt_t *failure_stack_ptr;
24496:3488:#endif
24497:3489:
24498:3490:    /* We fill all the registers internally, independent of what we
24499:3491:       return, for use in backreferences.  The number here includes
24500:3492:       an element for register zero.  */
24501:3493:    unsigned num_regs = bufp->re_nsub + 1;
24502:3494:
24503:3495:    /* The currently active registers.  */
24504:3496:    unsigned lowest_active_reg = NO_LOWEST_ACTIVE_REG;
24505:3497:    unsigned highest_active_reg = NO_HIGHEST_ACTIVE_REG;
24506:3498:
24507:3499:    /* Information on the contents of registers. These are pointers into
24508:3500:       the input strings; they record just what was matched (on this
24509:3501:       attempt) by a subexpression part of the pattern, that is, the
24510:3502:       regnum-th regstart pointer points to where in the pattern we began
24511:3503:       matching and the regnum-th regend points to right after where we
24512:3504:       stopped matching the regnum-th subexpression.  (The zeroth register
24513:3505:       keeps track of what the whole pattern matches.)  */
24514:3506:#ifdef MATCH_MAY_ALLOCATE       /* otherwise, these are global.  */
24515:3507:    const char **regstart, **regend;
24516:3508:#endif
24517:3509:
24518:3510:    /* If a group that's operated upon by a repetition operator fails to
24519:3511:       match anything, then the register for its start will need to be
24520:3512:       restored because it will have been set to wherever in the string we
24521:3513:       are when we last see its open-group operator.  Similarly for a
24522:3514:       register's end.  */
24523:3515:#ifdef MATCH_MAY_ALLOCATE       /* otherwise, these are global.  */
24524:3516:    const char **old_regstart, **old_regend;
24525:3517:#endif
24526:3518:
24527:3519:    /* The is_active field of reg_info helps us keep track of which (possibly
24528:3520:       nested) subexpressions we are currently in. The matched_something
24529:3521:       field of reg_info[reg_num] helps us tell whether or not we have
24530:3522:       matched any of the pattern so far this time through the reg_num-th
24531:3523:       subexpression.  These two fields get reset each time through any
24532:3524:       loop their register is in.  */
24533:3525:#ifdef MATCH_MAY_ALLOCATE       /* otherwise, this is global.  */
24534:3526:    register_info_type *reg_info;
24535:3527:#endif
24536:3528:
24537:3529:    /* The following record the register info as found in the above
24538:3530:       variables when we find a match better than any we've seen before. 
24539:3531:       This happens as we backtrack through the failure points, which in
24540:3532:       turn happens only if we have not yet matched the entire string. */
24541:3533:    unsigned best_regs_set = false;
24542:3534:#ifdef MATCH_MAY_ALLOCATE       /* otherwise, these are global.  */
24543:3535:    const char **best_regstart, **best_regend;
24544:3536:#endif
24545:3537:
24546:3538:    /* Logically, this is `best_regend[0]'.  But we don't want to have to
24547:3539:       allocate space for that if we're not allocating space for anything
24548:3540:       else (see below).  Also, we never need info about register 0 for
24549:3541:       any of the other register vectors, and it seems rather a kludge to
24550:3542:       treat `best_regend' differently than the rest.  So we keep track of
24551:3543:       the end of the best match so far in a separate variable.  We
24552:3544:       initialize this to NULL so that when we backtrack the first time
24553:3545:       and need to test it, it's not garbage.  */
24554:3546:    const char *match_end = NULL;
24555:3547:
24556:3548:    /* This helps SET_REGS_MATCHED avoid doing redundant work.  */
24557:3549:    int set_regs_matched_done = 0;
24558:3550:
24559:3551:    /* Used when we pop values we don't care about.  */
24560:3552:#ifdef MATCH_MAY_ALLOCATE       /* otherwise, these are global.  */
24561:3553:    const char **reg_dummy;
24562:3554:    register_info_type *reg_info_dummy;
24563:3555:#endif
24564:3556:
24565:3557:#ifdef DEBUG
24566:3558:    /* Counts the total number of registers pushed.  */
24567:3559:    unsigned num_regs_pushed = 0;
24568:3560:#endif
24569:3561:
24570:3562:    DEBUG_PRINT1 ("\n\nEntering re_match_2.\n");
24571:3563:
24572:3564:    INIT_FAIL_STACK ();
24573:3565:
24574:3566:#ifdef MATCH_MAY_ALLOCATE
24575:3567:    /* Do not bother to initialize all the register variables if there are
24576:3568:       no groups in the pattern, as it takes a fair amount of time.  If
24577:3569:       there are groups, we include space for register 0 (the whole
24578:3570:       pattern), even though we never use it, since it simplifies the
24579:3571:       array indexing.  We should fix this.  */
24580:3572:    if (bufp->re_nsub) {
24581:3573:        regstart = REGEX_TALLOC (num_regs, const char *);
24582:3574:        regend = REGEX_TALLOC (num_regs, const char *);
24583:3575:        old_regstart = REGEX_TALLOC (num_regs, const char *);
24584:3576:        old_regend = REGEX_TALLOC (num_regs, const char *);
24585:3577:        best_regstart = REGEX_TALLOC (num_regs, const char *);
24586:3578:        best_regend = REGEX_TALLOC (num_regs, const char *);
24587:3579:        reg_info = REGEX_TALLOC (num_regs, register_info_type);
24588:3580:        reg_dummy = REGEX_TALLOC (num_regs, const char *);
24589:3581:        reg_info_dummy = REGEX_TALLOC (num_regs, register_info_type);
24590:3582:
24591:3583:        if (!(regstart && regend && old_regstart && old_regend && reg_info
24592:3584:              && best_regstart && best_regend && reg_dummy
24593:3585:              && reg_info_dummy)) {
24594:3586:            FREE_VARIABLES ();
24595:3587:            return -2;
24596:3588:        }
24597:3589:    } else {
24598:3590:        /* We must initialize all our variables to NULL, so that
24599:3591:           `FREE_VARIABLES' doesn't try to free them.  */
24600:3592:        regstart = regend = old_regstart = old_regend = best_regstart
24601:3593:            = best_regend = reg_dummy = NULL;
24602:3594:        reg_info = reg_info_dummy = (register_info_type *) NULL;
24603:3595:    }
24604:3596:#endif                          /* MATCH_MAY_ALLOCATE */
24605:3597:
24606:3598:    /* The starting position is bogus.  */
24607:3599:    if (pos < 0 || pos > size1 + size2) {
24608:3600:        FREE_VARIABLES ();
24609:3601:        return -1;
24610:3602:    }
24611:3603:
24612:3604:    /* Initialize subexpression text positions to -1 to mark ones that no
24613:3605:       start_memory/stop_memory has been seen for. Also initialize the
24614:3606:       register information struct.  */
24615:3607:    for (mcnt = 1; mcnt < num_regs; mcnt++) {
24616:3608:        regstart[mcnt] = regend[mcnt]
24617:3609:            = old_regstart[mcnt] = old_regend[mcnt] = REG_UNSET_VALUE;
24618:3610:
24619:3611:        REG_MATCH_NULL_STRING_P (reg_info[mcnt]) = MATCH_NULL_UNSET_VALUE;
24620:3612:        IS_ACTIVE (reg_info[mcnt]) = 0;
24621:3613:        MATCHED_SOMETHING (reg_info[mcnt]) = 0;
24622:3614:        EVER_MATCHED_SOMETHING (reg_info[mcnt]) = 0;
24623:3615:    }
24624:3616:
24625:3617:    /* We move `string1' into `string2' if the latter's empty -- but not if
24626:3618:       `string1' is null.  */
24627:3619:    if (size2 == 0 && string1 != NULL) {
24628:3620:        string2 = string1;
24629:3621:        size2 = size1;
24630:3622:        string1 = 0;
24631:3623:        size1 = 0;
24632:3624:    }
24633:3625:    end1 = string1 + size1;
24634:3626:    end2 = string2 + size2;
24635:3627:
24636:3628:    /* Compute where to stop matching, within the two strings.  */
24637:3629:    if (stop <= size1) {
24638:3630:        end_match_1 = string1 + stop;
24639:3631:        end_match_2 = string2;
24640:3632:    } else {
24641:3633:        end_match_1 = end1;
24642:3634:        end_match_2 = string2 + stop - size1;
24643:3635:    }
24644:3636:
24645:3637:    /* `p' scans through the pattern as `d' scans through the data. 
24646:3638:       `dend' is the end of the input string that `d' points within.  `d'
24647:3639:       is advanced into the following input string whenever necessary, but
24648:3640:       this happens before fetching; therefore, at the beginning of the
24649:3641:       loop, `d' can be pointing at the end of a string, but it cannot
24650:3642:       equal `string2'.  */
24651:3643:    if (size1 > 0 && pos <= size1) {
24652:3644:        d = string1 + pos;
24653:3645:        dend = end_match_1;
24654:3646:    } else {
24655:3647:        d = string2 + pos - size1;
24656:3648:        dend = end_match_2;
24657:3649:    }
24658:3650:
24659:3651:    DEBUG_PRINT1 ("The compiled pattern is: ");
24660:3652:    DEBUG_PRINT_COMPILED_PATTERN (bufp, p, pend);
24661:3653:    DEBUG_PRINT1 ("The string to match is: `");
24662:3654:    DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);
24663:3655:    DEBUG_PRINT1 ("'\n");
24664:3656:
24665:3657:    /* This loops over pattern commands.  It exits by returning from the
24666:3658:       function if the match is complete, or it drops through if the match
24667:3659:       fails at this starting point in the input data.  */
24668:3660:    for (;;) {
24669:3661:        DEBUG_PRINT2 ("\n0x%x: ", p);
24670:3662:
24671:3663:        if (p == pend) {        /* End of pattern means we might have succeeded.  */
24672:3664:            DEBUG_PRINT1 ("end of pattern ... ");
24673:3665:
24674:3666:            /* If we haven't matched the entire string, and we want the
24675:3667:               longest match, try backtracking.  */
24676:3668:            if (d != end_match_2) {
24677:3669:                /* 1 if this match ends in the same string (string1 or string2)
24678:3670:                   as the best previous match.  */
24679:3671:                boolean same_str_p = (FIRST_STRING_P (match_end)
24680:3672:                                      == MATCHING_IN_FIRST_STRING);
24681:3673:                /* 1 if this match is the best seen so far.  */
24682:3674:                boolean best_match_p;
24683:3675:
24684:3676:                /* AIX compiler got confused when this was combined
24685:3677:                   with the previous declaration.  */
24686:3678:                if (same_str_p)
24687:3679:                    best_match_p = d > match_end;
24688:3680:                else
24689:3681:                    best_match_p = !MATCHING_IN_FIRST_STRING;
24690:3682:
24691:3683:                DEBUG_PRINT1 ("backtracking.\n");
24692:3684:
24693:3685:                if (!FAIL_STACK_EMPTY ()) { /* More failure points to try.  */
24694:3686:
24695:3687:                    /* If exceeds best match so far, save it.  */
24696:3688:                    if (!best_regs_set || best_match_p) {
24697:3689:                        best_regs_set = true;
24698:3690:                        match_end = d;
24699:3691:
24700:3692:                        DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
24701:3693:
24702:3694:                        for (mcnt = 1; mcnt < num_regs; mcnt++) {
24703:3695:                            best_regstart[mcnt] = regstart[mcnt];
24704:3696:                            best_regend[mcnt] = regend[mcnt];
24705:3697:                        }
24706:3698:                    }
24707:3699:                    goto fail;
24708:3700:                }
24709:3701:
24710:3702:                /* If no failure points, don't restore garbage.  And if
24711:3703:                   last match is real best match, don't restore second
24712:3704:                   best one. */
24713:3705:                else if (best_regs_set && !best_match_p) {
24714:3706:                  restore_best_regs:
24715:3707:                    /* Restore best match.  It may happen that `dend ==
24716:3708:                       end_match_1' while the restored d is in string2.
24717:3709:                       For example, the pattern `x.*y.*z' against the
24718:3710:                       strings `x-' and `y-z-', if the two strings are
24719:3711:                       not consecutive in memory.  */
24720:3712:                    DEBUG_PRINT1 ("Restoring best registers.\n");
24721:3713:
24722:3714:                    d = match_end;
24723:3715:                    dend = ((d >= string1 && d <= end1)
24724:3716:                            ? end_match_1 : end_match_2);
24725:3717:
24726:3718:                    for (mcnt = 1; mcnt < num_regs; mcnt++) {
24727:3719:                        regstart[mcnt] = best_regstart[mcnt];
24728:3720:                        regend[mcnt] = best_regend[mcnt];
24729:3721:                    }
24730:3722:                }
24731:3723:            }
24732:3724:            /* d != end_match_2 */
24733:3725:          succeed_label:
24734:3726:            DEBUG_PRINT1 ("Accepting match.\n");
24735:3727:
24736:3728:            /* If caller wants register contents data back, do it.  */
24737:3729:            if (regs && !bufp->no_sub) {
24738:3730:                /* Have the register data arrays been allocated?  */
24739:3731:                if (bufp->regs_allocated == REGS_UNALLOCATED) { /* No.  So allocate them with malloc.  We need one
24740:3732:                                                                   extra element beyond `num_regs' for the `-1' marker
24741:3733:                                                                   GNU code uses.  */
24742:3734:                    regs->num_regs = MAX (RE_NREGS, num_regs + 1);
24743:3735:                    regs->start = TALLOC (regs->num_regs, regoff_t);
24744:3736:                    regs->end = TALLOC (regs->num_regs, regoff_t);
24745:3737:                    if (regs->start == NULL || regs->end == NULL) {
24746:3738:                        FREE_VARIABLES ();
24747:3739:                        return -2;
24748:3740:                    }
24749:3741:                    bufp->regs_allocated = REGS_REALLOCATE;
24750:3742:                } else if (bufp->regs_allocated == REGS_REALLOCATE) { /* Yes.  If we need more elements than were already
24751:3743:                                                                         allocated, reallocate them.  If we need fewer, just
24752:3744:                                                                         leave it alone.  */
24753:3745:                    if (regs->num_regs < num_regs + 1) {
24754:3746:                        regs->num_regs = num_regs + 1;
24755:3747:                        RETALLOC (regs->start, regs->num_regs, regoff_t);
24756:3748:                        RETALLOC (regs->end, regs->num_regs, regoff_t);
24757:3749:                        if (regs->start == NULL || regs->end == NULL) {
24758:3750:                            FREE_VARIABLES ();
24759:3751:                            return -2;
24760:3752:                        }
24761:3753:                    }
24762:3754:                } else {
24763:3755:                    /* These braces fend off a "empty body in an else-statement"
24764:3756:                       warning under GCC when assert expands to nothing.  */
24765:3757:                    assert (bufp->regs_allocated == REGS_FIXED);
24766:3758:                }
24767:3759:
24768:3760:                /* Convert the pointer data in `regstart' and `regend' to
24769:3761:                   indices.  Register zero has to be set differently,
24770:3762:                   since we haven't kept track of any info for it.  */
24771:3763:                if (regs->num_regs > 0) {
24772:3764:                    regs->start[0] = pos;
24773:3765:                    regs->end[0] = (MATCHING_IN_FIRST_STRING
24774:3766:                                    ? ((regoff_t) (d - string1))
24775:3767:                                    : ((regoff_t) (d - string2 + size1)));
24776:3768:                }
24777:3769:
24778:3770:                /* Go through the first `min (num_regs, regs->num_regs)'
24779:3771:                   registers, since that is all we initialized.  */
24780:3772:                for (mcnt = 1; mcnt < MIN (num_regs, regs->num_regs);
24781:3773:                     mcnt++) {
24782:3774:                    if (REG_UNSET (regstart[mcnt])
24783:3775:                        || REG_UNSET (regend[mcnt]))
24784:3776:                        regs->start[mcnt] = regs->end[mcnt] = -1;
24785:3777:                    else {
24786:3778:                        regs->start[mcnt]
24787:3779:                            = (regoff_t)
24788:3780:                            POINTER_TO_OFFSET (regstart[mcnt]);
24789:3781:                        regs->end[mcnt]
24790:3782:                            = (regoff_t) POINTER_TO_OFFSET (regend[mcnt]);
24791:3783:                    }
24792:3784:                }
24793:3785:
24794:3786:                /* If the regs structure we return has more elements than
24795:3787:                   were in the pattern, set the extra elements to -1.  If
24796:3788:                   we (re)allocated the registers, this is the case,
24797:3789:                   because we always allocate enough to have at least one
24798:3790:                   -1 at the end.  */
24799:3791:                for (mcnt = num_regs; mcnt < regs->num_regs; mcnt++)
24800:3792:                    regs->start[mcnt] = regs->end[mcnt] = -1;
24801:3793:            }
24802:3794:            /* regs && !bufp->no_sub */
24803:3795:            DEBUG_PRINT4
24804:3796:                ("%u failure points pushed, %u popped (%u remain).\n",
24805:3797:                 nfailure_points_pushed, nfailure_points_popped,
24806:3798:                 nfailure_points_pushed - nfailure_points_popped);
24807:3799:            DEBUG_PRINT2 ("%u registers pushed.\n", num_regs_pushed);
24808:3800:
24809:3801:            mcnt = d - pos - (MATCHING_IN_FIRST_STRING
24810:3802:                              ? string1 : string2 - size1);
24811:3803:
24812:3804:            DEBUG_PRINT2 ("Returning %d from re_match_2.\n", mcnt);
24813:3805:
24814:3806:            FREE_VARIABLES ();
24815:3807:            return mcnt;
24816:3808:        }
24817:3809:
24818:3810:        /* Otherwise match next pattern command.  */
24819:3811:        switch (SWITCH_ENUM_CAST ((re_opcode_t) * p++)) {
24820:3812:            /* Ignore these.  Used to ignore the n of succeed_n's which
24821:3813:               currently have n == 0.  */
24822:3814:        case no_op:
24823:3815:            DEBUG_PRINT1 ("EXECUTING no_op.\n");
24824:3816:            break;
24825:3817:
24826:3818:        case succeed:
24827:3819:            DEBUG_PRINT1 ("EXECUTING succeed.\n");
24828:3820:            goto succeed_label;
24829:3821:
24830:3822:            /* Match the next n pattern characters exactly.  The following
24831:3823:               byte in the pattern defines n, and the n bytes after that
24832:3824:               are the characters to match.  */
24833:3825:        case exactn:
24834:3826:            mcnt = *p++;
24835:3827:            DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);
24836:3828:
24837:3829:            /* This is written out as an if-else so we don't waste time
24838:3830:               testing `translate' inside the loop.  */
24839:3831:            if (translate) {
24840:3832:                do {
24841:3833:                    PREFETCH ();
24842:3834:                    if (translate[(unsigned char) *d++] != (char) *p++)
24843:3835:                        goto fail;
24844:3836:                }
24845:3837:                while (--mcnt);
24846:3838:            } else {
24847:3839:                do {
24848:3840:                    PREFETCH ();
24849:3841:                    if (*d++ != (char) *p++)
24850:3842:                        goto fail;
24851:3843:                }
24852:3844:                while (--mcnt);
24853:3845:            }
24854:3846:            SET_REGS_MATCHED ();
24855:3847:            break;
24856:3848:
24857:3849:
24858:3850:            /* Match any character except possibly a newline or a null.  */
24859:3851:        case anychar:
24860:3852:            DEBUG_PRINT1 ("EXECUTING anychar.\n");
24861:3853:
24862:3854:            PREFETCH ();
24863:3855:
24864:3856:            if ((!(bufp->syntax & RE_DOT_NEWLINE)
24865:3857:                 && TRANSLATE (*d) == '\n')
24866:3858:                || (bufp->syntax & RE_DOT_NOT_NULL
24867:3859:                    && TRANSLATE (*d) == '\000'))
24868:3860:                goto fail;
24869:3861:
24870:3862:            SET_REGS_MATCHED ();
24871:3863:            DEBUG_PRINT2 ("  Matched `%d'.\n", *d);
24872:3864:            d++;
24873:3865:            break;
24874:3866:
24875:3867:
24876:3868:        case charset:
24877:3869:        case charset_not:
24878:3870:            {
24879:3871:                register unsigned char c;
24880:3872:                boolean not = (re_opcode_t) * (p - 1) == charset_not;
24881:3873:
24882:3874:                DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
24883:3875:
24884:3876:                PREFETCH ();
24885:3877:                c = TRANSLATE (*d); /* The character to match.  */
24886:3878:
24887:3879:                /* Cast to `unsigned' instead of `unsigned char' in case the
24888:3880:                   bit list is a full 32 bytes long.  */
24889:3881:                if (c < (unsigned) (*p * BYTEWIDTH)
24890:3882:                    && p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
24891:3883:                    not = !not;
24892:3884:
24893:3885:                p += 1 + *p;
24894:3886:
24895:3887:                if (!not)
24896:3888:                    goto fail;
24897:3889:
24898:3890:                SET_REGS_MATCHED ();
24899:3891:                d++;
24900:3892:                break;
24901:3893:            }
24902:3894:
24903:3895:
24904:3896:            /* The beginning of a group is represented by start_memory.
24905:3897:               The arguments are the register number in the next byte, and the
24906:3898:               number of groups inner to this one in the next.  The text
24907:3899:               matched within the group is recorded (in the internal
24908:3900:               registers data structure) under the register number.  */
24909:3901:        case start_memory:
24910:3902:            DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
24911:3903:
24912:3904:            /* Find out if this group can match the empty string.  */
24913:3905:            p1 = p;             /* To send to group_match_null_string_p.  */
24914:3906:
24915:3907:            if (REG_MATCH_NULL_STRING_P (reg_info[*p]) ==
24916:3908:                MATCH_NULL_UNSET_VALUE)
24917:3909:                REG_MATCH_NULL_STRING_P (reg_info[*p])
24918:3910:                    = group_match_null_string_p (&p1, pend, reg_info);
24919:3911:
24920:3912:            /* Save the position in the string where we were the last time
24921:3913:               we were at this open-group operator in case the group is
24922:3914:               operated upon by a repetition operator, e.g., with `(a*)*b'
24923:3915:               against `ab'; then we want to ignore where we are now in
24924:3916:               the string in case this attempt to match fails.  */
24925:3917:            old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
24926:3918:                ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
24927:3919:                : regstart[*p];
24928:3920:            DEBUG_PRINT2 ("  old_regstart: %d\n",
24929:3921:                          POINTER_TO_OFFSET (old_regstart[*p]));
24930:3922:
24931:3923:            regstart[*p] = d;
24932:3924:            DEBUG_PRINT2 ("  regstart: %d\n",
24933:3925:                          POINTER_TO_OFFSET (regstart[*p]));
24934:3926:
24935:3927:            IS_ACTIVE (reg_info[*p]) = 1;
24936:3928:            MATCHED_SOMETHING (reg_info[*p]) = 0;
24937:3929:
24938:3930:            /* Clear this whenever we change the register activity status.  */
24939:3931:            set_regs_matched_done = 0;
24940:3932:
24941:3933:            /* This is the new highest active register.  */
24942:3934:            highest_active_reg = *p;
24943:3935:
24944:3936:            /* If nothing was active before, this is the new lowest active
24945:3937:               register.  */
24946:3938:            if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
24947:3939:                lowest_active_reg = *p;
24948:3940:
24949:3941:            /* Move past the register number and inner group count.  */
24950:3942:            p += 2;
24951:3943:            just_past_start_mem = p;
24952:3944:
24953:3945:            break;
24954:3946:
24955:3947:
24956:3948:            /* The stop_memory opcode represents the end of a group.  Its
24957:3949:               arguments are the same as start_memory's: the register
24958:3950:               number, and the number of inner groups.  */
24959:3951:        case stop_memory:
24960:3952:            DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
24961:3953:
24962:3954:            /* We need to save the string position the last time we were at
24963:3955:               this close-group operator in case the group is operated
24964:3956:               upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
24965:3957:               against `aba'; then we want to ignore where we are now in
24966:3958:               the string in case this attempt to match fails.  */
24967:3959:            old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
24968:3960:                ? REG_UNSET (regend[*p]) ? d : regend[*p]
24969:3961:                : regend[*p];
24970:3962:            DEBUG_PRINT2 ("      old_regend: %d\n",
24971:3963:                          POINTER_TO_OFFSET (old_regend[*p]));
24972:3964:
24973:3965:            regend[*p] = d;
24974:3966:            DEBUG_PRINT2 ("      regend: %d\n",
24975:3967:                          POINTER_TO_OFFSET (regend[*p]));
24976:3968:
24977:3969:            /* This register isn't active anymore.  */
24978:3970:            IS_ACTIVE (reg_info[*p]) = 0;
24979:3971:
24980:3972:            /* Clear this whenever we change the register activity status.  */
24981:3973:            set_regs_matched_done = 0;
24982:3974:
24983:3975:            /* If this was the only register active, nothing is active
24984:3976:               anymore.  */
24985:3977:            if (lowest_active_reg == highest_active_reg) {
24986:3978:                lowest_active_reg = NO_LOWEST_ACTIVE_REG;
24987:3979:                highest_active_reg = NO_HIGHEST_ACTIVE_REG;
24988:3980:            } else {            /* We must scan for the new highest active register, since
24989:3981:                                   it isn't necessarily one less than now: consider
24990:3982:                                   (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
24991:3983:                                   new highest active register is 1.  */
24992:3984:                unsigned char r = *p - 1;
24993:3985:                while (r > 0 && !IS_ACTIVE (reg_info[r]))
24994:3986:                    r--;
24995:3987:
24996:3988:                /* If we end up at register zero, that means that we saved
24997:3989:                   the registers as the result of an `on_failure_jump', not
24998:3990:                   a `start_memory', and we jumped to past the innermost
24999:3991:                   `stop_memory'.  For example, in ((.)*) we save
25000:3992:                   registers 1 and 2 as a result of the *, but when we pop
25001:3993:                   back to the second ), we are at the stop_memory 1.
25002:3994:                   Thus, nothing is active.  */
25003:3995:                if (r == 0) {
25004:3996:                    lowest_active_reg = NO_LOWEST_ACTIVE_REG;
25005:3997:                    highest_active_reg = NO_HIGHEST_ACTIVE_REG;
25006:3998:                } else
25007:3999:                    highest_active_reg = r;
25008:4000:            }
25009:4001:
25010:4002:            /* If just failed to match something this time around with a
25011:4003:               group that's operated on by a repetition operator, try to
25012:4004:               force exit from the ``loop'', and restore the register
25013:4005:               information for this group that we had before trying this
25014:4006:               last match.  */
25015:4007:            if ((!MATCHED_SOMETHING (reg_info[*p])
25016:4008:                 || just_past_start_mem == p - 1)
25017:4009:                && (p + 2) < pend) {
25018:4010:                boolean is_a_jump_n = false;
25019:4011:
25020:4012:                p1 = p + 2;
25021:4013:                mcnt = 0;
25022:4014:                switch ((re_opcode_t) * p1++) {
25023:4015:                case jump_n:
25024:4016:                    is_a_jump_n = true;
25025:4017:                case pop_failure_jump:
25026:4018:                case maybe_pop_jump:
25027:4019:                case jump:
25028:4020:                case dummy_failure_jump:
25029:4021:                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
25030:4022:                    if (is_a_jump_n)
25031:4023:                        p1 += 2;
25032:4024:                    break;
25033:4025:
25034:4026:                default:
25035:4027:                    /* do nothing */ ;
25036:4028:                }
25037:4029:                p1 += mcnt;
25038:4030:
25039:4031:                /* If the next operation is a jump backwards in the pattern
25040:4032:                   to an on_failure_jump right before the start_memory
25041:4033:                   corresponding to this stop_memory, exit from the loop
25042:4034:                   by forcing a failure after pushing on the stack the
25043:4035:                   on_failure_jump's jump in the pattern, and d.  */
25044:4036:                if (mcnt < 0 && (re_opcode_t) * p1 == on_failure_jump
25045:4037:                    && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
25046:4038:                {
25047:4039:                    /* If this group ever matched anything, then restore
25048:4040:                       what its registers were before trying this last
25049:4041:                       failed match, e.g., with `(a*)*b' against `ab' for
25050:4042:                       regstart[1], and, e.g., with `((a*)*(b*)*)*'
25051:4043:                       against `aba' for regend[3].
25052:4044:
25053:4045:                       Also restore the registers for inner groups for,
25054:4046:                       e.g., `((a*)(b*))*' against `aba' (register 3 would
25055:4047:                       otherwise get trashed).  */
25056:4048:
25057:4049:                    if (EVER_MATCHED_SOMETHING (reg_info[*p])) {
25058:4050:                        unsigned r;
25059:4051:
25060:4052:                        EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
25061:4053:
25062:4054:                        /* Restore this and inner groups' (if any) registers.  */
25063:4055:                        for (r = *p; r < *p + *(p + 1); r++) {
25064:4056:                            regstart[r] = old_regstart[r];
25065:4057:
25066:4058:                            /* xx why this test?  */
25067:4059:                            if (old_regend[r] >= regstart[r])
25068:4060:                                regend[r] = old_regend[r];
25069:4061:                        }
25070:4062:                    }
25071:4063:                    p1++;
25072:4064:                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
25073:4065:                    PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
25074:4066:
25075:4067:                    goto fail;
25076:4068:                }
25077:4069:            }
25078:4070:
25079:4071:            /* Move past the register number and the inner group count.  */
25080:4072:            p += 2;
25081:4073:            break;
25082:4074:
25083:4075:
25084:4076:            /* \<digit> has been turned into a `duplicate' command which is
25085:4077:               followed by the numeric value of <digit> as the register number.  */
25086:4078:        case duplicate:
25087:4079:            {
25088:4080:                register const char *d2, *dend2;
25089:4081:                int regno = *p++; /* Get which register to match against.  */
25090:4082:                DEBUG_PRINT2 ("EXECUTING duplicate %d.\n", regno);
25091:4083:
25092:4084:                /* Can't back reference a group which we've never matched.  */
25093:4085:                if (REG_UNSET (regstart[regno])
25094:4086:                    || REG_UNSET (regend[regno]))
25095:4087:                    goto fail;
25096:4088:
25097:4089:                /* Where in input to try to start matching.  */
25098:4090:                d2 = regstart[regno];
25099:4091:
25100:4092:                /* Where to stop matching; if both the place to start and
25101:4093:                   the place to stop matching are in the same string, then
25102:4094:                   set to the place to stop, otherwise, for now have to use
25103:4095:                   the end of the first string.  */
25104:4096:
25105:4097:                dend2 = ((FIRST_STRING_P (regstart[regno])
25106:4098:                          == FIRST_STRING_P (regend[regno]))
25107:4099:                         ? regend[regno] : end_match_1);
25108:4100:                for (;;) {
25109:4101:                    /* If necessary, advance to next segment in register
25110:4102:                       contents.  */
25111:4103:                    while (d2 == dend2) {
25112:4104:                        if (dend2 == end_match_2)
25113:4105:                            break;
25114:4106:                        if (dend2 == regend[regno])
25115:4107:                            break;
25116:4108:
25117:4109:                        /* End of string1 => advance to string2. */
25118:4110:                        d2 = string2;
25119:4111:                        dend2 = regend[regno];
25120:4112:                    }
25121:4113:                    /* At end of register contents => success */
25122:4114:                    if (d2 == dend2)
25123:4115:                        break;
25124:4116:
25125:4117:                    /* If necessary, advance to next segment in data.  */
25126:4118:                    PREFETCH ();
25127:4119:
25128:4120:                    /* How many characters left in this segment to match.  */
25129:4121:                    mcnt = dend - d;
25130:4122:
25131:4123:                    /* Want how many consecutive characters we can match in
25132:4124:                       one shot, so, if necessary, adjust the count.  */
25133:4125:                    if (mcnt > dend2 - d2)
25134:4126:                        mcnt = dend2 - d2;
25135:4127:
25136:4128:                    /* Compare that many; failure if mismatch, else move
25137:4129:                       past them.  */
25138:4130:                    if (translate ? bcmp_translate (d, d2, mcnt, translate)
25139:4131:                        : bcmp (d, d2, mcnt))
25140:4132:                        goto fail;
25141:4133:                    d += mcnt, d2 += mcnt;
25142:4134:
25143:4135:                    /* Do this because we've match some characters.  */
25144:4136:                    SET_REGS_MATCHED ();
25145:4137:                }
25146:4138:            }
25147:4139:            break;
25148:4140:
25149:4141:
25150:4142:            /* begline matches the empty string at the beginning of the string
25151:4143:               (unless `not_bol' is set in `bufp'), and, if
25152:4144:               `newline_anchor' is set, after newlines.  */
25153:4145:        case begline:
25154:4146:            DEBUG_PRINT1 ("EXECUTING begline.\n");
25155:4147:
25156:4148:            if (AT_STRINGS_BEG (d)) {
25157:4149:                if (!bufp->not_bol)
25158:4150:                    break;
25159:4151:            } else if (d[-1] == '\n' && bufp->newline_anchor) {
25160:4152:                break;
25161:4153:            }
25162:4154:            /* In all other cases, we fail.  */
25163:4155:            goto fail;
25164:4156:
25165:4157:
25166:4158:            /* endline is the dual of begline.  */
25167:4159:        case endline:
25168:4160:            DEBUG_PRINT1 ("EXECUTING endline.\n");
25169:4161:
25170:4162:            if (AT_STRINGS_END (d)) {
25171:4163:                if (!bufp->not_eol)
25172:4164:                    break;
25173:4165:            }
25174:4166:
25175:4167:            /* We have to ``prefetch'' the next character.  */
25176:4168:            else if ((d == end1 ? *string2 : *d) == '\n'
25177:4169:                     && bufp->newline_anchor) {
25178:4170:                break;
25179:4171:            }
25180:4172:            goto fail;
25181:4173:
25182:4174:
25183:4175:            /* Match at the very beginning of the data.  */
25184:4176:        case begbuf:
25185:4177:            DEBUG_PRINT1 ("EXECUTING begbuf.\n");
25186:4178:            if (AT_STRINGS_BEG (d))
25187:4179:                break;
25188:4180:            goto fail;
25189:4181:
25190:4182:
25191:4183:            /* Match at the very end of the data.  */
25192:4184:        case endbuf:
25193:4185:            DEBUG_PRINT1 ("EXECUTING endbuf.\n");
25194:4186:            if (AT_STRINGS_END (d))
25195:4187:                break;
25196:4188:            goto fail;
25197:4189:
25198:4190:
25199:4191:            /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
25200:4192:               pushes NULL as the value for the string on the stack.  Then
25201:4193:               `pop_failure_point' will keep the current value for the
25202:4194:               string, instead of restoring it.  To see why, consider
25203:4195:               matching `foo\nbar' against `.*\n'.  The .* matches the foo;
25204:4196:               then the . fails against the \n.  But the next thing we want
25205:4197:               to do is match the \n against the \n; if we restored the
25206:4198:               string value, we would be back at the foo.
25207:4199:
25208:4200:               Because this is used only in specific cases, we don't need to
25209:4201:               check all the things that `on_failure_jump' does, to make
25210:4202:               sure the right things get saved on the stack.  Hence we don't
25211:4203:               share its code.  The only reason to push anything on the
25212:4204:               stack at all is that otherwise we would have to change
25213:4205:               `anychar's code to do something besides goto fail in this
25214:4206:               case; that seems worse than this.  */
25215:4207:        case on_failure_keep_string_jump:
25216:4208:            DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
25217:4209:
25218:4210:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
25219:4211:            DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);
25220:4212:
25221:4213:            PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
25222:4214:            break;
25223:4215:
25224:4216:
25225:4217:            /* Uses of on_failure_jump:
25226:4218:
25227:4219:               Each alternative starts with an on_failure_jump that points
25228:4220:               to the beginning of the next alternative.  Each alternative
25229:4221:               except the last ends with a jump that in effect jumps past
25230:4222:               the rest of the alternatives.  (They really jump to the
25231:4223:               ending jump of the following alternative, because tensioning
25232:4224:               these jumps is a hassle.)
25233:4225:
25234:4226:               Repeats start with an on_failure_jump that points past both
25235:4227:               the repetition text and either the following jump or
25236:4228:               pop_failure_jump back to this on_failure_jump.  */
25237:4229:        case on_failure_jump:
25238:4230:          on_failure:
25239:4231:            DEBUG_PRINT1 ("EXECUTING on_failure_jump");
25240:4232:
25241:4233:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
25242:4234:            DEBUG_PRINT3 (" %d (to 0x%x)", mcnt, p + mcnt);
25243:4235:
25244:4236:            /* If this on_failure_jump comes right before a group (i.e.,
25245:4237:               the original * applied to a group), save the information
25246:4238:               for that group and all inner ones, so that if we fail back
25247:4239:               to this point, the group's information will be correct.
25248:4240:               For example, in \(a*\)*\1, we need the preceding group,
25249:4241:               and in \(\(a*\)b*\)\2, we need the inner group.  */
25250:4242:
25251:4243:            /* We can't use `p' to check ahead because we push
25252:4244:               a failure point to `p + mcnt' after we do this.  */
25253:4245:            p1 = p;
25254:4246:
25255:4247:            /* We need to skip no_op's before we look for the
25256:4248:               start_memory in case this on_failure_jump is happening as
25257:4249:               the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
25258:4250:               against aba.  */
25259:4251:            while (p1 < pend && (re_opcode_t) * p1 == no_op)
25260:4252:                p1++;
25261:4253:
25262:4254:            if (p1 < pend && (re_opcode_t) * p1 == start_memory) {
25263:4255:                /* We have a new highest active register now.  This will
25264:4256:                   get reset at the start_memory we are about to get to,
25265:4257:                   but we will have saved all the registers relevant to
25266:4258:                   this repetition op, as described above.  */
25267:4259:                highest_active_reg = *(p1 + 1) + *(p1 + 2);
25268:4260:                if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
25269:4261:                    lowest_active_reg = *(p1 + 1);
25270:4262:            }
25271:4263:
25272:4264:            DEBUG_PRINT1 (":\n");
25273:4265:            PUSH_FAILURE_POINT (p + mcnt, d, -2);
25274:4266:            break;
25275:4267:
25276:4268:
25277:4269:            /* A smart repeat ends with `maybe_pop_jump'.
25278:4270:               We change it to either `pop_failure_jump' or `jump'.  */
25279:4271:        case maybe_pop_jump:
25280:4272:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
25281:4273:            DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
25282:4274:            {
25283:4275:                register unsigned char *p2 = p;
25284:4276:
25285:4277:                /* Compare the beginning of the repeat with what in the
25286:4278:                   pattern follows its end. If we can establish that there
25287:4279:                   is nothing that they would both match, i.e., that we
25288:4280:                   would have to backtrack because of (as in, e.g., `a*a')
25289:4281:                   then we can change to pop_failure_jump, because we'll
25290:4282:                   never have to backtrack.
25291:4283:
25292:4284:                   This is not true in the case of alternatives: in
25293:4285:                   `(a|ab)*' we do need to backtrack to the `ab' alternative
25294:4286:                   (e.g., if the string was `ab').  But instead of trying to
25295:4287:                   detect that here, the alternative has put on a dummy
25296:4288:                   failure point which is what we will end up popping.  */
25297:4289:
25298:4290:                /* Skip over open/close-group commands.
25299:4291:                   If what follows this loop is a ...+ construct,
25300:4292:                   look at what begins its body, since we will have to
25301:4293:                   match at least one of that.  */
25302:4294:                while (1) {
25303:4295:                    if (p2 + 2 < pend
25304:4296:                        && ((re_opcode_t) * p2 == stop_memory
25305:4297:                            || (re_opcode_t) * p2 == start_memory))
25306:4298:                        p2 += 3;
25307:4299:                    else if (p2 + 6 < pend
25308:4300:                             && (re_opcode_t) * p2 == dummy_failure_jump)
25309:4301:                        p2 += 6;
25310:4302:                    else
25311:4303:                        break;
25312:4304:                }
25313:4305:
25314:4306:                p1 = p + mcnt;
25315:4307:                /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
25316:4308:                   to the `maybe_finalize_jump' of this case.  Examine what 
25317:4309:                   follows.  */
25318:4310:
25319:4311:                /* If we're at the end of the pattern, we can change.  */
25320:4312:                if (p2 == pend) {
25321:4313:                    /* Consider what happens when matching ":\(.*\)"
25322:4314:                       against ":/".  I don't really understand this code
25323:4315:                       yet.  */
25324:4316:                    p[-3] = (unsigned char) pop_failure_jump;
25325:4317:                    DEBUG_PRINT1
25326:4318:                        ("  End of pattern: change to `pop_failure_jump'.\n");
25327:4319:                }
25328:4320:
25329:4321:                else if ((re_opcode_t) * p2 == exactn
25330:4322:                         || (bufp->newline_anchor
25331:4323:                             && (re_opcode_t) * p2 == endline)) {
25332:4324:                    register unsigned char c =
25333:4325:                        *p2 == (unsigned char) endline ? '\n' : p2[2];
25334:4326:
25335:4327:                    if ((re_opcode_t) p1[3] == exactn && p1[5] != c) {
25336:4328:                        p[-3] = (unsigned char) pop_failure_jump;
25337:4329:                        DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
25338:4330:                                      c, p1[5]);
25339:4331:                    }
25340:4332:
25341:4333:                    else if ((re_opcode_t) p1[3] == charset
25342:4334:                             || (re_opcode_t) p1[3] == charset_not) {
25343:4335:                        int not = (re_opcode_t) p1[3] == charset_not;
25344:4336:
25345:4337:                        if (c < (unsigned char) (p1[4] * BYTEWIDTH)
25346:4338:                            && p1[5 +
25347:4339:                                  c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
25348:4340:                            not = !not;
25349:4341:
25350:4342:                        /* `not' is equal to 1 if c would match, which means
25351:4343:                           that we can't change to pop_failure_jump.  */
25352:4344:                        if (!not) {
25353:4345:                            p[-3] = (unsigned char) pop_failure_jump;
25354:4346:                            DEBUG_PRINT1
25355:4347:                                ("  No match => pop_failure_jump.\n");
25356:4348:                        }
25357:4349:                    }
25358:4350:                } else if ((re_opcode_t) * p2 == charset) {
25359:4351:#ifdef DEBUG
25360:4352:                    register unsigned char c
25361:4353:                        = *p2 == (unsigned char) endline ? '\n' : p2[2];
25362:4354:#endif
25363:4355:
25364:4356:                    if ((re_opcode_t) p1[3] == exactn
25365:4357:                        && !((int) p2[1] * BYTEWIDTH > (int) p1[4]
25366:4358:                             && (p2[1 + p1[4] / BYTEWIDTH]
25367:4359:                                 & (1 << (p1[4] % BYTEWIDTH))))) {
25368:4360:                        p[-3] = (unsigned char) pop_failure_jump;
25369:4361:                        DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
25370:4362:                                      c, p1[5]);
25371:4363:                    }
25372:4364:
25373:4365:                    else if ((re_opcode_t) p1[3] == charset_not) {
25374:4366:                        int idx;
25375:4367:                        /* We win if the charset_not inside the loop
25376:4368:                           lists every character listed in the charset after.  */
25377:4369:                        for (idx = 0; idx < (int) p2[1]; idx++)
25378:4370:                            if (!(p2[2 + idx] == 0 || (idx < (int) p1[4]
25379:4371:                                                       &&
25380:4372:                                                       ((p2[2 + idx] &
25381:4373:                                                         ~p1[5 + idx]) ==
25382:4374:                                                        0))))
25383:4375:                                break;
25384:4376:
25385:4377:                        if (idx == p2[1]) {
25386:4378:                            p[-3] = (unsigned char) pop_failure_jump;
25387:4379:                            DEBUG_PRINT1
25388:4380:                                ("  No match => pop_failure_jump.\n");
25389:4381:                        }
25390:4382:                    } else if ((re_opcode_t) p1[3] == charset) {
25391:4383:                        int idx;
25392:4384:                        /* We win if the charset inside the loop
25393:4385:                           has no overlap with the one after the loop.  */
25394:4386:                        for (idx = 0;
25395:4387:                             idx < (int) p2[1] && idx < (int) p1[4]; idx++)
25396:4388:                            if ((p2[2 + idx] & p1[5 + idx]) != 0)
25397:4389:                                break;
25398:4390:
25399:4391:                        if (idx == p2[1] || idx == p1[4]) {
25400:4392:                            p[-3] = (unsigned char) pop_failure_jump;
25401:4393:                            DEBUG_PRINT1
25402:4394:                                ("  No match => pop_failure_jump.\n");
25403:4395:                        }
25404:4396:                    }
25405:4397:                }
25406:4398:            }
25407:4399:            p -= 2;             /* Point at relative address again.  */
25408:4400:            if ((re_opcode_t) p[-1] != pop_failure_jump) {
25409:4401:                p[-1] = (unsigned char) jump;
25410:4402:                DEBUG_PRINT1 ("  Match => jump.\n");
25411:4403:                goto unconditional_jump;
25412:4404:            }
25413:4405:            /* Note fall through.  */
25414:4406:
25415:4407:
25416:4408:            /* The end of a simple repeat has a pop_failure_jump back to
25417:4409:               its matching on_failure_jump, where the latter will push a
25418:4410:               failure point.  The pop_failure_jump takes off failure
25419:4411:               points put on by this pop_failure_jump's matching
25420:4412:               on_failure_jump; we got through the pattern to here from the
25421:4413:               matching on_failure_jump, so didn't fail.  */
25422:4414:        case pop_failure_jump:
25423:4415:            {
25424:4416:                /* We need to pass separate storage for the lowest and
25425:4417:                   highest registers, even though we don't care about the
25426:4418:                   actual values.  Otherwise, we will restore only one
25427:4419:                   register from the stack, since lowest will == highest in
25428:4420:                   `pop_failure_point'.  */
25429:4421:                unsigned dummy_low_reg, dummy_high_reg;
25430:4422:                unsigned char *pdummy;
25431:4423:                const char *sdummy;
25432:4424:
25433:4425:                DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
25434:4426:                POP_FAILURE_POINT (sdummy, pdummy,
25435:4427:                                   dummy_low_reg, dummy_high_reg,
25436:4428:                                   reg_dummy, reg_dummy, reg_info_dummy);
25437:4429:            }
25438:4430:            /* Note fall through.  */
25439:4431:
25440:4432:
25441:4433:            /* Unconditionally jump (without popping any failure points).  */
25442:4434:        case jump:
25443:4435:          unconditional_jump:
25444:4436:            EXTRACT_NUMBER_AND_INCR (mcnt, p); /* Get the amount to jump.  */
25445:4437:            DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
25446:4438:            p += mcnt;          /* Do the jump.  */
25447:4439:            DEBUG_PRINT2 ("(to 0x%x).\n", p);
25448:4440:            break;
25449:4441:
25450:4442:
25451:4443:            /* We need this opcode so we can detect where alternatives end
25452:4444:               in `group_match_null_string_p' et al.  */
25453:4445:        case jump_past_alt:
25454:4446:            DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
25455:4447:            goto unconditional_jump;
25456:4448:
25457:4449:
25458:4450:            /* Normally, the on_failure_jump pushes a failure point, which
25459:4451:               then gets popped at pop_failure_jump.  We will end up at
25460:4452:               pop_failure_jump, also, and with a pattern of, say, `a+', we
25461:4453:               are skipping over the on_failure_jump, so we have to push
25462:4454:               something meaningless for pop_failure_jump to pop.  */
25463:4455:        case dummy_failure_jump:
25464:4456:            DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
25465:4457:            /* It doesn't matter what we push for the string here.  What
25466:4458:               the code at `fail' tests is the value for the pattern.  */
25467:4459:            PUSH_FAILURE_POINT (0, 0, -2);
25468:4460:            goto unconditional_jump;
25469:4461:
25470:4462:
25471:4463:            /* At the end of an alternative, we need to push a dummy failure
25472:4464:               point in case we are followed by a `pop_failure_jump', because
25473:4465:               we don't want the failure point for the alternative to be
25474:4466:               popped.  For example, matching `(a|ab)*' against `aab'
25475:4467:               requires that we match the `ab' alternative.  */
25476:4468:        case push_dummy_failure:
25477:4469:            DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
25478:4470:            /* See comments just above at `dummy_failure_jump' about the
25479:4471:               two zeroes.  */
25480:4472:            PUSH_FAILURE_POINT (0, 0, -2);
25481:4473:            break;
25482:4474:
25483:4475:            /* Have to succeed matching what follows at least n times.
25484:4476:               After that, handle like `on_failure_jump'.  */
25485:4477:        case succeed_n:
25486:4478:            EXTRACT_NUMBER (mcnt, p + 2);
25487:4479:            DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);
25488:4480:
25489:4481:            assert (mcnt >= 0);
25490:4482:            /* Originally, this is how many times we HAVE to succeed.  */
25491:4483:            if (mcnt > 0) {
25492:4484:                mcnt--;
25493:4485:                p += 2;
25494:4486:                STORE_NUMBER_AND_INCR (p, mcnt);
25495:4487:                DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p, mcnt);
25496:4488:            } else if (mcnt == 0) {
25497:4489:                DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n",
25498:4490:                              p + 2);
25499:4491:                p[2] = (unsigned char) no_op;
25500:4492:                p[3] = (unsigned char) no_op;
25501:4493:                goto on_failure;
25502:4494:            }
25503:4495:            break;
25504:4496:
25505:4497:        case jump_n:
25506:4498:            EXTRACT_NUMBER (mcnt, p + 2);
25507:4499:            DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);
25508:4500:
25509:4501:            /* Originally, this is how many times we CAN jump.  */
25510:4502:            if (mcnt) {
25511:4503:                mcnt--;
25512:4504:                STORE_NUMBER (p + 2, mcnt);
25513:4505:                goto unconditional_jump;
25514:4506:            }
25515:4507:            /* If don't have to jump any more, skip over the rest of command.  */
25516:4508:            else
25517:4509:                p += 4;
25518:4510:            break;
25519:4511:
25520:4512:        case set_number_at:
25521:4513:            {
25522:4514:                DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
25523:4515:
25524:4516:                EXTRACT_NUMBER_AND_INCR (mcnt, p);
25525:4517:                p1 = p + mcnt;
25526:4518:                EXTRACT_NUMBER_AND_INCR (mcnt, p);
25527:4519:                DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
25528:4520:                STORE_NUMBER (p1, mcnt);
25529:4521:                break;
25530:4522:            }
25531:4523:
25532:4524:        case wordbound:
25533:4525:            DEBUG_PRINT1 ("EXECUTING wordbound.\n");
25534:4526:            if (AT_WORD_BOUNDARY (d))
25535:4527:                break;
25536:4528:            goto fail;
25537:4529:
25538:4530:        case notwordbound:
25539:4531:            DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
25540:4532:            if (AT_WORD_BOUNDARY (d))
25541:4533:                goto fail;
25542:4534:            break;
25543:4535:
25544:4536:        case wordbeg:
25545:4537:            DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
25546:4538:            if (WORDCHAR_P (d)
25547:4539:                && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
25548:4540:                break;
25549:4541:            goto fail;
25550:4542:
25551:4543:        case wordend:
25552:4544:            DEBUG_PRINT1 ("EXECUTING wordend.\n");
25553:4545:            if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
25554:4546:                && (!WORDCHAR_P (d) || AT_STRINGS_END (d)))
25555:4547:                break;
25556:4548:            goto fail;
25557:4549:
25558:4550:#ifdef emacs
25559:4551:        case before_dot:
25560:4552:            DEBUG_PRINT1 ("EXECUTING before_dot.\n");
25561:4553:            if (PTR_CHAR_POS ((unsigned char *) d) >= point)
25562:4554:                goto fail;
25563:4555:            break;
25564:4556:
25565:4557:        case at_dot:
25566:4558:            DEBUG_PRINT1 ("EXECUTING at_dot.\n");
25567:4559:            if (PTR_CHAR_POS ((unsigned char *) d) != point)
25568:4560:                goto fail;
25569:4561:            break;
25570:4562:
25571:4563:        case after_dot:
25572:4564:            DEBUG_PRINT1 ("EXECUTING after_dot.\n");
25573:4565:            if (PTR_CHAR_POS ((unsigned char *) d) <= point)
25574:4566:                goto fail;
25575:4567:            break;
25576:4568:#if 0                           /* not emacs19 */
25577:4569:        case at_dot:
25578:4570:            DEBUG_PRINT1 ("EXECUTING at_dot.\n");
25579:4571:            if (PTR_CHAR_POS ((unsigned char *) d) + 1 != point)
25580:4572:                goto fail;
25581:4573:            break;
25582:4574:#endif                          /* not emacs19 */
25583:4575:
25584:4576:        case syntaxspec:
25585:4577:            DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
25586:4578:            mcnt = *p++;
25587:4579:            goto matchsyntax;
25588:4580:
25589:4581:        case wordchar:
25590:4582:            DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
25591:4583:            mcnt = (int) Sword;
25592:4584:          matchsyntax:
25593:4585:            PREFETCH ();
25594:4586:            /* Can't use *d++ here; SYNTAX may be an unsafe macro.  */
25595:4587:            d++;
25596:4588:            if (SYNTAX (d[-1]) != (enum syntaxcode) mcnt)
25597:4589:                goto fail;
25598:4590:            SET_REGS_MATCHED ();
25599:4591:            break;
25600:4592:
25601:4593:        case notsyntaxspec:
25602:4594:            DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
25603:4595:            mcnt = *p++;
25604:4596:            goto matchnotsyntax;
25605:4597:
25606:4598:        case notwordchar:
25607:4599:            DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
25608:4600:            mcnt = (int) Sword;
25609:4601:          matchnotsyntax:
25610:4602:            PREFETCH ();
25611:4603:            /* Can't use *d++ here; SYNTAX may be an unsafe macro.  */
25612:4604:            d++;
25613:4605:            if (SYNTAX (d[-1]) == (enum syntaxcode) mcnt)
25614:4606:                goto fail;
25615:4607:            SET_REGS_MATCHED ();
25616:4608:            break;
25617:4609:
25618:4610:#else                           /* not emacs */
25619:4611:        case wordchar:
25620:4612:            DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
25621:4613:            PREFETCH ();
25622:4614:            if (!WORDCHAR_P (d))
25623:4615:                goto fail;
25624:4616:            SET_REGS_MATCHED ();
25625:4617:            d++;
25626:4618:            break;
25627:4619:
25628:4620:        case notwordchar:
25629:4621:            DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
25630:4622:            PREFETCH ();
25631:4623:            if (WORDCHAR_P (d))
25632:4624:                goto fail;
25633:4625:            SET_REGS_MATCHED ();
25634:4626:            d++;
25635:4627:            break;
25636:4628:#endif                          /* not emacs */
25637:4629:
25638:4630:        default:
25639:4631:            abort ();
25640:4632:        }
25641:4633:        continue;               /* Successfully executed one pattern command; keep going.  */
25642:4634:
25643:4635:
25644:4636:        /* We goto here if a matching operation fails. */
25645:4637:      fail:
25646:4638:        if (!FAIL_STACK_EMPTY ()) { /* A restart point is known.  Restore to that state.  */
25647:4639:            DEBUG_PRINT1 ("\nFAIL:\n");
25648:4640:            POP_FAILURE_POINT (d, p,
25649:4641:                               lowest_active_reg, highest_active_reg,
25650:4642:                               regstart, regend, reg_info);
25651:4643:
25652:4644:            /* If this failure point is a dummy, try the next one.  */
25653:4645:            if (!p)
25654:4646:                goto fail;
25655:4647:
25656:4648:            /* If we failed to the end of the pattern, don't examine *p.  */
25657:4649:            assert (p <= pend);
25658:4650:            if (p < pend) {
25659:4651:                boolean is_a_jump_n = false;
25660:4652:
25661:4653:                /* If failed to a backwards jump that's part of a repetition
25662:4654:                   loop, need to pop this failure point and use the next one.  */
25663:4655:                switch ((re_opcode_t) * p) {
25664:4656:                case jump_n:
25665:4657:                    is_a_jump_n = true;
25666:4658:                case maybe_pop_jump:
25667:4659:                case pop_failure_jump:
25668:4660:                case jump:
25669:4661:                    p1 = p + 1;
25670:4662:                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
25671:4663:                    p1 += mcnt;
25672:4664:
25673:4665:                    if ((is_a_jump_n && (re_opcode_t) * p1 == succeed_n)
25674:4666:                        || (!is_a_jump_n
25675:4667:                            && (re_opcode_t) * p1 == on_failure_jump))
25676:4668:                        goto fail;
25677:4669:                    break;
25678:4670:                default:
25679:4671:                    /* do nothing */ ;
25680:4672:                }
25681:4673:            }
25682:4674:
25683:4675:            if (d >= string1 && d <= end1)
25684:4676:                dend = end_match_1;
25685:4677:        } else
25686:4678:            break;              /* Matching at this starting point really fails.  */
25687:4679:    }                           /* for (;;) */
25688:4680:
25689:4681:    if (best_regs_set)
25690:4682:        goto restore_best_regs;
25691:4683:
25692:4684:    FREE_VARIABLES ();
25693:4685:
25694:4686:    return -1;                  /* Failure to match.  */
25695:4687:}                               /* re_match_2 */
25696:4688:
25697:4689:/* Subroutine definitions for re_match_2.  */
25698:4690:
25699:4691:
25700:4692:/* We are passed P pointing to a register number after a start_memory.
25701:4693:   
25702:4694:   Return true if the pattern up to the corresponding stop_memory can
25703:4695:   match the empty string, and false otherwise.
25704:4696:   
25705:4697:   If we find the matching stop_memory, sets P to point to one past its number.
25706:4698:   Otherwise, sets P to an undefined byte less than or equal to END.
25707:4699:
25708:4700:   We don't handle duplicates properly (yet).  */
25709:4701:
25710:4702:static boolean group_match_null_string_p (p, end, reg_info)
25711:4703:unsigned char **p, *end;
25712:4704:register_info_type *reg_info;
25713:4705:{
25714:4706:    int mcnt;
25715:4707:    /* Point to after the args to the start_memory.  */
25716:4708:    unsigned char *p1 = *p + 2;
25717:4709:
25718:4710:    while (p1 < end) {
25719:4711:        /* Skip over opcodes that can match nothing, and return true or
25720:4712:           false, as appropriate, when we get to one that can't, or to the
25721:4713:           matching stop_memory.  */
25722:4714:
25723:4715:        switch ((re_opcode_t) * p1) {
25724:4716:            /* Could be either a loop or a series of alternatives.  */
25725:4717:        case on_failure_jump:
25726:4718:            p1++;
25727:4719:            EXTRACT_NUMBER_AND_INCR (mcnt, p1);
25728:4720:
25729:4721:            /* If the next operation is not a jump backwards in the
25730:4722:               pattern.  */
25731:4723:
25732:4724:            if (mcnt >= 0) {
25733:4725:                /* Go through the on_failure_jumps of the alternatives,
25734:4726:                   seeing if any of the alternatives cannot match nothing.
25735:4727:                   The last alternative starts with only a jump,
25736:4728:                   whereas the rest start with on_failure_jump and end
25737:4729:                   with a jump, e.g., here is the pattern for `a|b|c':
25738:4730:
25739:4731:                   /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
25740:4732:                   /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
25741:4733:                   /exactn/1/c      
25742:4734:
25743:4735:                   So, we have to first go through the first (n-1)
25744:4736:                   alternatives and then deal with the last one separately.  */
25745:4737:
25746:4738:
25747:4739:                /* Deal with the first (n-1) alternatives, which start
25748:4740:                   with an on_failure_jump (see above) that jumps to right
25749:4741:                   past a jump_past_alt.  */
25750:4742:
25751:4743:                while ((re_opcode_t) p1[mcnt - 3] == jump_past_alt) {
25752:4744:                    /* `mcnt' holds how many bytes long the alternative
25753:4745:                       is, including the ending `jump_past_alt' and
25754:4746:                       its number.  */
25755:4747:
25756:4748:                    if (!alt_match_null_string_p (p1, p1 + mcnt - 3,
25757:4749:                                                  reg_info))
25758:4750:                        return false;
25759:4751:
25760:4752:                    /* Move to right after this alternative, including the
25761:4753:                       jump_past_alt.  */
25762:4754:                    p1 += mcnt;
25763:4755:
25764:4756:                    /* Break if it's the beginning of an n-th alternative
25765:4757:                       that doesn't begin with an on_failure_jump.  */
25766:4758:                    if ((re_opcode_t) * p1 != on_failure_jump)
25767:4759:                        break;
25768:4760:
25769:4761:                    /* Still have to check that it's not an n-th
25770:4762:                       alternative that starts with an on_failure_jump.  */
25771:4763:                    p1++;
25772:4764:                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
25773:4765:                    if ((re_opcode_t) p1[mcnt - 3] != jump_past_alt) {
25774:4766:                        /* Get to the beginning of the n-th alternative.  */
25775:4767:                        p1 -= 3;
25776:4768:                        break;
25777:4769:                    }
25778:4770:                }
25779:4771:
25780:4772:                /* Deal with the last alternative: go back and get number
25781:4773:                   of the `jump_past_alt' just before it.  `mcnt' contains
25782:4774:                   the length of the alternative.  */
25783:4775:                EXTRACT_NUMBER (mcnt, p1 - 2);
25784:4776:
25785:4777:                if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
25786:4778:                    return false;
25787:4779:
25788:4780:                p1 += mcnt;     /* Get past the n-th alternative.  */
25789:4781:            }                   /* if mcnt > 0 */
25790:4782:            break;
25791:4783:
25792:4784:
25793:4785:        case stop_memory:
25794:4786:            assert (p1[1] == **p);
25795:4787:            *p = p1 + 2;
25796:4788:            return true;
25797:4789:
25798:4790:
25799:4791:        default:
25800:4792:            if (!common_op_match_null_string_p (&p1, end, reg_info))
25801:4793:                return false;
25802:4794:        }
25803:4795:    }                           /* while p1 < end */
25804:4796:
25805:4797:    return false;
25806:4798:}                               /* group_match_null_string_p */
25807:4799:
25808:4800:
25809:4801:/* Similar to group_match_null_string_p, but doesn't deal with alternatives:
25810:4802:   It expects P to be the first byte of a single alternative and END one
25811:4803:   byte past the last. The alternative can contain groups.  */
25812:4804:
25813:4805:static boolean alt_match_null_string_p (p, end, reg_info)
25814:4806:unsigned char *p, *end;
25815:4807:register_info_type *reg_info;
25816:4808:{
25817:4809:    int mcnt;
25818:4810:    unsigned char *p1 = p;
25819:4811:
25820:4812:    while (p1 < end) {
25821:4813:        /* Skip over opcodes that can match nothing, and break when we get 
25822:4814:           to one that can't.  */
25823:4815:
25824:4816:        switch ((re_opcode_t) * p1) {
25825:4817:            /* It's a loop.  */
25826:4818:        case on_failure_jump:
25827:4819:            p1++;
25828:4820:            EXTRACT_NUMBER_AND_INCR (mcnt, p1);
25829:4821:            p1 += mcnt;
25830:4822:            break;
25831:4823:
25832:4824:        default:
25833:4825:            if (!common_op_match_null_string_p (&p1, end, reg_info))
25834:4826:                return false;
25835:4827:        }
25836:4828:    }                           /* while p1 < end */
25837:4829:
25838:4830:    return true;
25839:4831:}                               /* alt_match_null_string_p */
25840:4832:
25841:4833:
25842:4834:/* Deals with the ops common to group_match_null_string_p and
25843:4835:   alt_match_null_string_p.  
25844:4836:   
25845:4837:   Sets P to one after the op and its arguments, if any.  */
25846:4838:
25847:4839:static boolean common_op_match_null_string_p (p, end, reg_info)
25848:4840:unsigned char **p, *end;
25849:4841:register_info_type *reg_info;
25850:4842:{
25851:4843:    int mcnt;
25852:4844:    boolean ret;
25853:4845:    int reg_no;
25854:4846:    unsigned char *p1 = *p;
25855:4847:
25856:4848:    switch ((re_opcode_t) * p1++) {
25857:4849:    case no_op:
25858:4850:    case begline:
25859:4851:    case endline:
25860:4852:    case begbuf:
25861:4853:    case endbuf:
25862:4854:    case wordbeg:
25863:4855:    case wordend:
25864:4856:    case wordbound:
25865:4857:    case notwordbound:
25866:4858:#ifdef emacs
25867:4859:    case before_dot:
25868:4860:    case at_dot:
25869:4861:    case after_dot:
25870:4862:#endif
25871:4863:        break;
25872:4864:
25873:4865:    case start_memory:
25874:4866:        reg_no = *p1;
25875:4867:        assert (reg_no > 0 && reg_no <= MAX_REGNUM);
25876:4868:        ret = group_match_null_string_p (&p1, end, reg_info);
25877:4869:
25878:4870:        /* Have to set this here in case we're checking a group which
25879:4871:           contains a group and a back reference to it.  */
25880:4872:
25881:4873:        if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) ==
25882:4874:            MATCH_NULL_UNSET_VALUE)
25883:4875:            REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;
25884:4876:
25885:4877:        if (!ret)
25886:4878:            return false;
25887:4879:        break;
25888:4880:
25889:4881:        /* If this is an optimized succeed_n for zero times, make the jump.  */
25890:4882:    case jump:
25891:4883:        EXTRACT_NUMBER_AND_INCR (mcnt, p1);
25892:4884:        if (mcnt >= 0)
25893:4885:            p1 += mcnt;
25894:4886:        else
25895:4887:            return false;
25896:4888:        break;
25897:4889:
25898:4890:    case succeed_n:
25899:4891:        /* Get to the number of times to succeed.  */
25900:4892:        p1 += 2;
25901:4893:        EXTRACT_NUMBER_AND_INCR (mcnt, p1);
25902:4894:
25903:4895:        if (mcnt == 0) {
25904:4896:            p1 -= 4;
25905:4897:            EXTRACT_NUMBER_AND_INCR (mcnt, p1);
25906:4898:            p1 += mcnt;
25907:4899:        } else
25908:4900:            return false;
25909:4901:        break;
25910:4902:
25911:4903:    case duplicate:
25912:4904:        if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
25913:4905:            return false;
25914:4906:        break;
25915:4907:
25916:4908:    case set_number_at:
25917:4909:        p1 += 4;
25918:4910:
25919:4911:    default:
25920:4912:        /* All other opcodes mean we cannot match the empty string.  */
25921:4913:        return false;
25922:4914:    }
25923:4915:
25924:4916:    *p = p1;
25925:4917:    return true;
25926:4918:}                               /* common_op_match_null_string_p */
25927:4919:
25928:4920:
25929:4921:/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
25930:4922:   bytes; nonzero otherwise.  */
25931:4923:
25932:4924:static int bcmp_translate (s1, s2, len, translate)
25933:4925:unsigned char *s1, *s2;
25934:4926:register int len;
25935:4927:char *translate;
25936:4928:{
25937:4929:    register unsigned char *p1 = s1, *p2 = s2;
25938:4930:    while (len) {
25939:4931:        if (translate[*p1++] != translate[*p2++])
25940:4932:            return 1;
25941:4933:        len--;
25942:4934:    }
25943:4935:    return 0;
25944:4936:}
25945:4937:
25946:4938:/* Entry points for GNU code.  */
25947:4939:
25948:4940:/* re_compile_pattern is the GNU regular expression compiler: it
25949:4941:   compiles PATTERN (of length SIZE) and puts the result in BUFP.
25950:4942:   Returns 0 if the pattern was valid, otherwise an error string.
25951:4943:   
25952:4944:   Assumes the `allocated' (and perhaps `buffer') and `translate' fields
25953:4945:   are set in BUFP on entry.
25954:4946:   
25955:4947:   We call regex_compile to do the actual compilation.  */
25956:4948:
25957:4949:const char *re_compile_pattern (pattern, length, bufp)
25958:4950:const char *pattern;
25959:4951:int length;
25960:4952:struct re_pattern_buffer *bufp;
25961:4953:{
25962:4954:    reg_errcode_t ret;
25963:4955:
25964:4956:    /* GNU code is written to assume at least RE_NREGS registers will be set
25965:4957:       (and at least one extra will be -1).  */
25966:4958:    bufp->regs_allocated = REGS_UNALLOCATED;
25967:4959:
25968:4960:    /* And GNU code determines whether or not to get register information
25969:4961:       by passing null for the REGS argument to re_match, etc., not by
25970:4962:       setting no_sub.  */
25971:4963:    bufp->no_sub = 0;
25972:4964:
25973:4965:    /* Match anchors at newline.  */
25974:4966:    bufp->newline_anchor = 1;
25975:4967:
25976:4968:    ret = regex_compile (pattern, length, re_syntax_options, bufp);
25977:4969:
25978:4970:    if (!ret)
25979:4971:        return NULL;
25980:4972:    return gettext (re_error_msgid[(int) ret]);
25981:4973:}
25982:4974:
25983:4975:/* Entry points compatible with 4.2 BSD regex library.  We don't define
25984:4976:   them unless specifically requested.  */
25985:4977:
25986:4978:#ifdef _REGEX_RE_COMP
25987:4979:
25988:4980:/* BSD has one and only one pattern buffer.  */
25989:4981:static struct re_pattern_buffer re_comp_buf;
25990:4982:
25991:4983:char *re_comp (s)
25992:4984:const char *s;
25993:4985:{
25994:4986:    reg_errcode_t ret;
25995:4987:
25996:4988:    if (!s) {
25997:4989:        if (!re_comp_buf.buffer)
25998:4990:            return gettext ("No previous regular expression");
25999:4991:        return 0;
26000:4992:    }
26001:4993:
26002:4994:    if (!re_comp_buf.buffer) {
26003:4995:        re_comp_buf.buffer = (unsigned char *) malloc (200);
26004:4996:        if (re_comp_buf.buffer == NULL)
26005:4997:            return gettext (re_error_msgid[(int) REG_ESPACE]);
26006:4998:        re_comp_buf.allocated = 200;
26007:4999:
26008:5000:        re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
26009:5001:        if (re_comp_buf.fastmap == NULL)
26010:5002:            return gettext (re_error_msgid[(int) REG_ESPACE]);
26011:5003:    }
26012:5004:
26013:5005:    /* Since `re_exec' always passes NULL for the `regs' argument, we
26014:5006:       don't need to initialize the pattern buffer fields which affect it.  */
26015:5007:
26016:5008:    /* Match anchors at newlines.  */
26017:5009:    re_comp_buf.newline_anchor = 1;
26018:5010:
26019:5011:    ret = regex_compile (s, strlen (s), re_syntax_options, &re_comp_buf);
26020:5012:
26021:5013:    if (!ret)
26022:5014:        return NULL;
26023:5015:
26024:5016:    /* Yes, we're discarding `const' here if !HAVE_LIBINTL.  */
26025:5017:    return (char *) gettext (re_error_msgid[(int) ret]);
26026:5018:}
26027:5019:
26028:5020:
26029:5021:int re_exec (s)
26030:5022:const char *s;
26031:5023:{
26032:5024:    const int len = strlen (s);
26033:5025:    return
26034:5026:        0 <= re_search (&re_comp_buf, s, len, 0, len,
26035:5027:                        (struct re_registers *) 0);
26036:5028:}
26037:5029:#endif                          /* _REGEX_RE_COMP */
26038:5030:
26039:5031:/* POSIX.2 functions.  Don't define these for Emacs.  */
26040:5032:
26041:5033:#ifndef emacs
26042:5034:
26043:5035:/* regcomp takes a regular expression as a string and compiles it.
26044:5036:
26045:5037:   PREG is a regex_t *.  We do not expect any fields to be initialized,
26046:5038:   since POSIX says we shouldn't.  Thus, we set
26047:5039:
26048:5040:     `buffer' to the compiled pattern;
26049:5041:     `used' to the length of the compiled pattern;
26050:5042:     `syntax' to RE_SYNTAX_POSIX_EXTENDED if the
26051:5043:       REG_EXTENDED bit in CFLAGS is set; otherwise, to
26052:5044:       RE_SYNTAX_POSIX_BASIC;
26053:5045:     `newline_anchor' to REG_NEWLINE being set in CFLAGS;
26054:5046:     `fastmap' and `fastmap_accurate' to zero;
26055:5047:     `re_nsub' to the number of subexpressions in PATTERN.
26056:5048:
26057:5049:   PATTERN is the address of the pattern string.
26058:5050:
26059:5051:   CFLAGS is a series of bits which affect compilation.
26060:5052:
26061:5053:     If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we
26062:5054:     use POSIX basic syntax.
26063:5055:
26064:5056:     If REG_NEWLINE is set, then . and [^...] don't match newline.
26065:5057:     Also, regexec will try a match beginning after every newline.
26066:5058:
26067:5059:     If REG_ICASE is set, then we considers upper- and lowercase
26068:5060:     versions of letters to be equivalent when matching.
26069:5061:
26070:5062:     If REG_NOSUB is set, then when PREG is passed to regexec, that
26071:5063:     routine will report only success or failure, and nothing about the
26072:5064:     registers.
26073:5065:
26074:5066:   It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for
26075:5067:   the return codes and their meanings.)  */
26076:5068:
26077:5069:int regcomp (preg, pattern, cflags)
26078:5070:regex_t *preg;
26079:5071:const char *pattern;
26080:5072:int cflags;
26081:5073:{
26082:5074:    reg_errcode_t ret;
26083:5075:    unsigned syntax
26084:5076:        = (cflags & REG_EXTENDED) ?
26085:5077:        RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;
26086:5078:
26087:5079:    /* regex_compile will allocate the space for the compiled pattern.  */
26088:5080:    preg->buffer = 0;
26089:5081:    preg->allocated = 0;
26090:5082:    preg->used = 0;
26091:5083:
26092:5084:    /* Don't bother to use a fastmap when searching.  This simplifies the
26093:5085:       REG_NEWLINE case: if we used a fastmap, we'd have to put all the
26094:5086:       characters after newlines into the fastmap.  This way, we just try
26095:5087:       every character.  */
26096:5088:    preg->fastmap = 0;
26097:5089:
26098:5090:    if (cflags & REG_ICASE) {
26099:5091:        unsigned i;
26100:5092:
26101:5093:        preg->translate = (char *) malloc (CHAR_SET_SIZE);
26102:5094:        if (preg->translate == NULL)
26103:5095:            return (int) REG_ESPACE;
26104:5096:
26105:5097:        /* Map uppercase characters to corresponding lowercase ones.  */
26106:5098:        for (i = 0; i < CHAR_SET_SIZE; i++)
26107:5099:            preg->translate[i] = ISUPPER (i) ? tolower (i) : i;
26108:5100:    } else
26109:5101:        preg->translate = NULL;
26110:5102:
26111:5103:    /* If REG_NEWLINE is set, newlines are treated differently.  */
26112:5104:    if (cflags & REG_NEWLINE) { /* REG_NEWLINE implies neither . nor [^...] match newline.  */
26113:5105:        syntax &= ~RE_DOT_NEWLINE;
26114:5106:        syntax |= RE_HAT_LISTS_NOT_NEWLINE;
26115:5107:        /* It also changes the matching behavior.  */
26116:5108:        preg->newline_anchor = 1;
26117:5109:    } else
26118:5110:        preg->newline_anchor = 0;
26119:5111:
26120:5112:    preg->no_sub = !!(cflags & REG_NOSUB);
26121:5113:
26122:5114:    /* POSIX says a null character in the pattern terminates it, so we 
26123:5115:       can use strlen here in compiling the pattern.  */
26124:5116:    ret = regex_compile (pattern, strlen (pattern), syntax, preg);
26125:5117:
26126:5118:    /* POSIX doesn't distinguish between an unmatched open-group and an
26127:5119:       unmatched close-group: both are REG_EPAREN.  */
26128:5120:    if (ret == REG_ERPAREN)
26129:5121:        ret = REG_EPAREN;
26130:5122:
26131:5123:    return (int) ret;
26132:5124:}
26133:5125:
26134:5126:
26135:5127:/* regexec searches for a given pattern, specified by PREG, in the
26136:5128:   string STRING.
26137:5129:   
26138:5130:   If NMATCH is zero or REG_NOSUB was set in the cflags argument to
26139:5131:   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
26140:5132:   least NMATCH elements, and we set them to the offsets of the
26141:5133:   corresponding matched substrings.
26142:5134:   
26143:5135:   EFLAGS specifies `execution flags' which affect matching: if
26144:5136:   REG_NOTBOL is set, then ^ does not match at the beginning of the
26145:5137:   string; if REG_NOTEOL is set, then $ does not match at the end.
26146:5138:   
26147:5139:   We return 0 if we find a match and REG_NOMATCH if not.  */
26148:5140:
26149:5141:int regexec (preg, string, nmatch, pmatch, eflags)
26150:5142:const regex_t *preg;
26151:5143:const char *string;
26152:5144:size_t nmatch;
26153:5145:regmatch_t pmatch[];
26154:5146:int eflags;
26155:5147:{
26156:5148:    int ret;
26157:5149:    struct re_registers regs;
26158:5150:    regex_t private_preg;
26159:5151:    int len = strlen (string);
26160:5152:    boolean want_reg_info = !preg->no_sub && nmatch > 0;
26161:5153:
26162:5154:    private_preg = *preg;
26163:5155:
26164:5156:    private_preg.not_bol = !!(eflags & REG_NOTBOL);
26165:5157:    private_preg.not_eol = !!(eflags & REG_NOTEOL);
26166:5158:
26167:5159:    /* The user has told us exactly how many registers to return
26168:5160:       information about, via `nmatch'.  We have to pass that on to the
26169:5161:       matching routines.  */
26170:5162:    private_preg.regs_allocated = REGS_FIXED;
26171:5163:
26172:5164:    if (want_reg_info) {
26173:5165:        regs.num_regs = nmatch;
26174:5166:        regs.start = TALLOC (nmatch, regoff_t);
26175:5167:        regs.end = TALLOC (nmatch, regoff_t);
26176:5168:        if (regs.start == NULL || regs.end == NULL)
26177:5169:            return (int) REG_NOMATCH;
26178:5170:    }
26179:5171:
26180:5172:    /* Perform the searching operation.  */
26181:5173:    ret = re_search (&private_preg, string, len,
26182:5174:                     /* start: */ 0, /* range: */ len,
26183:5175:                     want_reg_info ? &regs : (struct re_registers *) 0);
26184:5176:
26185:5177:    /* Copy the register information to the POSIX structure.  */
26186:5178:    if (want_reg_info) {
26187:5179:        if (ret >= 0) {
26188:5180:            unsigned r;
26189:5181:
26190:5182:            for (r = 0; r < nmatch; r++) {
26191:5183:                pmatch[r].rm_so = regs.start[r];
26192:5184:                pmatch[r].rm_eo = regs.end[r];
26193:5185:            }
26194:5186:        }
26195:5187:
26196:5188:        /* If we needed the temporary register info, free the space now.  */
26197:5189:        free (regs.start);
26198:5190:        free (regs.end);
26199:5191:    }
26200:5192:
26201:5193:    /* We want zero return to mean success, unlike `re_search'.  */
26202:5194:    return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
26203:5195:}
26204:5196:
26205:5197:
26206:5198:/* Returns a message corresponding to an error code, ERRCODE, returned
26207:5199:   from either regcomp or regexec.   We don't use PREG here.  */
26208:5200:
26209:5201:size_t regerror (errcode, preg, errbuf, errbuf_size)
26210:5202:int errcode;
26211:5203:const regex_t *preg;
26212:5204:char *errbuf;
26213:5205:size_t errbuf_size;
26214:5206:{
26215:5207:    const char *msg;
26216:5208:    size_t msg_size;
26217:5209:
26218:5210:    if (errcode < 0
26219:5211:        || errcode >=
26220:5212:        (sizeof (re_error_msgid) / sizeof (re_error_msgid[0])))
26221:5213:        /* Only error codes returned by the rest of the code should be passed 
26222:5214:           to this routine.  If we are given anything else, or if other regex
26223:5215:           code generates an invalid error code, then the program has a bug.
26224:5216:           Dump core so we can fix it.  */
26225:5217:        abort ();
26226:5218:
26227:5219:    msg = gettext (re_error_msgid[errcode]);
26228:5220:
26229:5221:    msg_size = strlen (msg) + 1; /* Includes the null.  */
26230:5222:
26231:5223:    if (errbuf_size != 0) {
26232:5224:        if (msg_size > errbuf_size) {
26233:5225:            strncpy (errbuf, msg, errbuf_size - 1);
26234:5226:            errbuf[errbuf_size - 1] = 0;
26235:5227:        } else
26236:5228:            strcpy (errbuf, msg);
26237:5229:    }
26238:5230:
26239:5231:    return msg_size;
26240:5232:}
26241:5233:
26242:5234:
26243:5235:/* Free dynamically allocated space used by PREG.  */
26244:5236:
26245:5237:void regfree (preg)
26246:5238:regex_t *preg;
26247:5239:{
26248:5240:    if (preg->buffer != NULL)
26249:5241:        free (preg->buffer);
26250:5242:    preg->buffer = NULL;
26251:5243:
26252:5244:    preg->allocated = 0;
26253:5245:    preg->used = 0;
26254:5246:
26255:5247:    if (preg->fastmap != NULL)
26256:5248:        free (preg->fastmap);
26257:5249:    preg->fastmap = NULL;
26258:5250:    preg->fastmap_accurate = 0;
26259:5251:
26260:5252:    if (preg->translate != NULL)
26261:5253:        free (preg->translate);
26262:5254:    preg->translate = NULL;
26263:5255:}
26264:5256:
26265:5257:#endif                          /* not emacs  */
26266:5258:
26267:5259:/*
26268:5260:Local variables:
26269:5261:make-backup-files: t
26270:5262:version-control: t
26271:5263:trim-versions-without-asking: nil
26272:5264:End:
26273:5265:*/
26274:1:/* Definitions for data structures and routines for the regular
26275:2:   expression library, version 0.12.
26276:3:
26277:4:   Copyright (C) 1985, 89, 90, 91, 92, 93, 95 Free Software Foundation, Inc.
26278:5:
26279:6:   This program is free software; you can redistribute it and/or modify
26280:7:   it under the terms of the GNU General Public License as published by
26281:8:   the Free Software Foundation; either version 2, or (at your option)
26282:9:   any later version.
26283:10:
26284:11:   This program is distributed in the hope that it will be useful,
26285:12:   but WITHOUT ANY WARRANTY; without even the implied warranty of
26286:13:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
26287:14:   GNU General Public License for more details.
26288:15:
26289:16:   You should have received a copy of the GNU General Public License
26290:17:   along with this program; if not, write to the Free Software
26291:18:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
26292:19:
26293:20:#ifndef __REGEXP_LIBRARY_H__
26294:21:#define __REGEXP_LIBRARY_H__
26295:22:
26296:23:/* POSIX says that <sys/types.h> must be included (by the caller) before
26297:24:   <regex.h>.  */
26298:25:
26299:26:#if !defined (_POSIX_C_SOURCE) && !defined (_POSIX_SOURCE) && defined (VMS)
26300:27:/* VMS doesn't have `size_t' in <sys/types.h>, even though POSIX says it
26301:28:   should be there.  */
26302:29:#include <stddef.h>
26303:30:#endif
26304:31:
26305:32:
26306:33:/* The following bits are used to determine the regexp syntax we
26307:34:   recognize.  The set/not-set meanings are chosen so that Emacs syntax
26308:35:   remains the value 0.  The bits are given in alphabetical order, and
26309:36:   the definitions shifted by one from the previous bit; thus, when we
26310:37:   add or remove a bit, only one other definition need change.  */
26311:38:typedef unsigned reg_syntax_t;
26312:39:
26313:40:/* If this bit is not set, then \ inside a bracket expression is literal.
26314:41:   If set, then such a \ quotes the following character.  */
26315:42:#define RE_BACKSLASH_ESCAPE_IN_LISTS (1)
26316:43:
26317:44:/* If this bit is not set, then + and ? are operators, and \+ and \? are
26318:45:     literals. 
26319:46:   If set, then \+ and \? are operators and + and ? are literals.  */
26320:47:#define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS << 1)
26321:48:
26322:49:/* If this bit is set, then character classes are supported.  They are:
26323:50:     [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],
26324:51:     [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].
26325:52:   If not set, then character classes are not supported.  */
26326:53:#define RE_CHAR_CLASSES (RE_BK_PLUS_QM << 1)
26327:54:
26328:55:/* If this bit is set, then ^ and $ are always anchors (outside bracket
26329:56:     expressions, of course).
26330:57:   If this bit is not set, then it depends:
26331:58:        ^  is an anchor if it is at the beginning of a regular
26332:59:           expression or after an open-group or an alternation operator;
26333:60:        $  is an anchor if it is at the end of a regular expression, or
26334:61:           before a close-group or an alternation operator.  
26335:62:
26336:63:   This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because
26337:64:   POSIX draft 11.2 says that * etc. in leading positions is undefined.
26338:65:   We already implemented a previous draft which made those constructs
26339:66:   invalid, though, so we haven't changed the code back.  */
26340:67:#define RE_CONTEXT_INDEP_ANCHORS (RE_CHAR_CLASSES << 1)
26341:68:
26342:69:/* If this bit is set, then special characters are always special
26343:70:     regardless of where they are in the pattern.
26344:71:   If this bit is not set, then special characters are special only in
26345:72:     some contexts; otherwise they are ordinary.  Specifically, 
26346:73:     * + ? and intervals are only special when not after the beginning,
26347:74:     open-group, or alternation operator.  */
26348:75:#define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS << 1)
26349:76:
26350:77:/* If this bit is set, then *, +, ?, and { cannot be first in an re or
26351:78:     immediately after an alternation or begin-group operator.  */
26352:79:#define RE_CONTEXT_INVALID_OPS (RE_CONTEXT_INDEP_OPS << 1)
26353:80:
26354:81:/* If this bit is set, then . matches newline.
26355:82:   If not set, then it doesn't.  */
26356:83:#define RE_DOT_NEWLINE (RE_CONTEXT_INVALID_OPS << 1)
26357:84:
26358:85:/* If this bit is set, then . doesn't match NUL.
26359:86:   If not set, then it does.  */
26360:87:#define RE_DOT_NOT_NULL (RE_DOT_NEWLINE << 1)
26361:88:
26362:89:/* If this bit is set, nonmatching lists [^...] do not match newline.
26363:90:   If not set, they do.  */
26364:91:#define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL << 1)
26365:92:
26366:93:/* If this bit is set, either \{...\} or {...} defines an
26367:94:     interval, depending on RE_NO_BK_BRACES. 
26368:95:   If not set, \{, \}, {, and } are literals.  */
26369:96:#define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE << 1)
26370:97:
26371:98:/* If this bit is set, +, ? and | aren't recognized as operators.
26372:99:   If not set, they are.  */
26373:100:#define RE_LIMITED_OPS (RE_INTERVALS << 1)
26374:101:
26375:102:/* If this bit is set, newline is an alternation operator.
26376:103:   If not set, newline is literal.  */
26377:104:#define RE_NEWLINE_ALT (RE_LIMITED_OPS << 1)
26378:105:
26379:106:/* If this bit is set, then `{...}' defines an interval, and \{ and \}
26380:107:     are literals.
26381:108:  If not set, then `\{...\}' defines an interval.  */
26382:109:#define RE_NO_BK_BRACES (RE_NEWLINE_ALT << 1)
26383:110:
26384:111:/* If this bit is set, (...) defines a group, and \( and \) are literals.
26385:112:   If not set, \(...\) defines a group, and ( and ) are literals.  */
26386:113:#define RE_NO_BK_PARENS (RE_NO_BK_BRACES << 1)
26387:114:
26388:115:/* If this bit is set, then \<digit> matches <digit>.
26389:116:   If not set, then \<digit> is a back-reference.  */
26390:117:#define RE_NO_BK_REFS (RE_NO_BK_PARENS << 1)
26391:118:
26392:119:/* If this bit is set, then | is an alternation operator, and \| is literal. 
26393:120:   If not set, then \| is an alternation operator, and | is literal.  */
26394:121:#define RE_NO_BK_VBAR (RE_NO_BK_REFS << 1)
26395:122:
26396:123:/* If this bit is set, then an ending range point collating higher
26397:124:     than the starting range point, as in [z-a], is invalid.
26398:125:   If not set, then when ending range point collates higher than the
26399:126:     starting range point, the range is ignored.  */
26400:127:#define RE_NO_EMPTY_RANGES (RE_NO_BK_VBAR << 1)
26401:128:
26402:129:/* If this bit is set, then an unmatched ) is ordinary.
26403:130:   If not set, then an unmatched ) is invalid.  */
26404:131:#define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES << 1)
26405:132:
26406:133:/* If this bit is set, succeed as soon as we match the whole pattern,
26407:134:   without further backtracking.  */
26408:135:#define RE_NO_POSIX_BACKTRACKING (RE_UNMATCHED_RIGHT_PAREN_ORD << 1)
26409:136:
26410:137:/* This global variable defines the particular regexp syntax to use (for
26411:138:   some interfaces).  When a regexp is compiled, the syntax used is
26412:139:   stored in the pattern buffer, so changing this does not affect
26413:140:   already-compiled regexps.  */
26414:141:extern reg_syntax_t re_syntax_options;
26415:142:
26416:143:/* Define combinations of the above bits for the standard possibilities.
26417:144:   (The [[[ comments delimit what gets put into the Texinfo file, so
26418:145:   don't delete them!)  */
26419:146:/* [[[begin syntaxes]]] */
26420:147:#define RE_SYNTAX_EMACS 0
26421:148:
26422:149:#define RE_SYNTAX_AWK                                                        \
26423:150:  (RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DOT_NOT_NULL                        \
26424:151:   | RE_NO_BK_PARENS            | RE_NO_BK_REFS                                \
26425:152:   | RE_NO_BK_VBAR               | RE_NO_EMPTY_RANGES                        \
26426:153:   | RE_UNMATCHED_RIGHT_PAREN_ORD)
26427:154:
26428:155:#define RE_SYNTAX_POSIX_AWK                                                 \
26429:156:  (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS)
26430:157:
26431:158:#define RE_SYNTAX_GREP                                                        \
26432:159:  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES                                \
26433:160:   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS                                \
26434:161:   | RE_NEWLINE_ALT)
26435:162:
26436:163:#define RE_SYNTAX_EGREP                                                        \
26437:164:  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS                        \
26438:165:   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE                        \
26439:166:   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS                                \
26440:167:   | RE_NO_BK_VBAR)
26441:168:
26442:169:#define RE_SYNTAX_POSIX_EGREP                                                \
26443:170:  (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES)
26444:171:
26445:172:/* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */
26446:173:#define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC
26447:174:
26448:175:#define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC
26449:176:
26450:177:/* Syntax bits common to both basic and extended POSIX regex syntax.  */
26451:178:#define _RE_SYNTAX_POSIX_COMMON                                                \
26452:179:  (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL                \
26453:180:   | RE_INTERVALS  | RE_NO_EMPTY_RANGES)
26454:181:
26455:182:#define RE_SYNTAX_POSIX_BASIC                                                \
26456:183:  (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM)
26457:184:
26458:185:/* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes
26459:186:   RE_LIMITED_OPS, i.e., \? \+ \| are not recognized.  Actually, this
26460:187:   isn't minimal, since other operators, such as \`, aren't disabled.  */
26461:188:#define RE_SYNTAX_POSIX_MINIMAL_BASIC                                        \
26462:189:  (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)
26463:190:
26464:191:#define RE_SYNTAX_POSIX_EXTENDED                                        \
26465:192:  (_RE_SYNTAX_POSIX_COMMON | RE_CONTEXT_INDEP_ANCHORS                        \
26466:193:   | RE_CONTEXT_INDEP_OPS  | RE_NO_BK_BRACES                                \
26467:194:   | RE_NO_BK_PARENS       | RE_NO_BK_VBAR                                \
26468:195:   | RE_UNMATCHED_RIGHT_PAREN_ORD)
26469:196:
26470:197:/* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS
26471:198:   replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added.  */
26472:199:#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED                                \
26473:200:  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS                        \
26474:201:   | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES                                \
26475:202:   | RE_NO_BK_PARENS        | RE_NO_BK_REFS                                \
26476:203:   | RE_NO_BK_VBAR            | RE_UNMATCHED_RIGHT_PAREN_ORD)
26477:204:/* [[[end syntaxes]]] */
26478:205:
26479:206:/* Maximum number of duplicates an interval can allow.  Some systems
26480:207:   (erroneously) define this in other header files, but we want our
26481:208:   value, so remove any previous define.  */
26482:209:#ifdef RE_DUP_MAX
26483:210:#undef RE_DUP_MAX
26484:211:#endif
26485:212:#define RE_DUP_MAX ((1 << 15) - 1)
26486:213:
26487:214:
26488:215:/* POSIX `cflags' bits (i.e., information for `regcomp').  */
26489:216:
26490:217:/* If this bit is set, then use extended regular expression syntax.
26491:218:   If not set, then use basic regular expression syntax.  */
26492:219:#define REG_EXTENDED 1
26493:220:
26494:221:/* If this bit is set, then ignore case when matching.
26495:222:   If not set, then case is significant.  */
26496:223:#define REG_ICASE (REG_EXTENDED << 1)
26497:224:
26498:225:/* If this bit is set, then anchors do not match at newline
26499:226:     characters in the string.
26500:227:   If not set, then anchors do match at newlines.  */
26501:228:#define REG_NEWLINE (REG_ICASE << 1)
26502:229:
26503:230:/* If this bit is set, then report only success or fail in regexec.
26504:231:   If not set, then returns differ between not matching and errors.  */
26505:232:#define REG_NOSUB (REG_NEWLINE << 1)
26506:233:
26507:234:
26508:235:/* POSIX `eflags' bits (i.e., information for regexec).  */
26509:236:
26510:237:/* If this bit is set, then the beginning-of-line operator doesn't match
26511:238:     the beginning of the string (presumably because it's not the
26512:239:     beginning of a line).
26513:240:   If not set, then the beginning-of-line operator does match the
26514:241:     beginning of the string.  */
26515:242:#define REG_NOTBOL 1
26516:243:
26517:244:/* Like REG_NOTBOL, except for the end-of-line.  */
26518:245:#define REG_NOTEOL (1 << 1)
26519:246:
26520:247:
26521:248:/* If any error codes are removed, changed, or added, update the
26522:249:   `re_error_msg' table in regex.c.  */
26523:250:typedef enum {
26524:251:    REG_NOERROR = 0,            /* Success.  */
26525:252:    REG_NOMATCH,                /* Didn't find a match (for regexec).  */
26526:253:
26527:254:    /* POSIX regcomp return error codes.  (In the order listed in the
26528:255:       standard.)  */
26529:256:    REG_BADPAT,                 /* Invalid pattern.  */
26530:257:    REG_ECOLLATE,               /* Not implemented.  */
26531:258:    REG_ECTYPE,                 /* Invalid character class name.  */
26532:259:    REG_EESCAPE,                /* Trailing backslash.  */
26533:260:    REG_ESUBREG,                /* Invalid back reference.  */
26534:261:    REG_EBRACK,                 /* Unmatched left bracket.  */
26535:262:    REG_EPAREN,                 /* Parenthesis imbalance.  */
26536:263:    REG_EBRACE,                 /* Unmatched \{.  */
26537:264:    REG_BADBR,                  /* Invalid contents of \{\}.  */
26538:265:    REG_ERANGE,                 /* Invalid range end.  */
26539:266:    REG_ESPACE,                 /* Ran out of memory.  */
26540:267:    REG_BADRPT,                 /* No preceding re for repetition op.  */
26541:268:
26542:269:    /* Error codes we've added.  */
26543:270:    REG_EEND,                   /* Premature end.  */
26544:271:    REG_ESIZE,                  /* Compiled pattern bigger than 2^16 bytes.  */
26545:272:    REG_ERPAREN                 /* Unmatched ) or \); not returned from regcomp.  */
26546:273:} reg_errcode_t;
26547:274:
26548:275:/* This data structure represents a compiled pattern.  Before calling
26549:276:   the pattern compiler, the fields `buffer', `allocated', `fastmap',
26550:277:   `translate', and `no_sub' can be set.  After the pattern has been
26551:278:   compiled, the `re_nsub' field is available.  All other fields are
26552:279:   private to the regex routines.  */
26553:280:
26554:281:struct re_pattern_buffer {
26555:282:/* [[[begin pattern_buffer]]] */
26556:283:    /* Space that holds the compiled pattern.  It is declared as
26557:284:       `unsigned char *' because its elements are
26558:285:       sometimes used as array indexes.  */
26559:286:    unsigned char *buffer;
26560:287:
26561:288:    /* Number of bytes to which `buffer' points.  */
26562:289:    unsigned long allocated;
26563:290:
26564:291:    /* Number of bytes actually used in `buffer'.  */
26565:292:    unsigned long used;
26566:293:
26567:294:    /* Syntax setting with which the pattern was compiled.  */
26568:295:    reg_syntax_t syntax;
26569:296:
26570:297:    /* Pointer to a fastmap, if any, otherwise zero.  re_search uses
26571:298:       the fastmap, if there is one, to skip over impossible
26572:299:       starting points for matches.  */
26573:300:    char *fastmap;
26574:301:
26575:302:    /* Either a translate table to apply to all characters before
26576:303:       comparing them, or zero for no translation.  The translation
26577:304:       is applied to a pattern when it is compiled and to a string
26578:305:       when it is matched.  */
26579:306:    char *translate;
26580:307:
26581:308:    /* Number of subexpressions found by the compiler.  */
26582:309:    size_t re_nsub;
26583:310:
26584:311:    /* Zero if this pattern cannot match the empty string, one else.
26585:312:       Well, in truth it's used only in `re_search_2', to see
26586:313:       whether or not we should use the fastmap, so we don't set
26587:314:       this absolutely perfectly; see `re_compile_fastmap' (the
26588:315:       `duplicate' case).  */
26589:316:    unsigned can_be_null:1;
26590:317:
26591:318:    /* If REGS_UNALLOCATED, allocate space in the `regs' structure
26592:319:       for `max (RE_NREGS, re_nsub + 1)' groups.
26593:320:       If REGS_REALLOCATE, reallocate space if necessary.
26594:321:       If REGS_FIXED, use what's there.  */
26595:322:#define REGS_UNALLOCATED 0
26596:323:#define REGS_REALLOCATE 1
26597:324:#define REGS_FIXED 2
26598:325:    unsigned regs_allocated:2;
26599:326:
26600:327:    /* Set to zero when `regex_compile' compiles a pattern; set to one
26601:328:       by `re_compile_fastmap' if it updates the fastmap.  */
26602:329:    unsigned fastmap_accurate:1;
26603:330:
26604:331:    /* If set, `re_match_2' does not return information about
26605:332:       subexpressions.  */
26606:333:    unsigned no_sub:1;
26607:334:
26608:335:    /* If set, a beginning-of-line anchor doesn't match at the
26609:336:       beginning of the string.  */
26610:337:    unsigned not_bol:1;
26611:338:
26612:339:    /* Similarly for an end-of-line anchor.  */
26613:340:    unsigned not_eol:1;
26614:341:
26615:342:    /* If true, an anchor at a newline matches.  */
26616:343:    unsigned newline_anchor:1;
26617:344:
26618:345:/* [[[end pattern_buffer]]] */
26619:346:};
26620:347:
26621:348:typedef struct re_pattern_buffer regex_t;
26622:349:
26623:350:/* Type for byte offsets within the string.  POSIX mandates this.  */
26624:351:typedef int regoff_t;
26625:352:
26626:353:
26627:354:/* This is the structure we store register match data in.  See
26628:355:   regex.texinfo for a full description of what registers match.  */
26629:356:struct re_registers {
26630:357:    unsigned num_regs;
26631:358:    regoff_t *start;
26632:359:    regoff_t *end;
26633:360:};
26634:361:
26635:362:
26636:363:/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,
26637:364:   `re_match_2' returns information about at least this many registers
26638:365:   the first time a `regs' structure is passed.  */
26639:366:#ifndef RE_NREGS
26640:367:#define RE_NREGS 30
26641:368:#endif
26642:369:
26643:370:
26644:371:/* POSIX specification for registers.  Aside from the different names than
26645:372:   `re_registers', POSIX uses an array of structures, instead of a
26646:373:   structure of arrays.  */
26647:374:typedef struct {
26648:375:    regoff_t rm_so;             /* Byte offset from string's start to substring's start.  */
26649:376:    regoff_t rm_eo;             /* Byte offset from string's start to substring's end.  */
26650:377:} regmatch_t;
26651:378:
26652:379:/* Declarations for routines.  */
26653:380:
26654:381:/* To avoid duplicating every routine declaration -- once with a
26655:382:   prototype (if we are ANSI), and once without (if we aren't) -- we
26656:383:   use the following macro to declare argument types.  This
26657:384:   unfortunately clutters up the declarations a bit, but I think it's
26658:385:   worth it.  */
26659:386:
26660:387:#if __STDC__
26661:388:
26662:389:#define _RE_ARGS(args) args
26663:390:
26664:391:#else                           /* not __STDC__ */
26665:392:
26666:393:#define _RE_ARGS(args) ()
26667:394:
26668:395:#endif                          /* not __STDC__ */
26669:396:
26670:397:/* Sets the current default syntax to SYNTAX, and return the old syntax.
26671:398:   You can also simply assign to the `re_syntax_options' variable.  */
26672:399:extern reg_syntax_t re_set_syntax _RE_ARGS ((reg_syntax_t syntax));
26673:400:
26674:401:/* Compile the regular expression PATTERN, with length LENGTH
26675:402:   and syntax given by the global `re_syntax_options', into the buffer
26676:403:   BUFFER.  Return NULL if successful, and an error string if not.  */
26677:404:extern const char *re_compile_pattern
26678:405:_RE_ARGS ((const char *pattern, int length,
26679:406:           struct re_pattern_buffer * buffer));
26680:407:
26681:408:
26682:409:/* Compile a fastmap for the compiled pattern in BUFFER; used to
26683:410:   accelerate searches.  Return 0 if successful and -2 if was an
26684:411:   internal error.  */
26685:412:extern int re_compile_fastmap
26686:413:_RE_ARGS ((struct re_pattern_buffer * buffer));
26687:414:
26688:415:
26689:416:/* Search in the string STRING (with length LENGTH) for the pattern
26690:417:   compiled into BUFFER.  Start searching at position START, for RANGE
26691:418:   characters.  Return the starting position of the match, -1 for no
26692:419:   match, or -2 for an internal error.  Also return register
26693:420:   information in REGS (if REGS and BUFFER->no_sub are nonzero).  */
26694:421:extern int re_search
26695:422:_RE_ARGS ((struct re_pattern_buffer * buffer, const char *string,
26696:423:           int length, int start, int range, struct re_registers * regs));
26697:424:
26698:425:
26699:426:/* Like `re_search', but search in the concatenation of STRING1 and
26700:427:   STRING2.  Also, stop searching at index START + STOP.  */
26701:428:extern int re_search_2
26702:429:_RE_ARGS ((struct re_pattern_buffer * buffer, const char *string1,
26703:430:           int length1, const char *string2, int length2,
26704:431:           int start, int range, struct re_registers * regs, int stop));
26705:432:
26706:433:
26707:434:/* Like `re_search', but return how many characters in STRING the regexp
26708:435:   in BUFFER matched, starting at position START.  */
26709:436:extern int re_match
26710:437:_RE_ARGS ((struct re_pattern_buffer * buffer, const char *string,
26711:438:           int length, int start, struct re_registers * regs));
26712:439:
26713:440:
26714:441:/* Relates to `re_match' as `re_search_2' relates to `re_search'.  */
26715:442:extern int re_match_2
26716:443:_RE_ARGS ((struct re_pattern_buffer * buffer, const char *string1,
26717:444:           int length1, const char *string2, int length2,
26718:445:           int start, struct re_registers * regs, int stop));
26719:446:
26720:447:
26721:448:/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
26722:449:   ENDS.  Subsequent matches using BUFFER and REGS will use this memory
26723:450:   for recording register information.  STARTS and ENDS must be
26724:451:   allocated with malloc, and must each be at least `NUM_REGS * sizeof
26725:452:   (regoff_t)' bytes long.
26726:453:
26727:454:   If NUM_REGS == 0, then subsequent matches should allocate their own
26728:455:   register data.
26729:456:
26730:457:   Unless this function is called, the first search or match using
26731:458:   PATTERN_BUFFER will allocate its own register data, without
26732:459:   freeing the old data.  */
26733:460:extern void re_set_registers
26734:461:_RE_ARGS ((struct re_pattern_buffer * buffer, struct re_registers * regs,
26735:462:           unsigned num_regs, regoff_t * starts, regoff_t * ends));
26736:463:
26737:464:#ifdef _REGEX_RE_COMP
26738:465:/* 4.2 bsd compatibility.  */
26739:466:extern char *re_comp _RE_ARGS ((const char *));
26740:467:extern int re_exec _RE_ARGS ((const char *));
26741:468:#endif
26742:469:
26743:470:/* POSIX compatibility.  */
26744:471:extern int regcomp
26745:472:_RE_ARGS ((regex_t * preg, const char *pattern, int cflags));
26746:473:extern int regexec
26747:474:_RE_ARGS ((const regex_t * preg, const char *string, size_t nmatch,
26748:475:           regmatch_t pmatch[], int eflags));
26749:476:extern size_t regerror
26750:477:_RE_ARGS ((int errcode, const regex_t * preg, char *errbuf,
26751:478:           size_t errbuf_size));
26752:479:extern void regfree _RE_ARGS ((regex_t * preg));
26753:480:
26754:481:#endif                          /* not __REGEXP_LIBRARY_H__ */
26755:482:
26756:483:/*
26757:484:Local variables:
26758:485:make-backup-files: t
26759:486:version-control: t
26760:487:trim-versions-without-asking: nil
26761:488:End:
26762:489:*/
26763:1:#define SOLID
26764:2:#include "triangl.c"
26765:1:/*
26766:2:   Copyright (C) 1996 Paul Sheer
26767:3:
26768:4:   This program is free software; you can redistribute it and/or modify
26769:5:   it under the terms of the GNU General Public License as published by
26770:6:   the Free Software Foundation; either version 2 of the License, or
26771:7:   (at your option) any later version.
26772:8:
26773:9:   This program is distributed in the hope that it will be useful,
26774:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
26775:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
26776:12:   GNU General Public License for more details.
26777:13:
26778:14:   You should have received a copy of the GNU General Public License
26779:15:   along with this program; if not, write to the Free Software
26780:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
26781:17: */
26782:18:
26783:19:/* uncomment this line for some machines that don't have standard
26784:20:   headers/string-functions and cause a seg-fault on startup */
26785:21:
26786:22:#define CRASHES_ON_STARTUP
26787:23:
26788:24:
26789:25:#include <config.h>
26790:26:#include "global.h"
26791:27:#include <stdio.h>
26792:28:#include <stdlib.h>
26793:29:#include "my_string.h"
26794:30:#include <stdarg.h>
26795:31:#ifdef HAVE_UNISTD_H
26796:32:#include <unistd.h>
26797:33:#endif
26798:34:#include "stringtools.h"
26799:35:#include "regex.h"
26800:36:#include "time.h"
26801:37:
26802:38:#include "mad.h"
26803:39:
26804:40:/*
26805:41:   This cats a whole lot of strings together.
26806:42:   It has the advantage that the return result will
26807:43:   be free'd automatically, and MUST NOT be free'd
26808:44:   by the caller.
26809:45:   It will hold the most recent NUM_STORED strings.
26810:46: */
26811:47:#define NUM_STORED 32
26812:48:
26813:49:static char *stacked[NUM_STORED] = { 0, 0, 0, 0, 0, 0, 0, 0,
26814:50:    0, 0, 0, 0, 0, 0, 0, 0,
26815:51:    0, 0, 0, 0, 0, 0, 0, 0,
26816:52:    0, 0, 0, 0, 0, 0, 0, 0
26817:53:};
26818:54:
26819:55:char *catstrs (const char *first, ...)
26820:56:{
26821:57:    static int i = 0;
26822:58:    va_list ap;
26823:59:    int len;
26824:60:    char *data;
26825:61:
26826:62:    if (!first)
26827:63:        return 0;
26828:64:
26829:65:    len = strlen (first);
26830:66:    va_start (ap, first);
26831:67:
26832:68:    while ((data = va_arg (ap, char *)) != 0)
26833:69:         len += strlen (data);
26834:70:
26835:71:    len++;
26836:72:
26837:73:    i = (i + 1) % NUM_STORED;
26838:74:    if (stacked[i])
26839:75:        free (stacked[i]);
26840:76:
26841:77:    stacked[i] = malloc (len);
26842:78:    va_end (ap);
26843:79:    va_start (ap, first);
26844:80:    strcpy (stacked[i], first);
26845:81:    while ((data = va_arg (ap, char *)) != 0)
26846:82:         strcat (stacked[i], data);
26847:83:    va_end (ap);
26848:84:
26849:85:    return stacked[i];
26850:86:}
26851:87:
26852:88:void catstrs_clean (void)
26853:89:{
26854:90:    int i;
26855:91:    for (i = 0; i < NUM_STORED; i++)
26856:92:        if (stacked[i]) {
26857:93:            free (stacked[i]);
26858:94:            stacked[i] = 0;
26859:95:        }
26860:96:}
26861:97:
26862:98:
26863:99:/* alternative to free() */
26864:100:void destroy (void **p)
26865:101:{
26866:102:    if (*p) {
26867:103:        free (*p);
26868:104:        *p = 0;
26869:105:    }
26870:106:}
26871:107:
26872:108:#define my_lower_case(x) ((x) < 'a' ? (x) - 'A' + 'a' : (x))
26873:109:
26874:110:char *strcasechr (const char *s, int c)
26875:111:{
26876:112:    for (; my_lower_case (*s) != my_lower_case ((char) c); ++s)
26877:113:        if (*s == '\0')
26878:114:            return 0;
26879:115:    return (char *) s;
26880:116:}
26881:117:
26882:118:char *itoa (int i)
26883:119:{
26884:120:    static char t[20];
26885:121:    char *s = t + 19;
26886:122:    int j = i;
26887:123:    i = abs (i);
26888:124:    *s-- = 0;
26889:125:    do {
26890:126:        *s-- = i % 10 + '0';
26891:127:    } while ((i = i / 10));
26892:128:    if (j < 0)
26893:129:        *s-- = '-';
26894:130:    return ++s;
26895:131:}
26896:132:
26897:133:char *itoh (int i)
26898:134:{
26899:135:    static char t[20];
26900:136:    char *s = t + 19;
26901:137:    int j = i;
26902:138:    i = abs (i);
26903:139:    *s-- = 0;
26904:140:    do {
26905:141:        *s-- = i % 10 + '0';
26906:142:    } while ((i = i / 10));
26907:143:    if (j < 0)
26908:144:        *s-- = '-';
26909:145:    return ++s;
26910:146:}
26911:147:
26912:148:/*
26913:149:   returns a name based on the time times the pid, result must be
26914:150:   copied immediately and must not be free'd.
26915:151: */
26916:152:char *get_temp_file_name (void)
26917:153:{
26918:154:    return catstrs (PACKAGE,
26919:155:                    itoa ((int) abs ((int) time (0) * (int) getpid ())),
26920:156:                    ".tmp", 0);
26921:157:}
26922:158:
26923:159:/* this comes from the Midnight Commander src/tools.c */
26924:160:char *get_current_wd (char *buffer, int size)
26925:161:{
26926:162:    char *p;
26927:163:
26928:164:#ifdef HAVE_GETWD
26929:165:    p = (char *) getwd (buffer);
26930:166:#else
26931:167:    p = getcwd (buffer, size);
26932:168:#endif
26933:169:    return p;
26934:170:}
26935:171:
26936:172:/*
26937:173:   cd's to path and sets current_dir variable if getcwd works, else set
26938:174:   current_dir to "".
26939:175: */
26940:176:extern char current_dir[];
26941:177:int change_directory (const char *path)
26942:178:{
26943:179:    int e;
26944:180:    e = chdir (path);
26945:181:    if (e < 0)
26946:182:        return e;
26947:183:    if (!get_current_wd (current_dir, MAX_PATH_LEN))
26948:184:        strcpy (current_dir, "/");
26949:185:    return 0;
26950:186:}
26951:187:
26952:188:
26953:189:short *shortset (short *s, int c, size_t n)
26954:190:{
26955:191:    short *r = s;
26956:192:    while (n--)
26957:193:        *s++ = c;
26958:194:    return r;
26959:195:}
26960:196:
26961:197:
26962:198:char *name_trunc (const char *txt, int trunc_len)
26963:199:{
26964:200:    static char x[1024];
26965:201:    int txt_len, y;
26966:202:
26967:203:    txt_len = strlen (txt);
26968:204:    if (txt_len <= trunc_len) {
26969:205:        strcpy (x, txt);
26970:206:        return x;
26971:207:    }
26972:208:    y = trunc_len % 2;
26973:209:    strncpy (x, txt, (trunc_len / 2) + y);
26974:210:    strncpy (x + (trunc_len / 2) + y, txt + txt_len - (trunc_len / 2),
26975:211:             trunc_len / 2);
26976:212:    x[(trunc_len / 2) + y] = '~';
26977:213:    x[trunc_len] = 0;
26978:214:    return x;
26979:215:}
26980:216:
26981:217:/* cats together dir/file considering any possibility and removes
26982:218:   // /./ spaces etc */
26983:219:char *path_compress (const char *dir, const char *file)
26984:220:{
26985:221:    static char estr[1024] = "";
26986:222:    char *q;
26987:223:
26988:224:    if (file) {
26989:225:        if (*file == '/' || !dir) {
26990:226:            strcpy (estr, file);
26991:227:        } else {
26992:228:            strcpy (estr, catstrs (dir, "/", file, 0));
26993:229:        }
26994:230:    } else {
26995:231:        if (dir)
26996:232:            strcpy (estr, dir);
26997:233:        else
26998:234:            getcwd (estr, 1000);
26999:235:        if (!*estr)
27000:236:            return estr;
27001:237:    }
27002:238:    while ((q = strchr (estr, ' ')))
27003:239:        memmove (q, q + 1, strlen (q));
27004:240:    while ((q = strstr (estr, "//")))
27005:241:        memmove (q, q + 1, strlen (q));
27006:242:    while ((q = strstr (estr, "/./")))
27007:243:        memmove (q, q + 2, strlen (q) + 1);
27008:244:    if ((q = strstr (estr, "/.."))) {
27009:245:        *q = 0;
27010:246:        if ((q = strrchr (estr, '/')))
27011:247:            *(q + 1) = 0;
27012:248:    }
27013:249:    q = estr + strlen (estr) - 1;
27014:250:    if (q > estr)
27015:251:        if (*(q - 1) == '/' && *q == '.')
27016:252:            *(q - 1) = 0;
27017:253:    if (!strlen (estr))
27018:254:        strcpy (estr, dir);
27019:255:    return estr;
27020:256:}
27021:257:
27022:258:#define r_is_printable(x) ((x >= ' ' && x <= '~') || x >= 160)
27023:259:
27024:260:int strcolmove (unsigned char *str, int i, int column)
27025:261:{
27026:262:    int col = 0;
27027:263:    if (column <= 0)
27028:264:        return i;
27029:265:    for (col = 0; col < column; i++) {
27030:266:        while (str[i + 1] == '\b' && r_is_printable (str[i + 2])
27031:267:               && r_is_printable (str[i]))
27032:268:            i += 2;
27033:269:        if (!str[i] || str[i] == '\n')
27034:270:            break;
27035:271:        if (str[i] == '\r')
27036:272:            continue;
27037:273:        if (str[i] == '\t') {
27038:274:            col += 8 - (col % 8);
27039:275:            continue;
27040:276:        }
27041:277:        col++;
27042:278:    }
27043:279:    return i;
27044:280:}
27045:281:
27046:282:/*move to col character from beginning of line with i in the line somewhere. */
27047:283:/*If col is past the end of the line, it returns position of end of line */
27048:284:long strfrombeginline (const char *s, int i, int col)
27049:285:{
27050:286:    unsigned char *str = (unsigned char *) s;
27051:287:    if (i < 0) {
27052:288:        fprintf (stderr, "strfrombeginline called with negative index.\n");
27053:289:        exit (1);
27054:290:    }
27055:291:    while (i--)
27056:292:        if (str[i] == '\n') {
27057:293:            i++;
27058:294:            break;
27059:295:        }
27060:296:    if (i < 0)
27061:297:        i = 0;
27062:298:    return strcolmove (str, i, col);
27063:299:}
27064:300:
27065:301:/*
27066:302:    strip backspaces from the nroff file to produce normal text.
27067:303:    returns strlen(result) if l is non null
27068:304:*/
27069:305:char *str_strip_nroff (char *t, int *l)
27070:306:{
27071:307:    unsigned char *s = (unsigned char *) t;
27072:308:    unsigned char *r, *q;
27073:309:    int p;
27074:310:
27075:311:    q = r = malloc (strlen (t) + 2);
27076:312:    if (!r)
27077:313:        return 0;
27078:314:
27079:315:    for (p = 0; s[p]; p++) {
27080:316:        while (s[p + 1] == '\b' && r_is_printable (s[p + 2])
27081:317:               && r_is_printable (s[p]))
27082:318:            p += 2;
27083:319:        *q++ = s[p];
27084:320:    }
27085:321:    *q = 0;
27086:322:    if (l)
27087:323:        *l = ((unsigned long) q - (unsigned long) r);
27088:324:    return (char *) r;
27089:325:}
27090:326:
27091:327:long countlinesforward (const char *text, long from, long amount,
27092:328:                        long lines, int width)
27093:329:{
27094:330:    int col = 0, row = 0, q = 0;
27095:331:    unsigned char c;
27096:332:    int p = from;
27097:333:    if (!(amount | lines))
27098:334:        return 0;
27099:335:    for (; from < p + amount || !amount; from++) {
27100:336:        c = text[from];
27101:337:        if (!c) {
27102:338:            if (lines)
27103:339:                return q;
27104:340:            break;
27105:341:        }
27106:342:        if (lines && lines == row)
27107:343:            return from;
27108:344:        if (c == '\n' || col == width) {
27109:345:            col = 0;
27110:346:            q = from + 1;
27111:347:            row++;
27112:348:        }
27113:349:        if (c == '\r')
27114:350:            continue;
27115:351:        if (c == '\t') {
27116:352:            col = (col / 8) * 8 + 8;
27117:353:            continue;
27118:354:        }
27119:355:        col++;
27120:356:    }
27121:357:    return row;
27122:358:}
27123:359:
27124:360:/* returns pos of begin of line moved to */
27125:361:/* move forward from i, `lines' can be negative --- moveing backward */
27126:362:long strmovelines (const char *str, long from, long lines, int width)
27127:363:{
27128:364:    int p, q;
27129:365:    if (lines > 0)
27130:366:        return countlinesforward (str, from, 0, lines, width);
27131:367:    if (lines == 0)
27132:368:        return from;
27133:369:    else {
27134:370:        int line = 0;
27135:371:        p = from;
27136:372:        for (; p > 0;) {
27137:373:            q = p;
27138:374:            p = strfrombeginline (str, q - 1, 0);
27139:375:            line += countlinesforward (str, p, q - p, 0, width);
27140:376:            if (line > -lines)
27141:377:                return countlinesforward (str, p, 0, line + lines, width);
27142:378:            if (line == -lines)
27143:379:                return p;
27144:380:        }
27145:381:        return 0;
27146:382:    }
27147:383:}
27148:384:
27149:385:
27150:386:
27151:387:/*returns a positive or negative count of lines */
27152:388:long strcountlines (const char *str, long i, long amount, int width)
27153:389:{
27154:390:    int lines, p;
27155:391:    if (amount > 0) {
27156:392:        return countlinesforward (str, i, amount, 0, width);
27157:393:    }
27158:394:    if (amount == 0)
27159:395:        return 0;
27160:396:    if (i + amount < 0)
27161:397:        amount = -i;
27162:398:    p = strfrombeginline (str, i + amount, 0);
27163:399:    lines = countlinesforward (str, p, i + amount - p, 0, width);
27164:400:    return -countlinesforward (str, p, i - p, 0, width) + lines;
27165:401:}
27166:402:
27167:403:/*
27168:404:   returns a null terminated string. The string
27169:405:   is a copy of the line beginning at p and ending at '\n'
27170:406:   in the string src.
27171:407:   The result must not be free'd. This routine caches the last
27172:408:   four results.
27173:409: */
27174:410:char *strline (const char *src, int p)
27175:411:{
27176:412:    static char line[4][1024];
27177:413:    static int last = 0;
27178:414:    int i = 0;
27179:415:    char *r;
27180:416:    while (src[p] != '\n' && src[p] && i < 1000) {
27181:417:        i++;
27182:418:        p++;
27183:419:    }
27184:420:    r = line[last & 3];
27185:421:    memcpy (r, src + p - i, i);
27186:422:    r[i] = 0;
27187:423:    last++;
27188:424:    return r;
27189:425:}
27190:426:
27191:427:/*
27192:428:size_t strnlen (const char *s, size_t count)
27193:429:{
27194:430:    const char *sc;
27195:431:
27196:432:    for (sc = s; count-- && *sc != '\0'; ++sc)
27197:433:        /* nothing */ ;
27198:434:/*    return sc - s;
27199:435:} */
27200:436:
27201:437:
27202:438:#ifdef CRASHES_ON_STARTUP
27203:439:
27204:440:/* (this is waistful, but it solves sunos's non-standardness
27205:441:   that causes a segfault) */
27206:442:#define vfmtlen(a,b) (strlen(a)+2048)
27207:443:
27208:444:#else                           /* CRASHES_ON_STARTUP */
27209:445:
27210:446:#define is_digit(x) ((x) >= '0' && (x) <= '9')
27211:447:
27212:448:#define scount(v) { \
27213:449:                *p1++ = *p++; \
27214:450:                *p1++ = '%'; \
27215:451:                *p1++ = 'n'; \
27216:452:                *p1 = 0; \
27217:453:                sprintf(s,q1,v,&n); \
27218:454:                count += n; \
27219:455:            }
27220:456:
27221:457:
27222:458:/* returns the length of a string that would be printed if this
27223:459:   command was vprintf, but prints nothing */
27224:460:size_t vfmtlen (const char *fmt, va_list ap)
27225:461:{
27226:462:    char *q, *p, s[66];
27227:463:    int n;
27228:464:    char q1[32];
27229:465:    char *p1;
27230:466:    size_t count = 0;
27231:467:
27232:468:    p = q = (char *) fmt;
27233:469:
27234:470:    while ((p = strchr (p, '%'))) {
27235:471:        count += (size_t) ((unsigned long) p - (unsigned long) q);
27236:472:        q = p;
27237:473:        p1 = q1;
27238:474:        *p1++ = *p++;
27239:475:        if (*p == '%') {
27240:476:            p++;
27241:477:            count++;
27242:478:            q = p;
27243:479:            continue;
27244:480:        }
27245:481:        if (*p == 'n') {
27246:482:            p++;
27247:483:            q = p;
27248:484:            *va_arg (ap, int *) = count;
27249:485:            continue;
27250:486:        }
27251:487:        if (*p == '#')
27252:488:            *p1++ = *p++;
27253:489:        if (*p == '0')
27254:490:            *p1++ = *p++;
27255:491:        if (*p == '-')
27256:492:            *p1++ = *p++;
27257:493:        if (*p == '+')
27258:494:            *p1++ = *p++;
27259:495:        if (*p == '*') {
27260:496:            p++;
27261:497:            strcpy (p1, itoa (va_arg (ap, int)));
27262:498:            p1 += strlen (p1);
27263:499:        } else {
27264:500:            while (is_digit (*p))
27265:501:                *p1++ = *p++;
27266:502:        }
27267:503:        if (*p == '.')
27268:504:            *p1++ = *p++;
27269:505:        if (*p == '*') {
27270:506:            p++;
27271:507:            strcpy (p1, itoa (va_arg (ap, int)));
27272:508:            p1 += strlen (p1);
27273:509:        } else {
27274:510:            while (is_digit (*p))
27275:511:                *p1++ = *p++;
27276:512:        }
27277:513:        if (*p == 's') {
27278:514:            scount (va_arg (ap, char *));
27279:515:        } else if (*p == 'h') {
27280:516:            if (strchr ("diouxX", *p))
27281:517:                scount (va_arg (ap, short));
27282:518:        } else if (*p == 'l') {
27283:519:            *p1++ = *p++;
27284:520:            if (strchr ("diouxX", *p))
27285:521:                scount (va_arg (ap, long));
27286:522:        } else if (strchr ("cdiouxX", *p)) {
27287:523:            scount (va_arg (ap, int));
27288:524:        } else if (*p == 'L') {
27289:525:            *p1++ = *p++;
27290:526:            if (strchr ("EefgG", *p))
27291:527:                scount (va_arg (ap, double)); /* should be long double, but gives warnings on some machines */
27292:528:        } else if (strchr ("EefgG", *p)) {
27293:529:            scount (va_arg (ap, double));
27294:530:        } else if (strchr ("DOU", *p)) {
27295:531:            scount (va_arg (ap, long));
27296:532:        } else if (*p == 'p') {
27297:533:            scount (va_arg (ap, void *));
27298:534:        }
27299:535:        q = p;
27300:536:    }
27301:537:    return count + strlen (q);
27302:538:}
27303:539:
27304:540:#endif                          /* CRASHES_ON_STARTUP */
27305:541:
27306:542:#ifndef HAVE_MAD
27307:543:
27308:544:/* vsprintf with memory allocation. result must be free'd */
27309:545:char *vsprintf_alloc (const char *fmt, va_list ap)
27310:546:{
27311:547:    char *s;
27312:548:    size_t l;
27313:549:    s = malloc ((l = vfmtlen (fmt, ap)) + 1);
27314:550:    if (!s)
27315:551:        fprintf (stderr, "cooledit:%s:%d: malloc return zero\n", __FILE__,
27316:552:                 __LINE__);
27317:553:    s[l] = 0;
27318:554:    vsprintf (s, fmt, ap);
27319:555:    if (s[l])
27320:556:/* this is just in case there is a bug in vfmtlen above (it also
27321:557:    happens if you pass a incorrect format string) */
27322:558:        fprintf (stderr, "cooledit:%s:%d: vsprintf wrote out of bounds\n",
27323:559:                 __FILE__, __LINE__);
27324:560:    return s;
27325:561:}
27326:562:
27327:563:#else
27328:564:
27329:565:char *mad_vsprintf_alloc (const char *fmt, va_list ap, char *file,
27330:566:                          int line)
27331:567:{
27332:568:    char *s;
27333:569:    s = mad_alloc (vfmtlen (fmt, ap) + 1, file, line);
27334:570:    vsprintf (s, fmt, ap);
27335:571:    return s;
27336:572:}
27337:573:
27338:574:#endif
27339:575:
27340:576:char *sprintf_alloc (const char *fmt, ...)
27341:577:{
27342:578:    char *s;
27343:579:    va_list ap;
27344:580:    va_start (ap, fmt);
27345:581:    s = vsprintf_alloc (fmt, ap);
27346:582:    va_end (ap);
27347:583:    return s;
27348:584:}
27349:1:#ifndef STRING_TOOLS_H
27350:2:#define STRING_TOOLS_H
27351:3:
27352:4:#include "global.h"
27353:5:#include "my_string.h"
27354:6:
27355:7:#define clear(x,type) memset((x), 0, sizeof(type));
27356:8:
27357:9:short *shortset (short *s, int c, size_t n);
27358:10:
27359:11:/*move to col character from beginning of line with i in the line somewhere. */
27360:12:/*If col is past the end of the line, it returns position of end of line. */
27361:13:/*Can be used as movetobeginning of line if col = 0. */
27362:14:long strfrombeginline (const char *str, int i, int col);
27363:15:
27364:16:/*move forward from i, where `lines' can be negative --- moving backward */
27365:17:/*returns pos of begin of line moved to */
27366:18:long strmovelines (const char *str, long i, long lines, int width);
27367:19:
27368:20:/*returns a positive or negative count of lines
27369:21:   from i to i + amount */
27370:22:long strcountlines (const char *str, long i, long amount, int width);
27371:23:
27372:24:char *str_strip_nroff (char *t, int *l);
27373:25:
27374:26:/*returns a null terminated string. The string
27375:27:   is a copy of the line beginning at p and ending at '\n' 
27376:28:   in the string src.
27377:29:   The result must be free'd. */
27378:30:char *strline (const char *src, int p);
27379:31:
27380:32:int strcolmove (unsigned char *str, int i, int col);
27381:33:
27382:34:/*  cat many strings together. Result must not be free'd.
27383:35:   Free's your result after 32 calls. */
27384:36:char *catstrs (const char *first, ...);
27385:37:void catstrs_clean (void);
27386:38:
27387:39:/* for regexp */
27388:40:enum {
27389:41:    match_file, match_normal
27390:42:};
27391:43:extern int easy_patterns;
27392:44:char *convert_pattern (char *pattern, int match_type, int do_group);
27393:45:int regexp_match (char *pattern, char *string, int match_type);
27394:46:
27395:47:char *name_trunc (const char *txt, int trunc_len);
27396:48:char *path_compress (const char *dir, const char *file);
27397:49:
27398:50:#ifdef HAVE_MAD
27399:51:char *mad_vsprintf_alloc (const char *fmt, va_list ap, char *file,
27400:52:                          int line);
27401:53:#define vsprintf_alloc(f,a) mad_vsprintf_alloc(f, a, __FILE__, __LINE__)
27402:54:#else
27403:55:char *vsprintf_alloc (const char *fmt, va_list ap);
27404:56:#endif
27405:57:
27406:58:char *sprintf_alloc (const char *fmt, ...);
27407:59:char *itoa (int i);
27408:60:size_t strnlen (const char *s, size_t count);
27409:61:void destroy (void **p);
27410:62:char *get_temp_file_name (void);
27411:63:int change_directory (const char *path);
27412:64:char *get_current_wd (char *buffer, int size);
27413:65:char *strcasechr (const char *s, int c);
27414:66:
27415:67:#endif
27416:1:#define SOLID
27417:2:#define WRAP
27418:3:#include "triangl.c"
27419:1:/* textwidget.c - for drawing a scrollable text window widget
27420:2:   Copyright (C) 1997 Paul Sheer
27421:3:
27422:4:   This program is free software; you can redistribute it and/or modify
27423:5:   it under the terms of the GNU General Public License as published by
27424:6:   the Free Software Foundation; either version 2 of the License, or
27425:7:   (at your option) any later version.
27426:8:
27427:9:   This program is distributed in the hope that it will be useful,
27428:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
27429:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
27430:12:   GNU General Public License for more details.
27431:13:
27432:14:   You should have received a copy of the GNU General Public License
27433:15:   along with this program; if not, write to the Free Software
27434:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
27435:17: */
27436:18:
27437:19:#include <config.h>
27438:20:#include <stdio.h>
27439:21:#include <my_string.h>
27440:22:#include <stdlib.h>
27441:23:#include <stdarg.h>
27442:24:
27443:25:#include <X11/Xlib.h>
27444:26:#include <X11/Xutil.h>
27445:27:#include <X11/Xresource.h>
27446:28:#include "lkeysym.h"
27447:29:
27448:30:#include "stringtools.h"
27449:31:#include "app_glob.c"
27450:32:#include "edit.h"
27451:33:#include "editcmddef.h"
27452:34:
27453:35:#include "coolwidget.h"
27454:36:#include "coollocal.h"
27455:37:#include "dialog.h"
27456:38:
27457:39:#include "mad.h"
27458:40:
27459:41:int option_text_fg_normal = 0;
27460:42:int option_text_fg_bold = 17;
27461:43:int option_text_fg_italic = 16;
27462:44:
27463:45:int option_text_bg_normal = 22;
27464:46:int option_text_bg_marked = 25;
27465:47:int option_text_bg_highlighted = 12;
27466:48:
27467:49:CWidget *Cdrawtextbox (const char *identifier, Window parent, int x, int y,
27468:50:                       int width, int height, int line, int column,
27469:51:                       const char *text, long options)
27470:52:{
27471:53:    char *scroll;
27472:54:    int numlines;
27473:55:    CWidget *wdt;
27474:56:
27475:57:    int w, h;
27476:58:    if (width == AUTO_WIDTH || height == AUTO_HEIGHT)
27477:59:        Ctextsize (&w, &h, text);
27478:60:    if (width == AUTO_WIDTH)
27479:61:        width = w + 6;
27480:62:    if (height == AUTO_HEIGHT)
27481:63:        height = h + 6;
27482:64:
27483:65:    wdt = Csetupwidget (identifier, parent, x, y,
27484:66:                        width, height, CTEXTBOX_WIDGET, INPUT_KEY,
27485:67:                        Ccolor (option_text_bg_normal), 1);
27486:68:
27487:69:    wdt->options = options;
27488:70:    wdt->text = strdup (text);
27489:71:    numlines =
27490:72:        strcountlines (text, 0, 1000000000,
27491:73:                       options & TEXT_WRAP ? wdt->width /
27492:74:                       TEXT_M_WIDTH : 32000) + 1;
27493:75:
27494:76:    wdt->firstline = 0;
27495:77:    wdt->firstcolumn = 0;
27496:78:    wdt->cursor = 0;
27497:79:    wdt->current = 0;
27498:80:    wdt->numlines = numlines;
27499:81:    wdt->textlength = strlen (wdt->text);
27500:82:
27501:83:    Csettextboxpos (wdt, TEXT_SETLINE, line);
27502:84:    Csettextboxpos (wdt, TEXT_SETCOL, column);
27503:85:
27504:86:/* this will also set the hint position, Csethintpos() */
27505:87:    Cdrawvertscrollbar (scroll = catstrs (identifier, ".vsc", 0), parent,
27506:88:                        x + width + WIDGET_SPACING, y, height, AUTO_WIDTH,
27507:89:                        0, 0);
27508:90:
27509:91:    wdt->scrollbar = Cwidget (scroll);
27510:92:    wdt->scrollbar->textbox = wdt;
27511:93:
27512:94:    return wdt;
27513:95:}
27514:96:
27515:97:
27516:98:long Csettextboxpos (CWidget * w, int which, long p);
27517:99:void Cinputtobox (CWidget * wdt, CWidget * box);
27518:100:
27519:101:/* redraws the text box. If preserve is 0 then view position is reset to 0 */
27520:102:CWidget *Credrawtextbox (const char *identifier, const char *text,
27521:103:                         int preserve)
27522:104:{
27523:105:    CWidget *w = Cwidget (identifier);
27524:106:    CWidget *cell;
27525:107:    int numlines, firstline, firstcolumn, cursor;
27526:108:
27527:109:    char *input = catstrs ("sprinp", w->ident, 0);
27528:110:
27529:111:    if ((cell = Cwidget (input)))
27530:112:        Cundrawwidget (input);
27531:113:
27532:114:    free (w->text);
27533:115:    w->text = strdup (text);
27534:116:    w->textlength = strlen (w->text);
27535:117:    numlines =
27536:118:        strcountlines (text, 0, 1000000000,
27537:119:                       w->options & TEXT_WRAP ? w->width /
27538:120:                       TEXT_M_WIDTH : 32000) + 1;
27539:121:    w->numlines = numlines;
27540:122:    firstline = w->firstline;
27541:123:    firstcolumn = w->firstcolumn;
27542:124:    cursor = w->cursor;
27543:125:
27544:126:    w->firstline = 0;
27545:127:    w->current = 0;
27546:128:    w->firstcolumn = 0;
27547:129:    w->column = 0;
27548:130:    w->cursor = 0;
27549:131:
27550:132:    if (preserve) {
27551:133:        Csettextboxpos (w, TEXT_SETLINE, firstline);
27552:134:        Csettextboxpos (w, TEXT_SETCOL, firstcolumn);
27553:135:        Csettextboxpos (w, TEXT_SET_CURSOR_LINE, cursor);
27554:136:    }
27555:137:    Cexpose (identifier);
27556:138:
27557:139:    return w;
27558:140:}
27559:141:
27560:142:
27561:143:CWidget *Cdrawmanpage (const char *identifier, Window parent, int x, int y,
27562:144:                       int width, int height, int line, int column,
27563:145:                       const char *text)
27564:146:{
27565:147:    CWidget *w;
27566:148:    w = Cdrawtextbox (identifier, parent, x, y, width, height, line,
27567:149:                      column, text, MAN_PAGE);
27568:150:    return w;
27569:151:}
27570:152:
27571:153:
27572:154:
27573:155:/*
27574:156:   If which is TEXT_SETPOS the current offset of the top right
27575:157:   corner is set to p and the top line number is returned;
27576:158:   returns new ofset if which is TEXT_SETLINE (set the top line number);
27577:159:   returns new column if which is TEXT_SETCOL;
27578:160:   return top line number if which is TEXT_SET_CURSOR_LINE.
27579:161: */
27580:162:long Csettextboxpos (CWidget * wdt, int which, long p)
27581:163:{
27582:164:    long q;
27583:165:    int width;
27584:166:    if (p < 0)
27585:167:        p = 0;
27586:168:
27587:169:    width = wdt->options & TEXT_WRAP ? wdt->width / TEXT_M_WIDTH : 32000;
27588:170:
27589:171:    switch (which) {
27590:172:    case TEXT_SETCOL:
27591:173:        wdt->firstcolumn = p;
27592:174:        return p;
27593:175:    case TEXT_SETLINE:
27594:176:        if (p >= wdt->numlines)
27595:177:            p = wdt->numlines - 1;
27596:178:        if (p < 0)
27597:179:            p = 0;
27598:180:        q = strmovelines (wdt->text, wdt->current, p - wdt->firstline,
27599:181:                          width);
27600:182:        wdt->firstline +=
27601:183:            strcountlines (wdt->text, wdt->current, q - wdt->current,
27602:184:                           width);
27603:185:        wdt->current = q;
27604:186:        return wdt->current;
27605:187:    case TEXT_SETPOS:
27606:188:        wdt->firstline +=
27607:189:            strcountlines (wdt->text, wdt->current, p - wdt->current,
27608:190:                           width);
27609:191:        wdt->current = p;
27610:192:        return wdt->firstline;
27611:193:    case TEXT_SET_CURSOR_LINE:
27612:194:        if (p < 0)
27613:195:            p = 0;
27614:196:        if (p >= wdt->numlines)
27615:197:            p = wdt->numlines - 1;
27616:198:        wdt->cursor = p;
27617:199:        if (p < wdt->firstline)
27618:200:            Csettextboxpos (wdt, TEXT_SETLINE, p);
27619:201:        else if (p > wdt->firstline + wdt->height / TEXT_PIX_PER_LINE - 1)
27620:202:            Csettextboxpos (wdt, TEXT_SETLINE,
27621:203:                            p - wdt->height / TEXT_PIX_PER_LINE + 1);
27622:204:        return wdt->firstline;
27623:205:    }
27624:206:    Cerror ("settextpos: command not found.\n");
27625:207:    return 0;
27626:208:}
27627:209:
27628:210:
27629:211:/*
27630:212:   ->firstline   is line number of the top line in the window.
27631:213:   ->firstcolumn is column shift (positive).
27632:214:   ->current     is actual char position of first line in display.
27633:215:   ->numlines    is the total number of lines.
27634:216:   ->cursor      is the number of the highlighted line.
27635:217:   ->textlength  is the length of text excluding trailing NULL.
27636:218:   First three must be initialised to proper values (e.g. 0, 0 and 0).
27637:219: */
27638:220:
27639:221:#define r_is_printable(x) ((x >= ' ' && x <= '~') || x >= 160)
27640:222:
27641:223:extern int EditExposeRedraw;
27642:224:
27643:225:/*
27644:226:   Renders the text box, doing nroff formating if necesary.
27645:227:   wrapped text with nroff is not supported.
27646:228:   Returns number of text lines printed.
27647:229: */
27648:230:long Crendertextbox (CWidget * wdt, int redrawall)
27649:231:{
27650:232:    int w = wdt->width, h = wdt->height;
27651:233:    int nroff, col = 0, row = 0, height, width;
27652:234:    long from;
27653:235:    unsigned char c;
27654:236:    int wrap_mode, style = 0, draw = 1, index;
27655:237:    Window win;
27656:238:    unsigned short line[256];
27657:239:    static Window lastwin;
27658:240:    static long lasttexttop, lastcursorline, lastcol;
27659:241:    static int lastfocussed;
27660:242:    static long lastm1, lastm2;
27661:243:    int isfocussed;
27662:244:    long result, m1, m2;
27663:245:    unsigned char *text;
27664:246:    int curs = 1;
27665:247:
27666:248:    win = wdt->winid;
27667:249:    isfocussed = (win == CGetFocus ());
27668:250:
27669:251:    nroff = (wdt->options & MAN_PAGE);
27670:252:    wrap_mode = (wdt->options & TEXT_WRAP);
27671:253:    if (nroff)
27672:254:        wrap_mode = 0;
27673:255:
27674:256:    if (!redrawall) {
27675:257:        if (lastwin == win && lasttexttop == wdt->firstline
27676:258:            && lastfocussed == isfocussed && lastcol == wdt->firstcolumn
27677:259:            && lastcursorline == wdt->cursor && lastm1 == wdt->mark1
27678:260:            && lastm2 == wdt->mark2) {
27679:261:            draw = 0;
27680:262:        }
27681:263:    } else {
27682:264:        EditExposeRedraw = 1;
27683:265:    }
27684:266:
27685:267:    m1 = min (wdt->mark1, wdt->mark2);
27686:268:    m2 = max (wdt->mark1, wdt->mark2);
27687:269:
27688:270:/* when text is highlighted, the cursor must be off */
27689:271:    if (wdt->options & TEXT_BOX_NO_CURSOR || m1 != m2) /* don't draw the cursor line */
27690:272:        curs = 0;
27691:273:
27692:274:    edit_set_foreground_colors (Ccolor (option_text_fg_normal),
27693:275:                                Ccolor (option_text_fg_bold),
27694:276:                                Ccolor (option_text_fg_italic));
27695:277:    edit_set_background_colors (Ccolor (option_text_bg_normal), Ccolor (0),
27696:278:                                Ccolor (option_text_bg_marked), Ccolor (9),
27697:279:                                Ccolor (option_text_bg_highlighted));
27698:280:
27699:281:    text = (unsigned char *) wdt->text;
27700:282:    height = wdt->height / TEXT_PIX_PER_LINE;
27701:283:    width = wdt->width / TEXT_M_WIDTH;
27702:284:    from = wdt->current;
27703:285:
27704:286:    if (row + wdt->firstline == wdt->cursor && isfocussed && curs)
27705:287:        shortset ((short *) line, ' ' + 256 * MOD_HIGHLIGHTED, width);
27706:288:    else
27707:289:        shortset ((short *) line, ' ', width);
27708:290:    line[width] = 0;
27709:291:
27710:292:    for (; row < height; from++) {
27711:293:        c = text[from];
27712:294:        style = 0;
27713:295:        if (!c)
27714:296:            break;
27715:297:        if (c == '\n' || (col == width && wrap_mode)) {
27716:298:            if (from >= m1 && from < m2)
27717:299:                line[col - wdt->firstcolumn] = ' ' | (MOD_MARKED * 256);
27718:300:            col = 0;
27719:301:            if (draw)
27720:302:                xprint_to_widget (win, row, 0, 0, width - 1, line);
27721:303:            row++;
27722:304:            if (row + wdt->firstline == wdt->cursor && isfocussed && curs)
27723:305:                shortset ((short *) line, ' ' + 256 * MOD_HIGHLIGHTED,
27724:306:                          width);
27725:307:            else
27726:308:                shortset ((short *) line, ' ', width);
27727:309:            line[width] = 0;
27728:310:            if (c == '\n' || row >= height)
27729:311:                continue;
27730:312:        }
27731:313:        if (from >= m1 && from < m2)
27732:314:            style |= MOD_MARKED;
27733:315:        if (c == '\r')
27734:316:            continue;
27735:317:        if (c == '\t') {
27736:318:            int col2;
27737:319:            col2 = col + 8 - (col % 8);
27738:320:            do {
27739:321:                line[col - wdt->firstcolumn] =
27740:322:                    ' ' +
27741:323:                    ((style *
27742:324:                      256) | (line[col - wdt->firstcolumn] & 0xFF00));
27743:325:            } while (++col < col2);
27744:326:            continue;
27745:327:        }
27746:328:        if (nroff && text[from + 1] == '\b') {
27747:329:            if (r_is_printable (text[from + 2]) && r_is_printable (c)) {
27748:330:                from += 2;
27749:331:                while (text[from + 1] == '\b'
27750:332:                       && r_is_printable (text[from + 2])
27751:333:                       && r_is_printable (text[from]))
27752:334:                    from += 2;
27753:335:                c = text[from];
27754:336:                if (text[from - 2] == '_')
27755:337:                    style |= MOD_ITALIC;
27756:338:                else
27757:339:                    style |= MOD_BOLD;
27758:340:            }
27759:341:        }
27760:342:#if 0
27761:343:        if (wdt->found_len && from >= wdt->search_start
27762:344:            && from < wdt->search_start + wdt->found_len) {
27763:345:            style = MOD_HIGHLIGHTED;
27764:346:        }
27765:347:#endif
27766:348:        if (col >= wdt->firstcolumn && col < width + wdt->firstcolumn) {
27767:349:            index = col - wdt->firstcolumn;
27768:350:            if (!r_is_printable (c))
27769:351:                c = '.';
27770:352:            line[index] = c + ((style * 256) | (line[index] & 0xFF00));
27771:353:        }
27772:354:        col++;
27773:355:    }
27774:356:
27775:357:    result = row + 1;
27776:358:
27777:359:    do {
27778:360:        if (draw) {
27779:361:            xprint_to_widget (win, row, 0, 0, width - 1, line);
27780:362:            shortset ((short *) line, ' ', width);
27781:363:            line[width] = 0;
27782:364:        }
27783:365:    } while (row++ < height);
27784:366:
27785:367:    lasttexttop = wdt->firstline;
27786:368:    lastcol = wdt->firstcolumn;
27787:369:    lastwin = win;
27788:370:    lastcursorline = wdt->cursor;
27789:371:    lastfocussed = isfocussed;
27790:372:    lastm1 = wdt->mark1;
27791:373:    lastm2 = wdt->mark2;
27792:374:
27793:375:    if (isfocussed) {
27794:376:        Crenderbevel (win, 0, 0, w - 1, h - 1, 3, 1); /*most outer border bevel */
27795:377:    } else {
27796:378:        Crenderbevel (win, 2, 2, w - 3, h - 3, 1, 1); /*border bevel */
27797:379:        Crenderbevel (win, 0, 0, w - 1, h - 1, 2, 0); /*most outer border bevel */
27798:380:    }
27799:381:
27800:382:    EditExposeRedraw = 0;
27801:383:    return result;
27802:384:}
27803:385:
27804:386:
27805:387:
27806:388:/*
27807:389:   Count the number of lines that would be printed
27808:390:   by the above routine, but don't print anything.
27809:391:   If all is non-zero then count all the lines.
27810:392: */
27811:393:long Ccounttextboxlines (CWidget * wdt, int all)
27812:394:{
27813:395:    int nroff, col = 0, row = 0, height, width;
27814:396:    long from;
27815:397:    unsigned char c;
27816:398:    int wrap_mode;
27817:399:    unsigned char *text;
27818:400:
27819:401:    nroff = (wdt->options & MAN_PAGE);
27820:402:    wrap_mode = (wdt->options & TEXT_WRAP);
27821:403:    if (nroff)
27822:404:        wrap_mode = 0;
27823:405:
27824:406:    text = (unsigned char *) wdt->text;
27825:407:    height = wdt->height / TEXT_PIX_PER_LINE;
27826:408:    width = wdt->width / TEXT_M_WIDTH;
27827:409:    if (all)
27828:410:        from = 0;
27829:411:    else
27830:412:        from = wdt->current;
27831:413:
27832:414:    for (; row < height || all; from++) {
27833:415:        c = text[from];
27834:416:        if (!c)
27835:417:            break;
27836:418:        if ((c == '\n') || (col == width && wrap_mode)) {
27837:419:            col = 0;
27838:420:            row++;
27839:421:            if (c == '\n' || row >= height)
27840:422:                continue;
27841:423:        }
27842:424:        if (c == '\r')
27843:425:            continue;
27844:426:        if (c == '\t') {
27845:427:            col = (col / 8) * 8 + 8;
27846:428:            continue;
27847:429:        }
27848:430:        col++;
27849:431:    }
27850:432:    return row + 1;
27851:433:}
27852:434:
27853:435:/* move the text box cursor or the text window if there isn't one */
27854:436:int Ctextboxcursormove (CWidget * wdt, KeySym key)
27855:437:{
27856:438:    int handled = 0;
27857:439:/* when text is highlighted, the cursor must be off */
27858:440:    if (wdt->options & TEXT_BOX_NO_CURSOR || wdt->mark1 != wdt->mark2) {
27859:441:        int move = 0;
27860:442:        switch (key) {
27861:443:        case CK_Up:
27862:444:            handled = 1;
27863:445:            move = -1;
27864:446:            break;
27865:447:        case CK_Down:
27866:448:            handled = 1;
27867:449:            move = 1;
27868:450:            break;
27869:451:        case CK_Page_Up:
27870:452:            handled = 1;
27871:453:            move = 1 - wdt->height / TEXT_PIX_PER_LINE;
27872:454:            break;
27873:455:        case CK_Page_Down:
27874:456:            handled = 1;
27875:457:            move = wdt->height / TEXT_PIX_PER_LINE - 1;
27876:458:            break;
27877:459:        case CK_Home:
27878:460:            handled = 1;
27879:461:            move = -32000;
27880:462:            break;
27881:463:        case CK_End:
27882:464:            handled = 1;
27883:465:            move = 32000;
27884:466:            break;
27885:467:        case CK_Left:
27886:468:            handled = 1;
27887:469:            if (wdt->firstcolumn > 0)
27888:470:                wdt->firstcolumn--;
27889:471:            break;
27890:472:        case CK_Right:
27891:473:            handled = 1;
27892:474:            wdt->firstcolumn++;
27893:475:            break;
27894:476:        }
27895:477:        Csettextboxpos (wdt, TEXT_SETLINE, wdt->firstline + move);
27896:478:    } else {
27897:479:        switch (key) {
27898:480:        case CK_Up:
27899:481:            handled = 1;
27900:482:            wdt->cursor--;
27901:483:            break;
27902:484:        case CK_Down:
27903:485:            handled = 1;
27904:486:            wdt->cursor++;
27905:487:            break;
27906:488:        case CK_Page_Up:
27907:489:            handled = 1;
27908:490:            wdt->cursor -= (wdt->height / TEXT_PIX_PER_LINE - 1);
27909:491:            break;
27910:492:        case CK_Page_Down:
27911:493:            handled = 1;
27912:494:            wdt->cursor += (wdt->height / TEXT_PIX_PER_LINE - 1);
27913:495:            break;
27914:496:        case CK_Home:
27915:497:            handled = 1;
27916:498:            wdt->cursor = 0;
27917:499:            break;
27918:500:        case CK_End:
27919:501:            handled = 1;
27920:502:            wdt->cursor = wdt->numlines;
27921:503:            break;
27922:504:        case CK_Left:
27923:505:            handled = 1;
27924:506:            if (wdt->firstcolumn > 0) {
27925:507:                wdt->firstcolumn--;
27926:508:            }
27927:509:            break;
27928:510:        case CK_Right:
27929:511:            handled = 1;
27930:512:            wdt->firstcolumn++;
27931:513:            break;
27932:514:        }
27933:515:        Csettextboxpos (wdt, TEXT_SET_CURSOR_LINE, wdt->cursor); /* just does some checks */
27934:516:    }
27935:517:    return handled;
27936:518:}
27937:519:
27938:520:
27939:521:void edit_translate_xy (int xs, int ys, int *x, int *y);
27940:522:
27941:523:/* returns the position in the edit buffer of a window click */
27942:524:long text_get_click_pos (CWidget * w, int x, int y)
27943:525:{
27944:526:    long click;
27945:527:    int width;
27946:528:    width = w->options & TEXT_WRAP ? w->width / TEXT_M_WIDTH : 32000;
27947:529:    click = strmovelines (w->text, w->current, y, width);
27948:530:    click = strcolmove (w->text, click, x);
27949:531:    return click;
27950:532:}
27951:533:
27952:534:
27953:535:void text_mouse_mark (CWidget * w, XEvent * event, CEvent * ce)
27954:536:{
27955:537:    static Window win_press = 0;
27956:538:    static drag = 0;
27957:539:    static char *last_text;
27958:540:    long click;
27959:541:    int x, y;
27960:542:
27961:543:    edit_translate_xy (event->xbutton.x, event->xbutton.y, &x, &y);
27962:544:    click = text_get_click_pos (w, --x, --y);
27963:545:
27964:546:    if (event->type == ButtonPress) {
27965:547:        if (click >= min (w->mark1, w->mark2)
27966:548:            && click < max (w->mark1, w->mark2)) {
27967:549:            char *t, *t2;
27968:550:            int l, type;
27969:551:            l = abs (w->mark2 - w->mark1);
27970:552:            t = Cmalloc (l + 1);
27971:553:            memcpy (t, w->text + min (w->mark1, w->mark2), l);
27972:554:            t[l] = 0;
27973:555:            t2 = str_strip_nroff ((char *) t, &l);
27974:556:            free (t);
27975:557:            t2[l] = 0;
27976:558:            if (w->options & TEXT_FILES) {
27977:559:                char *p;
27978:560:                int i;
27979:561:                p = CDndFileList (t2, &l, &i);
27980:562:                if (!p) {
27981:563:                    free (t2);
27982:564:                    return;
27983:565:                }
27984:566:                free (t2);
27985:567:                t2 = p;
27986:568:                if (i == 1)
27987:569:                    type = DndFile;
27988:570:                else
27989:571:                    type = DndFiles;
27990:572:            } else {
27991:573:                type = DndText;
27992:574:            }
27993:575:            CDrag (event->xbutton.window, type, t2, l, 0);
27994:576:            free (t2);
27995:577:            return;
27996:578:        }
27997:579:        w->mark1 = w->mark2 = click;
27998:580:        win_press = w->winid;
27999:581:        last_text = w->text;
28000:582:        drag = 1;
28001:583:        return;
28002:584:    }
28003:585:    if (win_press != w->winid || !drag
28004:586:        || (unsigned long) last_text != (unsigned long) w->text) {
28005:587:        w->mark1 = w->mark2 = 0;
28006:588:        return;
28007:589:    }
28008:590:    if (event->type == ButtonRelease) {
28009:591:        win_press = 0;
28010:592:        drag = 0;
28011:593:        w->mark2 = click;
28012:594:        return;
28013:595:    }
28014:596:    if (event->type == MotionNotify) {
28015:597:        int h;
28016:598:        h = (w->height - 6) / TEXT_PIX_PER_LINE;
28017:599:        if (y > h && w->firstline < w->numlines - h - 2)
28018:600:            Csettextboxpos (w, TEXT_SETLINE, w->firstline + y - h);
28019:601:        if (y < 0)
28020:602:            Csettextboxpos (w, TEXT_SETLINE, w->firstline + y);
28021:603:        w->mark2 = click;
28022:604:    }
28023:605:}
28024:606:
28025:607:
28026:608:int eh_textbox (CWidget * w, XEvent * xevent, CEvent * cwevent)
28027:609:{
28028:610:    int cmd, ch;
28029:611:    int handled = 0;
28030:612:    int curpos;
28031:613:    char *intext;
28032:614:    char xlat;
28033:615:    KeySym key;
28034:616:    int redrawall;
28035:617:    int count;
28036:618:
28037:619:    redrawall = 0;
28038:620:    switch (xevent->type) {
28039:621:    case Expose:
28040:622:        if (!xevent->xexpose.count)
28041:623:            redrawall = 1;
28042:624:        break;
28043:625:    case ClientMessage:
28044:626:        w->mark1 = w->mark2 = 0;
28045:627:        break;
28046:628:    case ButtonPress:
28047:629:        CFocusWindow (w->winid);
28048:630:        if (xevent->xbutton.button == Button1)
28049:631:            w->cursor =
28050:632:                (xevent->xbutton.y - 6) / TEXT_PIX_PER_LINE + w->firstline;
28051:633:        if (w->cursor > w->numlines - 1)
28052:634:            w->cursor = w->numlines - 1;
28053:635:        if (w->cursor < 0)
28054:636:            w->cursor = 0;
28055:637:        cwevent->ident = w->ident;
28056:638:        cwevent->xt =
28057:639:            (xevent->xbutton.x - 7) / TEXT_M_WIDTH + w->firstcolumn;
28058:640:        cwevent->yt = w->cursor;
28059:641:    case ButtonRelease:
28060:642:    case MotionNotify:
28061:643:        Cresolvebutton (xevent, cwevent);
28062:644:        text_mouse_mark (w, xevent, cwevent);
28063:645:        break;
28064:646:    case FocusIn:
28065:647:    case FocusOut:
28066:648:        break;
28067:649:    case KeyPress:
28068:650:        xlat = 0;
28069:651:        XLookupString (&(xevent->xkey), &xlat, 1, &key, NULL);
28070:652:
28071:653:        curpos = w->firstline;
28072:654:        intext = w->text;
28073:655:
28074:656:        cwevent->ident = w->ident;
28075:657:        cwevent->key = key;
28076:658:        cwevent->xlat = xlat;
28077:659:        cwevent->state = xevent->xkey.state;
28078:660:
28079:661:        if (!(TEXT_NO_KEYS & w->options))
28080:662:            if (edit_translate_key
28081:663:                (0, xevent->xkey.keycode, key, xevent->xkey.state, &cmd,
28082:664:                 &ch)) {
28083:665:                cwevent->command = cmd;
28084:666:                handled = Ctextboxcursormove (w, cmd);
28085:667:            }
28086:668:        break;
28087:669:    default:
28088:670:        return 0;
28089:671:    }
28090:672:
28091:673:/* Now draw the changed text box, count will contain
28092:674:   the number of textlines displayed */
28093:675:    count = Crendertextbox (w, redrawall);
28094:676:
28095:677:/* now update the scrollbar position */
28096:678:    w->scrollbar->firstline = (double) 65535.0 *w->firstline / w->numlines;
28097:679:    w->scrollbar->numlines = (double) 65535.0 *count / w->numlines;
28098:680:    w->scrollbar->options = 0;
28099:681:    Crenderscrollbar (w->scrollbar);
28100:682:
28101:683:    return handled;
28102:684:}
28103:1:/*
28104:2:   Copyright (C) 1996 Paul Sheer
28105:3:
28106:4:   This program is free software; you can redistribute it and/or modify
28107:5:   it under the terms of the GNU General Public License as published by
28108:6:   the Free Software Foundation; either version 2 of the License, or
28109:7:   (at your option) any later version.
28110:8:
28111:9:   This program is distributed in the hope that it will be useful,
28112:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
28113:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
28114:12:   GNU General Public License for more details.
28115:13:
28116:14:   You should have received a copy of the GNU General Public License
28117:15:   along with this program; if not, write to the Free Software
28118:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
28119:17: */
28120:18:
28121:19:#include <config.h>
28122:20:
28123:21:#ifndef DO_NOT_USE_VGALIB
28124:22:#include <vga.h>
28125:23:#endif
28126:24:
28127:25:#include <vgagl.h>
28128:26:#include "triangle.h"
28129:27:#include <stdio.h>
28130:28:
28131:29:#define SHLB 8
28132:30:#define SHC 0
28133:31:#ifdef WRAP
28134:32:#define S_MASK 0x01ff00
28135:33:#endif
28136:34:
28137:35:
28138:36:#ifdef byte
28139:37:#undef byte
28140:38:#endif
28141:39:#define byte unsigned char
28142:40:
28143:41:#ifdef word
28144:42:#undef word
28145:43:#endif
28146:44:#define word unsigned short
28147:45:
28148:46:#ifdef quad_t
28149:47:#undef quad_t
28150:48:#endif
28151:49:
28152:50:#ifdef INT_IS_16_BITS
28153:51:#define quad_t unsigned long
28154:52:#else
28155:53:#define quad_t unsigned int
28156:54:#endif
28157:55:
28158:56:
28159:57:/* this assumes that BYTEWIDTH is not necessarily equal to bytes-per-pixel times WIDTH */
28160:58:
28161:59:#define assignvpoffset8(x, y, vp) vp = (y) * BYTEWIDTH + (x);
28162:60:#define assignvpoffset16(x, y, vp) vp = (y) * BYTEWIDTH + ((x) << 1);
28163:61:#define assignvpoffset24(x, y, vp) vp = (y) * BYTEWIDTH + (x) * 3;
28164:62:#define assignvpoffset32(x, y, vp) vp = (y) * BYTEWIDTH + ((x) << 2);
28165:63:
28166:64:#define declarevp8 byte *vpbyte = (byte *) VBUF
28167:65:#define declarevp16 word *vpword = (word *) VBUF
28168:66:#define declarevp24 byte *vpbyte = (byte *) VBUF
28169:67:#define declarevp32 quad_t *vpquad = (quad_t *) VBUF
28170:68:
28171:69:#define assignvp8(x, y, vp) vpbyte = (byte *) VBUF + (y) * BYTEWIDTH + (x);
28172:70:#define assignvp16(x, y, vp) vpword = (word *) ((byte *) VBUF + (y) * BYTEWIDTH) + (x);
28173:71:#define assignvp24(x, y, vp) vpbyte = (byte *) VBUF + (y) * BYTEWIDTH + (x) * 3;
28174:72:#define assignvp32(x, y, vp) vpquad = (quad_t *) ((byte *) VBUF + (y) * BYTEWIDTH) + (x);
28175:73:
28176:74:/* here we would like to have a single void pointer and cast it to byte, word or
28177:75:quad_t, but ansi does not allow casts on LHS   :(   */
28178:76:
28179:77:#define decvp8 *(--(vpbyte)) = lookup(color)
28180:78:#define incvp8 *((vpbyte)++) = lookup(color)
28181:79:#define decvp16 *(--(vpword)) = lookup(color)
28182:80:#define incvp16 *((vpword)++) = lookup(color)
28183:81:#define decvp24 *(--(vpbyte)) = lookup(color) >> 16; \
28184:82:                *(--(vpbyte)) = lookup(color) >> 8; \
28185:83:                *(--(vpbyte)) = lookup(color);
28186:84:#define incvp24 *((vpbyte)++) = lookup(color); \
28187:85:                *((vpbyte)++) = lookup(color) >> 8; \
28188:86:                *((vpbyte)++) = lookup(color) >> 16;
28189:87:#define decvp32 *(--(vpquad)) = lookup(color)
28190:88:#define incvp32 *((vpquad)++) = lookup(color)
28191:89:
28192:90:#define decvpoffset8 \
28193:91:                if (!offst--) \
28194:92:                    vga_setpage (--pg); \
28195:93:                *(vpbyte + offst) = lookup(color);
28196:94:#define incvpoffset8 \
28197:95:                *(vpbyte + offst) = lookup(color); \
28198:96:                if (!(++offst)) \
28199:97:                    vga_setpage (++pg);
28200:98:#define decvpoffset16 \
28201:99:                if (!offst) \
28202:100:                    vga_setpage (--pg); \
28203:101:                offst -= 2; \
28204:102:                *(vpword + offst) = lookup(color);
28205:103:#define incvpoffset16 \
28206:104:                *(vpword + offst) = lookup(color); \
28207:105:                offst += 2; \
28208:106:                if (!offst) \
28209:107:                    vga_setpage (++pg);
28210:108:#define decvpoffset24 \
28211:109:                if (!offst--) \
28212:110:                    vga_setpage (--pg); \
28213:111:                *(vpbyte + offst) = lookup(color) >> 16; \
28214:112:                if (!offst--) \
28215:113:                    vga_setpage (--pg); \
28216:114:                *(vpbyte + offst) = lookup(color) >> 8; \
28217:115:                if (!offst--) \
28218:116:                    vga_setpage (--pg); \
28219:117:                *(vpbyte + offst) = lookup(color);
28220:118:#define incvpoffset24 \
28221:119:                *(vpbyte + offst) = lookup(color); \
28222:120:                if (!(++offst)) \
28223:121:                    vga_setpage (++pg); \
28224:122:                *(vpbyte + offst) = lookup(color) >> 8; \
28225:123:                if (!(++offst)) \
28226:124:                    vga_setpage (++pg); \
28227:125:                *(vpbyte + offst) = lookup(color) >> 16; \
28228:126:                if (!(++offst)) \
28229:127:                    vga_setpage (++pg);
28230:128:#define decvpoffset32 \
28231:129:                if (!offst) \
28232:130:                    vga_setpage (--pg); \
28233:131:                offst -= 4; \
28234:132:                *(vpquad + offst) = lookup(color);
28235:133:#define incvpoffset32 \
28236:134:                *(vpquad + offst) = lookup(color); \
28237:135:                offst += 4; \
28238:136:                if (!offst) \
28239:137:                    vga_setpage (++pg);
28240:138:
28241:139:
28242:140:static int px1, px2, py;
28243:141:static long c;
28244:142:
28245:143:#ifdef INTERP
28246:144:static long c_x;
28247:145:#endif
28248:146:
28249:147:#ifdef WRAP
28250:148:static long xd, xd_x, yd, yd_x;
28251:149:static unsigned char *dat;
28252:150:#endif
28253:151:
28254:152:static long dx0, dy0;
28255:153:
28256:154:#if defined(WRAP) && defined(INTERP)
28257:155:
28258:156:/* this must only occur once */
28259:157:
28260:158:long color_lookup[TRIANGLE_COLOR_LOOKUP_TABLE_SIZE];
28261:159:static long *_color_lookup;
28262:160:
28263:161:void gl_trisetcolorlookup (int i, long c)
28264:162:{
28265:163:    if (i < TRIANGLE_COLOR_LOOKUP_TABLE_SIZE)
28266:164:        color_lookup[i] = c;
28267:165:}
28268:166:
28269:167:void (*tri_drawpoint) (int, int, int);
28270:168:static void (*_tri_drawpoint) (int, int, int);
28271:169:
28272:170:void gl_trisetdrawpoint (void (*draw_point) (int, int, int))
28273:171:{
28274:172:    tri_drawpoint = draw_point;
28275:173:}
28276:174:
28277:175:#else
28278:176:
28279:177:extern long color_lookup[TRIANGLE_COLOR_LOOKUP_TABLE_SIZE];
28280:178:static long *_color_lookup;
28281:179:extern void (*tri_drawpoint) (int, int, int);
28282:180:static void (*_tri_drawpoint) (int, int, int);
28283:181:
28284:182:#endif                          /* this static is just because static is faster than ordinary array (so I hear) in DLL's */
28285:183:
28286:184:
28287:185:#define TRI_BPP 8
28288:186:#include "trisetpixel.c"
28289:187:
28290:188:#undef TRI_BPP
28291:189:#define TRI_BPP 16
28292:190:#include "trisetpixel.c"
28293:191:
28294:192:#undef TRI_BPP
28295:193:#define TRI_BPP 24
28296:194:#include "trisetpixel.c"
28297:195:
28298:196:#undef TRI_BPP
28299:197:#define TRI_BPP 32
28300:198:#include "trisetpixel.c"
28301:199:
28302:200:#undef TRI_BPP
28303:201:
28304:202:
28305:203:/*
28306:204:   #define CONTEXT_VIRTUAL              0x0
28307:205:   #define CONTEXT_PAGED                0x1
28308:206:   #define CONTEXT_LINEAR               0x2
28309:207:   #define CONTEXT_MODEX                0x3
28310:208:   #define CONTEXT_PLANAR16             0x4
28311:209: */
28312:210:
28313:211:static void (*linefuncs[64]) (void) = {
28314:212:    colhline_pos_direct8, colhline_neg_direct8, colhline_pos_paged8, colhline_neg_paged8, /*2 */
28315:213:        colhline_pos_direct8, colhline_neg_direct8, colhline_pos_setpixel8, colhline_neg_setpixel8, /*4 */
28316:214:        colhline_pos_setpixel8, colhline_neg_setpixel8, colhline_pos_setpixel8, colhline_neg_setpixel8, /*6 */
28317:215:        colhline_pos_setpixel8, colhline_neg_setpixel8, colhline_pos_setpixel8, colhline_neg_setpixel8, /*8 */
28318:216:        colhline_pos_direct16, colhline_neg_direct16, colhline_pos_paged16, colhline_neg_paged16, /*2 */
28319:217:        colhline_pos_direct16, colhline_neg_direct16, colhline_pos_setpixel16, colhline_neg_setpixel16, /*4 */
28320:218:        colhline_pos_setpixel16, colhline_neg_setpixel16, colhline_pos_setpixel16, colhline_neg_setpixel16, /*6 */
28321:219:        colhline_pos_setpixel16, colhline_neg_setpixel16, colhline_pos_setpixel16, colhline_neg_setpixel16, /*8 */
28322:220:        colhline_pos_direct24, colhline_neg_direct24, colhline_pos_paged24, colhline_neg_paged24, /*2 */
28323:221:        colhline_pos_direct24, colhline_neg_direct24, colhline_pos_setpixel24, colhline_neg_setpixel24, /*4 */
28324:222:        colhline_pos_setpixel24, colhline_neg_setpixel24, colhline_pos_setpixel24, colhline_neg_setpixel24, /*6 */
28325:223:        colhline_pos_setpixel24, colhline_neg_setpixel24, colhline_pos_setpixel24, colhline_neg_setpixel24, /*8 */
28326:224:        colhline_pos_direct32, colhline_neg_direct32, colhline_pos_paged32, colhline_neg_paged32, /*2 */
28327:225:        colhline_pos_direct32, colhline_neg_direct32, colhline_pos_setpixel32, colhline_neg_setpixel32, /*4 */
28328:226:        colhline_pos_setpixel32, colhline_neg_setpixel32, colhline_pos_setpixel32, colhline_neg_setpixel32, /*6 */
28329:227:        colhline_pos_setpixel32, colhline_neg_setpixel32, colhline_pos_setpixel32, colhline_neg_setpixel32, /*8 */
28330:228:};
28331:229:
28332:230:
28333:231:#include "tri.c"
28334:1:#define INTERP
28335:2:#include "triangl.c"
28336:1:/*
28337:2:
28338:3:    3DKIT   version   1.2
28339:4:    High speed 3D graphics and rendering library for Linux.
28340:5:
28341:6:    Copyright (C) 1996  Paul Sheer   psheer@hertz.mech.wits.ac.za
28342:7:
28343:8:    This library is free software; you can redistribute it and/or
28344:9:    modify it under the terms of the GNU Library General Public
28345:10:    License as published by the Free Software Foundation; either
28346:11:    version 2 of the License, or (at your option) any later version.
28347:12:
28348:13:    This library is distributed in the hope that it will be useful,
28349:14:    but WITHOUT ANY WARRANTY; without even the implied warranty of
28350:15:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
28351:16:    Library General Public License for more details.
28352:17:
28353:18:    You should have received a copy of the GNU Library General Public
28354:19:    License along with this library; if not, write to the Free
28355:20:    Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
28356:21:    MA 02111-1307, USA
28357:22:
28358:23:*/
28359:24:
28360:25:/*
28361:26:
28362:27:File: triangle.h
28363:28:
28364:29:*/
28365:30:
28366:31:#define max(x,y)     (((x) > (y)) ? (x) : (y))
28367:32:#define min(x,y)     (((x) < (y)) ? (x) : (y))
28368:33:
28369:34:typedef struct {
28370:35:
28371:36:    unsigned char *bitmap1;
28372:37:    unsigned char *bitmap2;
28373:38:
28374:39:    int bf;
28375:40:
28376:41:} TD_tridata;
28377:42:
28378:43:
28379:44:
28380:45:void gl_triangle (int x0, int y0, int z0, int x1, int y1, int z1, int x2,
28381:46:                  int y2, int z2, int bf);
28382:47:void gl_wtriangle (int x0, int y0, int xd0, int yd0, int z0, int x1, int y1, int xd1, int yd1, int z1, int x2, int y2, int xd2, int yd2, int z2, TD_tridata * tri); /*This does not alter tri structure */
28383:48:void gl_swtriangle (int x0, int y0, int xd0, int yd0, int x1, int y1, int xd1, int yd1, int x2, int y2, int xd2, int yd2, int c, TD_tridata * tri); /*This does not alter tri structure */
28384:49:
28385:50:void gl_striangle (int x0, int y0, int x1, int y1, int x2, int y2,
28386:51:                   int color, int bf);
28387:52:
28388:53:
28389:54:#define TRIANGLE_COLOR_LOOKUP_TABLE_SIZE 4096
28390:55:
28391:56:void gl_trisetcolorlookup (int i, long c);
28392:57:void gl_trisetdrawpoint (void (setpixelfunc) (int, int, int));
28393:1:/*
28394:2:   Copyright (C) 1996 Paul Sheer
28395:3:
28396:4:   This program is free software; you can redistribute it and/or modify
28397:5:   it under the terms of the GNU General Public License as published by
28398:6:   the Free Software Foundation; either version 2 of the License, or
28399:7:   (at your option) any later version.
28400:8:
28401:9:   This program is distributed in the hope that it will be useful,
28402:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
28403:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
28404:12:   GNU General Public License for more details.
28405:13:
28406:14:   You should have received a copy of the GNU General Public License
28407:15:   along with this program; if not, write to the Free Software
28408:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
28409:17: */
28410:18:
28411:19:
28412:20:#ifdef WRAP
28413:21:#ifdef INTERP
28414:22:void gl_wtriangle (int x0, int y0, int xd0, int yd0, int z0,
28415:23:                   int x1, int y1, int xd1, int yd1, int z1,
28416:24:                   int x2, int y2, int xd2, int yd2, int z2,
28417:25:                   TD_tridata * tri)
28418:26:#else
28419:27:void gl_swtriangle (int x0, int y0, int xd0, int yd0,
28420:28:                    int x1, int y1, int xd1, int yd1,
28421:29:                    int x2, int y2, int xd2, int yd2, int z0,
28422:30:                    TD_tridata * tri)
28423:31:#endif
28424:32:#else
28425:33:#ifdef INTERP
28426:34:void gl_triangle (int x0, int y0, int z0,
28427:35:                  int x1, int y1, int z1, int x2, int y2, int z2, int bf)
28428:36:#else
28429:37:void gl_striangle (int x0, int y0,
28430:38:                   int x1, int y1, int x2, int y2, int z0, int bf)
28431:39:#endif
28432:40:#endif
28433:41:{
28434:42:    void (*colhline_pos) (void);
28435:43:    void (*colhline_neg) (void);
28436:44:
28437:45:    int dir;
28438:46:    long X;
28439:47:
28440:48:    long nz;
28441:49:    long g0, g1h = 0, g1l = 0;
28442:50:#ifdef INTERP
28443:51:    long c0;
28444:52:    long c_y;
28445:53:#endif
28446:54:#ifdef WRAP
28447:55:    long X0, Y0;
28448:56:    int bf = tri->bf;
28449:57:    long xd_y, yd_y;
28450:58:#endif
28451:59:
28452:60:    dir = 1;
28453:61:
28454:62:/*Max triangle size in the order of (2^31) >> SHLB)^(.5) : */
28455:63:
28456:64:    if ((nz = (x0 - x1) * (y0 - y2) - (y0 - y1) * (x0 - x2)) == 0)
28457:65:        return;                 /*the points are collinear. */
28458:66:
28459:67:#ifdef INTERP
28460:68:    c_x = -(((y0 - y1) * (z0 - z2) - (z0 - z1) * (y0 - y2)) << SHLB) / nz;
28461:69:    c_y = -(((z0 - z1) * (x0 - x2) - (x0 - x1) * (z0 - z2)) << SHLB) / nz;
28462:70:#endif
28463:71:
28464:72:#ifdef WRAP
28465:73:    xd_x =
28466:74:        -(((y0 - y1) * (xd0 - xd2) -
28467:75:           (xd0 - xd1) * (y0 - y2)) << SHLB) / nz;
28468:76:    xd_y =
28469:77:        -(((xd0 - xd1) * (x0 - x2) -
28470:78:           (x0 - x1) * (xd0 - xd2)) << SHLB) / nz;
28471:79:
28472:80:    yd_x =
28473:81:        -(((y0 - y1) * (yd0 - yd2) -
28474:82:           (yd0 - yd1) * (y0 - y2)) << SHLB) / nz;
28475:83:    yd_y =
28476:84:        -(((yd0 - yd1) * (x0 - x2) -
28477:85:           (x0 - x1) * (yd0 - yd2)) << SHLB) / nz;
28478:86:#endif
28479:87:
28480:88:#ifdef INTERP
28481:89:    if ((abs (c_x) > (6 << SHLB)) || (abs (c_y) > (6 << SHLB))) {
28482:90:        int tz0, tz1;
28483:91:
28484:92:        /*so that high colour gradients don't screw up at the edges. */
28485:93:        /*4 is the maximum gradient per pixel. */
28486:94:
28487:95:        c_x >>= 2;
28488:96:        c_y >>= 2;
28489:97:        tz0 = ((2 * z0 + z1 + z2) << SHLB) / 4;
28490:98:        tz1 = ((z0 + 2 * z1 + z2) << SHLB) / 4;
28491:99:        z2 = ((z0 + z1 + 2 * z2) << SHLB) / 4;
28492:100:        z0 = tz0;
28493:101:        z1 = tz1;
28494:102:    } else {
28495:103:        z0 <<= SHLB;
28496:104:        z1 <<= SHLB;
28497:105:        z2 <<= SHLB;
28498:106:    }
28499:107:#endif
28500:108:
28501:109:/************** BOOLEAN LOGIC HERE ************/
28502:110:/* The following allows a triangle to have a different picture on either side */
28503:111:/* To print triangles that don't appear when viewed from behind use bf = 0|1  */
28504:112:/* To print triangles that appear with a different picture when viewed from   */
28505:113:/*   behind use bf = 2|3                                                      */
28506:114:
28507:115:#ifdef WRAP
28508:116:    dat = tri->bitmap1;
28509:117:    if (nz > 0) {               /* nz is the cross product of the vectors of the two sides
28510:118:                                   it indicates whether the points were ordered clockwise
28511:119:                                   or anti-clockwise (you can find out which way by testing) */
28512:120:        if (bf == 1)
28513:121:            return;
28514:122:        if (bf == 3)
28515:123:            dat = tri->bitmap1;
28516:124:        dir++;
28517:125:    } else {
28518:126:        if (!bf)
28519:127:            return;
28520:128:        if (bf == 2)
28521:129:            dat = tri->bitmap2;
28522:130:    }
28523:131:#else
28524:132:    if (nz > 0) {
28525:133:        if (bf == 1)
28526:134:            return;
28527:135:        dir++;
28528:136:    } else {
28529:137:        if (!bf)
28530:138:            return;
28531:139:    }
28532:140:#endif
28533:141:
28534:142:#define Xchg(a,b) {X=(a);(a)=(b);(b)=X;}
28535:143:
28536:144:    if (y1 < y0) {
28537:145:        Xchg (y0, y1);
28538:146:        Xchg (x0, x1);
28539:147:#ifdef INTERP
28540:148:        Xchg (z0, z1);
28541:149:#endif
28542:150:#ifdef WRAP
28543:151:        Xchg (xd0, xd1);
28544:152:        Xchg (yd0, yd1);
28545:153:#endif
28546:154:        dir++;
28547:155:    }
28548:156:    if (y2 < y1) {
28549:157:        Xchg (y2, y1);
28550:158:        Xchg (x2, x1);
28551:159:#ifdef INTERP
28552:160:        Xchg (z2, z1);
28553:161:#endif
28554:162:#ifdef WRAP
28555:163:        Xchg (xd2, xd1);
28556:164:        Xchg (yd2, yd1);
28557:165:#endif
28558:166:
28559:167:        dir++;
28560:168:    }
28561:169:    if (y1 < y0) {
28562:170:        Xchg (y0, y1);
28563:171:        Xchg (x0, x1);
28564:172:#ifdef INTERP
28565:173:        Xchg (z0, z1);
28566:174:#endif
28567:175:#ifdef WRAP
28568:176:        Xchg (xd0, xd1);
28569:177:        Xchg (yd0, yd1);
28570:178:#endif
28571:179:        dir++;
28572:180:    }
28573:181:    _color_lookup = color_lookup;
28574:182:#ifdef INTERP
28575:183:    c0 = z0;
28576:184:#else
28577:185:    if (BYTESPERPIXEL == 1) {
28578:186:        c = z0;
28579:187:    } else {
28580:188:        c = _color_lookup[z0];
28581:189:    }
28582:190:#endif
28583:191:
28584:192:#ifdef WRAP
28585:193:    X0 = xd0 << SHLB;
28586:194:    Y0 = yd0 << SHLB;
28587:195:#endif
28588:196:
28589:197:    if (y2 == y0)
28590:198:        return;
28591:199:    g0 = ((long) (x2 - x0) << SHLB) / (y2 - y0);
28592:200:    if (y1 != y0)
28593:201:        g1h = ((long) (x1 - x0) << SHLB) / (y1 - y0);
28594:202:    if (y2 != y1)
28595:203:        g1l = ((long) (x2 - x1) << SHLB) / (y2 - y1);
28596:204:
28597:205:    dir = dir & 1;
28598:206:
28599:207:
28600:208:/* Very large triangles (larger than the screen) sometimes become a problem,
28601:209:   if so: */
28602:210:    if (__clip) {
28603:211:        if (((abs (x0 - x1) + abs (x1 - x2) + abs (x0 - x2)) >
28604:212:             ((__clipx2 - __clipx1) * 2))
28605:213:            || ((y2 - y0) > (__clipy2 - __clipy1)))
28606:214:            return;
28607:215:        if (y2 < __clipy1 || y0 > __clipy2 ||
28608:216:            (x0 < __clipx1 && x1 < __clipx1 && x2 < __clipx1) ||
28609:217:            (x0 > __clipx2 && x1 > __clipx2 && x2 > __clipx2))
28610:218:            return;
28611:219:    }
28612:220:    dx0 = x0;
28613:221:    dy0 = y0;
28614:222:
28615:223:    if (tri_drawpoint) {
28616:224:        _tri_drawpoint = tri_drawpoint;
28617:225:        colhline_pos = linefuncs[(7 * 2) + (BYTESPERPIXEL - 1) * 16];
28618:226:        colhline_neg = linefuncs[(7 * 2) + (BYTESPERPIXEL - 1) * 16 + 1];
28619:227:    } else {
28620:228:        _tri_drawpoint = gl_setpixel;
28621:229:        colhline_pos =
28622:230:            linefuncs[(MODETYPE * 2) + (BYTESPERPIXEL - 1) * 16];
28623:231:        colhline_neg =
28624:232:            linefuncs[(MODETYPE * 2) + (BYTESPERPIXEL - 1) * 16 + 1];
28625:233:    }
28626:234:
28627:235:#ifdef tri_set_color
28628:236:#undef tri_set_color
28629:237:#endif
28630:238:
28631:239:
28632:240:
28633:241:#ifdef WRAP
28634:242:#ifdef INTERP
28635:243:#define tri_set_color \
28636:244:                xd = X0 + xd_x * px1 + xd_y * py; \
28637:245:                yd = Y0 + yd_x * px1 + yd_y * py; \
28638:246:                c = c0 + c_x * px1 + c_y * py;
28639:247:#else
28640:248:#define tri_set_color \
28641:249:                xd = X0 + xd_x * px1 + xd_y * py; \
28642:250:                yd = Y0 + yd_x * px1 + yd_y * py;
28643:251:#endif
28644:252:#else
28645:253:#ifdef INTERP
28646:254:#define tri_set_color \
28647:255:                c = c0 + c_x * px1 + c_y * py;
28648:256:#else
28649:257:#define tri_set_color
28650:258:#endif
28651:259:#endif
28652:260:
28653:261:/*
28654:262:    if (dir == 1) {
28655:263:        if (y1 != y0)
28656:264:            for (py = 0; py < y1 - y0; py++) {
28657:265:                px1 = ((g0 * py) + (abs (g0) >> 1)) >> SHLB;
28658:266:                px2 = ((g1h * py) - (abs (g1h) >> 1)) >> SHLB;
28659:267:                tri_set_color;
28660:268:                colhline_neg ();
28661:269:            }
28662:270:        py = y1 - y0;
28663:271:        px1 = ((g0 * py) + (abs (g0) >> 1)) >> SHLB;
28664:272:        px2 = x1 - x0;
28665:273:        tri_set_color;
28666:274:        colhline_neg ();
28667:275:        if (y1 != y2)
28668:276:            for (py = y1 - y0 + 1; py <= y2 - y0; py++) {
28669:277:                px1 = ((g0 * py) + (abs (g0) >> 1)) >> SHLB;
28670:278:                px2 = (((g1l * (py - y1 + y0)) - (abs (g1l) >> 1)) >> SHLB) + x1 - x0;
28671:279:                tri_set_color;
28672:280:                colhline_neg ();
28673:281:            }
28674:282:    } else {
28675:283:        if (y0 != y1)
28676:284:            for (py = 0; py < y1 - y0; py++) {
28677:285:                px1 = ((g0 * py) - (abs (g0) >> 1)) >> SHLB;
28678:286:                px2 = ((g1h * py) + (abs (g1h) >> 1)) >> SHLB;
28679:287:                tri_set_color;
28680:288:                colhline_pos ();
28681:289:            }
28682:290:        py = y1 - y0;
28683:291:
28684:292:        px1 = ((g0 * py) - (abs (g0) >> 1)) >> SHLB;
28685:293:        px2 = x1 - x0;
28686:294:        tri_set_color;
28687:295:        colhline_pos ();
28688:296:        if (y1 != y2)
28689:297:            for (py = y1 - y0 + 1; py <= y2 - y0; py++) {
28690:298:                px1 = ((g0 * py) - (abs (g0) >> 1)) >> SHLB;
28691:299:                px2 = (((g1l * (py - y1 + y0)) + (abs (g1l) >> 1)) >> SHLB) + x1 - x0;
28692:300:                tri_set_color;
28693:301:                colhline_pos ();
28694:302:            }
28695:303:    }
28696:304:*/
28697:305:
28698:306:
28699:307:    if (dir == 1) {
28700:308:        if (y1 != y0) {
28701:309:            py = 0;
28702:310:            if (x1 < x0) {
28703:311:                px1 = 0;
28704:312:                px2 = -((abs (g1h) >> 1)) >> SHLB;
28705:313:            } else {
28706:314:                px1 = ((abs (g0) >> 1)) >> SHLB;
28707:315:                px2 = 0;
28708:316:            }
28709:317:            tri_set_color;
28710:318:
28711:319:            colhline_neg ();
28712:320:            if ((py = 1) < y1 - y0)
28713:321:                for (; py < y1 - y0; py++) {
28714:322:                    px1 = ((g0 * py) + (abs (g0) >> 1)) >> SHLB;
28715:323:                    px2 = ((g1h * py) - (abs (g1h) >> 1)) >> SHLB;
28716:324:                    tri_set_color;
28717:325:
28718:326:                    colhline_neg ();
28719:327:                }
28720:328:            px1 =
28721:329:                min (((g0 * py) + (abs (g0) >> 1)) >> SHLB,
28722:330:                     max (x2, x0) - x0);
28723:331:            px2 = x1 - x0;
28724:332:            tri_set_color;
28725:333:            colhline_neg ();
28726:334:        } else {
28727:335:            py = 0;
28728:336:            px1 = 0;
28729:337:            px2 = x1 - x0;
28730:338:            tri_set_color;
28731:339:
28732:340:            colhline_neg ();
28733:341:        }
28734:342:        if (y1 != y2) {
28735:343:            if ((py = y1 - y0 + 1) < y2 - y0)
28736:344:                for (; py < y2 - y0; py++) {
28737:345:                    px1 = ((g0 * py) + (abs (g0) >> 1)) >> SHLB;
28738:346:                    px2 =
28739:347:                        (((g1l * (py - y1 + y0)) -
28740:348:                          (abs (g1l) >> 1)) >> SHLB) + x1 - x0;
28741:349:                    tri_set_color;
28742:350:
28743:351:                    colhline_neg ();
28744:352:                }
28745:353:            if (x1 < x2) {
28746:354:                px1 = x2 - x0;
28747:355:                px2 = x2 - x0 - ((abs (g1l) >> 1) >> SHLB);
28748:356:            } else {
28749:357:                px1 = x2 - x0 + ((abs (g0) >> 1) >> SHLB);
28750:358:                px2 = x2 - x0;
28751:359:            }
28752:360:            tri_set_color;
28753:361:
28754:362:            colhline_neg ();
28755:363:        }
28756:364:    } else {
28757:365:        if (y1 != y0) {
28758:366:            py = 0;
28759:367:            if (x1 > x0) {
28760:368:                px1 = 0;
28761:369:                px2 = ((abs (g1h) >> 1)) >> SHLB;
28762:370:            } else {
28763:371:                px1 = -((abs (g0) >> 1)) >> SHLB;
28764:372:                px2 = 0;
28765:373:            }
28766:374:            tri_set_color;
28767:375:
28768:376:            colhline_pos ();
28769:377:            if ((py = 1) < y1 - y0)
28770:378:                for (; py < y1 - y0; py++) {
28771:379:                    px1 = ((g0 * py) - (abs (g0) >> 1)) >> SHLB;
28772:380:                    px2 = ((g1h * py) + (abs (g1h) >> 1)) >> SHLB;
28773:381:                    tri_set_color;
28774:382:
28775:383:                    colhline_pos ();
28776:384:                }
28777:385:            px1 =
28778:386:                max (((g0 * py) - (abs (g0) >> 1)) >> SHLB,
28779:387:                     min (x2, x0) - x0);
28780:388:            px2 = x1 - x0;
28781:389:            tri_set_color;
28782:390:            colhline_pos ();
28783:391:        } else {
28784:392:            py = 0;
28785:393:            px1 = 0;
28786:394:            px2 = x1 - x0;
28787:395:            tri_set_color;
28788:396:            colhline_pos ();
28789:397:        }
28790:398:        if (y1 != y2) {
28791:399:            if ((py = y1 - y0 + 1) < y2 - y0)
28792:400:                for (; py < y2 - y0; py++) {
28793:401:                    px1 = ((g0 * py) - (abs (g0) >> 1)) >> SHLB;
28794:402:                    px2 =
28795:403:                        (((g1l * (py - y1 + y0)) +
28796:404:                          (abs (g1l) >> 1)) >> SHLB) + x1 - x0;
28797:405:                    tri_set_color;
28798:406:
28799:407:                    colhline_pos ();
28800:408:                }
28801:409:            if (x1 > x2) {
28802:410:                px1 = x2 - x0;
28803:411:                px2 = x2 - x0 + ((abs (g1l) >> 1) >> SHLB);
28804:412:            } else {
28805:413:                px1 = x2 - x0 - ((abs (g0) >> 1) >> SHLB);
28806:414:                px2 = x2 - x0;
28807:415:            }
28808:416:
28809:417:            tri_set_color;
28810:418:
28811:419:            colhline_pos ();
28812:420:        }
28813:421:    }
28814:422:}
28815:1:/*
28816:2:   Copyright (C) 1996 Paul Sheer
28817:3:
28818:4:   This program is free software; you can redistribute it and/or modify
28819:5:   it under the terms of the GNU General Public License as published by
28820:6:   the Free Software Foundation; either version 2 of the License, or
28821:7:   (at your option) any later version.
28822:8:
28823:9:   This program is distributed in the hope that it will be useful,
28824:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
28825:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
28826:12:   GNU General Public License for more details.
28827:13:
28828:14:   You should have received a copy of the GNU General Public License
28829:15:   along with this program; if not, write to the Free Software
28830:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
28831:17: */
28832:18:
28833:19:#ifdef lookup
28834:20:#undef lookup
28835:21:#endif
28836:22:
28837:23:#if (TRI_BPP==8) || !defined(INTERP)
28838:24:#define lookup(x) x
28839:25:#else
28840:26:#define lookup(x) _color_lookup[x]
28841:27:#endif
28842:28:
28843:29:
28844:30:#ifdef assignvp
28845:31:#undef declarevp
28846:32:#undef assignvp
28847:33:#undef assignvpoffset
28848:34:#undef incvp
28849:35:#undef incvpoffset
28850:36:#undef decvp
28851:37:#undef decvpoffset
28852:38:#endif
28853:39:
28854:40:
28855:41:#if TRI_BPP==8
28856:42:#define declarevp declarevp8
28857:43:#define assignvp assignvp8
28858:44:#define assignvpoffset assignvpoffset8
28859:45:#define incvp incvp8
28860:46:#define incvpoffset incvpoffset8
28861:47:#define decvp decvp8
28862:48:#define decvpoffset decvpoffset8
28863:49:#endif
28864:50:#if TRI_BPP==16
28865:51:#define declarevp declarevp16
28866:52:#define assignvp assignvp16
28867:53:#define assignvpoffset assignvpoffset16
28868:54:#define incvp incvp16
28869:55:#define incvpoffset incvpoffset16
28870:56:#define decvp decvp16
28871:57:#define decvpoffset decvpoffset16
28872:58:#endif
28873:59:#if TRI_BPP==24
28874:60:#define declarevp declarevp24
28875:61:#define assignvp assignvp24
28876:62:#define assignvpoffset assignvpoffset24
28877:63:#define incvp incvp24
28878:64:#define incvpoffset incvpoffset24
28879:65:#define decvp decvp24
28880:66:#define decvpoffset decvpoffset24
28881:67:#endif
28882:68:#if TRI_BPP==32
28883:69:#define declarevp declarevp32
28884:70:#define assignvp assignvp32
28885:71:#define assignvpoffset assignvpoffset32
28886:72:#define incvp incvp32
28887:73:#define incvpoffset incvpoffset32
28888:74:#define decvp decvp32
28889:75:#define decvpoffset decvpoffset32
28890:76:#endif
28891:77:
28892:78:
28893:79:#ifdef color
28894:80:#undef color
28895:81:#endif
28896:82:
28897:83:#ifdef WRAP
28898:84:#ifdef INTERP
28899:85:#define color \
28900:86:    (dat[(xd >> SHLB) + (yd & S_MASK)] + (c >> (SHLB + SHC)))
28901:87:#else
28902:88:#define color \
28903:89:    (dat[(xd >> SHLB) + (yd & S_MASK)] + c)
28904:90:#endif
28905:91:#else
28906:92:#ifdef INTERP
28907:93:#define color \
28908:94:    (c >> (SHLB + SHC))
28909:95:#else
28910:96:#define color \
28911:97:    c
28912:98:#endif
28913:99:#endif
28914:100:
28915:101:
28916:102:/* these are actually all the same except for 8 */
28917:103:#if TRI_BPP==8
28918:104:static void colhline_neg_setpixel8 (void)
28919:105:#endif
28920:106:#if TRI_BPP==16
28921:107:static void colhline_neg_setpixel16 (void)
28922:108:#endif
28923:109:#if TRI_BPP==24
28924:110:static void colhline_neg_setpixel24 (void)
28925:111:#endif
28926:112:#if TRI_BPP==32
28927:113:static void colhline_neg_setpixel32 (void)
28928:114:#endif
28929:115:{
28930:116:    int count, y = py + dy0, x1 = px1 + dx0, x2 = px2 + dx0;
28931:117:    if (__clip) {
28932:118:        if (y < __clipy1 || y > __clipy2)
28933:119:            return;
28934:120:        if (x1 > __clipx2 + 1) {
28935:121:#ifdef WRAP
28936:122:            xd -= (x1 - __clipx2 - 1) * xd_x;
28937:123:            yd -= (x1 - __clipx2 - 1) * yd_x;
28938:124:#endif
28939:125:#ifdef INTERP
28940:126:            c -= (x1 - __clipx2 - 1) * c_x;
28941:127:#endif
28942:128:            x1 = __clipx2 + 1;
28943:129:        }
28944:130:        if (x2 < __clipx1) {
28945:131:            x2 = __clipx1;
28946:132:        }
28947:133:    }
28948:134:    count = x1 - x2;
28949:135:    if (count > 0) {
28950:136:        do {
28951:137:            _tri_drawpoint (--x1, y, lookup (color));
28952:138:#ifdef WRAP
28953:139:            yd -= yd_x;
28954:140:            xd -= xd_x;
28955:141:#endif
28956:142:#ifdef INTERP
28957:143:            c -= c_x;
28958:144:#endif
28959:145:        } while (--count);
28960:146:    }
28961:147:}
28962:148:
28963:149:
28964:150:#if TRI_BPP==8
28965:151:static void colhline_pos_setpixel8 (void)
28966:152:#endif
28967:153:#if TRI_BPP==16
28968:154:static void colhline_pos_setpixel16 (void)
28969:155:#endif
28970:156:#if TRI_BPP==24
28971:157:static void colhline_pos_setpixel24 (void)
28972:158:#endif
28973:159:#if TRI_BPP==32
28974:160:static void colhline_pos_setpixel32 (void)
28975:161:#endif
28976:162:{
28977:163:    int count, y = py + dy0, x1 = px1 + dx0, x2 = px2 + dx0;
28978:164:    if (__clip) {
28979:165:        if (y < __clipy1 || y > __clipy2)
28980:166:            return;
28981:167:        if (x1 < __clipx1) {
28982:168:#ifdef WRAP
28983:169:            xd += (__clipx1 - x1) * xd_x;
28984:170:            yd += (__clipx1 - x1) * yd_x;
28985:171:#endif
28986:172:#ifdef INTERP
28987:173:            c += (__clipx1 - x1) * c_x;
28988:174:#endif
28989:175:            x1 = __clipx1;
28990:176:        }
28991:177:        if (x2 > __clipx2 + 1) {
28992:178:            x2 = __clipx2 + 1;
28993:179:        }
28994:180:    }
28995:181:    count = x2 - x1;
28996:182:    if (count > 0) {
28997:183:        do {
28998:184:            _tri_drawpoint (x1++, y, lookup (color));
28999:185:#ifdef WRAP
29000:186:            yd += yd_x;
29001:187:            xd += xd_x;
29002:188:#endif
29003:189:#ifdef INTERP
29004:190:            c += c_x;
29005:191:#endif
29006:192:        } while (--count);
29007:193:    }
29008:194:}
29009:195:
29010:196:#ifndef DO_NOT_USE_VGALIB
29011:197:/*draw to 64k vga buffer setting vga page appropriately: */
29012:198:
29013:199:#if TRI_BPP==8
29014:200:static void colhline_neg_paged8 (void)
29015:201:#endif
29016:202:#if TRI_BPP==16
29017:203:static void colhline_neg_paged16 (void)
29018:204:#endif
29019:205:#if TRI_BPP==24
29020:206:static void colhline_neg_paged24 (void)
29021:207:#endif
29022:208:#if TRI_BPP==32
29023:209:static void colhline_neg_paged32 (void)
29024:210:#endif
29025:211:{
29026:212:    int count, y = py + dy0, x1 = px1 + dx0, x2 = px2 + dx0;
29027:213:    unsigned short offst;
29028:214:    int pg;
29029:215:    declarevp;
29030:216:    long vp = 0;
29031:217:    if (__clip) {
29032:218:        if (y < __clipy1 || y > __clipy2)
29033:219:            return;
29034:220:
29035:221:        if (x1 > __clipx2 + 1) {
29036:222:#ifdef WRAP
29037:223:            xd -= (x1 - __clipx2 - 1) * xd_x;
29038:224:            yd -= (x1 - __clipx2 - 1) * yd_x;
29039:225:#endif
29040:226:#ifdef INTERP
29041:227:            c -= (x1 - __clipx2 - 1) * c_x;
29042:228:#endif
29043:229:            x1 = __clipx2 + 1;
29044:230:        }
29045:231:        if (x2 < __clipx1) {
29046:232:            x2 = __clipx1;
29047:233:        }
29048:234:    }
29049:235:    count = x1 - x2;
29050:236:    assignvpoffset (x1, y, vp);
29051:237:    pg = vp >> 16;
29052:238:    vga_setpage (pg);
29053:239:    offst = vp;
29054:240:    if (count > 0) {
29055:241:        do {
29056:242:            decvpoffset;
29057:243:#ifdef WRAP
29058:244:            yd -= yd_x;
29059:245:            xd -= xd_x;
29060:246:#endif
29061:247:#ifdef INTERP
29062:248:            c -= c_x;
29063:249:#endif
29064:250:        } while (--count);
29065:251:    }
29066:252:}
29067:253:
29068:254:
29069:255:#if TRI_BPP==8
29070:256:static void colhline_pos_paged8 (void)
29071:257:#endif
29072:258:#if TRI_BPP==16
29073:259:static void colhline_pos_paged16 (void)
29074:260:#endif
29075:261:#if TRI_BPP==24
29076:262:static void colhline_pos_paged24 (void)
29077:263:#endif
29078:264:#if TRI_BPP==32
29079:265:static void colhline_pos_paged32 (void)
29080:266:#endif
29081:267:{
29082:268:    int count, y = py + dy0, x1 = px1 + dx0, x2 = px2 + dx0;
29083:269:    unsigned short offst;
29084:270:    int pg;
29085:271:    declarevp;
29086:272:    long vp = 0;
29087:273:    if (__clip) {
29088:274:        if (y < __clipy1 || y > __clipy2)
29089:275:            return;
29090:276:
29091:277:        if (x1 < __clipx1) {
29092:278:#ifdef WRAP
29093:279:            xd += (__clipx1 - x1) * xd_x;
29094:280:            yd += (__clipx1 - x1) * yd_x;
29095:281:#endif
29096:282:#ifdef INTERP
29097:283:            c += (__clipx1 - x1) * c_x;
29098:284:#endif
29099:285:            x1 = __clipx1;
29100:286:        }
29101:287:        if (x2 > __clipx2 + 1) {
29102:288:            x2 = __clipx2 + 1;
29103:289:        }
29104:290:    }
29105:291:    count = x2 - x1;
29106:292:    assignvpoffset (x1, y, vp);
29107:293:    pg = vp >> 16;
29108:294:    vga_setpage (pg);
29109:295:    offst = vp;
29110:296:    if (count > 0) {
29111:297:        do {
29112:298:            incvpoffset;
29113:299:#ifdef WRAP
29114:300:            yd += yd_x;
29115:301:            xd += xd_x;
29116:302:#endif
29117:303:#ifdef INTERP
29118:304:            c += c_x;
29119:305:#endif
29120:306:        } while (--count);
29121:307:    }
29122:308:}
29123:309:
29124:310:
29125:311:#else
29126:312:
29127:313:
29128:314:/*draw to 64k vga buffer setting vga page appropriately: */
29129:315:
29130:316:#if TRI_BPP==8
29131:317:static void colhline_neg_paged8 (void)
29132:318:#endif
29133:319:#if TRI_BPP==16
29134:320:static void colhline_neg_paged16 (void)
29135:321:#endif
29136:322:#if TRI_BPP==24
29137:323:static void colhline_neg_paged24 (void)
29138:324:#endif
29139:325:#if TRI_BPP==32
29140:326:static void colhline_neg_paged32 (void)
29141:327:#endif
29142:328:{
29143:329:}
29144:330:
29145:331:
29146:332:#if TRI_BPP==8
29147:333:static void colhline_pos_paged8 (void)
29148:334:#endif
29149:335:#if TRI_BPP==16
29150:336:static void colhline_pos_paged16 (void)
29151:337:#endif
29152:338:#if TRI_BPP==24
29153:339:static void colhline_pos_paged24 (void)
29154:340:#endif
29155:341:#if TRI_BPP==32
29156:342:static void colhline_pos_paged32 (void)
29157:343:#endif
29158:344:{
29159:345:}
29160:346:
29161:347:
29162:348:#endif
29163:349:
29164:350:/*draw to a linear address space (320x200 or virtual screen): */
29165:351:#if TRI_BPP==8
29166:352:static void colhline_neg_direct8 (void)
29167:353:#endif
29168:354:#if TRI_BPP==16
29169:355:static void colhline_neg_direct16 (void)
29170:356:#endif
29171:357:#if TRI_BPP==24
29172:358:static void colhline_neg_direct24 (void)
29173:359:#endif
29174:360:#if TRI_BPP==32
29175:361:static void colhline_neg_direct32 (void)
29176:362:#endif
29177:363:{
29178:364:    int count, y = py + dy0, x1 = px1 + dx0, x2 = px2 + dx0;
29179:365:    declarevp;
29180:366:    if (__clip) {
29181:367:        if (y < __clipy1 || y > __clipy2)
29182:368:            return;
29183:369:        if (x1 > __clipx2 + 1) {
29184:370:#ifdef WRAP
29185:371:            xd -= (x1 - __clipx2 - 1) * xd_x;
29186:372:            yd -= (x1 - __clipx2 - 1) * yd_x;
29187:373:#endif
29188:374:#ifdef INTERP
29189:375:            c -= (x1 - __clipx2 - 1) * c_x;
29190:376:#endif
29191:377:            x1 = __clipx2 + 1;
29192:378:        }
29193:379:        if (x2 < __clipx1)
29194:380:            x2 = __clipx1;
29195:381:    }
29196:382:    count = x1 - x2;
29197:383:    assignvp (x1, y, vp);
29198:384:    if (count > 0) {
29199:385:        do {
29200:386:            decvp;
29201:387:#ifdef WRAP
29202:388:            yd -= yd_x;
29203:389:            xd -= xd_x;
29204:390:#endif
29205:391:#ifdef INTERP
29206:392:            c -= c_x;
29207:393:#endif
29208:394:        } while (--count);
29209:395:    }
29210:396:}
29211:397:
29212:398:
29213:399:#if TRI_BPP==8
29214:400:static void colhline_pos_direct8 (void)
29215:401:#endif
29216:402:#if TRI_BPP==16
29217:403:static void colhline_pos_direct16 (void)
29218:404:#endif
29219:405:#if TRI_BPP==24
29220:406:static void colhline_pos_direct24 (void)
29221:407:#endif
29222:408:#if TRI_BPP==32
29223:409:static void colhline_pos_direct32 (void)
29224:410:#endif
29225:411:{
29226:412:    int count, y = py + dy0, x1 = px1 + dx0, x2 = px2 + dx0;
29227:413:    declarevp;
29228:414:    if (__clip) {
29229:415:        if (y < __clipy1 || y > __clipy2)
29230:416:            return;
29231:417:        if (x1 < __clipx1) {
29232:418:#ifdef WRAP
29233:419:            xd += (__clipx1 - x1) * xd_x;
29234:420:            yd += (__clipx1 - x1) * yd_x;
29235:421:#endif
29236:422:#ifdef INTERP
29237:423:            c += (__clipx1 - x1) * c_x;
29238:424:#endif
29239:425:            x1 = __clipx1;
29240:426:        }
29241:427:        if (x2 > __clipx2 + 1)
29242:428:            x2 = __clipx2 + 1;
29243:429:    }
29244:430:    count = x2 - x1;
29245:431:    assignvp (x1, y, vp);
29246:432:    if (count > 0) {
29247:433:        do {
29248:434:            incvp;
29249:435:#ifdef WRAP
29250:436:            yd += yd_x;
29251:437:            xd += xd_x;
29252:438:#endif
29253:439:#ifdef INTERP
29254:440:            c += c_x;
29255:441:#endif
29256:442:        } while (--count);
29257:443:    }
29258:444:}
29259:445:
29260:446:/*The following have not yet been implemented */
29261:447:
29262:448:/* Draws to planar 256 (these could be complicated) */
29263:449:/*static void colhline_neg_planar (void);
29264:450:static void colhline_pos_planar (void);*/
29265:451:
29266:452:/* Draws using accelerated */
29267:453:/*static void colhline_neg_accel (void);
29268:454:static void colhline_pos_accel (void);*/
29269:1:/* Graphics Library headerfile */
29270:2:
29271:3:#ifndef VGAGL_H
29272:4:#define VGAGL_H
29273:5:
29274:6:#ifndef DO_NOT_USE_VGALIB
29275:7:#define DO_NOT_USE_VGALIB
29276:8:#endif
29277:9:
29278:10:#ifdef __cplusplus
29279:11:extern "C" {
29280:12:#endif
29281:13:
29282:14:
29283:15:/* Graphics context */
29284:16:
29285:17:#define CONTEXT_VIRTUAL                0x0
29286:18:#define CONTEXT_PAGED                0x1
29287:19:#define CONTEXT_LINEAR                0x2
29288:20:#define CONTEXT_MODEX                0x3
29289:21:#define CONTEXT_PLANAR16        0x4
29290:22:
29291:23:#define MODEFLAG_PAGEFLIPPING_CAPABLE                0x01
29292:24:#define MODEFLAG_TRIPLEBUFFERING_CAPABLE        0x02
29293:25:#define MODEFLAG_PAGEFLIPPING_ENABLED                0x04
29294:26:#define MODEFLAG_TRIPLEBUFFERING_ENABLED        0x08
29295:27:#define MODEFLAG_FLIPPAGE_BANKALIGNED                0x10
29296:28:/*
29297:29: * The next two can never occur together, thus we use the same flag
29298:30: * (as svgalib does).
29299:31: */
29300:32:#define MODEFLAG_32BPP_SHIFT8                        0x20
29301:33:#define MODEFLAG_24BPP_REVERSED                        0x20
29302:34:
29303:35:    typedef struct {
29304:36:        void (*driver_setpixel_func) (int, int, int);
29305:37:        int (*driver_getpixel_func) (int, int);
29306:38:        void (*driver_hline_func) (int, int, int, int);
29307:39:        void (*driver_fillbox_func) (int, int, int, int, int);
29308:40:        void (*driver_putbox_func) (int, int, int, int, void *, int);
29309:41:        void (*driver_getbox_func) (int, int, int, int, void *, int);
29310:42:        void (*driver_putboxmask_func) (int, int, int, int, void *);
29311:43:        void (*driver_putboxpart_func) (int, int, int, int, int, int,
29312:44:                                        void *, int, int);
29313:45:        void (*driver_getboxpart_func) (int, int, int, int, int, int,
29314:46:                                        void *, int, int);
29315:47:        void (*driver_copybox_func) (int, int, int, int, int, int);
29316:48:    } framebufferfunctions;
29317:49:
29318:50:    typedef struct {
29319:51:        unsigned char modetype; /* virtual, paged, linear, mode X */
29320:52:        unsigned char modeflags; /* or planar16 */
29321:53:        unsigned char dummy;
29322:54:        unsigned char flippage;
29323:55:        int width;              /* width in pixels */
29324:56:        int height;             /* height in pixels */
29325:57:        int bytesperpixel;      /* bytes per pixel (1, 2, 3, or 4) */
29326:58:        int colors;             /* number of colors */
29327:59:        int bitsperpixel;       /* bits per pixel (8, 15, 16 or 24) */
29328:60:        int bytewidth;          /* length of a scanline in bytes */
29329:61:        char *vbuf;             /* address of framebuffer */
29330:62:        int clip;               /* clipping enabled? */
29331:63:        int clipx1;             /* top-left coordinate of clip window */
29332:64:        int clipy1;
29333:65:        int clipx2;             /* bottom-right coordinate of clip window */
29334:66:        int clipy2;
29335:67:        framebufferfunctions ff;
29336:68:    } GraphicsContext;
29337:69:
29338:70:    extern GraphicsContext currentcontext;
29339:71:
29340:72:#define BYTESPERPIXEL (currentcontext.bytesperpixel)
29341:73:#define BYTEWIDTH (currentcontext.bytewidth)
29342:74:#define WIDTH (currentcontext.width)
29343:75:#define HEIGHT (currentcontext.height)
29344:76:#define VBUF (currentcontext.vbuf)
29345:77:#define MODETYPE (currentcontext.modetype)
29346:78:#define MODEFLAGS (currentcontext.modeflags)
29347:79:#define BITSPERPIXEL (currentcontext.bitsperpixel)
29348:80:#define COLORS (currentcontext.colors)
29349:81:
29350:82:#define __clip (currentcontext.clip)
29351:83:#define __clipx1 (currentcontext.clipx1)
29352:84:#define __clipy1 (currentcontext.clipy1)
29353:85:#define __clipx2 (currentcontext.clipx2)
29354:86:#define __clipy2 (currentcontext.clipy2)
29355:87:
29356:88:
29357:89:/* Configuration */
29358:90:
29359:91:    int gl_setcontextvga (int m);
29360:92:    int gl_setcontextvgavirtual (int m);
29361:93:    void gl_setcontextvirtual (int w, int h, int bpp, int bitspp,
29362:94:                               void *vbuf);
29363:95:    void gl_setcontextwidth (int w);
29364:96:    void gl_setcontextheight (int h);
29365:97:    GraphicsContext *gl_allocatecontext (void);
29366:98:    void gl_setcontext (GraphicsContext * gc);
29367:99:    void gl_getcontext (GraphicsContext * gc);
29368:100:    void gl_freecontext (GraphicsContext * gc);
29369:101:
29370:102:/* Line drawing */
29371:103:
29372:104:    void gl_setpixel (int x, int y, int c);
29373:105:    void gl_setpixelrgb (int x, int y, int r, int g, int b);
29374:106:    int gl_getpixel (int x, int y);
29375:107:    void gl_getpixelrgb (int x, int y, int *r, int *g, int *b);
29376:108:    int gl_rgbcolor (int r, int g, int b);
29377:109:    void gl_hline (int x1, int y, int x2, int c);
29378:110:    void gl_line (int x1, int y1, int x2, int y2, int c);
29379:111:    void gl_circle (int x, int y, int r, int c);
29380:112:
29381:113:/* Box (bitmap) functions */
29382:114:
29383:115:    void gl_fillbox (int x, int y, int w, int h, int c);
29384:116:    void gl_getbox (int x, int y, int w, int h, void *dp);
29385:117:    void gl_putbox (int x, int y, int w, int h, void *dp);
29386:118:    void gl_putboxpart (int x, int y, int w, int h, int bw, int bh,
29387:119:                        void *b, int xo, int yo);
29388:120:    void gl_putboxmask (int x, int y, int w, int h, void *dp);
29389:121:    void gl_copybox (int x1, int y1, int w, int h, int x2, int y2);
29390:122:    void gl_copyboxtocontext (int x1, int y1, int w, int h,
29391:123:                              GraphicsContext * gc, int x2, int y2);
29392:124:    void gl_copyboxfromcontext (GraphicsContext * gc, int x1, int y1,
29393:125:                                int w, int h, int x2, int y2);
29394:126:/* The following functions only work in 256-color modes: */
29395:127:    void gl_compileboxmask (int w, int h, void *sdp, void *ddp);
29396:128:    int gl_compiledboxmasksize (int w, int h, void *sdp);
29397:129:    void gl_putboxmaskcompiled (int x, int y, int w, int h, void *dp);
29398:130:
29399:131:/* Miscellaneous */
29400:132:
29401:133:    void gl_clearscreen (int c);
29402:134:    void gl_scalebox (int w1, int h1, void *sb, int w2, int h2, void *db);
29403:135:    void gl_setdisplaystart (int x, int y);
29404:136:    void gl_enableclipping (void);
29405:137:    void gl_setclippingwindow (int x1, int y1, int x2, int y2);
29406:138:    void gl_disableclipping (void);
29407:139:
29408:140:/* Screen buffering */
29409:141:
29410:142:    void gl_copyscreen (GraphicsContext * gc);
29411:143:    void gl_setscreenoffset (int o);
29412:144:    int gl_enablepageflipping (GraphicsContext * gc);
29413:145:
29414:146:/* Text */
29415:147:
29416:148:/* Writemode flags. */
29417:149:#define WRITEMODE_OVERWRITE 0
29418:150:#define WRITEMODE_MASKED 1
29419:151:#define FONT_EXPANDED 0
29420:152:#define FONT_COMPRESSED 2
29421:153:
29422:154:    void gl_expandfont (int fw, int fh, int c, void *sfdp, void *dfdp);
29423:155:    void gl_setfont (int fw, int fh, void *fdp);
29424:156:    void gl_colorfont (int fw, int fh, int c, void *fdp);
29425:157:    void gl_setwritemode (int wm);
29426:158:    void gl_write (int x, int y, char *s);
29427:159:    void gl_writen (int x, int y, int n, char *s);
29428:160:    void gl_setfontcolors (int bg, int fg);
29429:161:
29430:162:    extern unsigned char *gl_font8x8; /* compressed 8x8 font */
29431:163:
29432:164:/* 256-color Palette */
29433:165:
29434:166:    typedef struct {
29435:167:        struct {
29436:168:            unsigned char red;  /* 6-bit values */
29437:169:            unsigned char green;
29438:170:            unsigned char blue;
29439:171:        } color[256];
29440:172:    } Palette;
29441:173:
29442:174:    void gl_setpalettecolor (int c, int r, int b, int g);
29443:175:    void gl_getpalettecolor (int c, int *r, int *b, int *g);
29444:176:    void gl_setpalettecolors (int s, int n, void *dp);
29445:177:    void gl_getpalettecolors (int s, int n, void *dp);
29446:178:    void gl_setpalette (void *p);
29447:179:    void gl_getpalette (void *p);
29448:180:    void gl_setrgbpalette (void);
29449:181:
29450:182:
29451:183:#ifdef __cplusplus
29452:184:}
29453:185:#endif
29454:186:#endif
29455:1:#ifndef DO_NOT_USE_VGALIB
29456:2:#define DO_NOT_USE_VGALIB
29457:3:#endif
29458:1:/*
29459:2:   Copyright (C) 1996 Paul Sheer
29460:3:
29461:4:   This program is free software; you can redistribute it and/or modify
29462:5:   it under the terms of the GNU General Public License as published by
29463:6:   the Free Software Foundation; either version 2 of the License, or
29464:7:   (at your option) any later version.
29465:8:
29466:9:   This program is distributed in the hope that it will be useful,
29467:10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
29468:11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
29469:12:   GNU General Public License for more details.
29470:13:
29471:14:   You should have received a copy of the GNU General Public License
29472:15:   along with this program; if not, write to the Free Software
29473:16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  
29474:17: */
29475:18:
29476:19:
29477:20:#include <config.h>
29478:21:#include <stdlib.h>
29479:22:#include <stdio.h>
29480:23:
29481:24:#include <X11/Xlib.h>
29482:25:#include <X11/Xutil.h>
29483:26:
29484:27:#include <math.h>
29485:28:#include <my_string.h>
29486:29:
29487:30:#include "stringtools.h"
29488:31:#include "app_glob.c"
29489:32:
29490:33:#include "coolwidget.h"
29491:34:#include "widget3d.h"
29492:35:
29493:36:#include "vgagl.h"
29494:37:#include "3dkit.h"
29495:38:
29496:39:#ifdef USING_MATRIXLIB
29497:40:#include "matrix.h"
29498:41:#endif
29499:42:
29500:43:#include "imagewidget.h"
29501:44:
29502:45:#include "mad.h"
29503:46:
29504:47:static Pixmap widget3d_currentpixmap;
29505:48:static long widget3d_thres;
29506:49:
29507:50:void local_striangle (int x0, int y0,
29508:51:                      int x1, int y1, int x2, int y2, int z0, int bf)
29509:52:{
29510:53:    long n;
29511:54:    XPoint p[3];
29512:55:    p[0].x = x0;
29513:56:    p[0].y = y0;
29514:57:    p[1].x = x1;
29515:58:    p[1].y = y1;
29516:59:    p[2].x = x2;
29517:60:    p[2].y = y2;
29518:61:
29519:62:    if ((((n =
29520:63:           (x0 - x1) * (y0 - y2) - (y0 - y1) * (x0 - x2)) > 0) + bf) & 1
29521:64:        || bf == 2) {
29522:65:        if (abs (n) < widget3d_thres) {
29523:66:            if (abs (x0) + abs (x1) + abs (x2) + abs (y0) + abs (y1) +
29524:67:                abs (y2) < 32000) {
29525:68:                if (Cdepth >= 8
29526:69:                    && (ClassOfVisual (Cvisual) == PseudoColor
29527:70:                        || ClassOfVisual (Cvisual) == StaticGray))
29528:71:                    Csetcolor (z0);
29529:72:                else
29530:73:                    Csetcolor (Cpixel[z0]);
29531:74:                XFillPolygon (CDisplay, widget3d_currentpixmap, CGC, p, 3,
29532:75:                              Convex, CoordModeOrigin);
29533:76:            }
29534:77:        }
29535:78:    }
29536:79:}
29537:80:
29538:81:
29539:82:
29540:83:void local_drawline (int x1, int y1, int x2, int y2, int c)
29541:84:{
29542:85:    Csetcolor (c);
29543:86:    if (abs (x1) + abs (x2) + abs (y1) + abs (y2) < 32000)
29544:87:        Cline (widget3d_currentpixmap, x1, y1, x2, y2);
29545:88:}
29546:89:
29547:90:
29548:91:void local_setpixel (int x, int y, int c)
29549:92:{
29550:93:    Csetcolor (c);
29551:94:    XDrawPoint (CDisplay, widget3d_currentpixmap, CGC, x, y);
29552:95:}
29553:96:
29554:97:
29555:98:
29556:99:/* this redraws the object. If force is non-zero then the object WILL
29557:100:   be redrawn. If not the routine checks if there are any events in the
29558:101:   event queue and only redraws if the event queue is empty. */
29559:102:CWidget *Credraw3dobject (const char *ident, int force)
29560:103:{
29561:104:    CWidget *w = Cwidget (ident);
29562:105:    Window win = w->winid;
29563:106:    TD_Solid *object = w->solid;
29564:107:
29565:108:    if (force || !CMousePending (ident)) {
29566:109:        gl_setcontext (w->gl_graphicscontext);
29567:110:        gl_enableclipping ();
29568:111:
29569:112:        widget3d_thres = w->width * w->height;
29570:113:        widget3d_currentpixmap = w->pixmap;
29571:114:        Csetcolor (C_FLAT);
29572:115:        Crect (widget3d_currentpixmap, 0, 0, w->width - 4, w->height - 4);
29573:116:        TD_draw_solid (object);
29574:117:        XCopyArea (CDisplay, widget3d_currentpixmap, win, CGC, 0, 0,
29575:118:                   w->width - 4, w->height - 4, 2, 2);
29576:119:    }
29577:120:    return w;
29578:121:}
29579:122:
29580:123:
29581:124:
29582:125:
29583:126:/* Allocates memory for the TD_Solid structure. returns 0 on error */
29584:127:TD_Solid *TD_allocate_solid (int max_num_surfaces)
29585:128:{
29586:129:    TD_Solid *object;
29587:130:
29588:131:    if ((object = malloc (sizeof (TD_Solid))) == NULL)
29589:132:        return 0;
29590:133:
29591:134:    memset (object, 0, sizeof (TD_Solid));
29592:135:
29593:136:    object->num_surfaces = max_num_surfaces;
29594:137:
29595:138:    if ((object->surf =
29596:139:         malloc (max_num_surfaces * sizeof (TD_Surface))) == NULL)
29597:140:        return 0;
29598:141:
29599:142:    memset (object->surf, 0, max_num_surfaces * sizeof (TD_Surface));
29600:143:
29601:144:    return object;
29602:145:}
29603:146:
29604:147:
29605:148:/*returns NULL on error, else returns a pointer to the surface points */
29606:149:TD_Surface *Calloc_surf (const char *ident, int surf_width,
29607:150:                         int surf_height, int *surf)
29608:151:{
29609:152:    int j = 0;
29610:153:    CWidget *w = Cwidget (ident);
29611:154:
29612:155:    for (; j < w->solid->num_surfaces; j++)
29613:156:        if (!w->solid->surf[j].point) { /* find the first unused surface */
29614:157:            if (surf)
29615:158:                *surf = j;
29616:159:            w->solid->surf[j].point =
29617:160:                Cmalloc (surf_width * surf_height * sizeof (TD_Point));
29618:161:            memset (w->solid->surf[j].point, 0,
29619:162:                    surf_width * surf_height * sizeof (TD_Point));
29620:163:            w->solid->surf[j].w = surf_width;
29621:164:            w->solid->surf[j].l = surf_height;
29622:165:            return &(w->solid->surf[j]);
29623:166:        }
29624:167:    Cerror ("Max number of surfaces exceeded for this solid.\n");
29625:168:    return NULL;
29626:169:}
29627:170:
29628:171:/* free the i'th surface if widget ident */
29629:172:void Cfree_surf (CWidget * w, int i)
29630:173:{
29631:174:
29632:175:    if (w->solid->surf[i].point) {
29633:176:        free (w->solid->surf[i].point);
29634:177:        w->solid->surf[i].point = NULL;
29635:178:    }
29636:179:}
29637:180:
29638:181:/* free the last surface of widget ident, returns first available surface in surf */
29639:182:/* returns 1 if there are any remaining unfree'd surfaces */
29640:183:int Cfree_last_surf (CWidget * w, int *surf)
29641:184:{
29642:185:    int j = 0;
29643:186:    for (; j < w->solid->num_surfaces; j++)
29644:187:        if (!w->solid->surf[j].point) /* find the first unused surface */
29645:188:            break;
29646:189:    if (surf)
29647:190:        *surf = j;
29648:191:    if (j > 0)
29649:192:        Cfree_surf (w, --j);
29650:193:    if (j)
29651:194:        return 1;
29652:195:    return 0;
29653:196:}
29654:197:
29655:198:void Cclear_all_surfaces (const char *ident)
29656:199:{
29657:200:    CWidget *w = Cwidget (ident);
29658:201:    while (Cfree_last_surf (w, NULL));
29659:202:}
29660:203:
29661:204:void Cinit_surf_points (const char *ident, int width, int height,
29662:205:                        TD_Point data[])
29663:206:{
29664:207:    TD_Surface *s = Calloc_surf (ident, width, height, NULL);
29665:208:    memcpy (s->point, data, width * height * sizeof (TD_Point));
29666:209:    TD_initcolor (s, -256);
29667:210:}
29668:211:
29669:212:#ifdef USING_MATRIXLIB
29670:213:
29671:214:void Cmatrix_to_surf (const char *ident, int surf_width, int surf_height,
29672:215:                      Matrix * x, Matrix * offset, double scale)
29673:216:{
29674:217:    TD_Point *p = Cmalloc (x->columns * sizeof (TD_Point));
29675:218:    int i;
29676:219:
29677:220:    for (i = 0; i < x->columns; i++) {
29678:221:        p[i].x = (double) (Mard (*x, 0, i) + Mard (*offset, 0, 0)) * scale;
29679:222:        p[i].y = (double) (Mard (*x, 1, i) + Mard (*offset, 1, 0)) * scale;
29680:223:        p[i].z =
29681:224:            (double) -(Mard (*x, 2, i) + Mard (*offset, 2, 0)) * scale;
29682:225:        p[i].dirx = 0;
29683:226:        p[i].diry = 0;
29684:227:        p[i].dirz = 0;
29685:228:    }
29686:229:
29687:230:    Cinit_surf_points (ident, surf_width, surf_height, p);
29688:231:    free (p);
29689:232:}
29690:233:
29691:234:#endif
29692:235:
29693:236:CWidget *Cdraw3dobject (const char *identifier, Window parent, int x,
29694:237:                        int y, int width, int height, int defaults,
29695:238:                        int max_num_surfaces)
29696:239:{
29697:240:    int i, j, n = 0;
29698:241:    CWidget *w;
29699:242:
29700:243:    TD_Solid *object;
29701:244:
29702:245:    if (!(object = TD_allocate_solid (max_num_surfaces)))
29703:246:        Cerror ("Error allocating memeory in call to Cdraw3dobject.\n");
29704:247:
29705:248:    width &= 0xFFFFFFFC;        /* width must be a multiple of 4 */
29706:249:
29707:250:    if (defaults) {
29708:251:
29709:252:        n = object->num_surfaces;
29710:253:
29711:254:        for (j = 0; j < n; j++) {
29712:255:            object->surf[j].backfacing = 1; /*don't draw any of surface that faces away */
29713:256:            object->surf[j].depth_per_color = 6; /*2^6 = 64 colors in the grey scale */
29714:257:            object->surf[j].bitmap1 = NULL;
29715:258:            object->surf[j].bitmap2 = NULL;
29716:259:            object->surf[j].mesh_color = Ccolor (6);
29717:260:        }
29718:261:
29719:262:        object->alpha = 0;      /* begin all at zero (flight dynamics */
29720:263:        object->beta = 0;       /* says plane is level */
29721:264:        object->gamma = 0;
29722:265:
29723:266:        object->xlight = -147;  /* lighting out of the screen,... */
29724:267:        object->ylight = -147;  /* ...to the right,... */
29725:268:        object->zlight = 147;   /* ...and from the top. */
29726:269:
29727:270:        object->distance = 85000; /* distance of the camera from the */
29728:271:        /* origin */
29729:272:
29730:273:        object->x_cam = 85000;
29731:274:        object->y_cam = 0;
29732:275:        object->z_cam = 0;
29733:276:
29734:277:/* These two are scale factors for the screen: */
29735:278:/* xscale is now calculated so that the maximum volume (-2^15 to 2^15 or
29736:279:   -2^31 to 2^31) will just fit inside the screen width at this distance: */
29737:280:        object->yscale = object->xscale =
29738:281:            (long) object->distance * (width + height) / (32768 * 4);
29739:282:/*to get display aspect square */
29740:283:
29741:284:/*The above gives an average (not to telescopic, and not to wide angle) view */
29742:285:
29743:286:/*use any triangle or linedrawing routine: */
29744:287:        object->draw_triangle = gl_triangle;
29745:288:        object->draw_striangle = local_striangle;
29746:289:        object->draw_wtriangle = gl_wtriangle;
29747:290:        object->draw_swtriangle = gl_swtriangle;
29748:291:        object->draw_line = local_drawline;
29749:292:        object->draw_point = local_setpixel;
29750:293:
29751:294:/* very important to set TDOPTION_INIT_ROTATION_MATRIX if you don't
29752:295:   calculate the rotation matrix yourself. */
29753:296:
29754:297:        object->option_flags = TDOPTION_INIT_ROTATION_MATRIX
29755:298:            | TDOPTION_ALL_SAME_RENDER | TDOPTION_SORT_SURFACES
29756:299:            | TDOPTION_ROTATE_OBJECT | TDOPTION_LIGHT_SOURCE_CAM
29757:300:            | TDOPTION_FLAT_TRIANGLE;
29758:301:
29759:302:        object->render = TD_MESH_AND_SOLID; /*how we want to render it */
29760:303:
29761:304:        object->posx = width / 2;
29762:305:        object->posy = height / 2;
29763:306:    }
29764:307:
29765:308:    w = Csetupwidget (identifier, parent, x, y,
29766:309:                      width + 4, height + 4, CTHREED_WIDGET, INPUT_MOTION,
29767:310:                      C_FLAT, 1);
29768:311:
29769:312:    w->solid = object;
29770:313:
29771:314:    w->pixmap = XCreatePixmap (CDisplay, CMain, width, height, Cdepth);
29772:315:
29773:316:    if (defaults) {
29774:317:        for (j = 0; j < n; j++) {
29775:318:            if (Cdepth >= 8
29776:319:                && (ClassOfVisual (Cvisual) == PseudoColor
29777:320:                    || ClassOfVisual (Cvisual) == StaticGray)) {
29778:321:/*In this case only we can use the actual pixel values because the
29779:322:   triangle routines can write the calculated pixel values to the buffer
29780:323:   which will be the same as the actual (hardware interpreted) pixel values */
29781:324:                object->surf[j].shadow = Cgrey (10);
29782:325:                object->surf[j].maxcolor = Cgrey (61);
29783:326:            } else {
29784:327:/*In all other cases, the triangle routine must calculate the color
29785:328:   and then convert it into a actual pixel value from the lookup
29786:329:   table. The triangle routine itself checks if
29787:330:   bytesperpixel is non-unity and performs lookup if so. */
29788:331:                object->surf[j].shadow = 43 + 10;
29789:332:                object->surf[j].maxcolor = 43 + 61;
29790:333:            }
29791:334:        }
29792:335:    }
29793:336:
29794:337:/*now use vgagl graphics contexts */
29795:338:    gl_setcontextvirtual (width, height, (Cdepth + 7) / 8, Cdepth, 0);
29796:339:    w->gl_graphicscontext = Cmalloc (sizeof (GraphicsContext));
29797:340:    gl_getcontext (w->gl_graphicscontext);
29798:341:
29799:342:    for (i = 0; i < 256; i++)
29800:343:        gl_trisetcolorlookup (i, Cpixel[i]);
29801:344:
29802:345:    Credraw3dobject (identifier, 2);
29803:346:
29804:347:    return w;
29805:348:}
29806:349:
29807:350:
29808:351:
29809:352:void Crender3dwidget (CWidget * wdt, int x, int y, int rendw, int rendh)
29810:353:{
29811:354:    int w = wdt->width;
29812:355:    int h = wdt->height;
29813:356:    Window win = wdt->winid;
29814:357:    int xim, yim, xwin, ywin;
29815:358:
29816:359:    xim = x - 2;
29817:360:    yim = y - 2;
29818:361:    xwin = x;
29819:362:    ywin = y;
29820:363:    if (xim < 0) {
29821:364:        rendw += xim;
29822:365:        xim = 0;
29823:366:        xwin = 2;
29824:367:    }
29825:368:    if (yim < 0) {
29826:369:        rendh += yim;
29827:370:        yim = 0;
29828:371:        ywin = 2;
29829:372:    }
29830:373:
29831:374:    XCopyArea (CDisplay, widget3d_currentpixmap, win, CGC, xim, yim, rendw,
29832:375:               rendh, xwin, ywin);
29833:376:
29834:377:    Crenderbevel (win, 0, 0, w - 1, h - 1, 2, 1);
29835:378:}
29836:1:
29837:2:#ifndef WIDGET_3D_H
29838:3:#define WIDGET_3D_H
29839:4:
29840:5:#ifdef USING_MATRIXLIB
29841:6:#include "matrix.h"
29842:7:void Cmatrix_to_surf (const char *ident, int surf_width, int surf_height,
29843:8:                      Matrix * x, Matrix * offset, double scale);
29844:9:#endif
29845:10:
29846:11:CWidget *Credraw3dobject (const char *ident, int force);
29847:12:
29848:13:CWidget *Cdraw3dobject (const char *identifier, Window parent, int x,
29849:14:                        int y, int width, int height, int defaults,
29850:15:                        int max_num_surfaces);
29851:16:
29852:17:
29853:18:void Cinit_surf_points (const char *ident, int width, int height,
29854:19:                        TD_Point data[]);
29855:20:
29856:21:void Cclear_all_surfaces (const char *ident);
29857:22:
29858:23:void Crender3dwidget (CWidget * wdt, int x, int y, int rendw, int rendh);
29859:24:
29860:25:#endif
29861:1:#if 1
29862:2:void push_action (WEdit * edit, long c)
29863:3:{
29864:4:    int i;
29865:5:    printf ("%d\n", c);
29866:6:    l_push_action (edit, c);
29867:7:    if (edit->stack_pointer)
29868:8:        for (i = 0; i < edit->stack_pointer; i++) {
29869:9:            if (edit->undo_stack[i] == CURS_RIGHT)
29870:10:                printf ("> ");
29871:11:            if (edit->undo_stack[i] == CURS_LEFT)
29872:12:                printf ("< ");
29873:13:            if (edit->undo_stack[i] == DELETE)
29874:14:                printf ("\\ ");
29875:15:            if (edit->undo_stack[i] == BACKSPACE)
29876:16:                printf ("^ ");
29877:17:            if (edit->undo_stack[i] >= KEY_PRESS) {
29878:18:                printf ("KK");
29879:19:                continue;
29880:20:            }
29881:21:            if (edit->undo_stack[i] <= '~' && edit->undo_stack[i] >= ' ')
29882:22:                printf ("%c+", edit->undo_stack[i]);
29883:23:            if (edit->undo_stack[i] <= '~' + 256
29884:24:                && edit->undo_stack[i] >= ' ' + 256)
29885:25:                printf ("%c-", edit->undo_stack[i] - 256);
29886:26:            if (edit->undo_stack[i] < 0)
29887:27:                printf ("%d", edit->undo_stack[i]);
29888:28:        }
29889:29:    printf ("\n");
29890:30:}
29891:31:#endif
29892:32:
29893:33:
29894:34:
29895:35:
29896:36:
29897:37:
29898:38:
29899:39:
29900:40:
29901:41:
29902:42:
29903:43:/* this must be appended onto edit.c */
29904:44:/*
29905:45:   This formats the region of text about the cursor.
29906:46:   A "soft return" occurs at the end of a line of text and is
29907:47:   represented by a " \n". A "hard return" is represented by
29908:48:   a "\n" only. The following routine removes all soft returns
29909:49:   from the paragraph, then inserts soft returns for correct
29910:50:   spacing.
29911:51:*/
29912:52:
29913:53:#if WORD_WRAP
29914:54:
29915:55:/* returns 0 if normal, 1 if the next is a " \n" or 2 if the next is a "\n" */
29916:56:int forward_word (WEdit * edit, long *p)
29917:57:{
29918:58:    int c;
29919:59:
29920:60:    for (;; *p++) {
29921:61:        c = edit_get_byte (edit, *p);
29922:62:        if (c == '\n')
29923:63:            return 2;
29924:64:        if (c == ' ') {
29925:65:            if (edit_get_byte (edit, ++*p) == '\n')
29926:66:                return 1;
29927:67:            else
29928:68:                return 0;
29929:69:        }
29930:70:    }
29931:71:}
29932:72:
29933:73:
29934:74:long edit_trunc_line (WEdit * edit, long p)
29935:75:{
29936:76:    int current = p;
29937:77:    int line = 0;
29938:78:    int q = p;
29939:79:    int r;
29940:80:
29941:81:    for (;;) {
29942:82:        while (!(r = forward_word (edit, &p)));
29943:83:        if (r == 2)
29944:84:            return p + 1;
29945:85:        line += (p - q);
29946:86:        q = p;
29947:87:        if (r == 1) {
29948:88:            p++;
29949:89:            forward_word (edit, &p)
29950:90:        }
29951:91:
29952:92:        if (edit_get_byte (edit, q) == ' '
29953:93:            && edit_get_byte (edit, q + 1) == '\n')
29954:94:
29955:95:            line++;
29956:96:    }
29957:97:}
29958:98:
29959:99:void edit_word_wrap (WEdit * edit)
29960:100:{
29961:101:    int line;
29962:102:    int c, b, i = 0;
29963:103:    long current;
29964:104:
29965:105:    edit->force |= REDRAW_PAGE;
29966:106:    current = edit->curs1;
29967:107:
29968:108:    b = edit_get_byte (edit, edit->curs1);
29969:109:    for (;;) {
29970:110:        if (i > 1024) {         /* if there are very long paragraphs, this could be slow, so
29971:111:                                   stop if we are trying to format to much at once */
29972:112:            edit_cursor_to_bol (edit);
29973:113:            break;
29974:114:        }
29975:115:        c = b;
29976:116:        if ((b = edit_cursor_move (edit, -1)) < 0) /* beginning of text */
29977:117:            break;
29978:118:        if (b != ' ' && c == '\n') {
29979:119:            while (edit_cursor_move (edit, 1) != '\n')
29980:120:                break;
29981:121:        }
29982:122:        i++;
29983:123:    }
29984:124:
29985:125:/*
29986:126:   we are now at the beginning of the paragraph: move to end, deleting
29987:127:   all soft returns, and inserting new soft returns.
29988:128:*/
29989:129:    i = 0;
29990:130:    line = 1;
29991:131:    c = edit_cursor_move (edit, 1);
29992:132:    for (;;) {
29993:133:        if (i > 2048)
29994:134:            break;
29995:135:        b = c;
29996:136:        if ((c = edit_cursor_move (edit, 1)) < 0)
29997:137:            break;              /* end of text */
29998:138:        line++;
29999:139:        if (c == '\n') {
30000:140:            if (b == ' ') {
30001:141:                edit_backspace (edit);
30002:142:                line--;
30003:143:                if (edit->curs1 <= current)
30004:144:                    current--;
30005:145:            } else {
30006:146:                break;
30007:147:            }
30008:148:        }
30009:149:        if (line >= word_wrap_line_length) {
30010:150:            int lcurrent;
30011:151:            int t, u;
30012:152:            lcurrent = edit->curs1;
30013:153:            edit_cursor_move (edit, -1);
30014:154:            for (;;) {
30015:155:                t = edit_cursor_move (edit, -1);
30016:156:                if (t == ' ') {
30017:157:                    edit_cursor_move (edit, 1);
30018:158:                    edit_insert (edit, '\n');
30019:159:                    if (edit->curs1 <= current)
30020:160:                        current++;
30021:161:                    line = 0;
30022:162:                    break;
30023:163:                }
30024:164:                if (t == '\n' || t < 0) { /* a loooong word */
30025:165:                    edit_cursor_move (edit, lcurrent - edit->curs1); /* return to our position */
30026:166:                    u = edit_cursor_move (edit, 1);
30027:167:                    for (;;) {  /* move forward until we see a space */
30028:168:                        t = u;
30029:169:                        u = edit_cursor_move (edit, 1);
30030:170:                        if (t == ' ') {
30031:171:                            if (u != '\n') { /* insert a newline unless there already is a newline at the end of the looong word */
30032:172:                                edit_cursor_move (edit, -1);
30033:173:                                edit_insert (edit, '\n');
30034:174:                                if (edit->curs1 <= current)
30035:175:                                    current++;
30036:176:                            }
30037:177:                            line = 0;
30038:178:                            goto done;
30039:179:                        }
30040:180:                        if (t == '\n' || t < 0) {
30041:181:                            line = 0;
30042:182:                            goto done;
30043:183:                        }
30044:184:                    }
30045:185:                }
30046:186:            }
30047:187:          done:;
30048:188:            c = '\n';
30049:189:        }
30050:190:        i++;
30051:191:    }
30052:192:/* return to the original position */
30053:193:    edit_cursor_move (edit, current - edit->curs1);
30054:194:}
30055:195:
30056:196:#endif
30057:1:/*
30058:2:
30059:3:    3DKIT   version   1.2
30060:4:    High speed 3D graphics and rendering library for Linux.
30061:5:
30062:6:    Copyright (C) 1996  Paul Sheer   psheer@hertz.mech.wits.ac.za
30063:7:
30064:8:    This library is free software; you can redistribute it and/or
30065:9:    modify it under the terms of the GNU Library General Public
30066:10:    License as published by the Free Software Foundation; either
30067:11:    version 2 of the License, or (at your option) any later version.
30068:12:
30069:13:    This library is distributed in the hope that it will be useful,
30070:14:    but WITHOUT ANY WARRANTY; without even the implied warranty of
30071:15:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
30072:16:    Library General Public License for more details.
30073:17:
30074:18:    You should have received a copy of the GNU Library General Public
30075:19:    License along with this library; if not, write to the Free
30076:20:    Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
30077:21:    MA 02111-1307, USA
30078:22:
30079:23:*/
30080:24:
30081:25:
30082:26:
30083:27:/*
30084:28:
30085:29:File: wrapsurf.c
30086:30:
30087:31:Comments or suggestions welcome.
30088:32:
30089:33:This function wraps a bitmap over a surface.
30090:34:See wrapdemo.c for a demonstration of its use.
30091:35:Use bitmap data of only 256x512 (see wtriangle.c)
30092:36:although any region within the bitmap can be drawn
30093:37:to the full extents of the surface, so multiple
30094:38:small bitmaps can reside in one image and be
30095:39:used for different surfaces.
30096:40:
30097:41:*/
30098:42:
30099:43:
30100:44:
30101:45:#define TD_MULCONSTANT 4096
30102:46:
30103:47:#include <config.h>
30104:48:#include <math.h>
30105:49:#include <stdlib.h>
30106:50:#include <stdio.h>
30107:51:
30108:52:#ifndef DO_NOT_USE_VGALIB
30109:53:#include <vga.h>
30110:54:#endif
30111:55:
30112:56:#include <vgagl.h>
30113:57:#include "3dkit.h"
30114:58:
30115:59:
30116:60:/*global for holding a surface temporarily:*/
30117:61:extern TD_Short_Point *temp;
30118:62:
30119:63:
30120:64:static void xchg (int *a, int *b)
30121:65:{
30122:66:    int t = *a;
30123:67:    *a = *b;
30124:68:    *b = t;
30125:69:}
30126:70:
30127:71:
30128:72:void TD_drawwrapsurface (TD_Solid * s, int which)
30129:73:{
30130:74:
30131:75:    TD_Surface *surf = &s->surf[which];
30132:76:    int w = surf->w;
30133:77:    int l = surf->l;
30134:78:    int bitmapwidth = surf->bitmapwidth;
30135:79:    int bitmaplength = surf->bitmaplength;
30136:80:    int i = 0, j = 0, k = 0, c = surf->mesh_color;
30137:81:    void (*dl) (int, int, int, int, int) = s->draw_line;
30138:82:
30139:83:    void (*dsw) (int, int, int, int,
30140:84:                 int, int, int, int,
30141:85:                 int, int, int, int, int,
30142:86:                 TD_tridata *) = s->draw_swtriangle;
30143:87:
30144:88:    void (*dw) (int, int, int, int, int,
30145:89:                int, int, int, int, int,
30146:90:                int, int, int, int, int, TD_tridata *) = s->draw_wtriangle;
30147:91:    int mesh;
30148:92:    long d1, d2, d3, d4, d;
30149:93:    long x1, y1, c1;
30150:94:    long x2, y2, c2;
30151:95:    long x3, y3, c3;
30152:96:    long x4, y4, c4;
30153:97:    long u1, v1;
30154:98:    long u2, v2;
30155:99:    long u3, v3;
30156:100:    long u4, v4;
30157:101:    int furthest, clockwise = 0;
30158:102:    TD_tridata tri;
30159:103:
30160:104:    tri.bitmap1 = surf->bitmap1;
30161:105:    tri.bitmap2 = surf->bitmap2;
30162:106:
30163:107:    if (s->option_flags & TDOPTION_ALL_SAME_RENDER)
30164:108:        mesh = (s->render == TD_MESH_AND_SOLID);
30165:109:    else
30166:110:        mesh = (surf->render == TD_MESH_AND_SOLID);
30167:111:
30168:112:/*distance of four corners (numbered clockwise): */
30169:113:    d1 = TD_finddistance (s, &surf->point[0]);
30170:114:    d2 = TD_finddistance (s, &surf->point[w - 1]);
30171:115:    d3 = TD_finddistance (s, &surf->point[w * l - 1]);
30172:116:    d4 = TD_finddistance (s, &surf->point[w * (l - 1)]);
30173:117:
30174:118:
30175:119:/*find furthest point */
30176:120:    furthest = 1;
30177:121:
30178:122:    d = d1;
30179:123:
30180:124:    if (d2 > d) {
30181:125:        furthest = 2;
30182:126:        d = d2;
30183:127:    }
30184:128:    if (d3 > d) {
30185:129:        furthest = 3;
30186:130:        d = d3;
30187:131:    }
30188:132:    if (d4 > d)
30189:133:        furthest = 4;
30190:134:
30191:135:
30192:136:/*draw scanning from the furthest point to the second furthest point */
30193:137:/*there are eight possibilities: */
30194:138:
30195:139:    switch (furthest) {
30196:140:    case 1:
30197:141:        if (d2 > d4) {
30198:142:            clockwise = 0;
30199:143:            for (j = 0; j < l; j++)
30200:144:                for (i = 0; i < w; i++) {
30201:145:                    TD_translate (s, &surf->point[i + j * w], &temp[k]);
30202:146:                    temp[k].u = i * bitmapwidth / (w - 1);
30203:147:                    temp[k].v = j * bitmaplength / (l - 1);
30204:148:                    temp[k].c =
30205:149:                        TD_findcolor (s, &surf->point[i + j * w], which);
30206:150:                    k++;
30207:151:                }
30208:152:        } else {
30209:153:            xchg (&l, &w);
30210:154:            clockwise = 1;
30211:155:            for (j = 0; j < l; j++)
30212:156:                for (i = 0; i < w; i++) {
30213:157:                    TD_translate (s, &surf->point[i * l + j], &temp[k]);
30214:158:                    temp[k].u = j * bitmapwidth / (l - 1);
30215:159:                    temp[k].v = i * bitmaplength / (w - 1);
30216:160:                    temp[k].c =
30217:161:                        TD_findcolor (s, &surf->point[i * l + j], which);
30218:162:                    k++;
30219:163:                }
30220:164:        }
30221:165:        break;
30222:166:
30223:167:    case 2:
30224:168:        if (d1 > d3) {
30225:169:            clockwise = 1;
30226:170:            for (j = 0; j < l; j++)
30227:171:                for (i = w - 1; i >= 0; i--) {
30228:172:                    TD_translate (s, &surf->point[i + j * w], &temp[k]);
30229:173:                    temp[k].u = i * bitmapwidth / (w - 1);
30230:174:                    temp[k].v = j * bitmaplength / (l - 1);
30231:175:                    temp[k].c =
30232:176:                        TD_findcolor (s, &surf->point[i + j * w], which);
30233:177:                    k++;
30234:178:                }
30235:179:        } else {
30236:180:            xchg (&l, &w);
30237:181:            clockwise = 0;
30238:182:            for (j = l - 1; j >= 0; j--)
30239:183:                for (i = 0; i < w; i++) {
30240:184:                    TD_translate (s, &surf->point[i * l + j], &temp[k]);
30241:185:                    temp[k].u = j * bitmapwidth / (l - 1);
30242:186:                    temp[k].v = i * bitmaplength / (w - 1);
30243:187:                    temp[k].c =
30244:188:                        TD_findcolor (s, &surf->point[i * l + j], which);
30245:189:                    k++;
30246:190:                }
30247:191:        }
30248:192:        break;
30249:193:
30250:194:    case 3:
30251:195:        if (d4 > d2) {
30252:196:            clockwise = 0;
30253:197:            for (j = l - 1; j >= 0; j--)
30254:198:                for (i = w - 1; i >= 0; i--) {
30255:199:                    TD_translate (s, &surf->point[i + j * w], &temp[k]);
30256:200:                    temp[k].u = i * bitmapwidth / (w - 1);
30257:201:                    temp[k].v = j * bitmaplength / (l - 1);
30258:202:                    temp[k].c =
30259:203:                        TD_findcolor (s, &surf->point[i + j * w], which);
30260:204:                    k++;
30261:205:                }
30262:206:        } else {
30263:207:            xchg (&l, &w);
30264:208:            clockwise = 1;
30265:209:            for (j = l - 1; j >= 0; j--)
30266:210:                for (i = w - 1; i >= 0; i--) {
30267:211:                    TD_translate (s, &surf->point[i * l + j], &temp[k]);
30268:212:                    temp[k].u = j * bitmapwidth / (l - 1);
30269:213:                    temp[k].v = i * bitmaplength / (w - 1);
30270:214:                    temp[k].c =
30271:215:                        TD_findcolor (s, &surf->point[i * l + j], which);
30272:216:                    k++;
30273:217:                }
30274:218:        }
30275:219:        break;
30276:220:
30277:221:    case 4:
30278:222:        if (d3 > d1) {
30279:223:            clockwise = 1;
30280:224:            for (j = l - 1; j >= 0; j--)
30281:225:                for (i = 0; i < w; i++) {
30282:226:                    TD_translate (s, &surf->point[i + j * w], &temp[k]);
30283:227:                    temp[k].u = i * bitmapwidth / (w - 1);
30284:228:                    temp[k].v = j * bitmaplength / (l - 1);
30285:229:                    temp[k].c =
30286:230:                        TD_findcolor (s, &surf->point[i + j * w], which);
30287:231:                    k++;
30288:232:                }
30289:233:        } else {
30290:234:            xchg (&l, &w);
30291:235:            clockwise = 0;
30292:236:            for (j = 0; j < l; j++)
30293:237:                for (i = w - 1; i >= 0; i--) {
30294:238:                    TD_translate (s, &surf->point[i * l + j], &temp[k]);
30295:239:                    temp[k].u = j * bitmapwidth / (l - 1);
30296:240:                    temp[k].v = i * bitmaplength / (w - 1);
30297:241:                    temp[k].c =
30298:242:                        TD_findcolor (s, &surf->point[i * l + j], which);
30299:243:                    k++;
30300:244:                }
30301:245:        }
30302:246:        break;
30303:247:    }
30304:248:
30305:249:    if (!surf->backfacing)
30306:250:        clockwise += 2;         /*Otherwise a different bitmap on either side */
30307:251:
30308:252:    tri.bf = clockwise;
30309:253:
30310:254:    for (k = 0, j = 0; j < l - 1; j++, k++) {
30311:255:        for (i = 0; i < w - 1; i++, k++) {
30312:256:
30313:257:/*define the grid square we are currently drawing: */
30314:258:            x1 = temp[k].x;
30315:259:            y1 = temp[k].y;
30316:260:            u1 = temp[k].u;
30317:261:            v1 = temp[k].v;
30318:262:            c1 = temp[k].c;
30319:263:
30320:264:            x2 = temp[k + 1].x;
30321:265:            y2 = temp[k + 1].y;
30322:266:            u2 = temp[k + 1].u;
30323:267:            v2 = temp[k + 1].v;
30324:268:            c2 = temp[k + 1].c;
30325:269:
30326:270:            x3 = temp[k + w + 1].x;
30327:271:            y3 = temp[k + w + 1].y;
30328:272:            u3 = temp[k + w + 1].u;
30329:273:            v3 = temp[k + w + 1].v;
30330:274:            c3 = temp[k + w + 1].c;
30331:275:
30332:276:            x4 = temp[k + w].x;
30333:277:            y4 = temp[k + w].y;
30334:278:            u4 = temp[k + w].u;
30335:279:            v4 = temp[k + w].v;
30336:280:            c4 = temp[k + w].c;
30337:281:
30338:282:            /*draw with two triangles */
30339:283:
30340:284:
30341:285:
30342:286:            if (furthest & 1) { /*draw with hypotenuse from point 1 to point 3 */
30343:287:                if (s->option_flags & TDOPTION_FLAT_TRIANGLE) {
30344:288:                    c1 = (c1 + c2 + c3 + c4) >> 2;
30345:289:                    (*dsw) (x1, y1, u1, v1, x2, y2, u2, v2, x3, y3, u3, v3,
30346:290:                            c1, &tri);
30347:291:                    (*dsw) (x1, y1, u1, v1, x3, y3, u3, v3, x4, y4, u4, v4,
30348:292:                            c1, &tri);
30349:293:                } else {
30350:294:                    (*dw) (x1, y1, u1, v1, c1, x2, y2, u2, v2, c2, x3, y3,
30351:295:                           u3, v3, c3, &tri);
30352:296:                    (*dw) (x1, y1, u1, v1, c1, x3, y3, u3, v3, c3, x4, y4,
30353:297:                           u4, v4, c4, &tri);
30354:298:                }
30355:299:            } else {            /*draw with hypotenuse from point 2 to point 4 */
30356:300:                if (s->option_flags & TDOPTION_FLAT_TRIANGLE) {
30357:301:                    c1 = (c1 + c2 + c3 + c4) >> 2;
30358:302:                    (*dsw) (x1, y1, u1, v1, x2, y2, u2, v2, x4, y4, u4, v4,
30359:303:                            c1, &tri);
30360:304:                    (*dsw) (x2, y2, u2, v2, x3, y3, u3, v3, x4, y4, u4, v4,
30361:305:                            c1, &tri);
30362:306:                } else {
30363:307:                    (*dw) (x1, y1, u1, v1, c1, x2, y2, u2, v2, c2, x4, y4,
30364:308:                           u4, v4, c4, &tri);
30365:309:                    (*dw) (x2, y2, u2, v2, c2, x3, y3, u3, v3, c3, x4, y4,
30366:310:                           u4, v4, c4, &tri);
30367:311:                }
30368:312:            }
30369:313:
30370:314:
30371:315:            if (mesh) {
30372:316:                (*dl) (x1, y1, x2, y2, c);
30373:317:                (*dl) (x1, y1, x4, y4, c);
30374:318:            }
30375:319:        }
30376:320:        if (mesh)
30377:321:            (*dl) (temp[k + w].x, temp[k + w].y, temp[k].x, temp[k].y, c);
30378:322:    }
30379:323:
30380:324:    if (mesh) {
30381:325:        for (i = 0; i < w - 1; i++, k++)
30382:326:            (*dl) (temp[k + 1].x, temp[k + 1].y, temp[k].x, temp[k].y, c);
30383:327:    }
30384:328:}
30385:1:#define WRAP
30386:2:#define INTERP
30387:3:#include "triangl.c"
